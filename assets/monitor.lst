0001   0000             ;
0002   0000             ; Monitor using CP/M BIOS
0003   0000             ;
0004   0000             ;
0005   0000             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006   0000             ;
0007   0000             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008   0000             ;
0009   0000             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010   0000             ; of this software and associated documentation files (the "Software"), to deal
0011   0000             ; in the Software without restriction, including without limitation the rights
0012   0000             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013   0000             ; copies of the Software, and to permit persons to whom the Software is
0014   0000             ; furnished to do so, subject to the following conditions:
0015   0000             ; 
0016   0000             ; The above copyright notice and this permission notice shall be included in all
0017   0000             ; copies or substantial portions of the Software.
0018   0000             ; 
0019   0000             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020   0000             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021   0000             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022   0000             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023   0000             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024   0000             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025   0000             ; SOFTWARE.
0026   0000             ;
0027   0000                                 .MODULE  main
0028   0000             
0029   0000             MONITOR_START       .EQU   0DB00h
0030   0000             
0031   DB00                                 .ORG   MONITOR_START
0032   DB00 CD 56 F0                        CALL   configure_hardware           ; Interrupts are configured and enabled here
0033   DB03             
0034   DB03 3A 03 FF                        LD      A, (boot_mode)
0035   DB06 E6 08                           AND     BOOT_TTY_INPUT
0036   DB08 3E 01                           LD      A, 1
0037   DB0A 28 01                           JR      Z, _set_iobyte
0038   DB0C AF                              XOR     A
0039   DB0D 32 03 00    _set_iobyte         LD      (iobyte), A
0040   DB10             
0041   DB10 3E 25                           LD      A, DRIVE_B_PAGE
0042   DB12 32 38 FF                        LD      (drive_b_mem_page), A
0043   DB15             
0044   DB15 21 A9 E5    _clock_check        LD      HL, timer_int
0045   DB18 22 FE FD                        LD      (0FDFEh), HL
0046   DB1B             
0047   DB1B 3E 01                           LD      A, 1
0048   DB1D 32 04 FF                        LD      (timer), A
0049   DB20 3E 03                           LD      A, 3
0050   DB22 CD 9A E5                        CALL    detect_int
0051   DB25             
0052   DB25 79                              LD      A, C
0053   DB26 B0                              OR      B
0054   DB27 20 0A                           JR      NZ, _clock_detected
0055   DB29             
0056   DB29 CD 3E F0    _no_clock           CALL    m_print_inline
0057   DB2C 2E 00                           .DB     ".", 0
0058   DB2E             
0059   DB2E CD DB F1                        CALL    _do_reti
0060   DB31 18 E2                           JR      _clock_check
0061   DB33             
0062   DB33 3E 07       _clock_detected     LD      A, 7
0063   DB35 CD 9A E5                        CALL    detect_int
0064   DB38 79                              LD      A, C
0065   DB39 B0                              OR      B 
0066   DB3A 28 ED                           JR      Z, _no_clock
0067   DB3C             
0068   DB3C                                 ; At this point BC ~= 13 * (clock * 100)
0069   DB3C                                 ; Divide by 13, round lowest digit up/down
0070   DB3C             
0071   DB3C C5                              PUSH    BC
0072   DB3D E1                              POP     HL
0073   DB3E 0E 0D                           LD      C, 13
0074   DB40 CD B6 E5                        CALL    divide_hl_c
0075   DB43             
0076   DB43 E5                              PUSH    HL
0077   DB44 D1                              POP     DE
0078   DB45 CD C3 E5                        CALL    de_to_bcd
0079   DB48             
0080   DB48 3A FB E5                        LD      A, (bcd_scratch)         ; Units
0081   DB4B FE 06                           CP      6
0082   DB4D 38 11                           JR      C, _display_speed
0083   DB4F             
0084   DB4F 2A FC E5                        LD      HL, (bcd_scratch+1)
0085   DB52 06 04                           LD      B,  4
0086   DB54             
0087   DB54 7E          _increment_bcd      LD      A, (HL)
0088   DB55 3C                              INC     A
0089   DB56 77                              LD      (HL), A
0090   DB57 FE 0A                           CP      10
0091   DB59 38 05                           JR      C, _display_speed        ; No carry here
0092   DB5B AF                              XOR     A
0093   DB5C 77                              LD      (HL), A
0094   DB5D 23                              INC     HL
0095   DB5E 10 F4                           DJNZ    _increment_bcd
0096   DB60             
0097   DB60 3A FE E5    _display_speed      LD      A, (bcd_scratch+3)
0098   DB63 A7                              AND     A
0099   DB64 28 05                           JR      Z, _skip_leading
0100   DB66 C6 30                           ADD     A, '0'
0101   DB68 32 92 DB                        LD      (_speed_value),A
0102   DB6B 3A FD E5    _skip_leading       LD       A, (bcd_scratch+2)
0103   DB6E C6 30                           ADD     A, '0'
0104   DB70 32 93 DB                        LD      (_speed_value+1), A
0105   DB73 3A FC E5                        LD      A, (bcd_scratch+1)
0106   DB76 C6 30                           ADD     A, '0'
0107   DB78 32 95 DB                        LD      (_speed_value+3), A
0108   DB7B             
0109   DB7B 01 30 00                        LD      BC, 30h
0110   DB7E CD 83 E5                        CALL    pause_for_ticks
0111   DB81             
0112   DB81 CD 3E F0                        CALL    m_print_inline
0113   DB84 0A 0D 43 6C                     .DB     NEWLINE, CARRIAGE_RETURN, "Clock speed "
0113   DB88 6F 63 6B 20 
0113   DB8C 73 70 65 65 
0113   DB90 64 20 
0114   DB92 20 30 2C 30 _speed_value        .DB     " 0,0Mhz", 0
0114   DB96 4D 68 7A 00 
0115   DB9A             
0116   DB9A 21 7C F1                        LD      HL, interrupt_handler
0117   DB9D 22 FE FD                        LD      (0FDFEh), HL
0118   DBA0             
0119   DBA0                                 ; Everything is now set up and running as we expect. Now handle boot options.
0120   DBA0             
0121   DBA0 3A 03 FF                        LD      A, (boot_mode)
0122   DBA3 E6 02                           AND     BOOT_NO_LED
0123   DBA5 28 18                           JR      Z, _keep_led_on
0124   DBA7             
0125   DBA7 CD 3E F0                        CALL    m_print_inline
0126   DBAA 0A 0D 4C 45                     .DB     NEWLINE, CARRIAGE_RETURN, "LED Off", 0
0126   DBAE 44 20 4F 66 
0126   DBB2 66 00 
0127   DBB4             
0128   DBB4 3A 6B F1                        LD      A, (default_screen_flags)
0129   DBB7 F6 20                           OR      CFLAGS_LED_OFF
0130   DBB9 32 6B F1                        LD      (default_screen_flags), A
0131   DBBC 32 32 FF                        LD      (console_flags), A
0132   DBBF             
0133   DBBF 3A 03 FF    _keep_led_on        LD      A, (boot_mode)
0134   DBC2 E6 01                           AND     BOOT_TO_CPM
0135   DBC4 20 47                           JR      NZ, boot_cpm
0136   DBC6             
0137   DBC6 01 60 00                        LD      BC, 60h
0138   DBC9 CD 83 E5                        CALL    pause_for_ticks
0139   DBCC             
0140   DBCC CD 3E F0                        CALL    m_print_inline
0141   DBCF 0A 0D 4D 69                     .DB     NEWLINE, CARRIAGE_RETURN, "MicroBeast Monitor 1.7", 0
0141   DBD3 63 72 6F 42 
0141   DBD7 65 61 73 74 
0141   DBDB 20 4D 6F 6E 
0141   DBDF 69 74 6F 72 
0141   DBE3 20 31 2E 37 
0141   DBE7 00 
0142   DBE8             
0143   DBE8 01 60 00                        LD      BC, 60h
0144   DBEB CD 83 E5                        CALL    pause_for_ticks
0145   DBEE             
0146   DBEE 0E 0A                           LD      C, NEWLINE
0147   DBF0 CD 3A EC                        CALL    bios_conout
0148   DBF3             
0149   DBF3 CD 00 E6    _monitor_menu       CALL    rtc_display_time
0150   DBF6             
0151   DBF6 01 40 00                        LD      BC, 040h
0152   DBF9 CD 83 E5                        CALL    pause_for_ticks
0153   DBFC             
0154   DBFC CD 9D EB    _monitor_read       CALL    bios_conist
0155   DBFF A7                              AND     A
0156   DC00 28 F1                           JR      Z, _monitor_menu
0157   DC02             
0158   DC02 CD C6 EB                        CALL    bios_conin
0159   DC05             
0160   DC05 21 2C DC                        LD      HL, main_menu
0161   DC08 CD 76 E4                        CALL    start_menu
0162   DC0B 18 E6                           JR      _monitor_menu
0163   DC0D             
0164   DC0D             
0165   DC0D CD 3E F0    boot_cpm            CALL    m_print_inline
0166   DC10 0A 0D 46 6F                     .DB     NEWLINE, CARRIAGE_RETURN, "Format RAM disk", 0
0166   DC14 72 6D 61 74 
0166   DC18 20 52 41 4D 
0166   DC1C 20 64 69 73 
0166   DC20 6B 00 
0167   DC22             
0168   DC22 CD A7 E3                        CALL    format_memdisk
0169   DC25             
0170   DC25 21 F1 EA    boot_without_format LD      HL, bios_boot
0171   DC28 E5                              PUSH    HL
0172   DC29 C3 5D EB                        JP      load_ccp
0173   DC2C             
0174   DC2C             
0175   DC2C 53 65 6C 65 main_menu           .DB     "Select action", 0
0175   DC30 63 74 20 61 
0175   DC34 63 74 69 6F 
0175   DC38 6E 00 
0176   DC3A             
0177   DC3A 0D DC                           .DW     boot_cpm
0178   DC3C 4C 61 75 6E                     .DB     "Launch CP/M", 0
0178   DC40 63 68 20 43 
0178   DC44 50 2F 4D 00 
0179   DC48             
0180   DC48 A6 E1                           .DW     memory_view
0181   DC4A 4D 65 6D 6F                     .DB     "Memory Editor", 0
0181   DC4E 72 79 20 45 
0181   DC52 64 69 74 6F 
0181   DC56 72 00 
0182   DC58             
0183   DC58 E0 DD                           .DW     ymodem_loader
0184   DC5A 59 2D 4D 6F                     .DB     "Y-Modem Transfer", 0
0184   DC5E 64 65 6D 20 
0184   DC62 54 72 61 6E 
0184   DC66 73 66 65 72 
0184   DC6A 00 
0185   DC6B             
0186   DC6B 83 DC                           .DW     set_date
0187   DC6D 53 65 74 20                     .DB     "Set Date", 0
0187   DC71 44 61 74 65 
0187   DC75 00 
0188   DC76             
0189   DC76 4A DD                           .DW     set_time
0190   DC78 53 65 74 20                     .DB     "Set Time", 0
0190   DC7C 54 69 6D 65 
0190   DC80 00 
0191   DC81 00 00                           .DW     0
0192   DC83             
0193   DC83             
0194   DC83                                 .INCLUDE monitor_dates.asm
0001+  DC83             ;
0002+  DC83             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0003+  DC83             ;
0004+  DC83             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0005+  DC83             ;
0006+  DC83             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0007+  DC83             ; of this software and associated documentation files (the "Software"), to deal
0008+  DC83             ; in the Software without restriction, including without limitation the rights
0009+  DC83             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0010+  DC83             ; copies of the Software, and to permit persons to whom the Software is
0011+  DC83             ; furnished to do so, subject to the following conditions:
0012+  DC83             ; 
0013+  DC83             ; The above copyright notice and this permission notice shall be included in all
0014+  DC83             ; copies or substantial portions of the Software.
0015+  DC83             ; 
0016+  DC83             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0017+  DC83             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0018+  DC83             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0019+  DC83             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0020+  DC83             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0021+  DC83             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0022+  DC83             ; SOFTWARE.
0023+  DC83             ;
0024+  DC83             
0025+  DC83 3A 2D FF    set_date            LD      A, (cursor_row)
0026+  DC86 C6 1F                           ADD     A, 31
0027+  DC88 32 A3 DC                        LD      (_set_date_row), A
0028+  DC8B 32 B6 DC                        LD      (_set_week_row), A
0029+  DC8E CD 3E F0                        CALL    m_print_inline
0030+  DC91 0D 44 61 74                     .DB     CARRIAGE_RETURN, "Date YY/MM/DD", ESCAPE_CHAR, "K", ESCAPE_CHAR, "Y",
0030+  DC95 65 20 59 59 
0030+  DC99 2F 4D 4D 2F 
0030+  DC9D 44 44 1B 4B 
0030+  DCA1 1B 59 
0031+  DCA3 00          _set_date_row       .DB     0
0032+  DCA4 25 00                           .DB     31+6, 0
0033+  DCA6 21 91 DD                        LD      HL, date_limits
0034+  DCA9 CD 9F DD                        CALL    get_date_time
0035+  DCAC             
0036+  DCAC 3E 01                           LD      A, 1
0037+  DCAE 32 97 DD    _select_loop        LD      (day_of_week), A
0038+  DCB1             
0039+  DCB1 CD 3E F0                        CALL    m_print_inline
0040+  DCB4 1B 59                           .DB     ESCAPE_CHAR, "Y", 
0041+  DCB6 00          _set_week_row       .DB     0
0042+  DCB7 2F 00                           .DB     31+16, 0
0043+  DCB9             
0044+  DCB9 3A 97 DD                        LD      A, (day_of_week)
0045+  DCBC 47                              LD      B, A
0046+  DCBD 21 8A E6                        LD      HL, weekdays
0047+  DCC0 10 0A       _week_loop          DJNZ    _next_week
0048+  DCC2             
0049+  DCC2 7E          _print_week         LD      A, (HL)
0050+  DCC3 23                              INC     HL
0051+  DCC4 A7                              AND     A
0052+  DCC5 28 0C                           JR      Z, _select_week
0053+  DCC7 CD 4B F0                        CALL    m_print_a_safe
0054+  DCCA 18 F6                           JR      _print_week
0055+  DCCC             
0056+  DCCC 7E          _next_week          LD      A, (HL)
0057+  DCCD 23                              INC     HL
0058+  DCCE A7                              AND     A
0059+  DCCF 20 FB                           JR      NZ, _next_week
0060+  DCD1 18 ED                           JR      _week_loop
0061+  DCD3             
0062+  DCD3 CD 9D EB    _select_week        CALL    bios_conist
0063+  DCD6 A7                              AND     A
0064+  DCD7 28 FA                           JR      Z, _select_week
0065+  DCD9 CD C6 EB                        CALL    bios_conin
0066+  DCDC FE 80                           CP      KEY_UP
0067+  DCDE 20 0A                           JR      NZ, _test_down
0068+  DCE0 3A 97 DD                        LD      A, (day_of_week)
0069+  DCE3 FE 07                           CP      7
0070+  DCE5 28 EC                           JR      Z, _select_week
0071+  DCE7 3C                              INC     A
0072+  DCE8 18 C4                           JR      _select_loop
0073+  DCEA FE 81       _test_down          CP      KEY_DOWN
0074+  DCEC 20 0A                           JR      NZ, _test_enter 
0075+  DCEE 3A 97 DD                        LD      A, (day_of_week)
0076+  DCF1 FE 01                           CP      1
0077+  DCF3 28 DE                           JR      Z, _select_week
0078+  DCF5 3D                              DEC     A
0079+  DCF6 18 B6                           JR      _select_loop
0080+  DCF8 FE 0D       _test_enter         CP      KEY_ENTER
0081+  DCFA 20 D7                           JR      NZ, _select_week
0082+  DCFC             
0083+  DCFC F3                              DI
0084+  DCFD 26 6F                           LD      H, RTC_ADDRESS      
0085+  DCFF 2E 03                           LD      L, RTC_REG_WKDAY
0086+  DD01 CD 14 F6                        CALL    i2c_write_to
0087+  DD04 D2 33 DD                        JP      NC, _clock_error
0088+  DD07             
0089+  DD07 21 97 DD                        LD      HL, day_of_week
0090+  DD0A 7E                              LD      A, (HL)
0091+  DD0B 23                              INC     HL
0092+  DD0C             
0093+  DD0C F6 08                           OR      RTC_WEEKDAY_RUNNING
0094+  DD0E CD 28 F6                        CALL    i2c_write
0095+  DD11 D2 33 DD                        JP      NC, _clock_error
0096+  DD14             
0097+  DD14 46          _write_date_loop    LD      B, (HL)
0098+  DD15 23                              INC     HL
0099+  DD16             
0100+  DD16 7E                              LD      A, (HL)
0101+  DD17 23                              INC     HL
0102+  DD18 CB 27                           SLA     A
0103+  DD1A CB 27                           SLA     A
0104+  DD1C CB 27                           SLA     A
0105+  DD1E CB 27                           SLA     A
0106+  DD20             
0107+  DD20 B0                              OR      B
0108+  DD21 FE FF                           CP      0ffh
0109+  DD23 CA 2E DD                        JP      Z, _start_clock
0110+  DD26 CD 28 F6                        CALL    i2c_write
0111+  DD29 D2 33 DD                        JP      NC, _clock_error
0112+  DD2C 18 E6                           JR      _write_date_loop
0113+  DD2E             
0114+  DD2E CD DC F5    _start_clock        CALL    i2c_stop
0115+  DD31 FB                              EI
0116+  DD32 C9                              RET
0117+  DD33             
0118+  DD33 CD DC F5    _clock_error        CALL    i2c_stop
0119+  DD36 FB                              EI
0120+  DD37 CD 3E F0                        CALL    m_print_inline
0121+  DD3A 0D 52 54 43                     .DB     CARRIAGE_RETURN, "RTC Error", ESCAPE_CHAR, "K", 0
0121+  DD3E 20 45 72 72 
0121+  DD42 6F 72 1B 4B 
0121+  DD46 00 
0122+  DD47 C3 C6 EB                        JP      bios_conin
0123+  DD4A             
0124+  DD4A 3A 2D FF    set_time            LD      A, (cursor_row)
0125+  DD4D C6 1F                           ADD     A, 31
0126+  DD4F 32 67 DD                        LD      (_set_time_row), A
0127+  DD52 CD 3E F0                        CALL    m_print_inline
0128+  DD55 0D 54 69 6D                     .DB     CARRIAGE_RETURN, "Time HH/mm/ss", ESCAPE_CHAR, "K", ESCAPE_CHAR, "Y",
0128+  DD59 65 20 48 48 
0128+  DD5D 2F 6D 6D 2F 
0128+  DD61 73 73 1B 4B 
0128+  DD65 1B 59 
0129+  DD67 00          _set_time_row       .DB     0
0130+  DD68 25 00                           .DB     31+6, 0
0131+  DD6A 21 8B DD                        LD      HL, time_limits
0132+  DD6D CD 9F DD                        CALL    get_date_time
0133+  DD70             
0134+  DD70 3A 99 DD                        LD      A, (digit_values+1)
0135+  DD73 F6 08                           OR      08h
0136+  DD75 32 99 DD                        LD      (digit_values+1), A
0137+  DD78 CD C6 EB                        CALL    bios_conin
0138+  DD7B             
0139+  DD7B F3                              DI
0140+  DD7C 26 6F                           LD      H, RTC_ADDRESS      
0141+  DD7E 2E 00                           LD      L, RTC_REG_SEC
0142+  DD80 CD 14 F6                        CALL    i2c_write_to
0143+  DD83 D2 33 DD                        JP      NC, _clock_error
0144+  DD86             
0145+  DD86 21 98 DD                        LD      HL, digit_values
0146+  DD89 18 89                           JR      _write_date_loop
0147+  DD8B                                 
0148+  DD8B 09 05 09 05 time_limits         .DB     9,5,9,5,3,2
0148+  DD8F 03 02 
0149+  DD91             
0150+  DD91 01 03 02 01 date_limits         .DB     1,3,2,1,9,9
0150+  DD95 09 09 
0151+  DD97             
0152+  DD97 01          day_of_week         .DB     1
0153+  DD98 00 00 00 00 digit_values        .DB     0,0,0,0,0,0
0153+  DD9C 00 00 
0154+  DD9E FF                              .DB     0FFh
0155+  DD9F             
0156+  DD9F 11 98 DD    get_date_time       LD      DE, digit_values
0157+  DDA2 01 06 00                        LD      BC, 6
0158+  DDA5 ED B0                           LDIR
0159+  DDA7 2B                              DEC     HL
0160+  DDA8 1B                              DEC     DE
0161+  DDA9 06 06                           LD      B, 6
0162+  DDAB             
0163+  DDAB E5          _get_digit          PUSH    HL
0164+  DDAC D5                              PUSH    DE
0165+  DDAD C5                              PUSH    BC
0166+  DDAE CD C6 EB                        CALL    bios_conin
0167+  DDB1 C1                              POP     BC
0168+  DDB2 D1                              POP     DE
0169+  DDB3 E1                              POP     HL
0170+  DDB4 D6 30                           SUB     '0'
0171+  DDB6 38 F3                           JR      C, _get_digit
0172+  DDB8 4F                              LD      C, A
0173+  DDB9 1A                              LD      A, (DE)
0174+  DDBA 32 CF DD                        LD      (_digit_compare+1),A
0175+  DDBD B9                              CP      C
0176+  DDBE 38 EB                           JR      C, _get_digit
0177+  DDC0             
0178+  DDC0 79                              LD      A, C
0179+  DDC1 12                              LD      (DE), A
0180+  DDC2 C6 30                           ADD     A,'0'
0181+  DDC4 CD 4B F0                        CALL    m_print_a_safe
0182+  DDC7             
0183+  DDC7 1A                              LD      A,(DE)
0184+  DDC8 2B                              DEC     HL
0185+  DDC9 1B                              DEC     DE
0186+  DDCA CB 40                           BIT     0, B
0187+  DDCC 20 0A                           JR      NZ, _next_tuple
0188+  DDCE FE 00       _digit_compare      CP      0
0189+  DDD0 28 03                           JR      Z, _next_digit
0190+  DDD2 3E 09                           LD      A, 9
0191+  DDD4 12                              LD      (DE), A
0192+  DDD5 10 D4       _next_digit         DJNZ    _get_digit
0193+  DDD7 C9                              RET
0194+  DDD8 CD 3E F0    _next_tuple         CALL    m_print_inline
0195+  DDDB 1B 43 00                        .DB     ESCAPE_CHAR, 'C', 0
0196+  DDDE 18 F5                           JR      _next_digit0195   DDE0             
0196   DDE0             
0197   DDE0 AF          ymodem_loader       XOR     A
0198   DDE1 32 32 E0                        LD      (_ymodem_set), A
0199   DDE4 21 AB E0                        LD      HL, ymodem_menu
0200   DDE7 CD 76 E4                        CALL    start_menu
0201   DDEA                                 
0202   DDEA 3A 32 E0                        LD      A, (_ymodem_set)
0203   DDED A7                              AND     A
0204   DDEE C8                              RET     Z
0205   DDEF             
0206   DDEF ED 5B 2F E0                     LD      DE, (_ymodem_address)
0207   DDF3 3A 31 E0                        LD      A, (_ymodem_page)
0208   DDF6 21 6F DA                        LD      HL, MONITOR_START-YMODEM_BUFFER
0209   DDF9 F3                              DI
0210   DDFA CD F3 E6                        CALL    ymodem
0211   DDFD FB                              EI
0212   DDFE A7                              AND     A
0213   DDFF CA B1 DE                        JP      Z, _ymodem_success
0214   DE02             
0215   DE02 3D                              DEC     A
0216   DE03 5F                              LD      E, A
0217   DE04 16 00                           LD      D, 0
0218   DE06 21 31 DE                        LD      HL, _ymodem_errors
0219   DE09 19                              ADD     HL, DE
0220   DE0A 19                              ADD     HL, DE
0221   DE0B             
0222   DE0B 7E                              LD      A, (HL)
0223   DE0C 23                              INC     HL
0224   DE0D 66                              LD      H, (HL)
0225   DE0E 6F                              LD      L, A
0226   DE0F             
0227   DE0F 79                              LD      A, C
0228   DE10 C6 30                           ADD     A, '0'
0229   DE12 32 6D DE                        LD      (_packet_err_code), A
0230   DE15             
0231   DE15 E5                              PUSH    HL
0232   DE16 CD 3E F0                        CALL    m_print_inline
0233   DE19 0D 45 52 52                     .DB     CARRIAGE_RETURN, "ERROR: ", 0
0233   DE1D 4F 52 3A 20 
0233   DE21 00 
0234   DE22             
0235   DE22 E1                              POP     HL
0236   DE23             
0237   DE23 7E          _ymodem_err_loop    LD      A, (HL)
0238   DE24 23                              INC     HL
0239   DE25 A7                              AND     A
0240   DE26 CA C6 EB                        JP      Z, bios_conin                   ; Wait for a key then go to main menu..
0241   DE29 4F                              LD      C, A
0242   DE2A E5                              PUSH    HL
0243   DE2B CD 3A EC                        CALL    bios_conout
0244   DE2E E1                              POP     HL
0245   DE2F 18 F2                           JR      _ymodem_err_loop
0246   DE31             
0247   DE31 41 DE       _ymodem_errors      .DW     _y_msg_timeout
0248   DE33 4B DE                           .DW     _y_msg_unknown
0249   DE35 5C DE                           .DW     _y_msg_cancel     
0250   DE37 65 DE                           .DW     _y_msg_packet
0251   DE39 72 DE                           .DW     _y_msg_length
0252   DE3B 80 DE                           .DW     _y_msg_no_dest
0253   DE3D 91 DE                           .DW     _y_msg_send
0254   DE3F A0 DE                           .DW     _y_msg_files
0255   DE41             
0256   DE41 54 69 6D 65 _y_msg_timeout      .DB     "Timeout", ESCAPE_CHAR, "K", 0
0256   DE45 6F 75 74 1B 
0256   DE49 4B 00 
0257   DE4B 55 6E 6B 6E _y_msg_unknown      .DB     "Unknown packet", ESCAPE_CHAR, "K", 0
0257   DE4F 6F 77 6E 20 
0257   DE53 70 61 63 6B 
0257   DE57 65 74 1B 4B 
0257   DE5B 00 
0258   DE5C 43 61 6E 63 _y_msg_cancel       .DB     "Cancel", ESCAPE_CHAR, "K", 0
0258   DE60 65 6C 1B 4B 
0258   DE64 00 
0259   DE65 50 61 63 6B _y_msg_packet       .DB     "Packet (", 
0259   DE69 65 74 20 28 
0260   DE6D             
0261   DE6D 30 29 1B 4B _packet_err_code    .DB     "0)", ESCAPE_CHAR, "K", 0
0261   DE71 00 
0262   DE72             
0263   DE72 46 69 6C 65 _y_msg_length       .DB     "File length", ESCAPE_CHAR, "K", 0
0263   DE76 20 6C 65 6E 
0263   DE7A 67 74 68 1B 
0263   DE7E 4B 00 
0264   DE80 4E 6F 20 64 _y_msg_no_dest      .DB     "No destination", ESCAPE_CHAR, "K", 0
0264   DE84 65 73 74 69 
0264   DE88 6E 61 74 69 
0264   DE8C 6F 6E 1B 4B 
0264   DE90 00 
0265   DE91 53 65 6E 64 _y_msg_send         .DB     "Send Timeout", ESCAPE_CHAR, "K", 0
0265   DE95 20 54 69 6D 
0265   DE99 65 6F 75 74 
0265   DE9D 1B 4B 00 
0266   DEA0 4D 75 6C 74 _y_msg_files        .DB     "Multiple files", ESCAPE_CHAR, "K", 0
0266   DEA4 69 70 6C 65 
0266   DEA8 20 66 69 6C 
0266   DEAC 65 73 1B 4B 
0266   DEB0 00 
0267   DEB1             
0268   DEB1 CD 3E F0    _ymodem_success     CALL    m_print_inline           
0269   DEB4 0D 4F 4B 20                     .DB     CARRIAGE_RETURN, "OK ",0
0269   DEB8 00 
0270   DEB9 3A 73 DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_high)
0271   DEBC FE FF                           CP      0FFh
0272   DEBE 28 06                           JR      Z, _ymodem_no_high
0273   DEC0 C6 30                           ADD     A, '0'
0274   DEC2 4F                              LD      C, A
0275   DEC3 CD 3A EC                        CALL    bios_conout
0276   DEC6 3A 72 DA    _ymodem_no_high     LD      A, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0277   DEC9 CD 42 E5                        CALL    hex_out
0278   DECC 3A 71 DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_low)
0279   DECF CD 42 E5                        CALL    hex_out
0280   DED2 CD 3E F0                        CALL    m_print_inline
0281   DED5 20 42 59 54                     .DB     " BYTES @ ", 0
0281   DED9 45 53 20 40 
0281   DEDD 20 00 
0282   DEDF 3A 6F DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)
0283   DEE2 17                              RLA
0284   DEE3 38 10                           JR      C, _ymodem_show_addr
0285   DEE5 1F                              RRA
0286   DEE6 CD 42 E5                        CALL    hex_out
0287   DEE9 0E 2F                           LD      C, '/'
0288   DEEB CD 3A EC                        CALL    bios_conout
0289   DEEE 3A 79 DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_high)
0290   DEF1 D6 40                           SUB     40h
0291   DEF3 18 03                           JR      _ymodem_addr
0292   DEF5             
0293   DEF5 3A 79 DA    _ymodem_show_addr   LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_high)
0294   DEF8 CD 42 E5    _ymodem_addr        CALL    hex_out
0295   DEFB 3A 78 DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0296   DEFE CD 42 E5                        CALL    hex_out
0297   DF01 CD 3E F0                        CALL    m_print_inline
0298   DF04 1B 4B 00                        .DB     ESCAPE_CHAR, "K", 0
0299   DF07 CD 9D EB    _ymodem_waitkey     CALL    bios_conist                  
0300   DF0A A7                              AND     A
0301   DF0B 28 FA                           JR      Z, _ymodem_waitkey
0302   DF0D             
0303   DF0D CD C6 EB                        CALL    bios_conin
0304   DF10             
0305   DF10             
0306   DF10 3A 6F DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)      ; Do something with the file.
0307   DF13 17                              RLA
0308   DF14 30 06                           JR      NC, _ymodem_handle_page
0309   DF16             
0310   DF16 21 33 E0                        LD      HL, ymodem_mem_menu
0311   DF19 C3 76 E4                        JP      start_menu
0312   DF1C             
0313   DF1C             
0314   DF1C 21 60 E0    _ymodem_handle_page LD      HL, ymodem_page_menu
0315   DF1F C3 76 E4                        JP      start_menu
0316   DF22             
0317   DF22 2A 78 DA    _ymodem_view        LD      HL, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0318   DF25 22 A0 E1                        LD      (monitor_address), HL
0319   DF28 C3 82 E2                        JP      edit_memory
0320   DF2B             
0321   DF2B 2A 78 DA    _ymodem_exec        LD      HL, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0322   DF2E E5                              PUSH    HL
0323   DF2F C9          _ymodem_exit        RET
0324   DF30             
0325   DF30 CD 3E F0    _ymodem_flash       CALL    m_print_inline
0326   DF33 0D 0A 50 61                     .DB     CARRIAGE_RETURN, NEWLINE, "Page 00-1f >", ESCAPE_CHAR, "K", 0
0326   DF37 67 65 20 30 
0326   DF3B 30 2D 31 66 
0326   DF3F 20 3E 1B 4B 
0326   DF43 00 
0327   DF44             
0328   DF44 06 02                           LD      B, 2
0329   DF46 CD F0 E3                        CALL    hex_input
0330   DF49 CD 62 E4                        CALL    delete_or_enter
0331   DF4C 3A 60 E4                        LD      A, (hex_input_result)
0332   DF4F FE 1F                           CP      1fh
0333   DF51 30 DD                           JR      NC, _ymodem_flash
0334   DF53             
0335   DF53 CD 3E F0                        CALL    m_print_inline
0336   DF56 20 59 2F 4E                     .DB     " Y/N?", 0
0336   DF5A 3F 00 
0337   DF5C CD C6 EB                        CALL    bios_conin
0338   DF5F FE 79                           CP      'y'
0339   DF61 20 B9                           JR      NZ, _ymodem_handle_page
0340   DF63             
0341   DF63 CD 3E F0                        CALL    m_print_inline
0342   DF66 0D 0A 57 72                     .DB     CARRIAGE_RETURN, NEWLINE, "Writing", ESCAPE_CHAR, "K", 0
0342   DF6A 69 74 69 6E 
0342   DF6E 67 1B 4B 00 
0343   DF72             
0344   DF72 3A 60 E4                        LD      A, (hex_input_result)
0345   DF75 17                              RLA
0346   DF76 17                              RLA
0347   DF77 57                              LD      D, A
0348   DF78             
0349   DF78 3A 6F DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)         ; Page loaded
0350   DF7B 32 31 E0    _next_page          LD      (_ymodem_page), A
0351   DF7E D3 71                           OUT     (IO_MEM_1), A
0352   DF80             
0353   DF80 2A 72 DA                        LD      HL, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0354   DF83 7D                              LD      A, L
0355   DF84 E6 C0                           AND     0c0h
0356   DF86 B4                              OR      H
0357   DF87 20 22                           JR      NZ, _full_page
0358   DF89             
0359   DF89 ED 4B 71 DA                     LD      BC, (MONITOR_START-YMODEM_INFO+ym_length_low)
0360   DF8D 78                              LD      A, B
0361   DF8E B1                              OR      C
0362   DF8F 28 06                           JR      Z, _flash_done
0363   DF91 21 00 40                        LD      HL, 4000h
0364   DF94 CD 84 FA                        CALL    flash_write
0365   DF97             
0366   DF97 3E 20       _flash_done         LD      A, RAM_PAGE_0
0367   DF99 D3 70                           OUT     (IO_MEM_0), A
0368   DF9B             
0369   DF9B CD 3E F0                        CALL    m_print_inline
0370   DF9E 0D 0A 44 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Done ", ESCAPE_CHAR, "K", 0           
0370   DFA2 6E 65 20 1B 
0370   DFA6 4B 00 
0371   DFA8 C3 C6 EB                        JP      bios_conin
0372   DFAB             
0373   DFAB 01 40 00    _full_page          LD      BC, 0040h
0374   DFAE AF                              XOR     A
0375   DFAF ED 42                           SBC     HL, BC
0376   DFB1 22 72 DA                        LD      (MONITOR_START-YMODEM_INFO+ym_length_mid), HL
0377   DFB4 21 00 40                        LD      HL, 4000h
0378   DFB7 44                              LD      B, H
0379   DFB8 4D                              LD      C, L
0380   DFB9 CD 84 FA                        CALL    flash_write
0381   DFBC 14                              INC     D
0382   DFBD 3A 31 E0                        LD      A,(_ymodem_page)
0383   DFC0 3C                              INC     A
0384   DFC1 18 B8                           JR      _next_page
0385   DFC3             
0386   DFC3 3A 73 DA    _ymodem_firmware    LD      A, (MONITOR_START-YMODEM_INFO+ym_length_high)
0387   DFC6 A7                              AND     A
0388   DFC7 20 52                           JR      NZ, _not_firmware
0389   DFC9 3A 72 DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0390   DFCC FE 40                           CP      040h
0391   DFCE 30 4B                           JR      NC, _not_firmware
0392   DFD0             
0393   DFD0 CD 3E F0                        CALL    m_print_inline
0394   DFD3 0D 57 72 69                     .DB     CARRIAGE_RETURN, "Write firmware, Y/N?", ESCAPE_CHAR, "K", 0
0394   DFD7 74 65 20 66 
0394   DFDB 69 72 6D 77 
0394   DFDF 61 72 65 2C 
0394   DFE3 20 59 2F 4E 
0394   DFE7 3F 1B 4B 00 
0395   DFEB CD C6 EB                        CALL    bios_conin
0396   DFEE FE 79                           CP      'y'
0397   DFF0 C2 1C DF                        JP      NZ, _ymodem_handle_page
0398   DFF3             
0399   DFF3 ED 4B 71 DA                     LD      BC, (MONITOR_START-YMODEM_INFO+ym_length_low)
0400   DFF7 3A 6F DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)         ; Page loaded
0401   DFFA D3 71                           OUT     (IO_MEM_1), A
0402   DFFC                                 
0403   DFFC 21 00 40                        LD      HL, 4000h
0404   DFFF 16 00                           LD      D, 0
0405   E001 CD 84 FA                        CALL    flash_write
0406   E004             
0407   E004 CD 3E F0                        CALL    m_print_inline
0408   E007 0D 0A 44 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Done ", ESCAPE_CHAR, "K", 0
0408   E00B 6E 65 20 1B 
0408   E00F 4B 00 
0409   E011 ED 5B 71 DA                     LD      DE, (MONITOR_START-YMODEM_INFO+ym_length_low)
0410   E015 CD 3B E5                        CALL    hex_word
0411   E018 C3 C6 EB                        JP      bios_conin
0412   E01B             
0413   E01B CD 3E F0    _not_firmware       CALL    m_print_inline
0414   E01E 0D 0A 54 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Too large", ESCAPE_CHAR, "K", 0
0414   E022 6F 20 6C 61 
0414   E026 72 67 65 1B 
0414   E02A 4B 00 
0415   E02C C3 C6 EB                        JP      bios_conin
0416   E02F             
0417   E02F             
0418   E02F 00 00       _ymodem_address     .DW     0
0419   E031 00          _ymodem_page        .DB     0
0420   E032 00          _ymodem_set         .DB     0
0421   E033             
0422   E033 46 69 6C 65 ymodem_mem_menu     .DB     "File actions", 0
0422   E037 20 61 63 74 
0422   E03B 69 6F 6E 73 
0422   E03F 00 
0423   E040 22 DF                           .DW     _ymodem_view
0424   E042 56 69 65 77                     .DB     "View file", 0
0424   E046 20 66 69 6C 
0424   E04A 65 00 
0425   E04C 2B DF                           .DW     _ymodem_exec
0426   E04E 52 75 6E 00                     .DB     "Run", 0
0427   E052 2F DF                           .DW     _ymodem_exit
0428   E054 4D 61 69 6E                     .DB     "Main menu", 0
0428   E058 20 6D 65 6E 
0428   E05C 75 00 
0429   E05E 00 00                           .DW     0
0430   E060             
0431   E060 46 69 6C 65 ymodem_page_menu    .DB     "File actions", 0
0431   E064 20 61 63 74 
0431   E068 69 6F 6E 73 
0431   E06C 00 
0432   E06D 30 DF                           .DW     _ymodem_flash
0433   E06F 43 6F 70 79                     .DB     "Copy to flash", 0
0433   E073 20 74 6F 20 
0433   E077 66 6C 61 73 
0433   E07B 68 00 
0434   E07D 25 DC                           .DW     boot_without_format
0435   E07F 43 50 4D 20                     .DB     "CPM Drive B", 0
0435   E083 44 72 69 76 
0435   E087 65 20 42 00 
0436   E08B C3 DF                           .DW     _ymodem_firmware
0437   E08D 55 70 64 61                     .DB     "Update firmware", 0
0437   E091 74 65 20 66 
0437   E095 69 72 6D 77 
0437   E099 61 72 65 00 
0438   E09D 2F DF                           .DW     _ymodem_exit
0439   E09F 4D 61 69 6E                     .DB     "Main menu", 0
0439   E0A3 20 6D 65 6E 
0439   E0A7 75 00 
0440   E0A9 00 00                           .DW     0
0441   E0AB             
0442   E0AB 44 6F 77 6E ymodem_menu         .DB     "Download options", 0
0442   E0AF 6C 6F 61 64 
0442   E0B3 20 6F 70 74 
0442   E0B7 69 6F 6E 73 
0442   E0BB 00 
0443   E0BC FD E0                           .DW     _ymodem_from_file
0444   E0BE 41 64 64 72                     .DB     "Address from file", 0
0444   E0C2 65 73 73 20 
0444   E0C6 66 72 6F 6D 
0444   E0CA 20 66 69 6C 
0444   E0CE 65 00 
0445   E0D0 1E E1                           .DW     _ymodem_logical
0446   E0D2 43 50 55 20                     .DB     "CPU (Logical) address",0
0446   E0D6 28 4C 6F 67 
0446   E0DA 69 63 61 6C 
0446   E0DE 29 20 61 64 
0446   E0E2 64 72 65 73 
0446   E0E6 73 00 
0447   E0E8 54 E1                           .DW     _ymodem_physical
0448   E0EA 50 68 79 73                     .DB     "Physical address", 0
0448   E0EE 69 63 61 6C 
0448   E0F2 20 61 64 64 
0448   E0F6 72 65 73 73 
0448   E0FA 00 
0449   E0FB 00 00                           .DW     0
0450   E0FD             
0451   E0FD 11 FF FF    _ymodem_from_file   LD      DE, 0FFFFh
0452   E100 ED 53 2F E0                     LD      (_ymodem_address), DE
0453   E104 ED 53 31 E0                     LD      (_ymodem_page), DE
0454   E108 CD 3E F0    _ymodem_transfer    CALL    m_print_inline
0455   E10B 0D 53 74 61                     .DB     CARRIAGE_RETURN, "Start transfer", ESCAPE_CHAR, "K", 0
0455   E10F 72 74 20 74 
0455   E113 72 61 6E 73 
0455   E117 66 65 72 1B 
0455   E11B 4B 00 
0456   E11D C9                              RET
0457   E11E             
0458   E11E CD 3E F0    _ymodem_logical     CALL    m_print_inline
0459   E121 0D 41 64 64                     .DB     CARRIAGE_RETURN, "Address 0000-FFFF >", ESCAPE_CHAR, "K", 0
0459   E125 72 65 73 73 
0459   E129 20 30 30 30 
0459   E12D 30 2D 46 46 
0459   E131 46 46 20 3E 
0459   E135 1B 4B 00 
0460   E138 06 04                           LD      B, 4
0461   E13A CD F0 E3                        CALL    hex_input
0462   E13D CD 62 E4                        CALL    delete_or_enter
0463   E140 3E FF                           LD      A, 0FFh
0464   E142 32 31 E0                        LD      (_ymodem_page), A
0465   E145             
0466   E145 ED 5B 60 E4 _ymodem_set_and_go  LD      DE, (hex_input_result)
0467   E149 ED 53 2F E0                     LD      (_ymodem_address), DE
0468   E14D 3E FF                           LD      A, 0FFh
0469   E14F 32 32 E0                        LD      (_ymodem_set), A
0470   E152 18 B4                           JR      _ymodem_transfer
0471   E154             
0472   E154 CD 3E F0    _ymodem_physical    CALL    m_print_inline
0473   E157 0D 50 61 67                     .DB     CARRIAGE_RETURN, "Page 20-3F >", ESCAPE_CHAR, "K", 0
0473   E15B 65 20 32 30 
0473   E15F 2D 33 46 20 
0473   E163 3E 1B 4B 00 
0474   E167 06 02                           LD      B, 2
0475   E169 CD F0 E3                        CALL    hex_input
0476   E16C CD 62 E4                        CALL    delete_or_enter
0477   E16F 3A 60 E4                        LD      A, (hex_input_result)
0478   E172 32 31 E0                        LD      (_ymodem_page), A
0479   E175 CD 3E F0                        CALL    m_print_inline
0480   E178 0D 4F 66 66                     .DB     CARRIAGE_RETURN, "Offset 0000-3FFF >", ESCAPE_CHAR, "K", 0
0480   E17C 73 65 74 20 
0480   E180 30 30 30 30 
0480   E184 2D 33 46 46 
0480   E188 46 20 3E 1B 
0480   E18C 4B 00 
0481   E18E 06 04                           LD      B, 4
0482   E190 CD F0 E3                        CALL    hex_input
0483   E193 CD 62 E4                        CALL    delete_or_enter
0484   E196 3A 61 E4                        LD      A, (hex_input_result+1)         ; YModem loads to page 1, so allow for offset..
0485   E199 F6 40                           OR      040h
0486   E19B 32 61 E4                        LD      (hex_input_result+1), A
0487   E19E 18 A5                           JR      _ymodem_set_and_go
0488   E1A0             
0489   E1A0             ;------------------------------ Memory Editor --------------------------------------------
0490   E1A0             
0491   E1A0 00 80       monitor_address     .DW     08000h              ; Default address is 0x8000
0492   E1A2 00          monitor_mode        .DB     0                   ; 0 = show address + 3 characters, ~0 = hide address + 8 characters
0493   E1A3 00          edit_col            .DB     0                   ; Column currently being edited..
0494   E1A4 00 00       edit_digit          .DW     0
0495   E1A6             
0496   E1A6 CD 42 E3    memory_view         CALL    display_mem_row
0497   E1A9             
0498   E1A9 CD 9D EB    _wait_key           CALL    bios_conist
0499   E1AC A7                              AND     A
0500   E1AD 28 FA                           JR      Z, _wait_key
0501   E1AF CD C6 EB                        CALL    bios_conin
0502   E1B2 CD C6 E4                        CALL    translate_cursors
0503   E1B5             
0504   E1B5 FE 80                           CP      KEY_UP
0505   E1B7 20 0D                           JR      NZ, _not_up
0506   E1B9 2A A0 E1    memory_up           LD      HL, (monitor_address)
0507   E1BC 11 08 00                        LD      DE, 8
0508   E1BF ED 52                           SBC     HL, DE
0509   E1C1 22 A0 E1                        LD      (monitor_address), HL
0510   E1C4 18 E0                           JR      memory_view
0511   E1C6             
0512   E1C6 FE 81       _not_up             CP      KEY_DOWN
0513   E1C8 20 0C                           JR      NZ, _not_down
0514   E1CA 2A A0 E1    memory_down         LD      HL, (monitor_address)
0515   E1CD 11 08 00                        LD      DE, 8
0516   E1D0 19                              ADD     HL, DE
0517   E1D1 22 A0 E1                        LD      (monitor_address), HL
0518   E1D4 18 D0                           JR      memory_view
0519   E1D6             
0520   E1D6 FE 20       _not_down           CP      ' '
0521   E1D8 20 09                           JR      NZ, _not_space
0522   E1DA 3A A2 E1                        LD      A, (monitor_mode)
0523   E1DD 2F                              CPL
0524   E1DE 32 A2 E1                        LD      (monitor_mode), A
0525   E1E1 18 C3                           JR      memory_view
0526   E1E3             
0527   E1E3 FE 0D       _not_space          CP      CARRIAGE_RETURN
0528   E1E5 28 0E                           JR      Z, _input_address
0529   E1E7             
0530   E1E7 FE 83                           CP      KEY_RIGHT
0531   E1E9 CA 82 E2                        JP      Z, edit_memory
0532   E1EC FE 08                           CP      KEY_BACKSPACE
0533   E1EE C8                              RET     Z
0534   E1EF             
0535   E1EF FE 78                           CP      'x'
0536   E1F1 28 1C                           JR      Z, execute
0537   E1F3 18 B4                           JR      _wait_key
0538   E1F5             
0539   E1F5 AF          _input_address      XOR     A
0540   E1F6 32 A2 E1                        LD      (monitor_mode), A
0541   E1F9 CD 42 E3                        CALL    display_mem_row
0542   E1FC 0E 0D                           LD      C, CARRIAGE_RETURN
0543   E1FE CD 3A EC                        CALL    bios_conout
0544   E201             
0545   E201 06 04                           LD      B, 4
0546   E203 CD F0 E3                        CALL    hex_input
0547   E206 2A 60 E4                        LD      HL, (hex_input_result)
0548   E209 22 A0 E1                        LD      (monitor_address), HL
0549   E20C C3 A6 E1                        JP      memory_view
0550   E20F             
0551   E20F AF          execute             XOR     A
0552   E210 32 A3 E1                        LD      (edit_col), A
0553   E213 CD 3E F0    execute_col         CALL    m_print_inline
0554   E216 0D 1B 62 2E                     .DB     CARRIAGE_RETURN, ESCAPE_CHAR, 'b', CPM_NUM+15, "Execute from ", 0
0554   E21A 45 78 65 63 
0554   E21E 75 74 65 20 
0554   E222 66 72 6F 6D 
0554   E226 20 00 
0555   E228 21 66 E2                        LD      HL, _exec_done
0556   E22B E5                              PUSH    HL
0557   E22C 2A A0 E1                        LD      HL, (monitor_address)
0558   E22F 3A A3 E1                        LD      A, (edit_col)
0559   E232 5F                              LD      E, A
0560   E233 16 00                           LD      D, 0
0561   E235 19                              ADD     HL, DE
0562   E236                                 
0563   E236 E5                              PUSH    HL
0564   E237 EB                              EX      DE, HL
0565   E238 CD 3B E5                        CALL    hex_word
0566   E23B CD 3E F0                        CALL    m_print_inline
0567   E23E 20 59 2F 4E                     .DB     " Y/N?", ESCAPE_CHAR, "K", 0
0567   E242 3F 1B 4B 00 
0568   E246             
0569   E246 CD C6 EB    _exec_loop          CALL    bios_conin
0570   E249 FE 79                           CP      'y'
0571   E24B 28 09                           JR      Z, _exec_go
0572   E24D FE 6E                           CP      'n'
0573   E24F 20 F5                           JR      NZ, _exec_loop
0574   E251 E1                              POP     HL
0575   E252 E1                              POP     HL
0576   E253 C3 A6 E1                        JP      memory_view
0577   E256             
0578   E256 CD 3E F0    _exec_go            CALL    m_print_inline
0579   E259 0A 0D 52 75                     .DB     NEWLINE, CARRIAGE_RETURN, "Running", ESCAPE_CHAR, "K", 0
0579   E25D 6E 6E 69 6E 
0579   E261 67 1B 4B 00 
0580   E265 C9                              RET
0581   E266             
0582   E266 F5          _exec_done          PUSH    AF
0583   E267 CD 3E F0                        CALL    m_print_inline
0584   E26A 0A 0D 44 6F                     .DB     NEWLINE, CARRIAGE_RETURN, "Done. A=",0
0584   E26E 6E 65 2E 20 
0584   E272 41 3D 00 
0585   E275 F1                              POP     AF
0586   E276 CD 42 E5                        CALL    hex_out
0587   E279 CD 3E F0                        CALL    m_print_inline
0588   E27C 1B 4B 00                        .DB     ESCAPE_CHAR, "K", 0
0589   E27F CD C6 EB                        CALL    bios_conin ;pause for a key, then return to memory edit at the execution location
0590   E282             
0591   E282             
0592   E282 AF          edit_memory         XOR     A
0593   E283 32 A3 E1    _set_col_and_edit   LD      (edit_col), A
0594   E286 CD 42 E3    _edit_loop          CALL    display_mem_row
0595   E289 3A A3 E1                        LD      A, (edit_col)
0596   E28C 87                              ADD     A, A
0597   E28D 4F                              LD      C, A
0598   E28E 3A A2 E1                        LD      A, (monitor_mode)
0599   E291 A7                              AND     A
0600   E292 20 04                           JR      NZ, _address_hidden
0601   E294 3E 05                           LD      A, 5
0602   E296 81                              ADD     A, C
0603   E297 4F                              LD      C, A
0604   E298 3A 2D FF    _address_hidden     LD      A, (cursor_row)
0605   E29B C6 1F                           ADD     A, 31
0606   E29D 32 AE E2                        LD      (_edit_set_row), A
0607   E2A0 79                              LD      A, C
0608   E2A1 C6 20                           ADD     A, 32
0609   E2A3 32 AF E2                        LD      (_edit_set_col), A
0610   E2A6             
0611   E2A6 CD 3E F0                        CALL    m_print_inline
0612   E2A9 1B 62 27                        .DB     ESCAPE_CHAR, 'b', CPM_NUM+8         ; Set the correct brightness
0613   E2AC 1B 59                           .DB     ESCAPE_CHAR, 'Y'                    ; And position the cursor
0614   E2AE 00          _edit_set_row       .DB     0
0615   E2AF 00          _edit_set_col       .DB     0
0616   E2B0 00                              .DB     0
0617   E2B1             
0618   E2B1 11 00 02                        LD      DE, 0200h
0619   E2B4 ED 53 A4 E1 _edit_next_digit    LD      (edit_digit), DE
0620   E2B8             
0621   E2B8 CD C6 EB    _edit_input         CALL    bios_conin
0622   E2BB CD C6 E4                        CALL    translate_cursors
0623   E2BE             
0624   E2BE FE 78                           CP      'x'
0625   E2C0 CA 13 E2                        JP      Z, execute_col
0626   E2C3             
0627   E2C3 FE 83                           CP      KEY_RIGHT
0628   E2C5 20 1B                           JR      NZ, _not_right
0629   E2C7 3A A3 E1    _edit_right         LD      A, (edit_col)
0630   E2CA FE 07                           CP      7
0631   E2CC 28 03                           JR      Z, _edit_wrap_down
0632   E2CE 3C                              INC     A
0633   E2CF 18 B2                           JR      _set_col_and_edit
0634   E2D1             
0635   E2D1 AF          _edit_wrap_down     XOR     A
0636   E2D2 32 A3 E1                        LD      (edit_col),A
0637   E2D5 11 08 00    _edit_down          LD      DE, 08h
0638   E2D8 2A A0 E1    _edit_move          LD      HL, (monitor_address)
0639   E2DB 19                              ADD     HL, DE
0640   E2DC 22 A0 E1                        LD      (monitor_address), HL
0641   E2DF C3 86 E2                        JP      _edit_loop
0642   E2E2             
0643   E2E2 FE 82       _not_right          CP      KEY_LEFT
0644   E2E4 20 13                           JR      NZ, _not_left
0645   E2E6 3A A3 E1                        LD      A, (edit_col)
0646   E2E9 A7                              AND     A
0647   E2EA 28 03                           JR      Z, _edit_wrap_up
0648   E2EC 3D                              DEC     A
0649   E2ED 18 94                           JR      _set_col_and_edit
0650   E2EF             
0651   E2EF 3E 07       _edit_wrap_up       LD      A, 7
0652   E2F1 32 A3 E1                        LD      (edit_col),A
0653   E2F4 11 F8 FF    _edit_up            LD      DE, 0FFF8h
0654   E2F7 18 DF                           JR      _edit_move
0655   E2F9             
0656   E2F9 FE 80       _not_left           CP      KEY_UP
0657   E2FB CA F4 E2                        JP      Z, _edit_up
0658   E2FE FE 81                           CP      KEY_DOWN
0659   E300 CA D5 E2                        JP      Z, _edit_down
0660   E303 FE 08                           CP      KEY_BACKSPACE
0661   E305 C2 13 E3                        JP      NZ, _not_delete
0662   E308             
0663   E308 3A A5 E1                        LD      A, (edit_digit+1)
0664   E30B FE 02                           CP      2
0665   E30D CA A6 E1                        JP      Z, memory_view
0666   E310 C3 86 E2                        JP      _edit_loop
0667   E313             
0668   E313 CD 69 E5    _not_delete         CALL    valid_hex_char
0669   E316 38 A0                           JR      C, _edit_input
0670   E318             
0671   E318 4F                              LD      C, A
0672   E319 CD 79 E5                        CALL    hex_char_to_num
0673   E31C F5                              PUSH    AF
0674   E31D CD 3A EC                        CALL    bios_conout
0675   E320 F1                              POP     AF
0676   E321                                 
0677   E321 ED 5B A4 E1                     LD      DE, (edit_digit)
0678   E325 CB 23                           SLA     E
0679   E327 CB 23                           SLA     E
0680   E329 CB 23                           SLA     E
0681   E32B CB 23                           SLA     E
0682   E32D B3                              OR      E
0683   E32E 5F                              LD      E, A
0684   E32F 15                              DEC     D
0685   E330 20 82                           JR      NZ, _edit_next_digit
0686   E332             
0687   E332 3A A3 E1                        LD      A, (edit_col)
0688   E335 4F                              LD      C, A
0689   E336 06 00                           LD      B, 0
0690   E338 2A A0 E1                        LD      HL, (monitor_address)
0691   E33B 09                              ADD     HL, BC
0692   E33C 73                              LD      (HL), E
0693   E33D CD 42 E3                        CALL    display_mem_row
0694   E340 18 85                           JR      _edit_right
0695   E342             
0696   E342 0E 0D       display_mem_row     LD      C, CARRIAGE_RETURN
0697   E344 CD 3A EC                        CALL    bios_conout
0698   E347 3A A2 E1                        LD      A, (monitor_mode)
0699   E34A A7                              AND     A
0700   E34B 20 14                           JR      NZ, _hex_values
0701   E34D             
0702   E34D CD 3E F0                        CALL    m_print_inline
0703   E350 0D 1B 62 2E                     .DB     CARRIAGE_RETURN, ESCAPE_CHAR, 'b', CPM_NUM+15, 0
0703   E354 00 
0704   E355             
0705   E355 ED 5B A0 E1                     LD      DE, (monitor_address)
0706   E359 CD 3B E5                        CALL    hex_word
0707   E35C             
0708   E35C 0E 20                           LD      C, ' '
0709   E35E CD 3A EC                        CALL    bios_conout
0710   E361             
0711   E361 CD 3E F0    _hex_values         CALL    m_print_inline
0712   E364 1B 62 26 00                     .DB     ESCAPE_CHAR, 'b', CPM_NUM+7, 0
0713   E368             
0714   E368 2A A0 E1                        LD      HL, (monitor_address)
0715   E36B 06 08                           LD      B, 8
0716   E36D 7E          _mem_hex            LD      A, (HL)
0717   E36E E5                              PUSH    HL
0718   E36F C5                              PUSH    BC
0719   E370 CD 42 E5                        CALL    hex_out
0720   E373 C1                              POP     BC
0721   E374 E1                              POP     HL
0722   E375 23                              INC     HL
0723   E376 10 F5                           DJNZ    _mem_hex
0724   E378             
0725   E378 CD 3E F0                        CALL    m_print_inline
0726   E37B 1B 62 2E 00                     .DB     ESCAPE_CHAR, 'b', CPM_NUM+15, 0
0727   E37F             
0728   E37F 2A A0 E1                        LD      HL, (monitor_address)
0729   E382 06 03                           LD      B, 3
0730   E384 3A A2 E1                        LD      A, (monitor_mode)
0731   E387 A7                              AND     A
0732   E388 28 02                           JR      Z, _mem_char
0733   E38A 06 08                           LD      B, 8
0734   E38C             
0735   E38C 7E          _mem_char           LD      A, (HL)
0736   E38D FE 20                           CP      ' '
0737   E38F D2 94 E3                        JP      NC, _not_control_char
0738   E392 3E 2E                           LD      A, '.'
0739   E394 FE 80       _not_control_char   CP      128
0740   E396 DA 9B E3                        JP      C, _not_extended_char
0741   E399 3E 2E                           LD      A, '.'
0742   E39B E5          _not_extended_char  PUSH    HL
0743   E39C C5                              PUSH    BC
0744   E39D 4F                              LD      C, A
0745   E39E CD 3A EC                        CALL    bios_conout
0746   E3A1 C1                              POP     BC
0747   E3A2 E1                              POP     HL
0748   E3A3 23                              INC     HL
0749   E3A4 10 E6                           DJNZ    _mem_char
0750   E3A6 C9                              RET
0751   E3A7             
0752   E3A7             ; Format memory disk
0753   E3A7             ;
0754   E3A7 3E 01       format_memdisk      LD      A, 1
0755   E3A9 4F                              LD      C, A
0756   E3AA CD 69 EF                        CALL    bios_seldsk
0757   E3AD             
0758   E3AD 21 80 00                        LD      HL, BIOS_SECTOR_ADDRESS     ; Sector buffer
0759   E3B0 22 EE E3                        LD      (_fmt_address),HL
0760   E3B3             
0761   E3B3 54                              LD      D, H                        ; Fill sector buffer with 0E5h (blank byte)
0762   E3B4 5D                              LD      E, L
0763   E3B5 13                              INC     DE
0764   E3B6 3E E5                           LD      A, 0E5h
0765   E3B8 77                              LD      (HL),A
0766   E3B9 01 7F 00                        LD      BC, 07fh
0767   E3BC ED B0                           LDIR
0768   E3BE             
0769   E3BE 3E 02                           LD      A,BIOS_BOOT_TRACKS          ; First track (Offset = 2)
0770   E3C0 32 EC E3    _fmt_track_loop     LD      (_fmt_track),A
0771   E3C3 4F                              LD      C,A                         ; Set track
0772   E3C4 CD 84 EF                        CALL    bios_settrk
0773   E3C7             
0774   E3C7 AF                              XOR     A                           ; Initial sector
0775   E3C8 32 ED E3    _fmt_sector_loop    LD      (_fmt_sector),A
0776   E3CB             
0777   E3CB FE 1A                           CP      MEMDISK_SECTORS
0778   E3CD 28 14                           JR      Z,_fmt_next_track
0779   E3CF 4F                              LD      C,A                         ; Set sector
0780   E3D0 CD 89 EF                        CALL    bios_setsec
0781   E3D3 ED 4B EE E3                     LD      BC,(_fmt_address)           ; Address to write from
0782   E3D7 CD 8E EF                        CALL    bios_setdma
0783   E3DA CD CC EF                        CALL    bios_write
0784   E3DD 3A ED E3                        LD      A,(_fmt_sector)
0785   E3E0             
0786   E3E0 3C                              INC     A
0787   E3E1 18 E5                           JR      _fmt_sector_loop
0788   E3E3             
0789   E3E3 3A EC E3    _fmt_next_track     LD      A,(_fmt_track)
0790   E3E6 FE 4F                           CP      MEMDISK_TRACKS
0791   E3E8 C8                              RET     Z
0792   E3E9 3C                              INC     A
0793   E3EA 18 D4                           JR      _fmt_track_loop
0794   E3EC             
0795   E3EC 00          _fmt_track          .DB     0
0796   E3ED 00          _fmt_sector         .DB     0
0797   E3EE 00 00       _fmt_address        .DW     0
0798   E3F0             
0799   E3F0             ;------------------------------------------------------
0800   E3F0             ; Read hex input into the (input_hex) address
0801   E3F0             ; Params - B = number of characters to input
0802   E3F0             ;
0803   E3F0 78          hex_input           LD      A, B
0804   E3F1 32 35 E4                        LD      (_hi_size), A
0805   E3F4 21 00 00                        LD      HL, 0
0806   E3F7 22 60 E4                        LD      (hex_input_result), HL
0807   E3FA             
0808   E3FA C5          _hi_loop            PUSH    BC
0809   E3FB CD 5D E5    _hi_loop_join       CALL    hex_char_in
0810   E3FE FE 08                           CP      KEY_BACKSPACE
0811   E400 28 34                           JR      Z, _hi_delete
0812   E402 4F                              LD      C, A
0813   E403 F5                              PUSH    AF
0814   E404 CD 3A EC                        CALL    bios_conout
0815   E407 F1                              POP     AF
0816   E408 CD 79 E5                        CALL    hex_char_to_num
0817   E40B 2A 60 E4                        LD      HL, (hex_input_result)
0818   E40E CB 27                           SLA     A
0819   E410 CB 27                           SLA     A
0820   E412 CB 27                           SLA     A
0821   E414 CB 27                           SLA     A
0822   E416             
0823   E416 CB 27                           SLA     A
0824   E418 CB 15                           RL      L
0825   E41A CB 14                           RL      H
0826   E41C CB 27                           SLA     A
0827   E41E CB 15                           RL      L
0828   E420 CB 14                           RL      H
0829   E422 CB 27                           SLA     A
0830   E424 CB 15                           RL      L
0831   E426 CB 14                           RL      H
0832   E428 CB 27                           SLA     A
0833   E42A CB 15                           RL      L
0834   E42C CB 14                           RL      H
0835   E42E 22 60 E4                        LD      (hex_input_result), HL
0836   E431 C1                              POP     BC
0837   E432 10 C6                           DJNZ    _hi_loop
0838   E434 C9                              RET
0839   E435             
0840   E435 00          _hi_size            .DB     0
0841   E436             
0842   E436 C1          _hi_delete          POP     BC
0843   E437 3A 35 E4    _hi_delete_join     LD      A, (_hi_size)
0844   E43A B8                              CP      B
0845   E43B 28 BD                           JR      Z, _hi_loop
0846   E43D 04                              INC     B
0847   E43E C5                              PUSH    BC
0848   E43F             
0849   E43F 2A 60 E4                        LD      HL, (hex_input_result)
0850   E442 CB 3C                           SRL     H
0851   E444 CB 1D                           RR      L
0852   E446 CB 3C                           SRL     H
0853   E448 CB 1D                           RR      L
0854   E44A CB 3C                           SRL     H
0855   E44C CB 1D                           RR      L
0856   E44E CB 3C                           SRL     H
0857   E450 CB 1D                           RR      L
0858   E452 22 60 E4                        LD      (hex_input_result), HL
0859   E455             
0860   E455 CD 3E F0                        CALL    m_print_inline
0861   E458 1B 44 20 1B                     .DB     ESCAPE_CHAR, "D ", ESCAPE_CHAR, "D", 0
0861   E45C 44 00 
0862   E45E 18 9B                           JR      _hi_loop_join
0863   E460             
0864   E460 00 00       hex_input_result    .DW     0
0865   E462             
0866   E462             delete_or_enter     ; Wait for Delete or enter keys and handle..
0867   E462 CD C6 EB                        CALL    bios_conin
0868   E465 FE 0D                           CP      CARRIAGE_RETURN
0869   E467 C8                              RET     Z
0870   E468 06 00                           LD      B, 0
0871   E46A FE 08                           CP      KEY_BACKSPACE
0872   E46C CC 37 E4                        CALL    Z, _hi_delete_join
0873   E46F 18 F1                           JR      delete_or_enter
0874   E471             
0875   E471             
0876   E471             ;------------------------------------------------------
0877   E471             ; Menu system
0878   E471 00          menu_index          .DB     0
0879   E472 00 00       menu_address        .DW     0
0880   E474 00 00       menu_current        .DW     0
0881   E476             
0882   E476 AF          start_menu          XOR    A
0883   E477 32 71 E4                        LD     (menu_index), A
0884   E47A 22 72 E4                        LD     (menu_address), HL
0885   E47D 32 C5 E4                        LD     (keyboard_escape), A
0886   E480             
0887   E480 CD FB E4    _menu_loop          CALL    _display_menu
0888   E483 01 58 02                        LD      BC, 600
0889   E486 CD 83 E5                        CALL    pause_for_ticks
0890   E489 CD 9D EB                        CALL    bios_conist
0891   E48C A7                              AND     A
0892   E48D C8                              RET     Z
0893   E48E             
0894   E48E CD C6 EB    _menu_key           CALL    bios_conin
0895   E491 CD C6 E4                        CALL    translate_cursors
0896   E494             
0897   E494 FE 81                           CP      KEY_DOWN
0898   E496 28 0D                           JR      Z, _menu_down
0899   E498 FE 80                           CP      KEY_UP
0900   E49A 28 12                           JR      Z, _menu_up
0901   E49C FE 08                           CP      KEY_BACKSPACE
0902   E49E C8                              RET     Z
0903   E49F FE 0D                           CP      KEY_ENTER
0904   E4A1 28 13                           JR      Z, _menu_enter
0905   E4A3 18 DB                           JR      _menu_loop
0906   E4A5             
0907   E4A5 3A 71 E4    _menu_down          LD      A, (menu_index)
0908   E4A8 3C                              INC     A
0909   E4A9 32 71 E4    _menu_set_index     LD      (menu_index),A
0910   E4AC 18 D2                           JR      _menu_loop
0911   E4AE             
0912   E4AE 3A 71 E4    _menu_up            LD      A, (menu_index)
0913   E4B1 3D                              DEC     A
0914   E4B2 28 CC                           JR      Z, _menu_loop
0915   E4B4 18 F3                           JR      _menu_set_index
0916   E4B6             
0917   E4B6 3A 71 E4    _menu_enter         LD      A, (menu_index)
0918   E4B9 A7                              AND     A
0919   E4BA 28 C4                           JR      Z, _menu_loop
0920   E4BC 2A 74 E4                        LD      HL, (menu_current)
0921   E4BF 7E                              LD      A, (HL)
0922   E4C0 23                              INC     HL
0923   E4C1 66                              LD      H, (HL)
0924   E4C2 6F                              LD      L, A
0925   E4C3 E5                              PUSH    HL
0926   E4C4 C9                              RET
0927   E4C5             
0928   E4C5 00          keyboard_escape     .DB     0
0929   E4C6             
0930   E4C6 FE 1B       translate_cursors   CP      KEY_ESCAPE
0931   E4C8 5F                              LD      E, A 
0932   E4C9 28 29                           JR      Z, _set_escape
0933   E4CB 3A C5 E4                        LD      A, (keyboard_escape)
0934   E4CE A7                              AND     A
0935   E4CF 7B                              LD      A, E                    ; Just return key code if escape hasn't been pressed
0936   E4D0 C8                              RET     Z
0937   E4D1                                                                 ; Handle VT Escape sequences
0938   E4D1 FE 5B                           CP      '['                     ; Ignore '[' (VT100 cursor sequence)
0939   E4D3 C8                              RET     Z
0940   E4D4 FE 41                           CP      'A'
0941   E4D6 16 80                           LD      D, KEY_UP
0942   E4D8 28 18                           JR      Z, _translate_key
0943   E4DA FE 42                           CP      'B'
0944   E4DC 16 81                           LD      D, KEY_DOWN
0945   E4DE 28 12                           JR      Z, _translate_key
0946   E4E0 FE 43                           CP      'C'
0947   E4E2 16 83                           LD      D, KEY_RIGHT
0948   E4E4 28 0C                           JR      Z, _translate_key
0949   E4E6 FE 44                           CP      'D'
0950   E4E8 16 82                           LD      D, KEY_LEFT
0951   E4EA 28 06                           JR      Z, _translate_key
0952   E4EC AF                              XOR     A                       ; Ignore rest of escape sequence
0953   E4ED 32 C5 E4                        LD      (keyboard_escape), A
0954   E4F0 7B          _return_e           LD      A, E
0955   E4F1 C9                              RET
0956   E4F2             
0957   E4F2 7A          _translate_key      LD      A, D
0958   E4F3 C9                              RET
0959   E4F4             
0960   E4F4 3E 01       _set_escape         LD      A, 1
0961   E4F6 32 C5 E4                        LD      (keyboard_escape), A
0962   E4F9 18 F5                           JR      _return_e
0963   E4FB             
0964   E4FB             
0965   E4FB 0E 0D       _display_menu       LD      C, CARRIAGE_RETURN
0966   E4FD CD 3A EC                        CALL    bios_conout
0967   E500             
0968   E500 3A 71 E4                        LD      A, (menu_index)
0969   E503 2A 72 E4                        LD      HL, (menu_address)
0970   E506 A7          _entry_loop         AND     A
0971   E507 28 12                           JR      Z, _display_entry
0972   E509 47                              LD      B, A
0973   E50A 7E          _next_menu          LD      A, (HL)
0974   E50B 23                              INC     HL
0975   E50C A7                              AND     A
0976   E50D 20 FB                           JR      NZ, _next_menu
0977   E50F             
0978   E50F 22 74 E4                        LD      (menu_current), HL
0979   E512 7E                              LD      A, (HL)
0980   E513 23                              INC     HL
0981   E514 5E                              LD      E, (HL)
0982   E515 23                              INC     HL
0983   E516 B3                              OR      E
0984   E517 28 19                           JR      Z, _menu_end
0985   E519 10 EF                           DJNZ    _next_menu
0986   E51B                                 
0987   E51B 7E          _display_entry      LD      A, (HL)
0988   E51C A7                              AND     A
0989   E51D 28 09                           JR      Z, _entry_end
0990   E51F 4F                              LD      C, A
0991   E520 E5                              PUSH    HL
0992   E521 CD 3A EC                        CALL    bios_conout
0993   E524 E1                              POP     HL
0994   E525 23                              INC     HL
0995   E526 18 F3                           JR      _display_entry
0996   E528 0E 1B       _entry_end          LD      C, ESCAPE_CHAR
0997   E52A CD 3A EC                        CALL    bios_conout
0998   E52D 0E 4B                           LD      C, 'K'
0999   E52F C3 3A EC                        JP      bios_conout
1000   E532             
1001   E532 3A 71 E4    _menu_end           LD      A, (menu_index)
1002   E535 3D                              DEC     A
1003   E536 32 71 E4                        LD      (menu_index), A
1004   E539 18 C0                           JR      _display_menu
1005   E53B             
1006   E53B             
1007   E53B             ;------------------------------------------------------
1008   E53B             ; Write the Hex value of DE as four characters to conout
1009   E53B             ;
1010   E53B D5          hex_word            PUSH    DE
1011   E53C 7A                              LD      A, D
1012   E53D CD 42 E5                        CALL    hex_out
1013   E540 D1                              POP     DE
1014   E541 7B                              LD      A, E                ; Fall into hex_out..
1015   E542             
1016   E542             ;------------------------------------------------------
1017   E542             ; Write the Hex value of A as two characters to conout
1018   E542             ;
1019   E542 4F          hex_out             LD      C, A
1020   E543 CB 3F                           SRL     A
1021   E545 CB 3F                           SRL     A
1022   E547 CB 3F                           SRL     A
1023   E549 CB 3F                           SRL     A
1024   E54B C5                              PUSH    BC
1025   E54C CD 51 E5                        CALL    _nibble
1026   E54F C1                              POP     BC
1027   E550 79                              LD      A, C
1028   E551             
1029   E551 E6 0F       _nibble             AND     $0F      ;LOW NIBBLE ONLY
1030   E553 C6 90                           ADD     A,$90
1031   E555 27                              DAA 
1032   E556 CE 40                           ADC     A,$40
1033   E558 27                              DAA 
1034   E559 4F                              LD      C,A
1035   E55A C3 3A EC                        JP      bios_conout
1036   E55D             
1037   E55D             
1038   E55D             ;------------------------------------------------------
1039   E55D             ; Only accept hex characters (0-9, a-f), or DELETE from the input
1040   E55D             ; Returns with character in A, a-f are capitalised
1041   E55D             ;
1042   E55D CD C6 EB    hex_char_in         CALL    bios_conin
1043   E560 FE 08                           CP      KEY_BACKSPACE
1044   E562 C8                              RET     Z
1045   E563 CD 69 E5                        CALL    valid_hex_char
1046   E566 38 F5                           JR      C, hex_char_in
1047   E568 C9                              RET
1048   E569             ;
1049   E569             ; Return with carry CLEAR if the character is a valid hex digit
1050   E569             ; Enter with A = character to test
1051   E569             ; Returns with A capitalised
1052   E569 FE 30       valid_hex_char      CP      '0'
1053   E56B D8                              RET     C
1054   E56C FE 3A                           CP      ':'
1055   E56E 3F                              CCF
1056   E56F D0                              RET     NC
1057   E570 FE 61                           CP      'a'
1058   E572 D8                              RET     C
1059   E573 FE 67                           CP      'g'
1060   E575 CB AF                           RES     5, a                ; Capitalise it..
1061   E577 3F                              CCF
1062   E578 C9                              RET
1063   E579             
1064   E579 FE 41       hex_char_to_num     CP      'A'
1065   E57B 30 03                           JR      NC, _alpha_char
1066   E57D D6 30                           SUB     '0'
1067   E57F C9                              RET
1068   E580 D6 37       _alpha_char         SUB     'A'-10
1069   E582 C9                              RET
1070   E583             
1071   E583             ;
1072   E583             ; Pause for BC ticks
1073   E583             ; Uses HL, DE
1074   E583             ;
1075   E583 ED 5B 04 FF pause_for_ticks     LD      DE, (timer)
1076   E587 C5          _pause_loop         PUSH    BC
1077   E588 D5                              PUSH    DE
1078   E589 CD 9D EB                        CALL    bios_conist
1079   E58C D1                              POP     DE
1080   E58D C1                              POP     BC
1081   E58E A7                              AND     A
1082   E58F C0                              RET     NZ
1083   E590 2A 04 FF                        LD      HL, (timer)
1084   E593 ED 52                           SBC     HL, DE
1085   E595 ED 42                           SBC     HL, BC
1086   E597 38 EE                           JR      C, _pause_loop
1087   E599 C9                              RET
1088   E59A             ;
1089   E59A             ; Detect (and time) interrupt
1090   E59A             ; Enter with A containing the mask for which bits of the timer byte we check for zero
1091   E59A             ; Return when the timer is zero, with BC containing 72 + 48*t-states taken
1092   E59A             ;
1093   E59A 01 00 00    detect_int          LD      BC, 0
1094   E59D 57                              LD      D, A
1095   E59E 3A 04 FF    _wait_for_tick      LD      A, (timer)               ; 13            ; Loop = 13+4+5+6+4+4+12 (=48) * BC + (13 + 4 + 11 + 13 + 4 + 17 + 10 (CALL)) = 72
1096   E5A1 A2                              AND     D                        ; 4
1097   E5A2 C8                              RET     Z                        ; 5 / 11
1098   E5A3 03                              INC     BC                       ; 6
1099   E5A4 79                              LD      A, C                     ; 4
1100   E5A5 B0                              OR      B                        ; 4
1101   E5A6 20 F6                           JR      NZ, _wait_for_tick       ; 7 / 12
1102   E5A8 C9                              RET
1103   E5A9             ;
1104   E5A9             ; Fast int routine to allow us to time CPU speed
1105   E5A9             ;
1106   E5A9 F3          timer_int           DI
1107   E5AA E5                              PUSH    HL
1108   E5AB 2A 04 FF                        LD      HL, (timer)
1109   E5AE 23                              INC     HL
1110   E5AF 22 04 FF                        LD      (timer), HL
1111   E5B2 E1                              POP     HL
1112   E5B3 FB                              EI
1113   E5B4 ED 4D                           RETI
1114   E5B6             
1115   E5B6             ; Divide HL by C (unsigned)
1116   E5B6             ;Inputs:
1117   E5B6             ;     HL is the numerator
1118   E5B6             ;     C is the denominator
1119   E5B6             ;Outputs:
1120   E5B6             ;     A is the remainder
1121   E5B6             ;     B is 0
1122   E5B6             ;     C is not changed
1123   E5B6             ;     DE is not changed
1124   E5B6             ;     HL is the quotient
1125   E5B6             ;
1126   E5B6             divide_hl_c
1127   E5B6 06 10                           LD      B, 16
1128   E5B8 AF                              XOR     A
1129   E5B9 29          _div0               ADD     HL, HL
1130   E5BA 17                              RLA
1131   E5BB B9                              CP      C
1132   E5BC 38 02                           JR      C,_div1
1133   E5BE 2C                              INC     L
1134   E5BF 91                              SUB     C
1135   E5C0 10 F7       _div1               DJNZ    _div0
1136   E5C2 C9                              RET
1137   E5C3             
1138   E5C3             ;
1139   E5C3             ; Convert DE to a five digit BCD value stored in bcd_scratch
1140   E5C3             ; 
1141   E5C3 AF          de_to_bcd           XOR     A
1142   E5C4 21 FB E5                        LD      HL, bcd_scratch
1143   E5C7 06 05                           LD      B, 5
1144   E5C9 77          _clear_scratch      LD      (HL), A
1145   E5CA 23                              INC     HL
1146   E5CB 10 FC                           DJNZ    _clear_scratch
1147   E5CD                 
1148   E5CD 06 10                           LD      B, 16           ; Convert 16 bits
1149   E5CF 0E 05       _bcd_loop           LD      C, 5
1150   E5D1 21 FB E5                        LD      HL, bcd_scratch
1151   E5D4 7E          _correct_digits     LD      A, (HL)
1152   E5D5 FE 05                           CP      5
1153   E5D7 38 03                           JR      C, _digit_ok
1154   E5D9 C6 03                           ADD     A, 3
1155   E5DB 77                              LD      (HL), A
1156   E5DC 23          _digit_ok           INC     HL
1157   E5DD 0D                              DEC     C
1158   E5DE 20 F4                           JR      NZ, _correct_digits                   
1159   E5E0             
1160   E5E0 21 FB E5                        LD      HL, bcd_scratch
1161   E5E3 0E 05                           LD      C, 5
1162   E5E5 CB 23                           SLA     E
1163   E5E7 CB 12                           RL      D
1164   E5E9             
1165   E5E9 7E          _shift_digits       LD      A, (HL)
1166   E5EA CB 17                           RL      A
1167   E5EC CB 67                           BIT     4, A
1168   E5EE 28 03                           JR      Z, _skip_carry
1169   E5F0 E6 0F                           AND     0Fh
1170   E5F2 37                              SCF
1171   E5F3 77          _skip_carry         LD      (HL), A
1172   E5F4 23                              INC     HL
1173   E5F5 0D                              DEC     C
1174   E5F6 20 F1                           JR      NZ, _shift_digits
1175   E5F8 10 D5                           DJNZ    _bcd_loop
1176   E5FA C9                              RET
1177   E5FB             
1178   E5FB 00 00 00 00 bcd_scratch         .DB      0,0,0,0,0      ; Five bytes - 0 to 99,999. Smallest digit (units) first
1178   E5FF 00 
1179   E600             
1180   E600                                 .INCLUDE  "monitor_rtc.asm"
0001+  E600             ;
0002+  E600             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0003+  E600             ;
0004+  E600             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0005+  E600             ;
0006+  E600             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0007+  E600             ; of this software and associated documentation files (the "Software"), to deal
0008+  E600             ; in the Software without restriction, including without limitation the rights
0009+  E600             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0010+  E600             ; copies of the Software, and to permit persons to whom the Software is
0011+  E600             ; furnished to do so, subject to the following conditions:
0012+  E600             ; 
0013+  E600             ; The above copyright notice and this permission notice shall be included in all
0014+  E600             ; copies or substantial portions of the Software.
0015+  E600             ; 
0016+  E600             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0017+  E600             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0018+  E600             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0019+  E600             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0020+  E600             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0021+  E600             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0022+  E600             ; SOFTWARE.
0023+  E600             ;
0024+  E600                                     .MODULE monitor_rtc
0025+  E600             
0026+  E600             _offset_sec             .EQU    0
0027+  E600             _offset_min             .EQU    1
0028+  E600             _offset_hour            .EQU    2
0029+  E600             _offset_wkday           .EQU    3
0030+  E600             _offset_date            .EQU    4
0031+  E600             _offset_month           .EQU    5
0032+  E600             _offset_year            .EQU    6
0033+  E600             
0034+  E600             
0035+  E600 21 DD F9    rtc_display_time        LD      HL, time_scratch
0036+  E603 CD B1 F9                            CALL    rtc_get_time_hl
0037+  E606 D2 D6 E6                            JP      NC, _get_error
0038+  E609             
0039+  E609 0E 0D                               LD      C, CARRIAGE_RETURN
0040+  E60B CD 3A EC                            CALL    bios_conout
0041+  E60E                                     
0042+  E60E 3A E0 F9                            LD      A, (time_scratch+_offset_wkday)
0043+  E611 21 8A E6                            LD      HL, weekdays
0044+  E614 4F                                  LD      C, A
0045+  E615             
0046+  E615 CD 74 E6                            CALL    _search_word
0047+  E618                                     
0048+  E618 CD 55 E6    _get_date               CALL    _space
0049+  E61B 3A E1 F9                            LD      A, (time_scratch+_offset_date)
0050+  E61E CD 52 E6                            CALL    _two_chars_space
0051+  E621             
0052+  E621 3A E2 F9                            LD      A, (time_scratch+_offset_month)
0053+  E624 21 A6 E6                            LD      HL, _months
0054+  E627 CB 67                               BIT     4, A
0055+  E629 28 02                               JR      Z, _month_ok
0056+  E62B D6 06                               SUB     6
0057+  E62D 4F          _month_ok               LD      C,A
0058+  E62E             
0059+  E62E CD 74 E6                            CALL    _search_word
0060+  E631 CD 55 E6                            CALL    _space
0061+  E634 3E 20                               LD      A, 20h
0062+  E636 CD 5A E6                            CALL    _two_chars
0063+  E639             
0064+  E639 3A E3 F9                            LD      A, (time_scratch+_offset_year)
0065+  E63C CD 52 E6                            CALL    _two_chars_space
0066+  E63F             
0067+  E63F 3A DF F9                            LD      A, (time_scratch+_offset_hour)
0068+  E642 CD 52 E6                            CALL    _two_chars_space
0069+  E645             
0070+  E645 3A DE F9                            LD      A, (time_scratch+_offset_min)
0071+  E648 CD 52 E6                            CALL    _two_chars_space
0072+  E64B             
0073+  E64B 3A DD F9                            LD      A, (time_scratch+_offset_sec)
0074+  E64E CD 5A E6                            CALL    _two_chars
0075+  E651 C9                                  RET
0076+  E652             
0077+  E652 CD 5A E6    _two_chars_space       CALL    _two_chars
0078+  E655 0E 20       _space                  LD      C, ' '
0079+  E657 C3 3A EC                            JP      bios_conout
0080+  E65A             
0081+  E65A 4F          _two_chars              LD      C,A
0082+  E65B CB 3F                               SRL     A
0083+  E65D CB 3F                               SRL     A
0084+  E65F CB 3F                               SRL     A
0085+  E661 CB 3F                               SRL     A
0086+  E663 C6 30                               ADD     A, '0'
0087+  E665 C5                                  PUSH    BC
0088+  E666 4F                                  LD      C, A
0089+  E667 CD 3A EC                            CALL    bios_conout
0090+  E66A C1                                  POP     BC
0091+  E66B 79                                  LD      A,C
0092+  E66C E6 0F                               AND     0fh
0093+  E66E C6 30                               ADD     A, '0'
0094+  E670 4F                                  LD      C, A
0095+  E671 C3 3A EC                            JP      bios_conout
0096+  E674             ;
0097+  E674             ; Search table pointed to by HL for the C'th word (1-based)
0098+  E674             ; Prints the chosen word to conout
0099+  E674             ;
0100+  E674 0D          _search_word            DEC     C
0101+  E675 20 0C                               JR      NZ, _next_char
0102+  E677                                     
0103+  E677 7E          _print_word             LD      A, (HL)
0104+  E678 23                                  INC     HL
0105+  E679 A7                                  AND     A
0106+  E67A C8                                  RET     Z
0107+  E67B 4F                                  LD      C, A
0108+  E67C E5                                  PUSH    HL
0109+  E67D CD 3A EC                            CALL    bios_conout
0110+  E680 E1                                  POP     HL
0111+  E681 18 F4                               JR      _print_word
0112+  E683             
0113+  E683 7E          _next_char              LD      A, (HL)
0114+  E684 23                                  INC     HL
0115+  E685 A7                                  AND     A
0116+  E686 20 FB                               JR      NZ, _next_char
0117+  E688 18 EA                               JR      _search_word
0118+  E68A             
0119+  E68A             
0120+  E68A 4D 6F 6E 00 weekdays                .DB "Mon",0
0121+  E68E 54 75 65 00                         .DB "Tue",0
0122+  E692 57 65 64 00                         .DB "Wed",0
0123+  E696 54 68 75 00                         .DB "Thu",0
0124+  E69A 46 72 69 00                         .DB "Fri",0
0125+  E69E 53 61 74 00                         .DB "Sat",0
0126+  E6A2 53 75 6E 00                         .DB "Sun",0
0127+  E6A6             
0128+  E6A6 4A 61 6E 00 _months                 .DB "Jan",0
0129+  E6AA 46 65 62 00                         .DB "Feb",0
0130+  E6AE 4D 61 72 00                         .DB "Mar",0
0131+  E6B2 41 70 72 00                         .DB "Apr",0
0132+  E6B6 4D 61 79 00                         .DB "May",0
0133+  E6BA 4A 75 6E 00                         .DB "Jun",0
0134+  E6BE 4A 75 6C 00                         .DB "Jul",0
0135+  E6C2 41 75 67 00                         .DB "Aug",0
0136+  E6C6 53 65 70 00                         .DB "Sep",0
0137+  E6CA 4F 63 74 00                         .DB "Oct",0
0138+  E6CE 4E 6F 76 00                         .DB "Nov",0
0139+  E6D2 44 65 63 00                         .DB "Dec",0
0140+  E6D6             
0141+  E6D6             
0142+  E6D6 CD DC F5    _get_error              CALL    i2c_stop
0143+  E6D9 CD 3E F0                            CALL    m_print_inline 
0144+  E6DC 45 72 72 6F                         .DB     "Error getting time\r\n", 0
0144+  E6E0 72 20 67 65 
0144+  E6E4 74 74 69 6E 
0144+  E6E8 67 20 74 69 
0144+  E6EC 6D 65 0D 0A 
0144+  E6F0 00 
0145+  E6F1 AF                                  XOR     A
0146+  E6F2 C9                                  RET
0147+  E6F3             
0148+  E6F3                                     .MODULE main1181   E6F3                                 .INCLUDE "ymodem.asm"
0001+  E6F3             ;
0002+  E6F3             ; YModem implementation.
0003+  E6F3             ; File format: The filename MAY indicate the load address in memory for the file. If so, the format is:
0004+  E6F3             ;       filename_mHHHH.suffix
0005+  E6F3             ;    or filename_pHH.suffix
0006+  E6F3             ;
0007+  E6F3             ; Where:  _mHHHH indicates a preferred destination address of HHHH (in memory) - four digits hexadecimal value (uppercase).
0008+  E6F3             ;   or    _pHH   indicates the page in memory that the file is intended for (assumes start at offset 0 in page..)
0009+  E6F3             ;
0010+  E6F3             ; When _p is used, the file is always written to bank 1 - address 4000h. It is expected that the calling program will
0011+  E6F3             ; then copy the data to the target page, which can be retrieved from the ym_file_mode return value.
0012+  E6F3             ; 
0013+  E6F3             ;
0014+  E6F3             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0015+  E6F3             ;
0016+  E6F3             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0017+  E6F3             ;
0018+  E6F3             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0019+  E6F3             ; of this software and associated documentation files (the "Software"), to deal
0020+  E6F3             ; in the Software without restriction, including without limitation the rights
0021+  E6F3             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0022+  E6F3             ; copies of the Software, and to permit persons to whom the Software is
0023+  E6F3             ; furnished to do so, subject to the following conditions:
0024+  E6F3             ; 
0025+  E6F3             ; The above copyright notice and this permission notice shall be included in all
0026+  E6F3             ; copies or substantial portions of the Software.
0027+  E6F3             ; 
0028+  E6F3             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0029+  E6F3             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0030+  E6F3             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0031+  E6F3             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0032+  E6F3             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0033+  E6F3             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0034+  E6F3             ; SOFTWARE.
0035+  E6F3             ;
0036+  E6F3             
0037+  E6F3                                 .MODULE ymodem
0038+  E6F3             
0039+  E6F3             _PAGE_PREFIX        .EQU    'p'
0040+  E6F3             _DEST_PREFIX        .EQU    'm'
0041+  E6F3             
0042+  E6F3             ; Return values
0043+  E6F3             YMODEM_SUCCESS      .EQU    000h
0044+  E6F3             YMODEM_TIMEOUT      .EQU    001h
0045+  E6F3             YMODEM_UNKNOWN      .EQU    002h            ; Unknown packet type (Packet byte in C)
0046+  E6F3             YMODEM_CANCEL       .EQU    003h            ; Cancelled by sender
0047+  E6F3             YMODEM_PACKET_ERROR .EQU    004h            ; Packet data error (Error code in C)
0048+  E6F3             YMODEM_LENGTH_ERROR .EQU    005h            ; Length data in zeroth packet is invalid
0049+  E6F3             YMODEM_NO_DEST      .EQU    006h            ; No destination provided
0050+  E6F3             YMODEM_SEND_TIMEOUT .EQU    007h
0051+  E6F3             YMODEM_MULTI_FILES  .EQU    008h            ; Cannot receive more than one file 
0052+  E6F3             
0053+  E6F3             _SOH                .EQU    001h            ; 128 byte data packet header
0054+  E6F3             _STX                .EQU    002h            ; 1024 byte data packet header
0055+  E6F3             _EOT                .EQU    004h            ; End transfer
0056+  E6F3             _ACK                .EQU    006h            ; Respond
0057+  E6F3             _NAK                .EQU    015h            ; No response
0058+  E6F3             _CAN                .EQU    018h            ; Transmission aborted
0059+  E6F3             _C                  .EQU    043h            ; Request packet
0060+  E6F3             
0061+  E6F3             _SOH_PACKET_SIZE    .EQU    128
0062+  E6F3             _STX_PACKET_SIZE    .EQU    1024
0063+  E6F3             _FRAME_OVERHEAD     .EQU    5               ; Three byte header + two byte CRC (high byte first)
0064+  E6F3             
0065+  E6F3             _TIMEOUT_COUNT      .EQU    50000
0066+  E6F3             
0067+  E6F3             _ERR_PACKET_COUNT   .EQU    1               ; Wrong packet index
0068+  E6F3             _ERR_CHECK_HIGH     .EQU    2               ; High byte of CRC failed
0069+  E6F3             _ERR_CHECK_LOW      .EQU    3               ; Low byte of CRC failed
0070+  E6F3             _ERR_CANCEL         .EQU    4               ; Got a cancel request without second cancel
0071+  E6F3             _ERR_ZERO_PACKET    .EQU    5               ; Zeroth packet must be SOH
0072+  E6F3             
0073+  E6F3             YM_DEST_FROM_FILE   .EQU    0FEh            ; File destination set from filename
0074+  E6F3             
0075+  E6F3             ymodem_data_length  .EQU    17              ; Size of data block before buffer
0076+  E6F3             
0077+  E6F3             ym_file_mode        .EQU    -17             ; FFh : Normal transfer,  FEh : Destination set by file, 0-7Fh : Page write 
0078+  E6F3             ym_file_count       .EQU    -16
0079+  E6F3             ym_length_low       .EQU    -15             ; Length specified in header packet
0080+  E6F3             ym_length_mid       .EQU    -14
0081+  E6F3             ym_length_high      .EQU    -13
0082+  E6F3             ym_loaded_high      .EQU    -12             ; Tracks high byte of length during load.
0083+  E6F3             ym_soh_saved_len    .EQU    -11             ; We have to copy part of a final SOH packet from the buffer - track actual length needed
0084+  E6F3             ym_soh_saved_len_h  .EQU    -10 
0085+  E6F3             ym_current_page     .EQU    -9              ; FFh if no paging, otherwise page to send data to
0086+  E6F3             ym_dest_low         .EQU    -8              ; If specified in file header - the destination address of the file
0087+  E6F3             ym_dest_high        .EQU    -7
0088+  E6F3             ym_current_packet   .EQU    -6              ; Expected packet number
0089+  E6F3             ym_packet_type      .EQU    -5              ; Packet type - SOH/STX
0090+  E6F3             ym_packet_num       .EQU    -4              ; Packet number we're currently receiving
0091+  E6F3             ym_packet_num_cpl   .EQU    -3              ; Complement..
0092+  E6F3             ym_crc_low          .EQU    -2              ; CRC Low byte
0093+  E6F3             ym_crc_high         .EQU    -1              ; CRC High byte
0094+  E6F3             
0095+  E6F3             YMODEM_BUFFER       .EQU    _SOH_PACKET_SIZE + ymodem_data_length
0096+  E6F3             YMODEM_INFO         .EQU    _SOH_PACKET_SIZE
0097+  E6F3             
0098+  E6F3             ;
0099+  E6F3             ; ymodem - Main entry point. Call with:
0100+  E6F3             ;     HL = Address of YMODEM_BUFFER (=128 + ymodem_data_length) byte buffer for receiving data
0101+  E6F3             ;     DE = (Optional) address to write data. 0xFFFF to accept destination from filename otherwise
0102+  E6F3             ;      A = Page to write data. 0xFF to disable paging/accept page from filename otherwise
0103+  E6F3             ;
0104+  E6F3             ; If using A to set a Page destination, DE should be an offset within Bank 1 (ie 4000h - 7FFFh)
0105+  E6F3             ; If the file specifies a page destination, DE is initialised to 4000h - the start of the page
0106+  E6F3             ;
0107+  E6F3             ; Returns status code in A:
0108+  E6F3             ;     YMODEM_SUCCESS : (=0) If the file was successfully received
0109+  E6F3             ;     YMODEM_xxxx    : (Non zero) If the receiver timed out waiting for a byte
0110+  E6F3             ;
0111+  E6F3             ; Note Bank 1 may have been set to a new page destination if one was specified.
0112+  E6F3             
0113+  E6F3 01 11 00    ymodem              LD      BC, ymodem_data_length      ; Skip data block at start of buffer
0114+  E6F6 09                              ADD     HL, BC
0115+  E6F7 E5                              PUSH    HL
0116+  E6F8 DD E1                           POP     IX
0117+  E6FA DD 77 F7                        LD      (IX+ym_current_page), A
0118+  E6FD DD 77 EF                        LD      (IX+ym_file_mode), A           ; Default normal transfer, 0FFh, else page 
0119+  E700 AF                              XOR     A                           
0120+  E701 DD 77 F0                        LD      (IX+ym_file_count), A
0121+  E704 3D                              DEC     A
0122+  E705 DD 73 F8                        LD      (IX+ym_dest_low), E
0123+  E708 DD 72 F9                        LD      (IX+ym_dest_high), D
0124+  E70B             
0125+  E70B AF          _ymodem_start       XOR     A                           ; Set initial packet number
0126+  E70C DD 77 FA                        LD      (IX+ym_current_packet), A
0127+  E70F FD 21 FF FF                     LD      IY, 0FFFFh                  ; IY - bytes to load. Default - load all bytes
0128+  E713             
0129+  E713                                 ; Now we can load.
0130+  E713                                 ; DE = destination
0131+  E713                                 ; IY = low 16 bits of length
0132+  E713                                 ; IX = load buffer
0133+  E713             
0134+  E713 CD A0 E9    _packet_loop        CALL    _recieve_safe
0135+  E716 20 07                           JR      NZ, _packet_byte
0136+  E718 3E 43       _send_crc_and_loop  LD      A, _C
0137+  E71A CD CB E9                        CALL    _send_byte
0138+  E71D 18 F4                           JR      _packet_loop
0139+  E71F             
0140+  E71F FE 01       _packet_byte        CP      _SOH
0141+  E721 C2 2C E7                        JP      NZ, _check_stx
0142+  E724             
0143+  E724 DD E5                           PUSH    IX                          ; SOH - May be zero'th or last packet
0144+  E726 E1                              POP     HL
0145+  E727 01 80 00                        LD      BC, _SOH_PACKET_SIZE
0146+  E72A 18 40                           JR      _receive_packet
0147+  E72C             
0148+  E72C FE 02       _check_stx          CP      _STX
0149+  E72E 20 07                           JR      NZ, _check_eot
0150+  E730                                                                     
0151+  E730 62                              LD      H, D                        ; STX packets go straight to DE
0152+  E731 6B                              LD      L, E
0153+  E732 01 00 04                        LD      BC, _STX_PACKET_SIZE    
0154+  E735 18 35                           JR      _receive_packet
0155+  E737             
0156+  E737 FE 04       _check_eot          CP      _EOT
0157+  E739 20 0A                           JR      NZ, _check_can
0158+  E73B                                                                     ; End of transmission
0159+  E73B 3E 06                           LD      A, _ACK 
0160+  E73D CD CB E9                        CALL    _send_byte
0161+  E740             
0162+  E740 DD 34 F0                        INC     (IX+ym_file_count)      
0163+  E743 18 C6                           JR      _ymodem_start  
0164+  E745             
0165+  E745 FE 18       _check_can          CP      _CAN
0166+  E747 20 1E                           JR      NZ, _unknown_packet
0167+  E749                                                                     ; Single cancel request. Check for another
0168+  E749 CD AB E9                        CALL    _receive_byte
0169+  E74C FE 18                           CP      _CAN
0170+  E74E 3E 04                           LD      A, _ERR_CANCEL
0171+  E750 20 10                           JR      NZ, _packet_error
0172+  E752             
0173+  E752 3E 06                           LD      A, _ACK 
0174+  E754 CD CB E9                        CALL    _send_byte
0175+  E757 CD A0 E9    _purge              CALL    _recieve_safe               ; Purge remains of any cancel request
0176+  E75A 20 FB                           JR      NZ, _purge
0177+  E75C             
0178+  E75C 3E 03                           LD      A, YMODEM_CANCEL
0179+  E75E A7                              AND     A
0180+  E75F C9                              RET
0181+  E760             
0182+  E760 3E 05       _zero_error         LD      A, _ERR_ZERO_PACKET
0183+  E762 4F          _packet_error       LD      C, A                        ; Packet data error - return error code in C
0184+  E763 3E 04                           LD      A, YMODEM_PACKET_ERROR
0185+  E765 A7                              AND     A
0186+  E766 C9                              RET
0187+  E767             
0188+  E767 4F          _unknown_packet     LD      C, A                        ; Unknown packet type - return header byte in C
0189+  E768 3E 02                           LD      A, YMODEM_UNKNOWN
0190+  E76A A7                              AND     A
0191+  E76B C9                              RET     
0192+  E76C             
0193+  E76C             ; Receive data for both SOH and STX packets..
0194+  E76C             ; At this point HL is destination (either DE or IX-buffer), and BC is a byte count
0195+  E76C             ;
0196+  E76C DD 77 FB    _receive_packet     LD      (IX+ym_packet_type), A   
0197+  E76F             
0198+  E76F DD 7E F7                        LD      A, (IX+ym_current_page)
0199+  E772 FE FF                           CP      0FFh
0200+  E774 28 02                           JR      Z, _no_page_specified
0201+  E776 D3 71                           OUT     (IO_MEM_1), A
0202+  E778             
0203+  E778 AF          _no_page_specified  XOR     A
0204+  E779 DD 77 F5                        LD      (IX+ym_soh_saved_len), A     ; Reset how many bytes of an SOH packet we actually loaded..
0205+  E77C DD 77 F6                        LD      (IX+ym_soh_saved_len_h), A
0206+  E77F             
0207+  E77F DD BE FA                        CP      (IX+ym_current_packet)         ; If this is the zeroth packet, it must be SOH
0208+  E782 20 07                           JR      NZ, _not_zeroth_packet
0209+  E784 3E 01                           LD      A, _SOH
0210+  E786 DD 96 FB                        SUB     (IX+ym_packet_type)            ; Leave A as zero if this is OK
0211+  E789 20 D5                           JR      NZ, _zero_error
0212+  E78B             
0213+  E78B DD 77 FF    _not_zeroth_packet  LD      (IX+ym_crc_high), A
0214+  E78E DD 77 FE                        LD      (IX+ym_crc_low), A
0215+  E791             
0216+  E791 CD AB E9                        CALL    _receive_byte   
0217+  E794 DD 77 FC                        LD      (IX+ym_packet_num), A
0218+  E797 CD AB E9                        CALL    _receive_byte   
0219+  E79A DD 77 FD                        LD      (IX+ym_packet_num_cpl), A
0220+  E79D             
0221+  E79D 7D          _data_loop          LD      A, L                        ; Handle paging if we're loading into paged memory..
0222+  E79E A7                              AND     A
0223+  E79F 20 12                           JR      NZ, _data_receive
0224+  E7A1 7C                              LD      A, H
0225+  E7A2 FE 80                           CP      80h
0226+  E7A4 20 0D                           JR      NZ, _data_receive
0227+  E7A6 DD 7E F7                        LD      A, (IX+ym_current_page)
0228+  E7A9 3C                              INC     A
0229+  E7AA 28 07                           JR      Z, _data_receive           ; Paging disabled
0230+  E7AC             
0231+  E7AC DD 77 F7                        LD      (IX+ym_current_page), A        ; Move to next page
0232+  E7AF D3 71                           OUT     (IO_MEM_1), A
0233+  E7B1 26 40                           LD      H, 40h
0234+  E7B3                                 
0235+  E7B3 CD AB E9    _data_receive       CALL    _receive_byte
0236+  E7B6             
0237+  E7B6 77                              LD      (HL), A
0238+  E7B7             
0239+  E7B7 CD 6D E9                        CALL    _calc_checksum  
0240+  E7BA             
0241+  E7BA C5                              PUSH    BC                          ; Count down the bytes remaining, and once we get to zero, send bytes to _dev_null
0242+  E7BB 01 FF FF                        LD      BC, -1
0243+  E7BE FD 09                           ADD     IY, BC                      ; Carry set if IY not zero
0244+  E7C0 C1                              POP     BC
0245+  E7C1 38 10                           JR      C, _in_range
0246+  E7C3             
0247+  E7C3 DD 35 F4                        DEC     (IX+ym_loaded_high)
0248+  E7C6 F2 D3 E7                        JP      P, _in_range
0249+  E7C9                  
0250+  E7C9 DD 34 F4                        INC     (IX+ym_loaded_high)      ; Keep resetting counter...
0251+  E7CC FD 23                           INC     IY
0252+  E7CE 21 9F E9                        LD      HL, _dev_null
0253+  E7D1 18 09                           JR      _do_next
0254+  E7D3             
0255+  E7D3 DD 34 F5    _in_range           INC     (IX+ym_soh_saved_len)
0256+  E7D6 20 03                           JR      NZ, _packet_part_ok
0257+  E7D8 DD 34 F6                        INC     (IX+ym_soh_saved_len_h)
0258+  E7DB 23          _packet_part_ok     INC     HL
0259+  E7DC             
0260+  E7DC 0B          _do_next            DEC     BC
0261+  E7DD             
0262+  E7DD 78                              LD      A, B
0263+  E7DE B1                              OR      C
0264+  E7DF 20 BC                           JR      NZ, _data_loop
0265+  E7E1             
0266+  E7E1 AF                              XOR     A
0267+  E7E2 CD 6D E9                        CALL    _calc_checksum  
0268+  E7E5 AF                              XOR     A
0269+  E7E6 CD 6D E9                        CALL    _calc_checksum  
0270+  E7E9             
0271+  E7E9 CD AB E9                        CALL    _receive_byte
0272+  E7EC 47                              LD      B, A
0273+  E7ED CD AB E9                        CALL    _receive_byte   
0274+  E7F0 4F                              LD      C, A
0275+  E7F1             ;
0276+  E7F1             ; Now do checks...
0277+  E7F1             
0278+  E7F1 DD 7E FC                        LD      A, (IX+ym_packet_num)
0279+  E7F4 2F                              CPL
0280+  E7F5 DD BE FD                        CP      (IX+ym_packet_num_cpl)
0281+  E7F8 3E 01                           LD      A, _ERR_PACKET_COUNT
0282+  E7FA C2 62 E7                        JP      NZ, _packet_error
0283+  E7FD DD 7E FF                        LD      A, (IX+ym_crc_high)
0284+  E800 B8                              CP      B
0285+  E801 3E 02                           LD      A, _ERR_CHECK_HIGH
0286+  E803 C2 62 E7                        JP      NZ, _packet_error
0287+  E806 DD 7E FE                        LD      A, (IX+ym_crc_low)
0288+  E809 B9                              CP      C
0289+  E80A 3E 03                           LD      A, _ERR_CHECK_LOW
0290+  E80C C2 62 E7                        JP      NZ, _packet_error
0291+  E80F             
0292+  E80F             ; CRC and packet number check out... 
0293+  E80F DD 7E FC                        LD      A, (IX+ym_packet_num)
0294+  E812 DD BE FA                        CP      (IX+ym_current_packet)
0295+  E815 20 23                           JR      NZ, _retry_packet               ; We need to restore IY (length) if we wish to survive.. DE is not updated until later, so OK
0296+  E817 DD 34 FA                        INC     (IX+ym_current_packet)
0297+  E81A A7                              AND     A
0298+  E81B 28 4A                           JR      Z, _header_packet
0299+  E81D             
0300+  E81D DD 7E FB                        LD      A, (IX+ym_packet_type)
0301+  E820 FE 01                           CP      _SOH
0302+  E822 20 0C                           JR      NZ, _not_soh
0303+  E824             
0304+  E824             ; SOH packets must be copied to DE -> 
0305+  E824 DD 4E F5                        LD      C, (IX+ym_soh_saved_len)
0306+  E827 06 00                           LD      B, 0
0307+  E829 DD E5                           PUSH    IX
0308+  E82B E1                              POP     HL
0309+  E82C ED B0                           LDIR
0310+  E82E 18 02                           JR      _send_ack
0311+  E830             
0312+  E830 54          _not_soh            LD      D, H
0313+  E831 5D                              LD      E, L
0314+  E832 3E 06       _send_ack           LD      A, _ACK 
0315+  E834 CD CB E9    _send_and_loop      CALL    _send_byte
0316+  E837 C3 18 E7                        JP      _send_crc_and_loop      
0317+  E83A             
0318+  E83A AF          _retry_packet       XOR     A                           ; Clear carry
0319+  E83B ED 52                           SBC     HL, DE
0320+  E83D 30 0D                           JR      NC, _retry_page_ok          
0321+  E83F             
0322+  E83F DD 7E F7                        LD      A,(IX+ym_current_page)         ; If HL (latest write dest) is less than DE (write dest at start of packet) assume we've changed pages..
0323+  E842 FE FF                           CP      0FFH
0324+  E844 28 06                           JR      Z, _retry_page_ok           ; We're not paging anyway...
0325+  E846 3D                              DEC     A 
0326+  E847 DD 77 F7                        LD      (IX+ym_current_page), A
0327+  E84A D3 71                           OUT     (IO_MEM_1),A
0328+  E84C             
0329+  E84C DD 4E F5    _retry_page_ok      LD      C, (IX+ym_soh_saved_len)     ; Restore IY (length)
0330+  E84F DD 46 F6                        LD      B, (IX+ym_soh_saved_len_h)
0331+  E852 FD E5                           PUSH    IY
0332+  E854 E1                              POP     HL
0333+  E855 09                              ADD     HL, BC
0334+  E856 30 03                           JR      NC, _retry_iy_ok
0335+  E858 DD 34 F4                        INC     (IX+ym_loaded_high)
0336+  E85B E5          _retry_iy_ok        PUSH    HL
0337+  E85C FD E1                           POP     IY
0338+  E85E                                                                     ; TODO: If we've changed the page, that needs to be restored as well
0339+  E85E             
0340+  E85E             
0341+  E85E CD A0 E9    _retry_drain        CALL   _recieve_safe                ; Drain the incoming stream before sending nak
0342+  E861 20 FB                           JR      NZ, _retry_drain
0343+  E863             
0344+  E863 3E 15                           LD      A, _NAK
0345+  E865 18 CD                           JR      _send_and_loop
0346+  E867             
0347+  E867             
0348+  E867 DD E5       _header_packet      PUSH    IX
0349+  E869 E1                              POP     HL
0350+  E86A 7E                              LD      A, (HL)                     ; Empty zeroth packet means end of batch send
0351+  E86B A7                              AND     A
0352+  E86C 20 09                           JR      NZ, _check_filecount
0353+  E86E             
0354+  E86E 3E 06                           LD      A, _ACK 
0355+  E870 CD CB E9                        CALL    _send_byte
0356+  E873 3E 00                           LD      A, YMODEM_SUCCESS   
0357+  E875 A7                              AND     A
0358+  E876 C9                              RET
0359+  E877             
0360+  E877 DD 7E F0    _check_filecount    LD      A, (IX+ym_file_count)
0361+  E87A A7                              AND     A
0362+  E87B 28 04                           JR      Z, _next_filechar
0363+  E87D             
0364+  E87D 3E 08                           LD      A, YMODEM_MULTI_FILES
0365+  E87F A7                              AND     A
0366+  E880 C9                              RET
0367+  E881             
0368+  E881 7E          _next_filechar      LD      A, (HL)
0369+  E882 23                              INC     HL
0370+  E883 A7          _check_char         AND     A
0371+  E884 28 71                           JR      Z, _read_length
0372+  E886 FE 5F                           CP      '_'                     ; Check for special transfer modes
0373+  E888 20 F7                           JR      NZ, _next_filechar
0374+  E88A 7E                              LD      A, (HL)
0375+  E88B 4F                              LD      C, A                    ; Remember the prefix char in C
0376+  E88C 23                              INC     HL
0377+  E88D FE 6D                           CP      _DEST_PREFIX
0378+  E88F 20 07                           JR      NZ, _check_flash
0379+  E891 06 04                           LD      B, 4
0380+  E893 11 00 00                        LD      DE, 0
0381+  E896 18 09                           JR      _parse_dest
0382+  E898             
0383+  E898 FE 70       _check_flash        CP      _PAGE_PREFIX
0384+  E89A 20 E7                           JR      NZ, _check_char
0385+  E89C 06 02                           LD      B, 2
0386+  E89E 11 00 00                        LD      DE, 0
0387+  E8A1             
0388+  E8A1 7E          _parse_dest         LD      A, (HL)
0389+  E8A2 23                              INC     HL
0390+  E8A3 D6 30                           SUB     '0'
0391+  E8A5 38 48                           JR      C, _invalid_dest
0392+  E8A7 FE 0A                           CP      10
0393+  E8A9 38 08                           JR      C, _digit_checked
0394+  E8AB D6 07                           SUB     7
0395+  E8AD 38 40                           JR      C, _invalid_dest
0396+  E8AF FE 10                           CP      16
0397+  E8B1 30 3C                           JR      NC, _invalid_dest
0398+  E8B3             
0399+  E8B3 E5          _digit_checked      PUSH    HL                          ; Shift existing dest left 4 bits and merge new hex digit
0400+  E8B4 62                              LD      H, D
0401+  E8B5 6B                              LD      L, E
0402+  E8B6 29                              ADD     HL, HL
0403+  E8B7 29                              ADD     HL, HL
0404+  E8B8 29                              ADD     HL, HL
0405+  E8B9 29                              ADD     HL, HL
0406+  E8BA B5                              OR      L
0407+  E8BB 54                              LD      D, H
0408+  E8BC 5F                              LD      E, A
0409+  E8BD E1                              POP     HL
0410+  E8BE 10 E1                           DJNZ    _parse_dest
0411+  E8C0             
0412+  E8C0 79                              LD      A, C                        ; Which char did we start with?
0413+  E8C1 FE 70                           CP      _PAGE_PREFIX
0414+  E8C3 20 12                           JR      NZ, _memory_dest
0415+  E8C5             
0416+  E8C5 DD 7E F7                        LD      A, (IX+ym_current_page)        ; Page prefix. Use original value if set when ymodem was called
0417+  E8C8 FE FF                           CP      0FFh
0418+  E8CA 20 B5                           JR      NZ, _next_filechar
0419+  E8CC             
0420+  E8CC DD 73 EF                        LD      (IX+ym_file_mode), E           ; Otherwise use the file specified value and load from 4000h
0421+  E8CF DD 73 F7                        LD      (IX+ym_current_page), E
0422+  E8D2 11 00 40                        LD      DE,04000h    
0423+  E8D5 18 10                           JR      _store_dest
0424+  E8D7             
0425+  E8D7 3E FF       _memory_dest        LD      A, 0FFh                     ; Only set the dest from the filename if 
0426+  E8D9 DD BE F8                        CP      (IX+ym_dest_low)               ; the routine was called with a destination of 0FFFFh
0427+  E8DC 20 A3                           JR      NZ, _next_filechar
0428+  E8DE DD BE F9                        CP      (IX+ym_dest_high)
0429+  E8E1 20 9E                           JR      NZ, _next_filechar
0430+  E8E3             
0431+  E8E3 DD 36 EF FE                     LD      (IX+ym_file_mode), YM_DEST_FROM_FILE
0432+  E8E7             
0433+  E8E7 DD 73 F8    _store_dest         LD      (IX+ym_dest_low), E
0434+  E8EA DD 72 F9                        LD      (IX+ym_dest_high), D
0435+  E8ED             
0436+  E8ED 18 92                           JR      _next_filechar
0437+  E8EF             
0438+  E8EF DD 5E F8    _invalid_dest       LD      E, (IX+ym_dest_low)            ; We silently skip invalid destination values
0439+  E8F2 DD 56 F9                        LD      D, (IX+ym_dest_high)
0440+  E8F5 18 8A                           JR      _next_filechar
0441+  E8F7             
0442+  E8F7 3E FF       _read_length        LD      A, 0FFh                     ; At this point we should have a valid destination
0443+  E8F9 DD BE F8                        CP      (IX+ym_dest_low)               
0444+  E8FC 20 09                           JR      NZ, _dest_ok
0445+  E8FE DD BE F9                        CP      (IX+ym_dest_high)
0446+  E901 20 04                           JR      NZ, _dest_ok
0447+  E903             
0448+  E903 3E 06                           LD      A, YMODEM_NO_DEST
0449+  E905 A7                              AND     A
0450+  E906 C9                              RET
0451+  E907             
0452+  E907 3E FF       _dest_ok            LD      A, 0FFh
0453+  E909 DD 77 F1                        LD      (IX+ym_length_low), A       ; Reset the length counter///
0454+  E90C DD 77 F2                        LD      (IX+ym_length_mid), A
0455+  E90F DD 77 F3                        LD      (IX+ym_length_high), A         
0456+  E912 DD 77 F4                        LD      (IX+ym_loaded_high), A
0457+  E915 FD 21 FF FF                     LD      IY, 0FFFFh 
0458+  E919 44                              LD      B, H
0459+  E91A 4D                              LD      C, L               
0460+  E91B 21 00 00                        LD      HL, 0
0461+  E91E 0A                              LD      A, (BC)                     ; Length is optional
0462+  E91F A7                              AND     A
0463+  E920 CA 32 E8                        JP      Z, _send_ack
0464+  E923             
0465+  E923 0A          _parse_length       LD      A, (BC)
0466+  E924 03                              INC     BC
0467+  E925 A7                              AND     A
0468+  E926 28 2F                           JR      Z, _length_end
0469+  E928 FE 20                           CP      ' '
0470+  E92A 28 2B                           JR      Z, _length_end
0471+  E92C D6 30                           SUB     '0'
0472+  E92E 38 39                           JR      C, _invalid_length
0473+  E930 FE 0A                           CP      10
0474+  E932 30 35                           JR      NC, _invalid_length
0475+  E934             
0476+  E934 C5                              PUSH    BC
0477+  E935 D5                              PUSH    DE
0478+  E936 F5                              PUSH    AF
0479+  E937             
0480+  E937 EB                              EX      DE, HL              ; HL into DE 
0481+  E938 3E 0A                           LD      A, 10
0482+  E93A             
0483+  E93A                                 ; DE x A  -> AHL  (from http://z80-heaven.wikidot.com/advanced-math#toc12)
0484+  E93A                                 ; preserves DE
0485+  E93A 01 00 08                        LD      BC, 0800h
0486+  E93D 61                              LD      H, C
0487+  E93E 69                              LD      L, C
0488+  E93F 29          _pl_loop            ADD     HL, HL
0489+  E940 17                              RLA
0490+  E941 30 02                           JR      NC, _pl_skip
0491+  E943 19                              ADD     HL, DE
0492+  E944 89                              ADC     A, C
0493+  E945 10 F8       _pl_skip            DJNZ    _pl_loop
0494+  E947             
0495+  E947 DD 77 F3                        LD      (IX+ym_length_high), A     ; Note we only handle overflow for one digit.. max value 655,359?
0496+  E94A F1                              POP     AF
0497+  E94B 5F                              LD      E, A
0498+  E94C 51                              LD      D, C
0499+  E94D 19                              ADD     HL, DE
0500+  E94E 30 03                           JR      NC, _pl_length_ok
0501+  E950 DD 34 F3                        INC     (IX+ym_length_high)
0502+  E953             
0503+  E953 D1          _pl_length_ok       POP     DE
0504+  E954 C1                              POP     BC
0505+  E955 18 CC                           JR      _parse_length
0506+  E957             
0507+  E957 E5          _length_end         PUSH    HL
0508+  E958 FD E1                           POP     IY
0509+  E95A DD 75 F1                        LD      (IX+ym_length_low), L
0510+  E95D DD 74 F2                        LD      (IX+ym_length_mid), H
0511+  E960 DD 7E F3                        LD      A, (IX+ym_length_high)
0512+  E963 DD 77 F4                        LD      (IX+ym_loaded_high), A
0513+  E966 C3 32 E8                        JP      _send_ack
0514+  E969             
0515+  E969 3E 05       _invalid_length     LD      A, YMODEM_LENGTH_ERROR      ; Hard fail on invalid length data
0516+  E96B A7                              AND     A
0517+  E96C C9                              RET
0518+  E96D             
0519+  E96D             ;-----
0520+  E96D             ; Calculate the checksum from A
0521+  E96D E5          _calc_checksum      PUSH    HL
0522+  E96E C5                              PUSH    BC
0523+  E96F             
0524+  E96F 06 01                           LD      B, 1
0525+  E971 4F                              LD      C, A
0526+  E972 DD 66 FF                        LD      H, (IX+ym_crc_high)
0527+  E975 DD 6E FE                        LD      L, (IX+ym_crc_low)
0528+  E978             
0529+  E978 29          _crc_loop           ADD     HL, HL
0530+  E979 F5                              PUSH    AF
0531+  E97A             
0532+  E97A CB 21                           SLA     C
0533+  E97C CB 10                           RL      B
0534+  E97E 30 02                           JR      NC, _no_in_overflow
0535+  E980 CB C1                           SET     0, C
0536+  E982             _no_in_overflow
0537+  E982 CB 40                           BIT     0, B
0538+  E984 28 01                           JR      Z, _no_in_bit
0539+  E986 23                              INC     HL
0540+  E987             _no_in_bit                    
0541+  E987 F1                              POP     AF
0542+  E988 30 08                           JR      NC, _no_crc_overflow
0543+  E98A 3E 21                           LD      A, 021h
0544+  E98C AD                              XOR     L 
0545+  E98D 6F                              LD      L,A
0546+  E98E 3E 10                           LD      A, 010h
0547+  E990 AC                              XOR     H 
0548+  E991 67                              LD      H, A
0549+  E992             _no_crc_overflow
0550+  E992 CB 41                           BIT     0, C
0551+  E994 28 E2                           JR      Z, _crc_loop    
0552+  E996             
0553+  E996 DD 74 FF                        LD      (IX+ym_crc_high), H
0554+  E999 DD 75 FE                        LD      (IX+ym_crc_low), L
0555+  E99C C1                              POP     BC
0556+  E99D E1                              POP     HL
0557+  E99E C9                              RET
0558+  E99F             
0559+  E99F 00          _dev_null           .DB     0
0560+  E9A0             
0561+  E9A0             ;
0562+  E9A0             ; Recieve a byte with timeout, without exiting ymodem
0563+  E9A0             ; If success, A contains byte, non-zero flag set
0564+  E9A0             ; Otherwise A is zero, Zero flag is set
0565+  E9A0             ;
0566+  E9A0 21 A9 E9    _recieve_safe       LD      HL, _back_safe
0567+  E9A3 E5                              PUSH    HL
0568+  E9A4 CD AB E9                        CALL    _receive_byte
0569+  E9A7 E1                              POP     HL
0570+  E9A8 C9                              RET
0571+  E9A9 AF          _back_safe          XOR     A
0572+  E9AA C9                              RET     
0573+  E9AB             
0574+  E9AB             ;
0575+  E9AB             ; Receive a byte with timeout
0576+  E9AB             ; If success: A contains byte, non-zero flag set
0577+  E9AB             ; Otherwise : Pops the return address off the stack and returns to the original caller with A containing YMODEM_TIMEOUT
0578+  E9AB             ;
0579+  E9AB C5          _receive_byte       PUSH    BC
0580+  E9AC 01 50 C3                        LD      BC, _TIMEOUT_COUNT
0581+  E9AF DB 25       _receive_loop       IN      A, (UART_LINE_STATUS)
0582+  E9B1 CB 47                           BIT     0, A
0583+  E9B3 20 12                           JR      NZ, _receive_ready
0584+  E9B5 78                              LD      A, B
0585+  E9B6 06 0A                           LD      B, 10
0586+  E9B8 A7          _rx_delay           AND     A
0587+  E9B9 10 FD                           DJNZ    _rx_delay
0588+  E9BB 47                              LD      B, A
0589+  E9BC 0B                              DEC     BC
0590+  E9BD 78                              LD      A, B
0591+  E9BE B1                              OR      C
0592+  E9BF 20 EE                           JR      NZ, _receive_loop
0593+  E9C1 C1                              POP     BC
0594+  E9C2 C1                              POP     BC
0595+  E9C3 3E 01                           LD      A, YMODEM_TIMEOUT
0596+  E9C5 A7                              AND     A
0597+  E9C6 C9                              RET
0598+  E9C7             
0599+  E9C7 DB 20       _receive_ready      IN      A, (UART_TX_RX)
0600+  E9C9 C1                              POP     BC
0601+  E9CA C9                              RET
0602+  E9CB             
0603+  E9CB             ;
0604+  E9CB             ; Send a byte with timeout
0605+  E9CB             ; If success: returns normally, no registers affected
0606+  E9CB             ; Otherwise : Pops the return address off the stack and returns to the original caller with A containing YMODEM_SEND_TIMEOUT
0607+  E9CB             ;
0608+  E9CB C5          _send_byte          PUSH    BC
0609+  E9CC F5                              PUSH    AF
0610+  E9CD 01 50 C3                        LD      BC, _TIMEOUT_COUNT
0611+  E9D0 DB 25       _send_loop          IN      A, (UART_LINE_STATUS)
0612+  E9D2 CB 6F                           BIT     5, A
0613+  E9D4 C2 E4 E9                        JP      NZ, _send_ready             ; Bit 5 is set when the UART is ready
0614+  E9D7 0B                              DEC     BC
0615+  E9D8 78                              LD      A, B
0616+  E9D9 B1                              OR      C
0617+  E9DA C2 D0 E9                        JP      NZ, _send_loop
0618+  E9DD             
0619+  E9DD F1                              POP     AF
0620+  E9DE C1                              POP     BC
0621+  E9DF C1                              POP     BC
0622+  E9E0             
0623+  E9E0 3E 07                           LD      A, YMODEM_SEND_TIMEOUT
0624+  E9E2 A7                              AND     A
0625+  E9E3 C9                              RET
0626+  E9E4             
0627+  E9E4 F1          _send_ready         POP     AF
0628+  E9E5 C1                              POP     BC
0629+  E9E6 D3 20                           OUT     (UART_TX_RX), A
0630+  E9E8 C9                              RET
0631+  E9E9             
0632+  E9E9                                 .MODULE main1182   E9E9             
1183   E9E9~            .IF $ >= BIOS_START
1184   E9E9~                .ECHO "End of Monitor is too high ("
1185   E9E9~                .ECHO $
1186   E9E9~                .ECHO " > "
1187   E9E9~                .ECHO BIOS_START
1188   E9E9~                .ECHO ") \n\n"
1189   E9E9~                .STOP
1190   E9E9             .ENDIF
1191   E9E9             
1192   E9E9             .ECHO "Spare after monitor "
1193   E9E9             .ECHO BIOS_START-$
1194   E9E9             .ECHO "\n\n"
1195   E9E9             
1196   E9E9 FF FF FF FF                     .FILL  BIOS_START-$
1196   E9ED FF FF FF FF 
1196   E9F1 FF FF FF FF 
1196   E9F5 FF FF FF FF 
1196   E9F9 FF FF FF FF 
1196   E9FD FF FF FF 
1197   EA00             
1198   EA00                                 .INCLUDE "bios.asm"
0001+  EA00             ;
0002+  EA00             ; Simple-ish CP/M compatible BIOS
0003+  EA00             ;
0004+  EA00             ; References - http://www.gaby.de/cpm/manuals/archive/cpm22htm/axb.htm - CPM Manual 'Simple skeletal BIOS'
0005+  EA00             ;
0006+  EA00             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0007+  EA00             ;
0008+  EA00             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0009+  EA00             ;
0010+  EA00             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0011+  EA00             ; of this software and associated documentation files (the "Software"), to deal
0012+  EA00             ; in the Software without restriction, including without limitation the rights
0013+  EA00             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0014+  EA00             ; copies of the Software, and to permit persons to whom the Software is
0015+  EA00             ; furnished to do so, subject to the following conditions:
0016+  EA00             ; 
0017+  EA00             ; The above copyright notice and this permission notice shall be included in all
0018+  EA00             ; copies or substantial portions of the Software.
0019+  EA00             ; 
0020+  EA00             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0021+  EA00             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0022+  EA00             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0023+  EA00             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0024+  EA00             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0025+  EA00             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0026+  EA00             ; SOFTWARE.
0027+  EA00             ;
0028+  EA00                                 .MODULE  main
0029+  EA00             
0030+  EA00             BIOS_START          .EQU    0EA00h   ; If this is changed, CP/M must be rebuilt and the disk image updated
0031+  EA00             BIOS_TOP            .EQU    0FDFDh
0032+  EA00             
0033+  EA00             CCP                 .EQU    BIOS_START - 01600h
0034+  EA00             BDOS                .EQU    CCP + 0806h
0035+  EA00             
0036+  EA00             CCP_SECTOR_COUNT    .EQU    (BIOS_START-CCP)/128
0037+  EA00             
0038+  EA00~            .IF (CCP_SECTOR_COUNT * 128) < (BIOS_START-CCP)
0039+  EA00~                .ECHO "CCP isn't an exact multiple of 128 byte sectors\n"
0040+  EA00~                .ECHO "  Got "
0041+  EA00~                .ECHO (BIOS_START-CCP)
0042+  EA00~                .ECHO "\n"
0043+  EA00~                .STOP
0044+  EA00             .ENDIF
0045+  EA00             
0046+  EA00             iobyte              .EQU    03h     ; Location of Intel standard I/O definition byte
0047+  EA00             usrdrv              .EQU    04h     ; Location of Current user number and drive
0048+  EA00             tpabuf              .EQU    0080h   ; Default I/O buffer and command line storage
0049+  EA00             
0050+  EA00             IO_BAT              .EQU    02h     ; CONsole IO defined by RDR for input, LST for output
0051+  EA00             
0052+  EA00             bios_start          .ORG    BIOS_START
0053+  EA00             
0054+  EA00 C3 F1 EA                        JP      bios_boot     ;  0 Initialize
0055+  EA03 C3 34 EB    wboote              JP      bios_wboot    ;  1 Warm boot
0056+  EA06 C3 9D EB                        JP      bios_conist   ;  2 Console status - Return A = 0FFH if character ready, 00H if not
0057+  EA09 C3 C6 EB                        JP      bios_conin    ;  3 Console input  - Wait for input, returning character in A
0058+  EA0C C3 3A EC                        JP      bios_conout   ;  4 Console OUTput - Write character in C to console
0059+  EA0F C3 64 EF                        JP      bios_list     ;  5 List OUTput
0060+  EA12 C3 66 EF                        JP      bios_punch    ;  6 punch OUTput
0061+  EA15 C3 68 EF                        JP      bios_reader   ;  7 Reader input
0062+  EA18 C3 82 EF                        JP      bios_home     ;  8 Home disk
0063+  EA1B C3 69 EF                        JP      bios_seldsk   ;  9 Select disk
0064+  EA1E C3 84 EF                        JP      bios_settrk   ; 10 Select track
0065+  EA21 C3 89 EF                        JP      bios_setsec   ; 11 Select sector
0066+  EA24 C3 8E EF                        JP      bios_setdma   ; 12 Set DMA ADDress
0067+  EA27 C3 93 EF                        JP      bios_read     ; 13 Read 128 bytes
0068+  EA2A C3 CC EF                        JP      bios_write    ; 14 Write 128 bytes
0069+  EA2D C3 39 F0                        JP      bios_listst   ; 15 List status
0070+  EA30 C3 3B F0                        JP      bios_sectrn   ; 16 Sector translate
0071+  EA33             
0072+  EA33             MEMDISK_SECTORS     .EQU    26
0073+  EA33             MEMDISK_TRACKS      .EQU    79
0074+  EA33             
0075+  EA33             BIOS_BOOT_TRACKS    .EQU    2
0076+  EA33             BIOS_SECTOR_ADDRESS .EQU    tpabuf
0077+  EA33             
0078+  EA33             DRIVE_A_PAGE        .EQU    04h     ; Page 4 of ROM - offset 010000h
0079+  EA33             DRIVE_B_PAGE        .EQU    25h     ; Page 5 of RAM
0080+  EA33             
0081+  EA33             CONSOLE_PAGE        .EQU    24h     ; Page 4 of RAM - Console emulation for non-VideoBeast systems
0082+  EA33             
0083+  EA33             ; Disk Parameter Headers -------------------------------------------------------
0084+  EA33             ; These are 256K discs, equivalent to this disc format (for cpmtools)
0085+  EA33             ; 
0086+  EA33             ; References : https://www.idealine.info/sharpmz/dpb.htm - Explanation of values
0087+  EA33             ;              https://jeelabs.org/article/1715b/        - Bootstrapping CP/M
0088+  EA33             ;
0089+  EA33             ; diskdef memotech-type50
0090+  EA33             ;  seclen 128
0091+  EA33             ;  tracks 79
0092+  EA33             ;  sectrk 26
0093+  EA33             ;  blocksize 1024
0094+  EA33             ;  maxdir 64
0095+  EA33             ;  skew 1
0096+  EA33             ;  boottrk 2
0097+  EA33             ;  os 2.2
0098+  EA33             ; end
0099+  EA33             ;
0100+  EA33             MAX_DRIVES          .EQU    2
0101+  EA33             
0102+  EA33 00 00 00 00 dpbase              .DW     0,0,0,0,dirbuf,dpb0,0,sys_alv0      ; Disk 0 is Flash
0102+  EA37 00 00 00 00 
0102+  EA3B 71 EA 53 EA 
0102+  EA3F 00 00 45 FF 
0103+  EA43 00 00 00 00                     .DW     0,0,0,0,dirbuf,dpb1,0,sys_alv1      ; Disk 1 is RAM
0103+  EA47 00 00 00 00 
0103+  EA4B 71 EA 62 EA 
0103+  EA4F 00 00 65 FF 
0104+  EA53             
0105+  EA53 1A 00       dpb0                .DW     MEMDISK_SECTORS     ; SPT - sectors per track
0106+  EA55 03                              .DB     3                   ; BSH - block shift factor  BSH+BLM together mean 1024 byte blocksize
0107+  EA56 07                              .DB     7                   ; BLM - block mask
0108+  EA57 00                              .DB     0                   ; EXM - Extent mask
0109+  EA58 F7 00                           .DW     247                 ; DSM - Storage size (blocks - 1)
0110+  EA5A 3F 00                           .DW     63                  ; DRM - Number of directory entries - 1
0111+  EA5C C0                              .DB     192                 ; AL0 - 1 bit set per directory block
0112+  EA5D 00                              .DB     0                   ; AL1 - ... 8 more bits
0113+  EA5E 00 00                           .DW     0                   ; CKS - DIR check vector size (DRM+1)/4 (0=fixed disk)
0114+  EA60 02 00                           .DW     BIOS_BOOT_TRACKS    ; OFF - Reserved tracks
0115+  EA62             
0116+  EA62 1A 00       dpb1                .DW     MEMDISK_SECTORS     ; SPT - sectors per track
0117+  EA64 03                              .DB     3                   ; BSH - block shift factor  BSH+BLM together mean 1024 byte blocksize
0118+  EA65 07                              .DB     7                   ; BLM - block mask
0119+  EA66 00                              .DB     0                   ; EXM - Extent mask
0120+  EA67 F7 00                           .DW     247                 ; DSM - Storage size (blocks - 1)
0121+  EA69 3F 00                           .DW     63                  ; DRM - Number of directory entries - 1
0122+  EA6B C0                              .DB     192                 ; AL0 - 1 bit set per directory block
0123+  EA6C 00                              .DB     0                   ; AL1 - ... 8 more bits
0124+  EA6D 00 00                           .DW     0                   ; CKS - DIR check vector size (DRM+1)/4 (0=fixed disk)
0125+  EA6F 02 00                           .DW     BIOS_BOOT_TRACKS    ; OFF - Reserved tracks
0126+  EA71             
0127+  EA71 00 00 00 00 dirbuf              .FILL   128, 0 ; disk directory scratch area
0127+  EA75 00 00 00 00 
0127+  EA79 00 00 00 00 
0127+  EA7D 00 00 00 00 
0127+  EA81 00 00 00 00 
0127+  EA85 00 00 00 00 
0127+  EA89 00 00 00 00 
0127+  EA8D 00 00 00 00 
0127+  EA91 00 00 00 00 
0127+  EA95 00 00 00 00 
0127+  EA99 00 00 00 00 
0127+  EA9D 00 00 00 00 
0127+  EAA1 00 00 00 00 
0127+  EAA5 00 00 00 00 
0127+  EAA9 00 00 00 00 
0127+  EAAD 00 00 00 00 
0127+  EAB1 00 00 00 00 
0127+  EAB5 00 00 00 00 
0127+  EAB9 00 00 00 00 
0127+  EABD 00 00 00 00 
0127+  EAC1 00 00 00 00 
0127+  EAC5 00 00 00 00 
0127+  EAC9 00 00 00 00 
0127+  EACD 00 00 00 00 
0127+  EAD1 00 00 00 00 
0127+  EAD5 00 00 00 00 
0127+  EAD9 00 00 00 00 
0127+  EADD 00 00 00 00 
0127+  EAE1 00 00 00 00 
0127+  EAE5 00 00 00 00 
0127+  EAE9 00 00 00 00 
0127+  EAED 00 00 00 00 
0128+  EAF1             
0129+  EAF1             ; BIOS Entry points ---------------------------------------------------------------
0130+  EAF1             
0131+  EAF1             bios_boot     ;  0 Initialize - This is called on first boot when CCP and BIOS have all been read into memory. Initialise hardware and start CCP
0132+  EAF1 F3                              DI
0133+  EAF2 31 00 00                        LD      SP,000h
0134+  EAF5 21 00 EA                        LD      HL,BIOS_START        ; Why are we doing this?
0135+  EAF8 22 FE FF                        LD      (0FFFEh),HL
0136+  EAFB CD 56 F0                        CALL    configure_hardware
0137+  EAFE AF                              XOR     A
0138+  EAFF 32 04 00                        LD      (usrdrv),A
0139+  EB02             
0140+  EB02 3A 03 FF                        LD      A, (boot_mode)
0141+  EB05 E6 08                           AND     BOOT_TTY_INPUT
0142+  EB07 3E 01                           LD      A, 1                 ; Input on keyboard, output on display
0143+  EB09 28 01                           JR      Z, _boot_iobyte
0144+  EB0B AF                              XOR     A                    ; Input from serial/tty, output on display
0145+  EB0C 32 03 00    _boot_iobyte        LD      (iobyte),A           
0146+  EB0F             
0147+  EB0F 3A 03 FF                        LD      A, (boot_mode)       ; If we need to restore the B drive on boot, patch the CCP command
0148+  EB12 E6 04                           AND     BOOT_RESTORE_B       ; See CP/M 2.2 Application Node 01 2/20/82 "The CCP Auto-Load Feature"
0149+  EB14 28 25                           JR      Z, start_cpm
0150+  EB16             
0151+  EB16 21 2B EB                        LD      HL, _restore_command ; Auto-run the RESTORE command
0152+  EB19 11 07 D4                        LD      DE, CCP+7
0153+  EB1C 01 09 00                        LD      BC, _restore_command_len
0154+  EB1F ED B0                           LDIR
0155+  EB21 3A 03 FF                        LD      A, (boot_mode)       ; Clear the boot_mode flag to prevent accidentally overwriting drive B
0156+  EB24 EE 04                           XOR     BOOT_RESTORE_B
0157+  EB26 32 03 FF                        LD      (boot_mode), A
0158+  EB29 18 10                           JR      start_cpm
0159+  EB2B             
0160+  EB2B 07 52 45 53 _restore_command     .DB     7, "RESTORE", 0
0160+  EB2F 54 4F 52 45 
0160+  EB33 00 
0161+  EB34             _restore_command_len .EQU   $-_restore_command
0162+  EB34             
0163+  EB34             ;------------------------------------------------------                    
0164+  EB34             bios_wboot    ;  1 Warm boot - Hardware is intialised, but CCP should be reloaded before being run
0165+  EB34 F3                              DI
0166+  EB35 31 00 00                        LD      SP,000h
0167+  EB38                                 ;CALL    setup_screen
0168+  EB38 CD 5D EB                        CALL    load_ccp
0169+  EB3B             
0170+  EB3B FB          start_cpm           EI                           ; Make sure interrupts are enabled
0171+  EB3C 21 80 00                        LD      HL,tpabuf            ; Address of BIOS DMA buffer
0172+  EB3F 22 40 FF                        LD      (sys_dmaaddr),hl
0173+  EB42 3E C3                           LD      A, 0C3h              ; Opcode for 'JP'
0174+  EB44 32 00 00                        LD      (00h),A              ; Load at start of RAM
0175+  EB47 21 03 EA                        LD      HL,wboote            ; Address of jump for a warm boot
0176+  EB4A 22 01 00                        LD      (01h),HL
0177+  EB4D 32 05 00                        LD      (05h),a              ; Opcode for 'JP'
0178+  EB50 21 06 DC                        LD      HL,BDOS              ; Address of jump for the BDOS
0179+  EB53 22 06 00                        LD      (06h),HL
0180+  EB56 3A 04 00                        LD      A,(usrdrv)           ; Save new drive number (0)  ; TODO: Ugh? Where is this set, what does it mean???
0181+  EB59 4F                              LD      C, A                 ; Pass drive number in C
0182+  EB5A C3 00 D4                        JP      CCP                  ; Start CP/M by jumping to the CCP
0183+  EB5D             
0184+  EB5D                                 ; Load CCP - Note we're doing this through BIOS calls, so if we move the OS to a different
0185+  EB5D                                 ;       drive, the code should still function...
0186+  EB5D 0E 00       load_ccp            LD      C, 0
0187+  EB5F CD 69 EF                        CALL    bios_seldsk
0188+  EB62 CD 82 EF                        CALL    bios_home            ; Go to track 0
0189+  EB65             
0190+  EB65 06 2C                           LD      B, CCP_SECTOR_COUNT
0191+  EB67 0E 00                           LD      C, 0                 ; Track number
0192+  EB69 16 00                           LD      D, 0                 ; Sector to read - start with sector 0 (TODO: Check sectors are 0 based)
0193+  EB6B 21 00 D4                        LD      HL, CCP
0194+  EB6E C5          _read_ccp           PUSH    BC
0195+  EB6F D5                              PUSH    DE
0196+  EB70 E5                              PUSH    HL
0197+  EB71 4A                              LD      C, D                 ; Set the sector to read
0198+  EB72 CD 89 EF                        CALL    bios_setsec
0199+  EB75 C1                              POP     BC
0200+  EB76 C5                              PUSH    BC
0201+  EB77 CD 8E EF                        CALL    bios_setdma
0202+  EB7A CD 93 EF                        CALL    bios_read
0203+  EB7D A7                              AND     A                    ; Reboot if error 
0204+  EB7E 20 B4                           JR      NZ, bios_wboot
0205+  EB80             
0206+  EB80 E1                              POP     HL                   ; Calculate next address to read
0207+  EB81 11 80 00                        LD      DE, 128
0208+  EB84 19                              ADD     HL, DE
0209+  EB85 D1                              POP     DE                   ; Count down the sectors
0210+  EB86 C1                              POP     BC
0211+  EB87 05                              DEC     B
0212+  EB88 C8                              RET     Z                    ; And return if we've read 'em all
0213+  EB89             
0214+  EB89 14                              INC     D                    ; Otherwise, increment sector   
0215+  EB8A 7A                              LD      A, D
0216+  EB8B FE 1B                           CP      27
0217+  EB8D 38 DF                           JR      C, _read_ccp
0218+  EB8F             
0219+  EB8F 16 01                           LD      D, 1                 ; Or, set sector back to 1 and increment track 
0220+  EB91 0C                              INC     C
0221+  EB92             
0222+  EB92 C5                              PUSH    BC
0223+  EB93 D5                              PUSH    DE
0224+  EB94 E5                              PUSH    HL
0225+  EB95 CD 84 EF                        CALL    bios_settrk
0226+  EB98 E1                              POP     HL
0227+  EB99 D1                              POP     DE
0228+  EB9A C1                              POP     BC
0229+  EB9B 18 D1                           JR      _read_ccp
0230+  EB9D             
0231+  EB9D             
0232+  EB9D                                 
0233+  EB9D             ;------------------------------------------------------  
0234+  EB9D             bios_conist   ; CONSOLE STATUS, - Return A = 0FFH if character ready, 00H if not
0235+  EB9D 3A 03 00                        LD      A, (iobyte)                ; Check input on CON
0236+  EBA0 E6 03                           AND     03h
0237+  EBA2 28 12                           JR      Z, _coninst_tty
0238+  EBA4 FE 02                           CP      IO_BAT
0239+  EBA6 28 15                           JR      Z, _coninst_rdr
0240+  EBA8             
0241+  EBA8 3A 36 FF    _coninst_kbd        LD      A, (console_identify)
0242+  EBAB A7                              AND     A
0243+  EBAC 20 05                           JR      NZ, _coninst_has_char
0244+  EBAE             
0245+  EBAE 3A 28 FF                        LD      A, (input_size)
0246+  EBB1 A7                              AND     A
0247+  EBB2 C8                              RET     Z
0248+  EBB3 3E FF       _coninst_has_char   LD      A, 0FFh
0249+  EBB5 C9                              RET
0250+  EBB6              
0251+  EBB6 AF          _coninst_tty        XOR     A
0252+  EBB7 CD 8B F5                        CALL    uart_ready
0253+  EBBA D0                              RET     NC
0254+  EBBB 3D                              DEC     A
0255+  EBBC C9                              RET     
0256+  EBBD 3A 03 00    _coninst_rdr        LD      A, (iobyte)                 ; Input is determined by RDR
0257+  EBC0 E6 0C                           AND     0Ch
0258+  EBC2 28 F2                           JR      Z, _coninst_tty
0259+  EBC4 18 E2                           JR      _coninst_kbd
0260+  EBC6             
0261+  EBC6             ;------------------------------------------------------  
0262+  EBC6             bios_conin    ;  3 Console input - Wait for input, returning character in A
0263+  EBC6 3A 03 00                        LD      A, (iobyte)
0264+  EBC9 E6 03                           AND     03h
0265+  EBCB 28 17                           JR      Z, _conin_tty
0266+  EBCD FE 02                           CP      02h
0267+  EBCF 28 19                           JR      Z, _conin_rdr
0268+  EBD1                                 
0269+  EBD1 3A 36 FF    _conin_kbd          LD      A, (console_identify)           ; If the terminal has been sent an identity request escape sequence, return the response
0270+  EBD4 3D                              DEC     A
0271+  EBD5 FA F3 EB                        JP      M, _conin_read_char
0272+  EBD8 32 36 FF                        LD      (console_identify), A
0273+  EBDB 21 37 EC                        LD      HL, _indentity_sequence
0274+  EBDE 4F                              LD      C, A
0275+  EBDF 06 00                           LD      B, 0
0276+  EBE1 09                              ADD     HL, BC
0277+  EBE2 7E                              LD      A, (HL) 
0278+  EBE3 C9                              RET        
0279+  EBE4             
0280+  EBE4 CD 9A F5    _conin_tty          CALL    uart_receive
0281+  EBE7 D8                              RET     C
0282+  EBE8 18 12                           JR      _conin_wait                     ; Flash cursor if nothing is waiting...
0283+  EBEA                  
0284+  EBEA 3A 03 00    _conin_rdr          LD      A, (iobyte)
0285+  EBED E6 0C                           AND     0ch
0286+  EBEF 28 F3                           JR      Z, _conin_tty
0287+  EBF1 18 DE                           JR      _conin_kbd
0288+  EBF3             
0289+  EBF3 3A 28 FF    _conin_read_char    LD      A, (input_size)                 ; Don't blink cursor if there is a character already waiting..
0290+  EBF6 A7                              AND     A
0291+  EBF7 28 03                           JR      Z, _conin_wait
0292+  EBF9 C3 5E F4                        JP      get_key
0293+  EBFC             
0294+  EBFC 3A 32 FF    _conin_wait         LD      A, (console_flags)              ; Turn the cursor on..
0295+  EBFF F6 01                           OR      CFLAGS_SHOW_CURSOR
0296+  EC01 32 32 FF                        LD      (console_flags), A
0297+  EC04 F3                              DI
0298+  EC05 ED 5B 2D FF                     LD      DE, (cursor_row)
0299+  EC09 7A                              LD      A, D                            ; Force cursor update...
0300+  EC0A 3D                              DEC     A
0301+  EC0B 32 2E FF                        LD      (cursor_col),A
0302+  EC0E CD 5A ED                        CALL    _conout_csr_update
0303+  EC11 FB                              EI
0304+  EC12             
0305+  EC12 3A 03 00                        LD      A, (iobyte)
0306+  EC15 E6 03                           AND     03h
0307+  EC17 28 17                           JR      Z, _conin_wait_tty
0308+  EC19             
0309+  EC19 CD 5E F4                        CALL    get_key                         ; Wait for a key
0310+  EC1C             
0311+  EC1C 47          _conin_done         LD      B, A
0312+  EC1D 3A 32 FF                        LD      A, (console_flags)
0313+  EC20 E6 FE                           AND     ~CFLAGS_SHOW_CURSOR
0314+  EC22 32 32 FF                        LD      (console_flags), A
0315+  EC25                                 ;
0316+  EC25 C5                              PUSH    BC
0317+  EC26 1E 00                           LD      E, 0
0318+  EC28 F3                              DI
0319+  EC29 CD 79 F2                        CALL    update_cursor
0320+  EC2C FB                              EI
0321+  EC2D C1                              POP     BC
0322+  EC2E 78                              LD      A, B
0323+  EC2F C9                              RET
0324+  EC30             
0325+  EC30 CD 9A F5    _conin_wait_tty     CALL    uart_receive
0326+  EC33 38 E7                           JR      C, _conin_done
0327+  EC35 18 F9                           JR      _conin_wait_tty
0328+  EC37             
0329+  EC37 4B 2F 1B    _indentity_sequence .DB     'K', '/', ESCAPE_CHAR           ; RETURNED BY VT-52 emulation - note sequence is reversed
0330+  EC3A             IDENTITY_LENGTH     .EQU    3
0331+  EC3A             
0332+  EC3A             ;------------------------------------------------------  
0333+  EC3A             bios_conout   ;  4 Console OUTput  - Write character in C to console
0334+  EC3A 3A 03 00                        LD      A, (iobyte)
0335+  EC3D E6 03                           AND     03h
0336+  EC3F FE 02                           CP      IO_BAT
0337+  EC41 20 0B                           JR      NZ, _conout_disp_tty
0338+  EC43             
0339+  EC43 3A 03 00                        LD      A, (iobyte)
0340+  EC46 E6 C0                           AND     0C0h
0341+  EC48 20 08                           JR      NZ, _conout_disp 
0342+  EC4A 79                              LD      A, C
0343+  EC4B C3 6E F5                        JP      uart_send
0344+  EC4E             
0345+  EC4E 79          _conout_disp_tty    LD      A, C
0346+  EC4F CD 6E F5                        CALL    uart_send
0347+  EC52             
0348+  EC52 3A 34 FF    _conout_disp        LD      A, (console_escape)             ; Test to see if handling an escape sequence and expect more parameters
0349+  EC55 B7                              OR      A
0350+  EC56 C2 0B ED                        JP      NZ, _conout_escape_seq
0351+  EC59             
0352+  EC59 3A 32 FF                        LD      A, (console_flags)              ; Test to see if we're expecting an escape character
0353+  EC5C E6 08                           AND     CFLAGS_ESCAPE
0354+  EC5E CA F8 EC                        JP      Z, _conout_check_esc
0355+  EC61             
0356+  EC61                                                                         ; If so, this is the first character after we got an escape...
0357+  EC61 ED 5B 2D FF                     LD      DE, (cursor_row)                ; Get cursor position in DE
0358+  EC65 3A 32 FF                        LD      A,(console_flags)               ; Reset the escape flag
0359+  EC68 E6 F7                           AND     ~CFLAGS_ESCAPE
0360+  EC6A 32 32 FF                        LD      (console_flags),A
0361+  EC6D             
0362+  EC6D 79                              LD      A, C
0363+  EC6E             
0364+  EC6E FE 41                           CP      'A'
0365+  EC70 20 04                           JR      NZ, _conout_not_up
0366+  EC72 1D                              DEC     E
0367+  EC73 C3 5A ED                        JP      _conout_csr_update
0368+  EC76             
0369+  EC76 FE 42       _conout_not_up      CP      'B'
0370+  EC78 20 04                           JR      NZ, _conout_not_down
0371+  EC7A 1C                              INC     E
0372+  EC7B C3 5A ED                        JP      _conout_csr_update
0373+  EC7E             
0374+  EC7E FE 43       _conout_not_down    CP      'C'
0375+  EC80 20 09                           JR      NZ, _conout_not_right
0376+  EC82 3A 30 FF                        LD      A, (console_width)
0377+  EC85 BA                              CP      D
0378+  EC86 C8                              RET     Z                           
0379+  EC87 14                              INC     D
0380+  EC88 C3 5A ED                        JP      _conout_csr_update
0381+  EC8B             
0382+  EC8B FE 44       _conout_not_right   CP      'D'
0383+  EC8D 20 05                           JR      NZ, _conout_not_left
0384+  EC8F 15                              DEC     D
0385+  EC90 C8                              RET     Z
0386+  EC91 C3 5A ED                        JP      _conout_csr_update
0387+  EC94             
0388+  EC94 FE 46       _conout_not_left    CP      'F'                         ; Enter graphics mode.. not supported
0389+  EC96 C8                              RET     Z
0390+  EC97             
0391+  EC97 FE 47                           CP      'G'                         ; Exit graphics mode
0392+  EC99 C8                              RET     Z
0393+  EC9A             
0394+  EC9A FE 48                           CP      'H'
0395+  EC9C 20 06                           JR      NZ, _conout_not_home
0396+  EC9E 11 01 01                        LD      DE, 0101h
0397+  ECA1 C3 5A ED                        JP      _conout_csr_update
0398+  ECA4             
0399+  ECA4 FE 49       _conout_not_home    CP      'I'                         ; Reverse line feed. Insert line above and move cursor up. Not supported
0400+  ECA6 C8                              RET     Z                    
0401+  ECA7             
0402+  ECA7 FE 4A                           CP      'J'
0403+  ECA9 20 19                           JR      NZ, _conout_not_clr_sc
0404+  ECAB             
0405+  ECAB CD CE EC                        CALL    _conout_clr_ln
0406+  ECAE ED 4B 2D FF                     LD      BC, (cursor_row)
0407+  ECB2 0E 00                           LD      C, 0
0408+  ECB4 04          _conout_clr_scrn    INC     B
0409+  ECB5 3A 2F FF                        LD      A, (console_height)
0410+  ECB8 B8                              CP      B
0411+  ECB9 CA 0F EE                        JP      Z, _redraw_buffer
0412+  ECBC C5                              PUSH    BC
0413+  ECBD 78                              LD      A, B
0414+  ECBE CD 3D EF                        CALL    clear_screen_row
0415+  ECC1 C1                              POP     BC
0416+  ECC2 18 F0                           JR      _conout_clr_scrn
0417+  ECC4             
0418+  ECC4 FE 4B       _conout_not_clr_sc  CP      'K'
0419+  ECC6 20 11                           JR      NZ, _conout_not_clr_ln
0420+  ECC8             
0421+  ECC8 CD CE EC                        CALL   _conout_clr_ln
0422+  ECCB C3 0F EE                        JP     _redraw_buffer
0423+  ECCE             
0424+  ECCE ED 4B 2D FF _conout_clr_ln      LD      BC, (cursor_row)
0425+  ECD2 05                              DEC     B
0426+  ECD3 79                              LD      A, C
0427+  ECD4 3D                              DEC     A
0428+  ECD5 48                              LD      C, B
0429+  ECD6 C3 3D EF                        JP      clear_screen_row
0430+  ECD9             
0431+  ECD9 FE 59       _conout_not_clr_ln  CP      'Y'
0432+  ECDB 20 08                           JR      NZ, _conout_not_pos
0433+  ECDD             
0434+  ECDD 32 34 FF    _conout_start_esc   LD      (console_escape), A         ; Start an escape sequence
0435+  ECE0 AF                              XOR     A
0436+  ECE1 32 35 FF                        LD      (console_param1), A
0437+  ECE4 C9                              RET
0438+  ECE5             
0439+  ECE5 FE 5A       _conout_not_pos     CP      'Z'
0440+  ECE7 20 06                           JR      NZ, _conout_not_ident
0441+  ECE9 3E 03                           LD      A, IDENTITY_LENGTH
0442+  ECEB 32 36 FF                        LD      (console_identify), A
0443+  ECEE C9                              RET
0444+  ECEF             
0445+  ECEF FE 62       _conout_not_ident   CP      'b'
0446+  ECF1 28 EA                           JR      Z, _conout_start_esc
0447+  ECF3 FE 63                           CP      'c'
0448+  ECF5 28 E6                           JR      Z, _conout_start_esc
0449+  ECF7             
0450+  ECF7                                 ; TODO: Any addtional escape sequences here...
0451+  ECF7 C9                              RET
0452+  ECF8             
0453+  ECF8 79          _conout_check_esc   LD      A, C                    
0454+  ECF9 FE 1B                           CP      ESCAPE_CHAR
0455+  ECFB C2 E6 EE                        JP      NZ, _conout_character
0456+  ECFE             
0457+  ECFE 3A 32 FF                        LD      A, (console_flags)
0458+  ED01 F6 08                           OR      CFLAGS_ESCAPE
0459+  ED03 32 32 FF                        LD      (console_flags), A
0460+  ED06 AF                              XOR     A
0461+  ED07 32 34 FF                        LD      (console_escape),A
0462+  ED0A C9                              RET
0463+  ED0B             
0464+  ED0B 3A 34 FF    _conout_escape_seq  LD      A,(console_escape)
0465+  ED0E FE 59                           CP      'Y'
0466+  ED10 28 0D                           JR      Z, _conout_esc_pos
0467+  ED12 FE 62                           CP      'b'
0468+  ED14 28 31                           JR      Z, _conout_esc_foreg
0469+  ED16 FE 63                           CP      'c'
0470+  ED18 28 1C                           JR      Z, _conout_esc_backg
0471+  ED1A             
0472+  ED1A                                 ; All unknown sequences reset the escape sequence
0473+  ED1A AF          _conout_reset_seq   XOR     A
0474+  ED1B 32 34 FF                        LD      (console_escape),A
0475+  ED1E C9                              RET
0476+  ED1F             
0477+  ED1F 3A 35 FF    _conout_esc_pos     LD      A, (console_param1)
0478+  ED22 A7                              AND     A
0479+  ED23 20 05                           JR      NZ, _conout_pos_param
0480+  ED25 79                              LD      A, C
0481+  ED26 32 35 FF                        LD      (console_param1),A
0482+  ED29 C9                              RET
0483+  ED2A             
0484+  ED2A D6 1F       _conout_pos_param   SUB     31
0485+  ED2C 5F                              LD      E, A
0486+  ED2D 79                              LD      A, C
0487+  ED2E D6 1F                           SUB     31
0488+  ED30 57                              LD      D, A
0489+  ED31 CD 1A ED                        CALL    _conout_reset_seq
0490+  ED34 18 24                           JR      _conout_csr_update
0491+  ED36             
0492+  ED36 3A 31 FF    _conout_esc_backg   LD      A, (console_colour)
0493+  ED39 E6 F0                           AND     0F0h
0494+  ED3B 47                              LD      B, A
0495+  ED3C 79                              LD      A, C
0496+  ED3D D6 1F                           SUB     31
0497+  ED3F E6 0F                           AND     0Fh
0498+  ED41 B0          _conout_set_colour  OR      B
0499+  ED42 32 31 FF                        LD      (console_colour), A
0500+  ED45 18 D3                           JR      _conout_reset_seq
0501+  ED47             
0502+  ED47 3A 31 FF    _conout_esc_foreg   LD      A, (console_colour)
0503+  ED4A E6 0F                           AND     0Fh
0504+  ED4C 47                              LD      B, A
0505+  ED4D 79                              LD      A, C
0506+  ED4E D6 1F                           SUB     31
0507+  ED50 CB 27                           SLA     A
0508+  ED52 CB 27                           SLA     A
0509+  ED54 CB 27                           SLA     A
0510+  ED56 CB 27                           SLA     A
0511+  ED58 18 E7                           JR      _conout_set_colour
0512+  ED5A             
0513+  ED5A             ; Cursor position has changed, check if we need to update the whole display.
0514+  ED5A             ; This is entered with DE as D = new cursor column, E = new cursor row
0515+  ED5A             ;         Writes new cursor poition to (cursor_row, cursor_column)
0516+  ED5A             ;         Returns HL = updated display column, row to track the cursor position..
0517+  ED5A             ; Assume column is always within range, row may be before start/after end of visible screen
0518+  ED5A             ;
0519+  ED5A 2A 2B FF    _conout_csr_update  LD      HL, (display_row)           ; HL = current display column, row..
0520+  ED5D ED 4B 2D FF                     LD      BC, (cursor_row)            ; BC = old values of cursor column, row
0521+  ED61 7B                              LD      A, E                        
0522+  ED62 B9                              CP      C
0523+  ED63 32 2D FF                        LD      (cursor_row), A
0524+  ED66 20 0A                           JR      NZ, _conout_check_row       ; If cursor row has changed, we must update display_row and optionally screen_offset
0525+  ED68             
0526+  ED68 7A          _conout_track_col   LD      A, D
0527+  ED69 B8                              CP      B
0528+  ED6A 32 2E FF                        LD      (cursor_col), A
0529+  ED6D 20 1A                           JR      NZ, _conout_check_col       ; If only column has changed, we may update display_col..
0530+  ED6F C3 0F EE                        JP      _redraw_buffer              ; Otherwise, nothing has changed. Make sure display is up to date
0531+  ED72             
0532+  ED72 A7          _conout_check_row   AND     A                           
0533+  ED73 20 05                           JR      NZ, _conout_chk_bottom         
0534+  ED75 3C                              INC     A                           ; We're above the screen, fix the cursor_row but set L (display row) to -1 
0535+  ED76 32 2D FF                        LD      (cursor_row), A
0536+  ED79             
0537+  ED79 AF                              XOR     A
0538+  ED7A             
0539+  ED7A 3D          _conout_chk_bottom  DEC     A
0540+  ED7B 6F                              LD      L, A                        ; Update the display row in HL which will force refresh
0541+  ED7C 3A 2F FF                        LD      A, (console_height)
0542+  ED7F BD                              CP      L
0543+  ED80 20 03                           JR      NZ, _conout_not_bottom
0544+  ED82             
0545+  ED82 32 2D FF                        LD      (cursor_row), A
0546+  ED85             
0547+  ED85 7A          _conout_not_bottom  LD      A, D                        ; Write col here since it wasn't previously set...
0548+  ED86 32 2E FF                        LD      (cursor_col), A
0549+  ED89             
0550+  ED89 7C          _conout_check_col   LD      A, H                        ; Current display col
0551+  ED8A 3C                              INC     A
0552+  ED8B 92                              SUB     D                           ; Subtract new cursor col
0553+  ED8C 30 18                           JR      NC, _conout_scroll_l        ; Cursor col is before beginning of screen
0554+  ED8E             
0555+  ED8E 3A 32 FF                        LD      A, (console_flags)
0556+  ED91 E6 01                           AND     CFLAGS_SHOW_CURSOR
0557+  ED93 3E 01                           LD      A, 1
0558+  ED95 28 01                           JR      Z, _conout_keep_left
0559+  ED97 3D                              DEC     A
0560+  ED98 C6 18       _conout_keep_left   ADD     A, DISPLAY_WIDTH          
0561+  ED9A 47                              LD      B, A
0562+  ED9B 84                              ADD     A, H                        ; Right hand edge of display...
0563+  ED9C BA                              CP      D
0564+  ED9D 30 0A                           JR      NC, _conout_refresh
0565+  ED9F             
0566+  ED9F 7A                              LD      A, D                        ; Cursor col is after end of screen
0567+  EDA0 90                              SUB     B
0568+  EDA1 30 05                           JR      NC, _conout_scroll_done
0569+  EDA3 AF                              XOR     A
0570+  EDA4 18 02                           JR      _conout_scroll_done
0571+  EDA6             
0572+  EDA6 7A          _conout_scroll_l    LD      A, D
0573+  EDA7 3D                              DEC     A
0574+  EDA8 67          _conout_scroll_done LD      H, A
0575+  EDA9             
0576+  EDA9             
0577+  EDA9             ; We enter with HL = new display column, row
0578+  EDA9             ; At this point one or both of display row or column may changed, so update the whole display...   
0579+  EDA9             ; If row is -1, we're before the beginning of the screen - need to scroll up
0580+  EDA9             ; And if row > console_height, we need to scroll down.. Display row stays constant, but screen_offset changes..
0581+  EDA9             
0582+  EDA9             ; Do scroll first, then only change display row/col if console_flags is set to track cursor..
0583+  EDA9             ; If display row/col have changed, compare screen buffer with display buffer and update whichever characters/brightnesses have changed..
0584+  EDA9             ;
0585+  EDA9             ; 
0586+  EDA9             _conout_refresh     
0587+  EDA9 7D                              LD      A, L
0588+  EDAA B7                              OR      A
0589+  EDAB F2 C2 ED                        JP      P, _conout_row_postv
0590+  EDAE             
0591+  EDAE                                 ; Display row negative
0592+  EDAE AF                              XOR     A
0593+  EDAF 6F                              LD      L, A                        ; Reset display row to zero
0594+  EDB0 3A 2A FF                        LD      A, (screen_offset)
0595+  EDB3 3D                              DEC     A
0596+  EDB4 E6 3F                           AND     03Fh
0597+  EDB6 32 2A FF                        LD      (screen_offset), A
0598+  EDB9 E5                              PUSH    HL
0599+  EDBA 0E 00                           LD      C, 0
0600+  EDBC CD 3D EF                        CALL    clear_screen_row
0601+  EDBF E1                              POP     HL
0602+  EDC0 18 43                           JR      _conout_update_display
0603+  EDC2             
0604+  EDC2 3A 2F FF    _conout_row_postv   LD      A, (console_height)
0605+  EDC5 4F                              LD      C, A                        ; Remember for later on
0606+  EDC6 BD                              CP      L
0607+  EDC7 20 3C                           JR      NZ, _conout_update_display
0608+  EDC9             
0609+  EDC9                                 ; display row below screen
0610+  EDC9 E5                              PUSH    HL
0611+  EDCA 3A 2A FF                        LD      A, (screen_offset)
0612+  EDCD 3C                              INC     A
0613+  EDCE E6 3F                           AND     03Fh
0614+  EDD0 32 2A FF                        LD      (screen_offset), A
0615+  EDD3                                 ; SUB     C
0616+  EDD3 E6 3F                           AND     03Fh
0617+  EDD5 6F                              LD      L, A
0618+  EDD6             
0619+  EDD6 3A 29 FF                        LD      A, (screen_page)
0620+  EDD9 FE 40                           CP      VIDEOBEAST_PAGE
0621+  EDDB 20 20                           JR      NZ, _not_videobeast
0622+  EDDD             
0623+  EDDD F3                              DI
0624+  EDDE D3 71                           OUT     (IO_MEM_1), A
0625+  EDE0 3E F3                           LD      A, VB_UNLOCK
0626+  EDE2 32 FE 7F                        LD      (VB_REGISTERS_LOCKED), A
0627+  EDE5 7D                              LD      A, L
0628+  EDE6 87                              ADD     A, A
0629+  EDE7 87                              ADD     A, A
0630+  EDE8 87                              ADD     A, A
0631+  EDE9 32 C7 7F                        LD      (VB_LAYER_4+LAYER_SCROLL_Y), A
0632+  EDEC 3E 10                           LD      A, 010h
0633+  EDEE 38 01                           JR      C, _conout_scroll_xy
0634+  EDF0 AF                              XOR     A
0635+  EDF1 32 C6 7F    _conout_scroll_xy   LD      (VB_LAYER_4+LAYER_SCROLL_XY), A
0636+  EDF4 32 FE 7F                        LD      (VB_REGISTERS_LOCKED), A    ; Either value will re-lock registers..
0637+  EDF7             
0638+  EDF7 3A 3A FF                        LD      A, (page_1_mapping)
0639+  EDFA D3 71                           OUT     (IO_MEM_1), A
0640+  EDFC FB                              EI 
0641+  EDFD             
0642+  EDFD 79          _not_videobeast     LD      A, C
0643+  EDFE                                 
0644+  EDFE 0E 00                           LD      C, 0
0645+  EE00 CD 3D EF                        CALL    clear_screen_row
0646+  EE03 E1                              POP     HL 
0647+  EE04 2D                              DEC     L
0648+  EE05             
0649+  EE05             _conout_update_display
0650+  EE05                                 ; We've scrolled if necessary, update the display row if required..
0651+  EE05 3A 32 FF                        LD      A, (console_flags)
0652+  EE08 E6 02                           AND     CFLAGS_TRACK_CURSOR         
0653+  EE0A 28 03                           JR      Z, _redraw_buffer
0654+  EE0C 22 2B FF                        LD      (display_row), HL           ; Only move display row if we're tracking the cursor
0655+  EE0F             
0656+  EE0F F3          _redraw_buffer      DI
0657+  EE10 CD 15 EE                        CALL    unsafe_redraw
0658+  EE13 FB                              EI
0659+  EE14 C9                              RET
0660+  EE15             
0661+  EE15             ;----------------------------------------------------------------------------------------------------
0662+  EE15             ; Note that this uses Mem Page 1
0663+  EE15             ;
0664+  EE15 3A 32 FF    unsafe_redraw       LD      A, (console_flags)
0665+  EE18 E6 20                           AND     CFLAGS_LED_OFF
0666+  EE1A C0                              RET     NZ
0667+  EE1B             
0668+  EE1B 2A 2B FF    unsafe_led_redraw   LD      HL, (display_row)       ; Calculate our screen source in DE
0669+  EE1E 3A 2A FF                        LD      A, (screen_offset)      
0670+  EE21 85                              ADD     A, L
0671+  EE22             
0672+  EE22 E6 3F                           AND     03Fh
0673+  EE24 F6 40                           OR      040h                    ; We're going to use page 1 for the screen buffer
0674+  EE26 57                              LD      D, A
0675+  EE27 7C                              LD      A, H
0676+  EE28 CB 27                           SLA     A
0677+  EE2A 5F                              LD      E, A
0678+  EE2B             
0679+  EE2B 21 85 FF                        LD      HL, display_buffer
0680+  EE2E 06 18                           LD      B, DISPLAY_WIDTH
0681+  EE30 0E 00                           LD      C, 0
0682+  EE32             
0683+  EE32 3A 32 FF                        LD      A, (console_flags)      ; Don't draw last character if we've moved
0684+  EE35 E6 24                           AND     CFLAGS_SHOW_MOVED | CFLAGS_LED_OFF
0685+  EE37 28 01                           JR      Z, _full_redraw
0686+  EE39 05                              DEC     B
0687+  EE3A             
0688+  EE3A 3A 29 FF    _full_redraw        LD      A, (screen_page)
0689+  EE3D D3 71                           OUT     (IO_MEM_1), A
0690+  EE3F             
0691+  EE3F 1A          _redraw_loop        LD      A, (DE)
0692+  EE40 BE                              CP      (HL)
0693+  EE41 28 0A                           JR      Z, _redraw_skip_char
0694+  EE43 77                              LD      (HL), A
0695+  EE44 C5                              PUSH    BC
0696+  EE45 E5                              PUSH    HL
0697+  EE46 D5                              PUSH    DE
0698+  EE47 CD DB F7                        CALL    disp_character
0699+  EE4A D1                              POP     DE
0700+  EE4B E1                              POP     HL
0701+  EE4C C1                              POP     BC
0702+  EE4D             
0703+  EE4D 23          _redraw_skip_char   INC     HL
0704+  EE4E 13                              INC     DE
0705+  EE4F             
0706+  EE4F 3A 32 FF                        LD      A, (console_flags)
0707+  EE52 E6 24                           AND     CFLAGS_SHOW_MOVED | CFLAGS_LED_OFF
0708+  EE54 1A                              LD      A, (DE)  
0709+  EE55 28 05                           JR      Z, _redraw_normal
0710+  EE57             
0711+  EE57 CB 3F                           SRL     A
0712+  EE59 CB 3F                           SRL     A
0713+  EE5B 3C                              INC     A
0714+  EE5C             
0715+  EE5C BE          _redraw_normal      CP      (HL)
0716+  EE5D 28 12                           JR      Z, _redraw_skip_bri
0717+  EE5F 77                              LD      (HL), A
0718+  EE60 C5                              PUSH    BC
0719+  EE61 E5                              PUSH    HL
0720+  EE62 D5                              PUSH    DE                
0721+  EE63 7E                              LD      A, (HL)             ; Ugh... disp_char_bright has parameters in other order..
0722+  EE64 CB 3F                           SRL     A
0723+  EE66 E6 78                           AND     078h
0724+  EE68 47                              LD      B, A
0725+  EE69 79                              LD      A, C
0726+  EE6A 48                              LD      C, B
0727+  EE6B CD 9D F7                        CALL    disp_char_bright    ; Column A, brightness C
0728+  EE6E D1                              POP     DE
0729+  EE6F E1                              POP     HL
0730+  EE70 C1                              POP     BC
0731+  EE71             
0732+  EE71 23          _redraw_skip_bri    INC     HL
0733+  EE72 13                              INC     DE
0734+  EE73 0C                              INC     C
0735+  EE74 10 C9                           DJNZ    _redraw_loop
0736+  EE76             
0737+  EE76 3A 32 FF                        LD      A, (console_flags)
0738+  EE79 4F                              LD      C, A
0739+  EE7A E6 24                           AND     CFLAGS_SHOW_MOVED | CFLAGS_LED_OFF
0740+  EE7C 28 5D                           JR      Z, _redraw_done
0741+  EE7E             
0742+  EE7E                                 ; We've moved the cursor, so draw the last character as our location bitmap..
0743+  EE7E 36 00       _redraw_moved       LD      (HL), 0
0744+  EE80 23                              INC     HL
0745+  EE81 36 80                           LD      (HL), DISP_DEFAULT_BRIGHTNESS
0746+  EE83 79                              LD      A, C
0747+  EE84 E6 20                           AND     CFLAGS_LED_OFF
0748+  EE86 79                              LD      A, C
0749+  EE87 28 05                           JR      Z, _led_normal
0750+  EE89             
0751+  EE89 21 07 09                        LD      HL, LED_OFF_BITMAP
0752+  EE8C 18 41                           JR      _redraw_map2
0753+  EE8E             
0754+  EE8E E6 02       _led_normal         AND     CFLAGS_TRACK_CURSOR
0755+  EE90 20 4F                           JR      NZ, _redraw_tracking
0756+  EE92             
0757+  EE92 21 00 00                        LD      HL, 0
0758+  EE95 ED 4B 2D FF                     LD      BC, (cursor_row)
0759+  EE99 0D                              DEC     C
0760+  EE9A                                 
0761+  EE9A ED 5B 2B FF                     LD      DE, (display_row)
0762+  EE9E 7B                              LD      A, E
0763+  EE9F A7                              AND     A
0764+  EEA0 20 05                           JR      NZ, _redraw_not_top
0765+  EEA2 21 01 00                        LD      HL, MOVE_TOP_BITMAP
0766+  EEA5 18 0A                           JR      _redraw_not_bottom
0767+  EEA7             
0768+  EEA7 3A 2F FF    _redraw_not_top     LD      A, (console_height)
0769+  EEAA 3D                              DEC     A
0770+  EEAB BB                              CP      E
0771+  EEAC 20 03                           JR      NZ, _redraw_not_bottom
0772+  EEAE 21 08 00                        LD      HL, MOVE_BOTTOM_BITMAP
0773+  EEB1             
0774+  EEB1 7B          _redraw_not_bottom  LD      A, E
0775+  EEB2 B9                              CP      C
0776+  EEB3 01 00 00                        LD      BC, 0
0777+  EEB6 20 04                           JR      NZ, _redraw_not_row
0778+  EEB8 0E C0                           LD      C, MOVE_ROW_BITMAP_L
0779+  EEBA 18 08                           JR      _redraw_map
0780+  EEBC             
0781+  EEBC 06 28       _redraw_not_row     LD      B, MOVE_BELOW_BITMAP_H
0782+  EEBE 38 02                           JR      C, _redraw_not_above
0783+  EEC0 18 02                           JR      _redraw_map
0784+  EEC2             
0785+  EEC2 06 05       _redraw_not_above   LD      B, MOVE_ABOVE_BITMAP_H
0786+  EEC4             
0787+  EEC4 09          _redraw_map         ADD     HL, BC
0788+  EEC5 3A 2C FF                        LD      A, (display_col)
0789+  EEC8 A7                              AND     A
0790+  EEC9 20 04                           JR      NZ, _redraw_map2
0791+  EECB 3E 30                           LD      A, MOVE_AT_LEFT_BITMAP
0792+  EECD B5                              OR      L
0793+  EECE 6F                              LD      L, A
0794+  EECF 3E 17       _redraw_map2        LD      A, DISPLAY_WIDTH-1
0795+  EED1 CD FC F7                        CALL    disp_bitmask
0796+  EED4             
0797+  EED4 3E 17                           LD      A, DISPLAY_WIDTH-1
0798+  EED6 0E 80                           LD      C, DISP_DEFAULT_BRIGHTNESS
0799+  EED8 CD 9D F7                        CALL    disp_char_bright
0800+  EEDB             
0801+  EEDB 3A 3A FF    _redraw_done        LD      A, (page_1_mapping)
0802+  EEDE D3 71                           OUT     (IO_MEM_1), A
0803+  EEE0 C9                              RET
0804+  EEE1             
0805+  EEE1 21 3F 2D    _redraw_tracking    LD      HL, 2d3fh          ; Tracking symbol
0806+  EEE4 18 E9                           JR      _redraw_map2
0807+  EEE6             
0808+  EEE6             MOVE_TOP_BITMAP     .EQU    0001h
0809+  EEE6             MOVE_BOTTOM_BITMAP  .EQU    0008h
0810+  EEE6             MOVE_ROW_BITMAP_L   .EQU    0c0h
0811+  EEE6             MOVE_ABOVE_BITMAP_H .EQU    05h
0812+  EEE6             MOVE_BELOW_BITMAP_H .EQU    28h
0813+  EEE6             MOVE_AT_LEFT_BITMAP .EQU    030h
0814+  EEE6             LED_OFF_BITMAP      .EQU    0907h
0815+  EEE6             
0816+  EEE6             ;---------------------------------------- Simple character output.. 
0817+  EEE6 ED 5B 2D FF _conout_character   LD      DE, (cursor_row)
0818+  EEEA FE 0D                           CP      CARRIAGE_RETURN
0819+  EEEC 20 05                           JR      NZ, _conout_not_cr
0820+  EEEE                
0821+  EEEE 16 01                           LD      D, 1
0822+  EEF0 C3 5A ED                        JP      _conout_csr_update
0823+  EEF3             
0824+  EEF3 FE 0A       _conout_not_cr      CP      NEWLINE
0825+  EEF5 20 04                           JR      NZ, _conout_not_lf
0826+  EEF7             
0827+  EEF7 1C                              INC     E
0828+  EEF8 C3 5A ED                        JP      _conout_csr_update
0829+  EEFB             
0830+  EEFB FE 08       _conout_not_lf      CP      BACKSPACE_CHAR
0831+  EEFD 20 05                           JR      NZ, _conout_visible
0832+  EEFF             
0833+  EEFF 15                              DEC     D
0834+  EF00 C2 5A ED                        JP      NZ, _conout_csr_update
0835+  EF03 C9                              RET
0836+  EF04             
0837+  EF04                                 ; Now, C is character to write,
0838+  EF04 ED 5B 2D FF _conout_visible     LD      DE, (cursor_row)
0839+  EF08 15                              DEC     D                       ; 1 based col
0840+  EF09 1D                              DEC     E                       ; 1 based row
0841+  EF0A             
0842+  EF0A 3A 2A FF                        LD      A, (screen_offset)      ; Write the character and colour into our screen buffer
0843+  EF0D 83                              ADD     A, E
0844+  EF0E             
0845+  EF0E E6 3F                           AND     03Fh
0846+  EF10 F6 40                           OR      040h                    ; We're going to use page 1 for the screen buffer
0847+  EF12 67                              LD      H, A
0848+  EF13 7A                              LD      A, D
0849+  EF14 CB 27                           SLA     A
0850+  EF16 6F                              LD      L, A
0851+  EF17 3A 29 FF                        LD      A, (screen_page)
0852+  EF1A D3 71                           OUT     (IO_MEM_1), A
0853+  EF1C 71                              LD      (HL), C
0854+  EF1D 3A 31 FF                        LD      A, (console_colour)
0855+  EF20 23                              INC     HL
0856+  EF21 77                              LD      (HL), A
0857+  EF22 3A 3A FF                        LD      A, (page_1_mapping)
0858+  EF25 D3 71                           OUT     (IO_MEM_1), A
0859+  EF27             
0860+  EF27 ED 5B 2D FF                     LD      DE, (cursor_row)
0861+  EF2B 3A 30 FF                        LD      A, (console_width)
0862+  EF2E 6F                              LD      L, A
0863+  EF2F 7A                              LD      A, D
0864+  EF30 BD                              CP      L
0865+  EF31 28 04                           JR      Z, _conout_wrap
0866+  EF33 14                              INC     D
0867+  EF34 C3 5A ED                        JP      _conout_csr_update
0868+  EF37             
0869+  EF37 16 01       _conout_wrap        LD      D, 1
0870+  EF39 1C                              INC     E
0871+  EF3A C3 5A ED                        JP      _conout_csr_update          ; If we've wrapped, use the new wrap position..
0872+  EF3D             ;
0873+  EF3D             ;
0874+  EF3D             ; Fill the row of the screen buffer with space chars..
0875+  EF3D             ; Enter with A -> row of screen buffer, C -> start column
0876+  EF3D             ;          Uses HL, C
0877+  EF3D             ;
0878+  EF3D 67          clear_screen_row    LD      H, A
0879+  EF3E 3A 2A FF                        LD      A, (screen_offset)
0880+  EF41 84                              ADD     A, H
0881+  EF42             
0882+  EF42 E6 3F                           AND    03Fh
0883+  EF44 F6 40                           OR     040h
0884+  EF46 67                              LD     H, A
0885+  EF47 79                              LD     A, C
0886+  EF48 81                              ADD    A, C
0887+  EF49 6F                              LD     L, A
0888+  EF4A             
0889+  EF4A 3A 31 FF                        LD      A, (console_colour)
0890+  EF4D 4F                              LD      C, A
0891+  EF4E             
0892+  EF4E 3A 29 FF                        LD      A, (screen_page)
0893+  EF51 D3 71                           OUT     (IO_MEM_1), A
0894+  EF53             
0895+  EF53 3E 20       _clear_loop         LD      A, ' '
0896+  EF55 77                              LD      (HL), A
0897+  EF56 2C                              INC     L
0898+  EF57 71                              LD      (HL), C
0899+  EF58 2C                              INC     L
0900+  EF59 3E FE                           LD      A, 0FEh
0901+  EF5B BD                              CP      L
0902+  EF5C 20 F5                           JR      NZ, _clear_loop
0903+  EF5E             
0904+  EF5E 3A 3A FF                        LD      A, (page_1_mapping)
0905+  EF61 D3 71                           OUT     (IO_MEM_1), A
0906+  EF63 C9                              RET
0907+  EF64             ;------------------------------------------------------  
0908+  EF64             bios_list     ;  5 List OUTput
0909+  EF64 AF                              XOR     A
0910+  EF65 C9                              RET
0911+  EF66                                 
0912+  EF66             ;------------------------------------------------------  
0913+  EF66             bios_punch    ;  6 punch OUTput
0914+  EF66 AF                              XOR     A
0915+  EF67 C9                              RET
0916+  EF68                                 
0917+  EF68             ;------------------------------------------------------  
0918+  EF68             bios_reader   ;  7 Reader input
0919+  EF68 C9                              RET
0920+  EF69                                 
0921+  EF69             
0922+  EF69                                 
0923+  EF69             ;------------------------------------------------------  
0924+  EF69             bios_seldsk   ;  9 Select disk - Select disc in C, returns HL =  address of DPH, or 0 if error
0925+  EF69                                 ; Store C in A, Check drive is in range
0926+  EF69 79                              LD      A, C
0927+  EF6A 21 00 00                        LD      HL, 0
0928+  EF6D FE 02                           CP      MAX_DRIVES
0929+  EF6F D0                              RET     NC
0930+  EF70             
0931+  EF70 06 00                           LD      B, 0
0932+  EF72 CB 21                           SLA     C
0933+  EF74 CB 21                           SLA     C
0934+  EF76 CB 21                           SLA     C
0935+  EF78 CB 21                           SLA     C
0936+  EF7A 21 33 EA                        LD      HL, dpbase
0937+  EF7D 09                              ADD     HL, BC
0938+  EF7E 32 44 FF                        LD      (sys_seldsk), A
0939+  EF81 C9                              RET
0940+  EF82             
0941+  EF82             ;------------------------------------------------------  
0942+  EF82             bios_home     ;  8 Home disk
0943+  EF82 0E 00                           LD      C, 0            
0944+  EF84             ;------------------------------------------------------  
0945+  EF84             bios_settrk   ; 10 Select track - Move drive to track stored in C - 0 based (0-76)
0946+  EF84 79                              LD      A, C
0947+  EF85 32 3D FF                        LD      (sys_track), A
0948+  EF88 C9                              RET
0949+  EF89                                 
0950+  EF89             ;------------------------------------------------------  
0951+  EF89             bios_setsec   ; 11 Select sector - Move drive to sector stored in BC - 1 based (1-26) - TODO: Confirm this, not sure if true..
0952+  EF89 ED 43 3E FF                     LD      (sys_sector), BC
0953+  EF8D C9                              RET
0954+  EF8E                                 
0955+  EF8E             ;------------------------------------------------------  
0956+  EF8E             bios_setdma   ; 12 Set DMA ADDress - Set the DMA address to BC - source or destination for disk read/write
0957+  EF8E                           ; Note: CP/M 2.2 appears to only set this to the DIRBUF address defined in the DPF, or the USER DMA address (0x80h)
0958+  EF8E ED 43 40 FF                     LD      (sys_dmaaddr), BC
0959+  EF92 C9                              RET
0960+  EF93                                 
0961+  EF93             ;------------------------------------------------------  
0962+  EF93             ;
0963+  EF93             ; Uses Mem Page 1, 2
0964+  EF93             ;
0965+  EF93             bios_read     ; 13 Read 128 bytes
0966+  EF93 CD FF EF                        CALL    _get_memdisc_addr
0967+  EF96 F3                              DI
0968+  EF97 D3 71                           OUT     (IO_MEM_1), A
0969+  EF99 CB F0                           SET     6, B            ; Point B into page 1
0970+  EF9B C5                              PUSH    BC
0971+  EF9C E1                              POP     HL
0972+  EF9D 0E 80                           LD      C, 128
0973+  EF9F             
0974+  EF9F ED 5B 40 FF                     LD      DE, (sys_dmaaddr)
0975+  EFA3 7A                              LD      A, D
0976+  EFA4 07                              RLCA
0977+  EFA5 07                              RLCA
0978+  EFA6 E6 03                           AND     03h             ; Bottom two bits
0979+  EFA8 F6 20                           OR      RAM_PAGE_0
0980+  EFAA 47                              LD      B, A            ; B is destination page
0981+  EFAB D3 72       _read_page          OUT     (IO_MEM_2), A
0982+  EFAD             
0983+  EFAD CB FA                           SET     7, D            ; Point D to second page
0984+  EFAF CB B2                           RES     6, D
0985+  EFB1             
0986+  EFB1 ED A0       _read_next          LDI
0987+  EFB3 79                              LD      A, C
0988+  EFB4 B7                              OR      A
0989+  EFB5 28 08                           JR      Z, _read_write_done
0990+  EFB7             
0991+  EFB7 CB 72                           BIT     6, D
0992+  EFB9 28 F6                           JR      Z, _read_next
0993+  EFBB             
0994+  EFBB 04                              INC     B
0995+  EFBC 78                              LD      A, B
0996+  EFBD 18 EC                           JR      _read_page
0997+  EFBF             
0998+  EFBF 3A 3A FF    _read_write_done    LD      A, (page_1_mapping)   ; Return page map to normal
0999+  EFC2 D3 71                           OUT     (IO_MEM_1), A
1000+  EFC4 3A 3B FF                        LD      A, (page_2_mapping)
1001+  EFC7 D3 72                           OUT     (IO_MEM_2), A
1002+  EFC9 FB                              EI
1003+  EFCA AF                              XOR     A               ; No errors
1004+  EFCB C9                              RET
1005+  EFCC                                 
1006+  EFCC             ;------------------------------------------------------  
1007+  EFCC             ;
1008+  EFCC             ; Uses Mem Page 1, 2
1009+  EFCC             ;
1010+  EFCC             bios_write    ; 14 Write 128 bytes
1011+  EFCC 3A 44 FF                        LD      A, (sys_seldsk)
1012+  EFCF B7                              OR      A
1013+  EFD0 20 02                           JR      NZ, _write_ok
1014+  EFD2 3C                              INC     A
1015+  EFD3 C9                              RET
1016+  EFD4             
1017+  EFD4 CD FF EF    _write_ok           CALL    _get_memdisc_addr
1018+  EFD7 F3                              DI
1019+  EFD8 D3 71                           OUT     (IO_MEM_1), A
1020+  EFDA CB F0                           SET     6, B
1021+  EFDC C5                              PUSH    BC
1022+  EFDD D1                              POP     DE
1023+  EFDE 0E 80                           LD      C, 128
1024+  EFE0             
1025+  EFE0 2A 40 FF                        LD      HL, (sys_dmaaddr)
1026+  EFE3 7C                              LD      A, H
1027+  EFE4 07                              RLCA
1028+  EFE5 07                              RLCA
1029+  EFE6 E6 03                           AND     03h              ; Bottom two bits
1030+  EFE8 F6 20                           OR      RAM_PAGE_0
1031+  EFEA 47                              LD      B, A             ; B is source page
1032+  EFEB D3 72       _write_page         OUT     (IO_MEM_2), A
1033+  EFED             
1034+  EFED CB FC                           SET     7, H
1035+  EFEF CB B4                           RES     6, H
1036+  EFF1             
1037+  EFF1 ED A0       _write_next         LDI
1038+  EFF3 79                              LD      A, C
1039+  EFF4 B7                              OR      A
1040+  EFF5 28 C8                           JR      Z, _read_write_done
1041+  EFF7             
1042+  EFF7 CB 74                           BIT     6, H
1043+  EFF9 28 F6                           JR      Z, _write_next
1044+  EFFB             
1045+  EFFB 04                              INC     B
1046+  EFFC 78                              LD      A, B
1047+  EFFD 18 EC                           JR      _write_page
1048+  EFFF                                 
1049+  EFFF             ; IN THIS CASE, WE HAVE SAVED THE DISK NUMBER IN 'DISKNO' (0, 1)
1050+  EFFF             ;           THE TRACK NUMBER IN 'TRACK' (0-76)
1051+  EFFF             ;           THE SECTOR NUMBER IN 'SECTOR' (1-26)
1052+  EFFF             ;           THE DMA ADDRESS IN 'DMAAD' (0-65535)
1053+  EFFF             ;
1054+  EFFF             ; Returns BC = address in page for sector
1055+  EFFF             ;          A = page number (ROM/RAM)
1056+  EFFF             ;
1057+  EFFF             ; Note: BC is always aligned to page boundaries, so a sector will never overlap the end of a page.
1058+  EFFF             ;
1059+  EFFF 21 00 00    _get_memdisc_addr   LD      HL, 0
1060+  F002 ED 4B 3D FF                     LD      BC, (sys_track)     ; C is track, B is sector (up to 256!)
1061+  F006 68                              LD      L, B
1062+  F007 44                              LD      B, H 
1063+  F008 CB 21                           SLA     C                   ; x 2
1064+  F00A CB 10                           RL      B
1065+  F00C 09                              ADD     HL, BC
1066+  F00D CB 21                           SLA     C                   ; x 4
1067+  F00F CB 10                           RL      B
1068+  F011 CB 21                           SLA     C                   ; x 8
1069+  F013 CB 10                           RL      B
1070+  F015 09                              ADD     HL, BC
1071+  F016 CB 21                           SLA     C                   ; x 16
1072+  F018 CB 10                           RL      B
1073+  F01A 09                              ADD     HL, BC              ; HL = Sector + BC * (2 + 8 + 16) = sector + track * 26
1074+  F01B             
1075+  F01B 7D                              LD      A, L
1076+  F01C E6 7F                           AND     07Fh
1077+  F01E 47                              LD      B, A
1078+  F01F 0E 00                           LD      C, 0
1079+  F021 CB 38                           SRL     B
1080+  F023 CB 19                           RR      C                   ; BC = Address in page of sector
1081+  F025             
1082+  F025 CB 25                           SLA     L
1083+  F027 CB 14                           RL      H                   ; H is now page number 
1084+  F029             
1085+  F029 3A 44 FF                        LD      A, (sys_seldsk)
1086+  F02C B7                              OR      A
1087+  F02D 28 05                           JR      Z, _get_memdisk_a
1088+  F02F 3A 38 FF                        LD      A, (drive_b_mem_page)
1089+  F032 84                              ADD     A, H
1090+  F033 C9                              RET
1091+  F034 3A 37 FF    _get_memdisk_a      LD      A, (drive_a_mem_page)
1092+  F037 84                              ADD     A, H
1093+  F038 C9                              RET
1094+  F039             
1095+  F039             
1096+  F039             ;------------------------------------------------------  
1097+  F039             bios_listst   ; 15 List status
1098+  F039 AF                              XOR     A
1099+  F03A C9                              RET
1100+  F03B                                 
1101+  F03B             ;------------------------------------------------------  
1102+  F03B             bios_sectrn   ; 16 Sector translate - BC = logical sector number (zero based), DE = address of translation table. Return HL as physical sector number
1103+  F03B 69                              LD      L, C                ; No skewing needed, just return BC in HL
1104+  F03C 60                              LD      H, B
1105+  F03D C9                              RET
1106+  F03E                                 
1107+  F03E             ;------------------------------------------------------
1108+  F03E             ; Inline print. Preserves HL, DE, BC
1109+  F03E             ;
1110+  F03E E3          m_print_inline      EX      (SP), HL
1111+  F03F 7E          _inline_loop        LD      A, (HL)
1112+  F040 23                              INC     HL
1113+  F041 A7                              AND     A
1114+  F042 28 05                           JR      Z, _inline_done
1115+  F044 CD 4B F0                        CALL    m_print_a_safe
1116+  F047 18 F6                           JR      _inline_loop
1117+  F049             
1118+  F049 E3          _inline_done        EX      (SP), HL
1119+  F04A C9                              RET
1120+  F04B             
1121+  F04B             ;------------------------------------------------------
1122+  F04B             ; Print character in A. Preserves HL, DE, BC
1123+  F04B             ;
1124+  F04B E5          m_print_a_safe      PUSH    HL
1125+  F04C D5                              PUSH    DE
1126+  F04D C5                              PUSH    BC
1127+  F04E 4F                              LD      C, A
1128+  F04F CD 3A EC                        CALL    bios_conout
1129+  F052 C1                              POP     BC
1130+  F053 D1                              POP     DE
1131+  F054 E1                              POP     HL
1132+  F055 C9                              RET
1133+  F056             
1134+  F056             ;------------------------------------------------------  
1135+  F056             
1136+  F056 F3          configure_hardware  DI     
1137+  F057 3E 20                           LD      A, RAM_PAGE_0
1138+  F059 D3 70                           OUT     (IO_MEM_0), A       ; Page 0 is RAM 0 
1139+  F05B 32 39 FF                        LD      (page_0_mapping), A
1140+  F05E 3C                              INC     A
1141+  F05F D3 71                           OUT     (IO_MEM_1), A       ; Page 1 is RAM 1
1142+  F061 32 3A FF                        LD      (page_1_mapping), A
1143+  F064 3C                              INC      A
1144+  F065 D3 72                           OUT     (IO_MEM_2), A       ; Page 2 is RAM 2 
1145+  F067 32 3B FF                        LD      (page_2_mapping), A
1146+  F06A 3C                              INC     A                   ; Assume we're in RAM 3
1147+  F06B 32 3C FF                        LD      (page_3_mapping), A
1148+  F06E             
1149+  F06E 21 00 FE                        LD      HL, 0FE00h          ; Set up the IM 2 table
1150+  F071 06 00                           LD      B, 0
1151+  F073 36 FD       _fill_vector        LD      (HL), 0FDh
1152+  F075 23                              INC     HL
1153+  F076 10 FB                           DJNZ    _fill_vector
1154+  F078             
1155+  F078 CD DF F2                        CALL    keyboard_init       ; Set up the keyboard status tables
1156+  F07B             
1157+  F07B 3E C3                           LD      A, 0C3h             ; JP reset   instruction
1158+  F07D 32 FD FD                        LD      (0FDFDh), A
1159+  F080 21 7C F1                        LD      HL, interrupt_handler
1160+  F083 22 FE FD                        LD      (0FDFEh), HL
1161+  F086             
1162+  F086 21 00 00                        LD      HL, 0
1163+  F089 22 CF FF                        LD      (user_interrupt), HL
1164+  F08C             
1165+  F08C 3E 02                           LD      A, 2
1166+  F08E D3 13                           OUT     (PIO_B_CTRL),A      ; Zero interrupt vector
1167+  F090             
1168+  F090 3E B7                           LD      A, 0B7h             ; Enable interrupts on any of the following bits
1169+  F092 D3 13                           OUT     (PIO_B_CTRL),A
1170+  F094 00                              NOP
1171+  F095 3E CF                           LD      A, 0CFh             ; Just B5 (RTC interrupt) 
1172+  F097 D3 13                           OUT     (PIO_B_CTRL),A
1173+  F099             
1174+  F099 3E FE                           LD      A, 0FEh
1175+  F09B ED 47                           LD      I, A
1176+  F09D ED 5E                           IM      2
1177+  F09F             
1178+  F09F CD F9 F0                        CALL    setup_screen
1179+  F0A2             
1180+  F0A2 3E 04                           LD      A, DRIVE_A_PAGE
1181+  F0A4 32 37 FF                        LD      (drive_a_mem_page), A
1182+  F0A7             
1183+  F0A7 FB                              EI
1184+  F0A8             
1185+  F0A8 3E 00                           LD      A, 0
1186+  F0AA CD 42 F5                        CALL    uart_init           ; Reinitialise the UART to make sure we've not missed anything
1187+  F0AD             
1188+  F0AD CD 0C F9                        CALL    rtc_init            ; Make sure clock is running and reset time if necesary
1189+  F0B0             
1190+  F0B0 06 04       _set_ctrl           LD      B, 4                ; Set RTC Coarse mode and Output Pin to Square wave - gives 64 Hz pulse
1191+  F0B2 C5          _set_ctrl_loop      PUSH    BC
1192+  F0B3 26 6F                           LD      H, RTC_ADDRESS      
1193+  F0B5 2E 07                           LD      L, RTC_REG_CTRL
1194+  F0B7 CD 14 F6                        CALL    i2c_write_to
1195+  F0BA 30 0B                           JR      NC, _rtc_ack_error
1196+  F0BC 3E 44                           LD      A, RTC_64HZ_ENABLED
1197+  F0BE CD 28 F6                        CALL    i2c_write
1198+  F0C1 30 04                           JR      NC, _rtc_ack_error
1199+  F0C3 AF                              XOR     A
1200+  F0C4 CD 28 F6                        CALL    i2c_write
1201+  F0C7 CD DC F5    _rtc_ack_error      CALL    i2c_stop
1202+  F0CA             
1203+  F0CA CD D5 F0                        CALL    _pause
1204+  F0CD             
1205+  F0CD CD DA F0                        CALL    _check_ctrl
1206+  F0D0 C1                              POP     BC
1207+  F0D1 C8                              RET     Z
1208+  F0D2 10 DE                           DJNZ    _set_ctrl_loop
1209+  F0D4 C9                              RET
1210+  F0D5             
1211+  F0D5 06 00       _pause              LD      B, 0
1212+  F0D7 10 FE                           DJNZ    $
1213+  F0D9 C9                              RET
1214+  F0DA             
1215+  F0DA             ; Check that the control is set to coarse trim and 0 offset
1216+  F0DA             ; Returns with Zero flag set if settings are good.
1217+  F0DA             ;
1218+  F0DA 26 6F       _check_ctrl         LD      H, RTC_ADDRESS      
1219+  F0DC 2E 07                           LD      L, RTC_REG_CTRL
1220+  F0DE CD F3 F5                        CALL    i2c_read_from
1221+  F0E1 16 02                           LD      D, 2
1222+  F0E3 30 11                           JR      NC, _ctrl_error
1223+  F0E5 5F                              LD      E, A
1224+  F0E6 CD 86 F6                        CALL    i2c_ack
1225+  F0E9 CD 73 F6                        CALL    i2c_read
1226+  F0EC 57                              LD      D, A
1227+  F0ED CD DC F5                        CALL    i2c_stop
1228+  F0F0 7B                              LD      A, E
1229+  F0F1 06 04                           LD      B, 4
1230+  F0F3 FE 44                           CP      RTC_64HZ_ENABLED
1231+  F0F5 C0                              RET     NZ
1232+  F0F6 7A          _ctrl_error         LD      A, D
1233+  F0F7 A7                              AND     A
1234+  F0F8 C9                              RET 
1235+  F0F9             
1236+  F0F9             ; SHOULD NOT BE CALLED WITH INTERRUPTS ENABLED!
1237+  F0F9             ;
1238+  F0F9 3E 40       setup_screen        LD      A, VIDEOBEAST_PAGE
1239+  F0FB D3 71                           OUT     (IO_MEM_1), A
1240+  F0FD 21 00 40                        LD      HL, PAGE_1_START
1241+  F100 AF                              XOR     A
1242+  F101 47                              LD      B, A
1243+  F102 77          _videobeast_check   LD      (HL), A
1244+  F103 BE                              CP      (HL)
1245+  F104 20 2E                           JR      NZ, _no_videobeast
1246+  F106 C6 0D                           ADD     A, 13
1247+  F108 10 F8                           DJNZ    _videobeast_check
1248+  F10A             
1249+  F10A 3E 40                           LD      A, VIDEOBEAST_PAGE
1250+  F10C 32 62 F1                        LD      (_screen_defaults), A
1251+  F10F 21 1E 50                        LD      HL, 0501Eh          ; 80 x 30 screen
1252+  F112 22 68 F1                        LD      (_screen_size), HL
1253+  F115             
1254+  F115 3E F3                           LD      A, VB_UNLOCK
1255+  F117 32 FE 7F                        LD      (VB_REGISTERS_LOCKED), A
1256+  F11A 3E 01                           LD      A, MODE_848 | MODE_MAP_16K
1257+  F11C 32 FF 7F                        LD      (VB_MODE), A
1258+  F11F AF                              XOR     A
1259+  F120 32 F9 7F                        LD      (VB_PAGE_0), A
1260+  F123 32 D0 7F                        LD      (VB_LAYER_5), A             ; Clear page 'above' our console
1261+  F126             
1262+  F126 21 70 F1                        LD      HL, _videobeast
1263+  F129 11 C0 7F                        LD      DE, VB_LAYER_4
1264+  F12C 01 0C 00                        LD      BC, _videobeast_length
1265+  F12F ED B0                           LDIR
1266+  F131 32 FE 7F                        LD      (VB_REGISTERS_LOCKED), A  ; Lock registers
1267+  F134             
1268+  F134 11 29 FF    _no_videobeast      LD      DE, screen_page     ; Copy the startup defaults to the shared_data area
1269+  F137 21 62 F1                        LD      HL, _screen_defaults
1270+  F13A 01 0E 00                        LD      BC, _defaults_length
1271+  F13D ED B0                           LDIR
1272+  F13F 3A 29 FF                        LD      A, (screen_page)    ; Clear the screen buffer
1273+  F142 D3 71                           OUT     (IO_MEM_1), A       ; Screen buffer is in PAGE_1
1274+  F144 21 00 40                        LD      HL, PAGE_1_START
1275+  F147 11 02 40                        LD      DE, PAGE_1_START+2
1276+  F14A 0E 20                           LD      C, ' '
1277+  F14C 3A 31 FF                        LD      A, (console_colour)
1278+  F14F 47                              LD      B, A
1279+  F150 ED 43 00 40                     LD      (PAGE_1_START), BC
1280+  F154 01 FA 3F                        LD      BC, 16378           ; Don't over write last couple of bytes (VideoBeast)
1281+  F157 ED B0                           LDIR
1282+  F159             
1283+  F159 CD 3E F8                        CALL    disp_clear          ; Clear the LED screen
1284+  F15C             
1285+  F15C 3A 3A FF    restore_page_return LD      A, (page_1_mapping)       ; Return Page 1 to normal RAM
1286+  F15F D3 71                           OUT     (IO_MEM_1), A
1287+  F161 C9                              RET
1288+  F162             
1289+  F162 24          _screen_defaults    .DB     CONSOLE_PAGE        ; Screen buffer page
1290+  F163 00                              .DB     0                   ; Row offset in buffer
1291+  F164 00 00                           .DB     0,0                 ; Row, column being shown on LED Display
1292+  F166 01 01                           .DB     1,1                 ; Row, column of cursor
1293+  F168 18 40       _screen_size        .DB     24,64               ; Console height (rows), width (columns)
1294+  F16A F0                              .DB     0F0h                ; Current colour [7:4] = background, [3:0] = foreground
1295+  F16B 02          default_screen_flags .DB     CFLAGS_TRACK_CURSOR ; Flags
1296+  F16C 00                              .DB     0                   ; Timer
1297+  F16D 00 00                           .DB     0, 0                ; Escape char and first parameter
1298+  F16F 00                              .DB     0                   ; Disable identifier sequence
1299+  F170             _defaults_length    .EQU    $-_screen_defaults
1300+  F170             
1301+  F170 01 01 1E 02 _videobeast         .DB     TYPE_TEXT, 1, 30, 2, 81         ; Text, top, bottom, left, right
1301+  F174 51 
1302+  F175 00 00 00                        .DB     0, 0, 0                         ; No scroll
1303+  F178 00 10                           .DB     0, 010h                         ; Char map in page 0, font 16x2K -> 32K
1304+  F17A 07 00                           .DB     7, 0                            ; Palette 0, no hi-res
1305+  F17C             _videobeast_length  .EQU    $-_videobeast
1306+  F17C             
1307+  F17C F3          interrupt_handler   DI
1308+  F17D ED 73 CD FF                     LD      (intr_stack), SP
1309+  F181 31 CD FF                        LD      SP, intr_stack
1310+  F184 F5                              PUSH    AF
1311+  F185 D9                              EXX
1312+  F186 CD F4 F2                        CALL    keyboard_poll
1313+  F189             
1314+  F189 3A 13 FF                        LD      A,(control_key_pressed)
1315+  F18C A7                              AND     A
1316+  F18D C4 DE F1                        CALL    NZ, handle_screen_shift
1317+  F190             
1318+  F190 3A 33 FF                        LD      A, (console_timer)
1319+  F193 3D                              DEC     A
1320+  F194 FA A7 F1                        JP      M, _not_moved
1321+  F197 32 33 FF                        LD      (console_timer), A
1322+  F19A 20 0B                           JR      NZ, _not_moved
1323+  F19C             
1324+  F19C 3A 32 FF                        LD      A, (console_flags)
1325+  F19F E6 FB                           AND     ~CFLAGS_SHOW_MOVED
1326+  F1A1 32 32 FF                        LD      (console_flags), A
1327+  F1A4 CD 15 EE                        CALL    unsafe_redraw
1328+  F1A7             
1329+  F1A7 2A 04 FF    _not_moved          LD      HL, (timer)
1330+  F1AA 5D                              LD      E, L                ; E is old low byte of timer - used to blink cursor
1331+  F1AB 23                              INC     HL
1332+  F1AC 22 04 FF                        LD      (timer), HL
1333+  F1AF 7C                              LD      A, H
1334+  F1B0 B5                              OR      L
1335+  F1B1 20 07                           JR      NZ, _timer_done
1336+  F1B3 2A 06 FF                        LD      HL, (timer+2)
1337+  F1B6 23                              INC     HL
1338+  F1B7 22 06 FF                        LD      (timer+2),HL   
1339+  F1BA             
1340+  F1BA 3A 32 FF    _timer_done         LD      A, (console_flags)
1341+  F1BD E6 01                           AND     CFLAGS_SHOW_CURSOR
1342+  F1BF 28 0B                           JR      Z, _int_done
1343+  F1C1             
1344+  F1C1 3A 04 FF                        LD      A, (timer)          ; Blink when timer bit changes
1345+  F1C4 AB                              XOR     E
1346+  F1C5 E6 20                           AND     020h
1347+  F1C7 28 03                           JR      Z, _int_done
1348+  F1C9 CD 79 F2                        CALL    update_cursor
1349+  F1CC             
1350+  F1CC 2A CF FF    _int_done           LD      HL, (user_interrupt)
1351+  F1CF 7C                              LD      A, H
1352+  F1D0 B5                              OR      L
1353+  F1D1 C4 DD F1                        CALL    NZ, _do_usr_interrupt
1354+  F1D4             
1355+  F1D4 D9                              EXX
1356+  F1D5 F1                              POP     AF
1357+  F1D6 ED 7B CD FF                     LD      SP, (intr_stack)
1358+  F1DA FB                              EI
1359+  F1DB ED 4D       _do_reti            RETI
1360+  F1DD             
1361+  F1DD E9          _do_usr_interrupt   JP      (HL)
1362+  F1DE             
1363+  F1DE             ; Enter with A containing a special control character
1364+  F1DE             ;
1365+  F1DE             ;
1366+  F1DE FE 90       handle_screen_shift CP      KEY_CTRL_UP
1367+  F1E0 20 25                           JR      NZ, _not_ctrl_up
1368+  F1E2             
1369+  F1E2 3A 2B FF                        LD      A, (display_row)
1370+  F1E5 3D                              DEC     A
1371+  F1E6 FA 74 F2                        JP      M, _shift_done
1372+  F1E9 F5          _shift_row          PUSH    AF
1373+  F1EA 1E 00                           LD      E, 0
1374+  F1EC CD 79 F2                        CALL    update_cursor
1375+  F1EF F1                              POP     AF
1376+  F1F0 32 2B FF                        LD      (display_row), A
1377+  F1F3             
1378+  F1F3 3A 32 FF    _shift_complete     LD      A, (console_flags)
1379+  F1F6 E6 FD                           AND     ~CFLAGS_TRACK_CURSOR
1380+  F1F8 F6 04       _flags_and_redraw   OR      CFLAGS_SHOW_MOVED
1381+  F1FA 32 32 FF                        LD      (console_flags), A
1382+  F1FD 3E 3C                           LD      A, SHOW_MOVE_DELAY
1383+  F1FF 32 33 FF                        LD      (console_timer),A
1384+  F202 CD 1B EE                        CALL    unsafe_led_redraw       ; Always redraw regardless of LED status
1385+  F205 18 6D                           JR      _shift_done
1386+  F207             
1387+  F207 FE 91       _not_ctrl_up        CP      KEY_CTRL_DOWN
1388+  F209 20 0D                           JR      NZ, _not_ctrl_down
1389+  F20B             
1390+  F20B 3A 2F FF    _shift_down         LD      A, (console_height)
1391+  F20E 4F                              LD      C, A
1392+  F20F 3A 2B FF                        LD      A, (display_row)
1393+  F212 3C                              INC     A
1394+  F213 B9                              CP      C
1395+  F214 28 5E                           JR      Z, _shift_done
1396+  F216 18 D1                           JR      _shift_row
1397+  F218             
1398+  F218 FE 93       _not_ctrl_down      CP      KEY_CTRL_RIGHT
1399+  F21A 20 0F                           JR      NZ, _not_ctrl_right
1400+  F21C             
1401+  F21C 3A 30 FF                        LD      A, (console_width)
1402+  F21F D6 17                           SUB     DISPLAY_WIDTH-1
1403+  F221 4F                              LD      C, A
1404+  F222 3A 2C FF                        LD      A, (display_col)
1405+  F225 3C                              INC     A
1406+  F226 B9                              CP      C
1407+  F227 28 4B                           JR      Z, _shift_done
1408+  F229 18 0B                           JR      _shift_col
1409+  F22B             
1410+  F22B FE 92       _not_ctrl_right     CP      KEY_CTRL_LEFT
1411+  F22D 20 13                           JR      NZ, _not_ctrl_left
1412+  F22F             
1413+  F22F 3A 2C FF                        LD      A, (display_col)
1414+  F232 3D                              DEC     A
1415+  F233 FA 74 F2                        JP      M, _shift_done
1416+  F236 F5          _shift_col          PUSH    AF
1417+  F237 1E 00                           LD      E, 0
1418+  F239 CD 79 F2                        CALL    update_cursor
1419+  F23C F1                              POP     AF
1420+  F23D 32 2C FF                        LD      (display_col), A
1421+  F240 18 B1                           JR      _shift_complete
1422+  F242             
1423+  F242 FE 94       _not_ctrl_left      CP      KEY_CTRL_ENTER
1424+  F244 20 19                           JR      NZ, _not_ctrl_enter
1425+  F246 3A 2D FF                        LD      A, (cursor_row)
1426+  F249 3D                              DEC     A
1427+  F24A 32 2B FF                        LD      (display_row), A
1428+  F24D 3A 2E FF                        LD      A, (cursor_col)
1429+  F250 D6 16                           SUB     DISPLAY_WIDTH-2
1430+  F252 30 01                           JR      NC, _col_ok
1431+  F254 AF                              XOR     A
1432+  F255             
1433+  F255 32 2C FF    _col_ok             LD      (display_col), A
1434+  F258 3A 32 FF                        LD      A, (console_flags)
1435+  F25B F6 02                           OR      CFLAGS_TRACK_CURSOR
1436+  F25D 18 99                           JR      _flags_and_redraw
1437+  F25F             
1438+  F25F FE 95       _not_ctrl_enter     CP      KEY_CTRL_SPACE
1439+  F261 20 06                           JR      NZ, _not_ctrl_space
1440+  F263             
1441+  F263 AF                              XOR     A
1442+  F264 32 2C FF                        LD      (display_col), A
1443+  F267 18 A2                           JR      _shift_down
1444+  F269             
1445+  F269 FE 96       _not_ctrl_space     CP      KEY_CTRL_D
1446+  F26B 20 07                           JR      NZ, _shift_done
1447+  F26D             
1448+  F26D 3A 32 FF                        LD      A, (console_flags)
1449+  F270 EE 20                           XOR     CFLAGS_LED_OFF
1450+  F272 18 84                           JR      _flags_and_redraw
1451+  F274             
1452+  F274 AF          _shift_done         XOR     A
1453+  F275 32 13 FF                        LD      (control_key_pressed),A
1454+  F278 C9                              RET
1455+  F279             
1456+  F279             ;
1457+  F279             ; Blinks the cursor 
1458+  F279             ;  Enter with E = timer low byte. 
1459+  F279             ;  If CURSOR_BIT is 1, show the cursor at the line, otherwise restore the existing character
1460+  F279             ;
1461+  F279 3A 2B FF    update_cursor       LD      A, (display_row)    ; Are we on the same row as the cursor?
1462+  F27C 47                              LD      B, A
1463+  F27D 3A 2D FF                        LD      A, (cursor_row)
1464+  F280 3D                              DEC     A
1465+  F281 B8                              CP      B
1466+  F282 C0                              RET     NZ
1467+  F283             
1468+  F283 3A 2C FF                        LD      A, (display_col)    ; Check the cursor column is within the display window
1469+  F286 47                              LD      B, A
1470+  F287 3A 2E FF                        LD      A, (cursor_col)
1471+  F28A 3D                              DEC     A
1472+  F28B 90                              SUB     B
1473+  F28C F8                              RET     M
1474+  F28D             
1475+  F28D 06 00                           LD      B, 0
1476+  F28F 4F                              LD      C, A
1477+  F290             
1478+  F290 3A 29 FF                        LD      A, (screen_page)
1479+  F293 FE 40                           CP      VIDEOBEAST_PAGE
1480+  F295 20 2E                           JR      NZ, _skip_videobeast
1481+  F297             
1482+  F297 D3 71                           OUT     (IO_MEM_1), A
1483+  F299             
1484+  F299 3A 2A FF                        LD      A, (screen_offset)
1485+  F29C 67                              LD      H, A
1486+  F29D 3A 2D FF                        LD      A, (cursor_row)         ; 1 based
1487+  F2A0 3D                              DEC     A
1488+  F2A1 84                              ADD     A, H
1489+  F2A2 E6 3F                           AND     03Fh
1490+  F2A4 F6 40                           OR      040h                    ; Page 1 for videobeast
1491+  F2A6 67                              LD      H, A
1492+  F2A7 3A 2E FF                        LD      A, (cursor_col)
1493+  F2AA 3D                              DEC     A
1494+  F2AB 87                              ADD     A, A
1495+  F2AC 6F                              LD      L, A
1496+  F2AD 2C                              INC     L
1497+  F2AE             
1498+  F2AE 7B                              LD      A, E
1499+  F2AF E6 20                           AND     20h
1500+  F2B1 3A 31 FF                        LD      A, (console_colour)
1501+  F2B4 28 08                           JR      Z, _normal
1502+  F2B6 CB 0F                           RRC     A 
1503+  F2B8 CB 0F                           RRC     A
1504+  F2BA CB 0F                           RRC     A
1505+  F2BC CB 0F                           RRC     A
1506+  F2BE 77          _normal             LD      (HL), A
1507+  F2BF             
1508+  F2BF 2B                              DEC     HL
1509+  F2C0 3A 3A FF                        LD      A, (page_1_mapping)
1510+  F2C3 D3 71                           OUT     (IO_MEM_1), A
1511+  F2C5             
1512+  F2C5 79          _skip_videobeast    LD      A, C
1513+  F2C6 FE 18                           CP      DISPLAY_WIDTH
1514+  F2C8 D0                              RET     NC
1515+  F2C9             
1516+  F2C9 3A 32 FF                        LD      A, (console_flags)
1517+  F2CC E6 20                           AND     CFLAGS_LED_OFF
1518+  F2CE C0                              RET     NZ
1519+  F2CF             
1520+  F2CF                                 ; At this point, BC holds the current display column for the cursor..
1521+  F2CF 21 85 FF                        LD      HL, display_buffer
1522+  F2D2 09                              ADD     HL, BC
1523+  F2D3 09                              ADD     HL, BC
1524+  F2D4             
1525+  F2D4 7B                              LD      A, E
1526+  F2D5 E6 20                           AND     20h
1527+  F2D7 7E                              LD      A, (HL)
1528+  F2D8 28 02                           JR      Z, _unblink
1529+  F2DA 3E 5F                           LD      A, '_'
1530+  F2DC C3 DB F7    _unblink            JP    disp_character
1531+  F2DF             
1532+  F2DF                                 .INCLUDE "../ports.asm"
0001++ F2DF             ;
0002++ F2DF             ; Port definintions
0003++ F2DF             ;
0004++ F2DF             ;
0005++ F2DF             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006++ F2DF             ;
0007++ F2DF             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008++ F2DF             ;
0009++ F2DF             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010++ F2DF             ; of this software and associated documentation files (the "Software"), to deal
0011++ F2DF             ; in the Software without restriction, including without limitation the rights
0012++ F2DF             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013++ F2DF             ; copies of the Software, and to permit persons to whom the Software is
0014++ F2DF             ; furnished to do so, subject to the following conditions:
0015++ F2DF             ; 
0016++ F2DF             ; The above copyright notice and this permission notice shall be included in all
0017++ F2DF             ; copies or substantial portions of the Software.
0018++ F2DF             ; 
0019++ F2DF             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020++ F2DF             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021++ F2DF             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022++ F2DF             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023++ F2DF             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024++ F2DF             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025++ F2DF             ; SOFTWARE.
0026++ F2DF             ;
0027++ F2DF             
0028++ F2DF             BACKSPACE_CHAR      .EQU  08h
0029++ F2DF             CARRIAGE_RETURN     .EQU  0Dh
0030++ F2DF             NEWLINE             .EQU  0Ah
0031++ F2DF             ESCAPE_CHAR         .EQU  1Bh
0032++ F2DF             CPM_NUM             .EQU  1Fh
0033++ F2DF             
0034++ F2DF             ;=================================== UART ============================================
0035++ F2DF             UART_TX_RX          .EQU    020h    ; Read: receiver buffer, Write: transmitter buffer
0036++ F2DF             UART_INT_ENABLE     .EQU    021h    ; Interrupt enable register
0037++ F2DF             UART_INT_ID         .EQU    022h    ; Read: Interrupt identification register
0038++ F2DF             UART_FIFO_CTRL      .EQU    022h    ; Write: FIFO Control register
0039++ F2DF             UART_LINE_CTRL      .EQU    023h    ; Line control register
0040++ F2DF             UART_MODEM_CTRL     .EQU    024h    ; Modem control
0041++ F2DF             UART_LINE_STATUS    .EQU    025h    ; Line status
0042++ F2DF             UART_MODEM_STATUS   .EQU    026h    ; Modem status
0043++ F2DF             UART_SCRATCH        .EQU    027h    ; Scratch register
0044++ F2DF             
0045++ F2DF             ;==================================== PIO ============================================
0046++ F2DF             PIO_A_DATA          .EQU  010h
0047++ F2DF             PIO_A_CTRL          .EQU  012h
0048++ F2DF             
0049++ F2DF             PIO_B_DATA          .EQU  011h
0050++ F2DF             PIO_B_CTRL          .EQU  013h
0051++ F2DF             
0052++ F2DF             PIO_MODE_0          .EQU  00Fh      ; Mode 0: All outputs
0053++ F2DF             PIO_MODE_1          .EQU  04fh      ; Mode 1: All inputs
0054++ F2DF             PIO_MODE_2          .EQU  080h      ; Mode 2 (Port A only): Bi-directional
0055++ F2DF             PIO_MODE_3          .EQU  0CFh      ; Mode 3: Per-pin I/O on the given port - write an additional word with bits set (1) for input, reset (0) for output on the matching pin.
0056++ F2DF             
0057++ F2DF             PIO_SET_INTERRUPT   .EQU  007h      ; Set interrupt control world. By itself, this wil disable interrupts on the given port. OR with the following constants to change this
0058++ F2DF             PIO_ENABLE_INT      .EQU  080h      ; Enable interrupts on the given port, when OR'd with the PIO_SET_INTERRUPT control word.
0059++ F2DF             PIO_INT_MASK        .EQU  010h      ; When OR'd with the PIO_SET_INTERRUPT control word, the following word will enable interrupts for pins where the matching bit is zero
0060++ F2DF             
0061++ F2DF             ;================================== AUDIO ============================================
0062++ F2DF             ; Constants for Audio output
0063++ F2DF             AUDIO_PIO           .EQU  1         ; Audio on PIO (rev. 0.1 boards)
0064++ F2DF             AUDIO_UART          .EQU  2         ; Audio on UART (rev. 0.2 boards)
0065++ F2DF             
0066++ F2DF             AUDIO_VERSION       .EQU  AUDIO_UART
0067++ F2DF             
0068++ F2DF~            #IF AUDIO_VERSION = AUDIO_PIO
0069++ F2DF~            PORT_B_IOMASK       .EQU  0EFh      ; All inputs, apart from bit 4 (audio out)
0070++ F2DF~            AUDIO_MASK          .EQU  010h      ; Bitmask for audio output on Port B. The bit is set for the output pin.
0071++ F2DF~            AUDIO_PORT          .EQU  PIO_B_DATA
0072++ F2DF~            
0073++ F2DF             #ELSE
0074++ F2DF             PORT_B_IOMASK       .EQU  0FFh      ; All inputs
0075++ F2DF             AUDIO_MASK          .EQU  008h      ; Bitmask for audio output on UART Out 2. The bit is set for the output pin
0076++ F2DF             AUDIO_PORT          .EQU  UART_MODEM_CTRL
0077++ F2DF             
0078++ F2DF             #ENDIF
0079++ F2DF             
0080++ F2DF             
0081++ F2DF             ;=================================== MEMORY PAGING ===================================
0082++ F2DF             IO_MEM_0            .EQU    070h      ; Page 0: 0000h - 3fffh
0083++ F2DF             IO_MEM_1            .EQU    071h      ; Page 1: 4000h - 7fffh
0084++ F2DF             IO_MEM_2            .EQU    072h      ; Page 2: 8000h - bfffh
0085++ F2DF             IO_MEM_3            .EQU    073h      ; Page 3: c000h - ffffh
0086++ F2DF             
0087++ F2DF             IO_MEM_CTRL         .EQU    074h      ; Paging enable register
0088++ F2DF             IO_MEM_ENABLE       .EQU    1
0089++ F2DF             IO_MEM_DISABLE      .EQU    0 
0090++ F2DF             
0091++ F2DF             RAM_PAGE_0          .EQU    020h
0092++ F2DF             RAM_PAGE_1          .EQU    021h
0093++ F2DF             RAM_PAGE_2          .EQU    022h
0094++ F2DF             RAM_PAGE_3          .EQU    023h
0095++ F2DF             
0096++ F2DF             RAM_PAGE_16         .EQU    030h
0097++ F2DF             RAM_PAGE_31         .EQU    03Fh
0098++ F2DF             
0099++ F2DF             ROM_PAGE_0          .EQU    000h
0100++ F2DF             ROM_PAGE_16         .EQU    010h
0101++ F2DF             
0102++ F2DF             PAGE_1_START        .EQU    4000h
0103++ F2DF             
0104++ F2DF             ;====================================== I2C DEVICES ===================================
0105++ F2DF             I2C_DATA_BIT            .equ    7
0106++ F2DF             I2C_CLK_BIT             .equ    6
0107++ F2DF             
0108++ F2DF             I2C_DATA_MASK           .equ    1 << I2C_DATA_BIT
0109++ F2DF             I2C_CLK_MASK            .equ    1 << I2C_CLK_BIT
0110++ F2DF             
0111++ F2DF             ; Display
0112++ F2DF             ;==========
0113++ F2DF             DL_ADDRESS              .EQU    050h     ; Left  Matrix controller I2C address
0114++ F2DF             DR_ADDRESS              .EQU    053h     ; Right Matrix controller I2C address
0115++ F2DF             
0116++ F2DF             DISP_REG_CRWL           .EQU    0FEh     ; Command Register write lock
0117++ F2DF             DISP_UNLOCK             .EQU    0C5h     ; Unlock command
0118++ F2DF             
0119++ F2DF             DISP_DEFAULT_BRIGHTNESS .EQU    080h     ; Default brightness
0120++ F2DF             DISP_DIMMED             .EQU    018h     ; Dimmed
0121++ F2DF             
0122++ F2DF             DISPLAY_WIDTH           .EQU    24       ; 24 characters
0123++ F2DF             
0124++ F2DF             ; RTC
0125++ F2DF             ;==========
0126++ F2DF             RTC_ADDRESS             .EQU    06fh
0127++ F2DF             
0128++ F2DF             RTC_REG_SEC             .EQU    000h    ; Also has oscillator enable bit in B7, 1 = run
0129++ F2DF             RTC_REG_MIN             .EQU    001h
0130++ F2DF             RTC_REG_HOUR            .EQU    002h    ; B6: 1 = 12hr/ 0 = 24hr clock (r/w) 
0131++ F2DF                                                     ;        If 12 hr clock, B5: 1 = PM/ 0 = AM. B4: hour tens. Otherwise B5-4: hour tens, B3-0: hour units
0132++ F2DF             RTC_REG_WKDAY           .EQU    003h    ; Oscillator status bit in B5, 1 = enabled and running. 
0133++ F2DF                                                     ;   B4: 1 = power was lost, write 0 to clear (timestamp registers are set)
0134++ F2DF                                                     ;   B3: 1 = enable external battery supply (VBAT)
0135++ F2DF                                                     ;   B2-0: Weekday, from 1 to 7 
0136++ F2DF             RTC_REG_DATE            .EQU    004h    ; BCD Date (1 to 31)
0137++ F2DF             RTC_REG_MTH             .EQU    005h    ; B5: 1 = Leap year (read only). B4: month tens, B3-0: month units  (Month is 1 to 12)
0138++ F2DF             RTC_REG_YEAR            .EQU    006h    ; BCD Year
0139++ F2DF             
0140++ F2DF             RTC_REG_CTRL            .EQU    007h    ; B7: If Square wave and Alarm 0 and Alarm 1 are disabled, sets Output Pin level
0141++ F2DF                                                     ;   B6: SQWEN, 1 = Enable square wave on Output Pin, Alarms disabled
0142++ F2DF                                                     ;   B5, B4: Alarm 1, 0 Enable. 1 = Alarm is enabled
0143++ F2DF                                                     ;   B3: 1 = Use external oscillator
0144++ F2DF                                                     ;   B2: CRSTRIM, 1 = Coarse trim mode, Output pin is 64Hz
0145++ F2DF                                                     ;   B1-0: If SQWEN = 1 & CRSTRIM = 0, sets Output pin freq. 00 -> 1Hz, 01 -> 4.096kHz, 10 -> 8.192kHz, 11 -> 32.768kHz
0146++ F2DF             RTC_REG_TRIM            .EQU    008h    ; Trim, initially 0. B7: Sign, 1=Add, 0=Subtract clock cycles.  
0147++ F2DF                                                     ;   B6-0: Trim amount/2. Applied 1 every minute in fine trim, 128 times a second in coarse trim mode. 0 = disable trim
0148++ F2DF             
0149++ F2DF             RTC_64HZ_ENABLED        .EQU    044h    ; Value for RTC_REG_CTRL to enable 64Hz interrupt output
0150++ F2DF             
0151++ F2DF             RTC_WEEKDAY_RUNNING     .EQU    008h    ; Value for RTC_REG_WKDAY for normal running of clock
0152++ F2DF             
0153++ F2DF             RTC_SRAM_OPT            .EQU    020h    ; Start address of the 4 byte boot options settings in SRAM
1533+  F2DF             
1534+  F2DF                                 .INCLUDE "../io.asm"
0001++ F2DF             ;
0002++ F2DF             ; I/O routines.. specifically keyboard and serial
0003++ F2DF             ;
0004++ F2DF             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ F2DF             ;
0006++ F2DF             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ F2DF             ;
0008++ F2DF             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ F2DF             ; of this software and associated documentation files (the "Software"), to deal
0010++ F2DF             ; in the Software without restriction, including without limitation the rights
0011++ F2DF             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ F2DF             ; copies of the Software, and to permit persons to whom the Software is
0013++ F2DF             ; furnished to do so, subject to the following conditions:
0014++ F2DF             ; 
0015++ F2DF             ; The above copyright notice and this permission notice shall be included in all
0016++ F2DF             ; copies or substantial portions of the Software.
0017++ F2DF             ; 
0018++ F2DF             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ F2DF             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ F2DF             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ F2DF             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ F2DF             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ F2DF             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ F2DF             ; SOFTWARE.
0025++ F2DF             ;
0026++ F2DF             
0027++ F2DF             
0028++ F2DF 21 08 FF    keyboard_init       LD      HL, keyboard_state
0029++ F2E2 06 20                           LD      B, io_data_end - keyboard_state
0030++ F2E4 AF                              XOR     A
0031++ F2E5 77          _init_loop          LD      (HL),A
0032++ F2E6 23                              INC     HL
0033++ F2E7 10 FC                           DJNZ    _init_loop
0034++ F2E9 AF                              XOR     A
0035++ F2EA 32 28 FF                        LD      (input_size),A
0036++ F2ED 32 27 FF                        LD      (input_free),A
0037++ F2F0 32 26 FF                        LD      (input_pos),A
0038++ F2F3 C9                              RET
0039++ F2F4             
0040++ F2F4             ; Poll the keyboard, adding raw codes to the keyboard_state buffer, and decoded characters to the input_buffer
0041++ F2F4             ;
0042++ F2F4 01 00 FD    keyboard_poll       LD      BC, 0FD00h          ; Check shift key
0043++ F2F7 3A 12 FF                        LD      A, (key_shift_state)
0044++ F2FA E6 FC                           AND     ~(KEY_SHIFT_BIT | KEY_CTRL_BIT)
0045++ F2FC 57                              LD      D, A
0046++ F2FD             
0047++ F2FD ED 78                           IN      A, (C)
0048++ F2FF E6 20                           AND     020h
0049++ F301 20 04                           JR      NZ, _check_ctrl_key
0050++ F303 3E 01                           LD      A, KEY_SHIFT_BIT
0051++ F305 B2                              OR      D
0052++ F306 57                              LD      D, A
0053++ F307             
0054++ F307 01 00 FE    _check_ctrl_key     LD      BC, 0FE00h          ; Keyboard row 0
0055++ F30A ED 78                           IN      A, (C)
0056++ F30C E6 10                           AND     010h
0057++ F30E 20 04                           JR      NZ, _store_modifiers
0058++ F310 3E 02                           LD      A, KEY_CTRL_BIT
0059++ F312 B2                              OR      D
0060++ F313 57                              LD      D, A
0061++ F314             
0062++ F314 7A          _store_modifiers    LD      A, D
0063++ F315 32 12 FF                        LD      (key_shift_state), A
0064++ F318             
0065++ F318             
0066++ F318 21 82 F4                        LD      HL, keyboard
0067++ F31B ED 78       _poll_loop          IN      A, (C)              ; BC -> Keyboard row port..
0068++ F31D 16 01                           LD      D, 1                ; D -> Current Bit
0069++ F31F 5F                              LD      E, A                ; E -> Key row bit set
0070++ F320 22 10 FF    _next_key           LD      (keyboard_pos), HL
0071++ F323 A2                              AND     D
0072++ F324 20 3F                           JR      NZ, _released
0073++ F326                                                             ; Key is pressed... add it to state buffer
0074++ F326 C5                              PUSH    BC
0075++ F327 7E                              LD      A, (HL)             ; Raw key code in A
0076++ F328             
0077++ F328 21 08 FF                        LD      HL, keyboard_state
0078++ F32B 06 08                           LD      B, _key_state_size
0079++ F32D BE          _check_pressed      CP      (HL)
0080++ F32E CA 7E F3                        JP      Z, _do_nothing      ; Key already in state table - nothing to do..
0081++ F331 23                              INC     HL
0082++ F332 05                              DEC     B
0083++ F333 20 F8                           JR      NZ, _check_pressed
0084++ F335                                                             ; Key wasn't pressed, so add it to the first free slot
0085++ F335 21 08 FF                        LD      HL, keyboard_state
0086++ F338 06 08                           LD      B, _key_state_size
0087++ F33A 4F                              LD      C, A
0088++ F33B AF                              XOR     A
0089++ F33C BE          _find_free          CP      (HL)
0090++ F33D 28 07                           JR      Z, _key_pressed
0091++ F33F 23                              INC     HL
0092++ F340 05                              DEC     B
0093++ F341 20 F9                           JR      NZ, _find_free
0094++ F343 C3 7E F3                        JP      _do_nothing         ; No free slots, so ignore the key
0095++ F346             
0096++ F346 71          _key_pressed        LD      (HL), C             ; Found free slot, store the raw key code
0097++ F347             
0098++ F347                                 ; Reset repeat counter       
0099++ F347             
0100++ F347 2A 10 FF                        LD      HL, (keyboard_pos)  ; Get the current keyboard character location
0101++ F34A 01 30 00                        LD      BC, _keyboard_size
0102++ F34D 3A 12 FF                        LD      A, (key_shift_state)
0103++ F350 A7                              AND     A
0104++ F351 28 04                           JR      Z, _got_keycode
0105++ F353 09          _modifier_offset    ADD     HL, BC
0106++ F354 3D                              DEC     A
0107++ F355 20 FC                           JR      NZ, _modifier_offset
0108++ F357             
0109++ F357 7E          _got_keycode        LD      A, (HL) 
0110++ F358 32 14 FF                        LD      (last_keycode), A
0111++ F35B CD AE F3                        CALL    _store_key
0112++ F35E AF                              XOR     A
0113++ F35F 32 15 FF                        LD      (key_repeat_time), A
0114++ F362             
0115++ F362 C1                              POP     BC
0116++ F363 18 1A                           JR      _poll_next
0117++ F365             
0118++ F365                                                             ; Key is not pressed... remove it from the state buffer if it was pressed (key up event)
0119++ F365                                                             ; TODO: This is rather inefficient...
0120++ F365 C5          _released           PUSH    BC
0121++ F366 7E                              LD      A, (HL)             ; Raw key code in A
0122++ F367 A7                              AND     A
0123++ F368 28 14                           JR      Z, _do_nothing      ; Ignore character zero
0124++ F36A             
0125++ F36A 21 08 FF                        LD      HL, keyboard_state
0126++ F36D 06 08                           LD      B, _key_state_size
0127++ F36F BE          _check_released     CP      (HL)
0128++ F370 28 06                           JR      Z, _handle_release
0129++ F372 23                              INC     HL
0130++ F373 05                              DEC     B
0131++ F374 20 F9                           JR      NZ, _check_released
0132++ F376 18 06                           JR      _do_nothing         ; Code not in state buffer, not released
0133++ F378             
0134++ F378 4F          _handle_release     LD      C, A
0135++ F379 AF                              XOR     A
0136++ F37A 77                              LD      (HL), A             ; Remove it from the buffer 
0137++ F37B 32 14 FF                        LD      (last_keycode), A
0138++ F37E                                                             ; TODO: We should probably tell someone about this...
0139++ F37E C1          _do_nothing         POP     BC
0140++ F37F             
0141++ F37F 2A 10 FF    _poll_next          LD      HL, (keyboard_pos)
0142++ F382 7B                              LD      A, E                ; Get the bitmask back
0143++ F383 23                              INC     HL
0144++ F384 CB 22                           SLA     D
0145++ F386 CB 72                           BIT     6, D
0146++ F388 CA 20 F3                        JP      Z, _next_key
0147++ F38B             
0148++ F38B CB 00                           RLC     B                   ; Move to the next key row
0149++ F38D 3E FE                           LD      A, 0FEh
0150++ F38F B8                              CP      B
0151++ F390 C2 1B F3                        JP      NZ, _poll_loop
0152++ F393             
0153++ F393 3A 14 FF                        LD      A, (last_keycode)
0154++ F396 A7                              AND     A
0155++ F397 C8                              RET     Z
0156++ F398 3A 15 FF                        LD      A, (key_repeat_time)
0157++ F39B 3C                              INC     A
0158++ F39C 32 15 FF                        LD      (key_repeat_time), A
0159++ F39F FE 28                           CP      KEY_REPEAT_DELAY
0160++ F3A1 28 08                           JR      Z, _do_repeat
0161++ F3A3 FE 2F                           CP      KEY_REPEAT_AFTER
0162++ F3A5 C0                              RET     NZ
0163++ F3A6 3E 28                           LD      A, KEY_REPEAT_DELAY
0164++ F3A8 32 15 FF                        LD      (key_repeat_time),A
0165++ F3AB 3A 14 FF    _do_repeat          LD      A, (last_keycode)
0166++ F3AE             
0167++ F3AE             
0168++ F3AE             ; Store the decoded keycode in A to the relevant buffer...
0169++ F3AE 4F          _store_key          LD      C, A
0170++ F3AF E6 F8                           AND     CTRL_KEY_MASK       ; Check for special control characters 
0171++ F3B1 FE 90                           CP      CTRL_KEY_CHECK
0172++ F3B3 20 05                           JR      NZ, _get_key
0173++ F3B5             
0174++ F3B5 79                              LD      A, C                ; Store them in a separate location
0175++ F3B6 32 13 FF                        LD      (control_key_pressed), A
0176++ F3B9 C9                              RET
0177++ F3BA                                                             ; Write the character to the input buffer
0178++ F3BA 79          _get_key            LD      A, C                ; Get the actual character...
0179++ F3BB A7                              AND     A                   ; Skip blank character codes
0180++ F3BC C8                              RET     Z
0181++ F3BD             
0182++ F3BD 6F                              LD      L, A                ; Store it in L
0183++ F3BE             
0184++ F3BE 3A 28 FF                        LD      A, (input_size)     ; Now check we have space
0185++ F3C1 FE 10                           CP      _input_buffer_size
0186++ F3C3 C8                              RET     Z
0187++ F3C4             
0188++ F3C4 3C                              INC     A
0189++ F3C5 32 28 FF                        LD      (input_size), A
0190++ F3C8             
0191++ F3C8 06 00                           LD      B, 0
0192++ F3CA 3A 27 FF                        LD      A, (input_free)
0193++ F3CD 4F                              LD      C, A
0194++ F3CE 7D                              LD      A, L                ; Get the character from L
0195++ F3CF 21 16 FF                        LD      HL, input_buffer
0196++ F3D2 09                              ADD     HL, BC
0197++ F3D3 77                              LD      (HL), A             ; Store the character
0198++ F3D4             
0199++ F3D4 0C                              INC     C                   ; Point to next byte in input
0200++ F3D5 3E 0F                           LD      A, 0Fh
0201++ F3D7 A1                              AND     C
0202++ F3D8 32 27 FF                        LD      (input_free), A
0203++ F3DB C9                              RET
0204++ F3DC             
0205++ F3DC             ;
0206++ F3DC             ; Reads the next available character in A, returning that or 0 if none are available
0207++ F3DC             ; Z flag is set if no character
0208++ F3DC             ; Uses HL, BC, A
0209++ F3DC 3A 28 FF    read_character      LD      A, (input_size)
0210++ F3DF A7                              AND     A
0211++ F3E0 C8                              RET     Z
0212++ F3E1             
0213++ F3E1 F3                              DI                          ; Make sure we don't get into a race condition..
0214++ F3E2 3A 28 FF                        LD      A, (input_size)
0215++ F3E5 3D                              DEC     A
0216++ F3E6 32 28 FF                        LD      (input_size),A
0217++ F3E9 3A 26 FF                        LD      A, (input_pos)
0218++ F3EC 4F                              LD      C, A
0219++ F3ED 3C                              INC     A
0220++ F3EE E6 0F                           AND     0Fh
0221++ F3F0 32 26 FF                        LD      (input_pos),A
0222++ F3F3 06 00                           LD      B, 0
0223++ F3F5 21 16 FF                        LD      HL, input_buffer
0224++ F3F8 09                              ADD     HL, BC
0225++ F3F9 7E                              LD      A, (HL)
0226++ F3FA B7                              OR      A
0227++ F3FB FB                              EI
0228++ F3FC C9                              RET
0229++ F3FD                                 
0230++ F3FD             ;;
0231++ F3FD             ; D = Octave 2-6
0232++ F3FD             ; E = Note 0-11
0233++ F3FD             ; C = 1-15 duration, ~tenths of a second
0234++ F3FD             ;
0235++ F3FD 3E 07       play_note           LD      A, 7
0236++ F3FF 92                              SUB     D
0237++ F400 16 00                           LD      D, 0
0238++ F402 21 44 F4                        LD      HL, _note_table
0239++ F405 19                              ADD     HL, DE
0240++ F406 19                              ADD     HL, DE
0241++ F407             
0242++ F407 5E                              LD      E, (HL)
0243++ F408 23                              INC     HL
0244++ F409 56                              LD      D, (HL)
0245++ F40A             
0246++ F40A A7          _note_octave        AND     A
0247++ F40B 28 07                           JR      Z, _note_shifted
0248++ F40D             
0249++ F40D CB 3A                           SRL     D
0250++ F40F CB 1B                           RR      E
0251++ F411 3D                              DEC     A
0252++ F412 18 F6                           JR      _note_octave
0253++ F414             
0254++ F414 41          _note_shifted       LD      B, C
0255++ F415 4F                              LD      C, A        ; A is zero from previous octave calc
0256++ F416 CB 20                           SLA     B    
0257++ F418 CB 20                           SLA     B    
0258++ F41A CB 20                           SLA     B    
0259++ F41C CB 20                           SLA     B           ; Now BC = 4096 * C
0260++ F41E             
0261++ F41E DB 24                           IN      A, (AUDIO_PORT)
0262++ F420 32 31 F4                        LD      (_tone_val+1), A
0263++ F423 F3                              DI
0264++ F424             
0265++ F424             _tone_loop          ; 186 T-states          
0266++ F424 19                              ADD     HL, DE              ; 11
0267++ F425 1F                              RRA                         ; 4   Carry into bit 7
0268++ F426 CB 2F                           SRA     A                   ; 8   Copy to bit 6
0269++ F428 CB 2F                           SRA     A                   ; 8   ..5
0270++ F42A CB 2F                           SRA     A                   ; 8   ..4
0271++ F42C CB 2F                           SRA     A                   ; 8   ..3
0272++ F42E             
0273++ F42E E6 08                           AND     AUDIO_MASK          ; 7
0274++ F430 EE 00       _tone_val           XOR     0                   ; 7
0275++ F432 32 31 F4                        LD      (_tone_val+1), A    ; 13
0276++ F435             
0277++ F435 D3 24                           OUT     (AUDIO_PORT),A      ; 12
0278++ F437             
0279++ F437 78                              LD      A, B                ; 4
0280++ F438 06 05                           LD      B, 5                ; 7
0281++ F43A 10 FE                           DJNZ    $                   ; 4 * 13 + 7 = 59
0282++ F43C 47                              LD      B, A                ; 4
0283++ F43D             
0284++ F43D 0B                              DEC     BC                  ; 6
0285++ F43E 78                              LD      A, B                ; 4
0286++ F43F B1                              OR      C                   ; 4
0287++ F440 20 E2                           JR      NZ, _tone_loop      ; 12
0288++ F442             
0289++ F442 FB                              EI
0290++ F443 C9                              RET
0291++ F444             
0292++ F444 EB 18       _note_table         .DW 6379
0293++ F446 65 1A                           .DW 6757
0294++ F448 F6 1B                           .DW 7158
0295++ F44A A1 1D                           .DW 7585
0296++ F44C 63 1F                           .DW 8035
0297++ F44E 40 21                           .DW 8512
0298++ F450 3F 23                           .DW 9023
0299++ F452 51 25                           .DW 9553
0300++ F454 8C 27                           .DW 10124
0301++ F456 EA 29                           .DW 10730
0302++ F458 60 2C                           .DW 11360
0303++ F45A 0D 2F                           .DW 12045
0304++ F45C 00 00                           .DW 0
0305++ F45E             
0306++ F45E             ;
0307++ F45E             ; Get the next key press
0308++ F45E             ;
0309++ F45E CD DC F3    get_key             CALL    read_character
0310++ F461 06 00                           LD      B, 0
0311++ F463 10 FE                           DJNZ    $
0312++ F465 28 F7                           JR      Z, get_key
0313++ F467 C9                              RET
0314++ F468             ;
0315++ F468             ; Wait for a key to be pressed and released
0316++ F468             ;
0317++ F468             ;
0318++ F468 CD DC F3    wait_for_key        CALL    read_character
0319++ F46B 06 00                           LD      B, 0
0320++ F46D 10 FE                           DJNZ    $
0321++ F46F 28 F7                           JR      Z, wait_for_key
0322++ F471             
0323++ F471             ;
0324++ F471             ; wait until there are no keys being pressed
0325++ F471             ;
0326++ F471             ;
0327++ F471 CD DC F3    wait_no_keys        CALL    read_character
0328++ F474 20 FB                           JR      NZ, wait_no_keys
0329++ F476 01 00 00                        LD      BC, 0h              ; Make sure key is released
0330++ F479 ED 78                           IN      A, (C)
0331++ F47B E6 3F                           AND     03Fh
0332++ F47D FE 3F                           CP      03Fh
0333++ F47F 20 F0                           JR      NZ, wait_no_keys
0334++ F481 C9                              RET
0335++ F482             
0336++ F482             ; Non-printing key codes
0337++ F482             ;
0338++ F482             KEY_ENTER       .EQU    13
0339++ F482             KEY_DELETE      .EQU    127
0340++ F482             KEY_CTRL_C      .EQU    03h
0341++ F482             KEY_CTRL_E      .EQU    05h
0342++ F482             
0343++ F482             KEY_CTRL_P      .EQU    10h
0344++ F482             KEY_CTRL_R      .EQU    12h
0345++ F482             KEY_CTRL_S      .EQU    13h
0346++ F482             KEY_CTRL_U      .EQU    15h
0347++ F482             KEY_CTRL_X      .EQU    18h
0348++ F482             KEY_CTRL_Z      .EQU    1Ah
0349++ F482             KEY_ESCAPE      .EQU    1Bh
0350++ F482             
0351++ F482             KEY_BACKSPACE   .EQU    08h
0352++ F482             
0353++ F482             ; Modifier and special keys have key codes with the top bit set..
0354++ F482             ;
0355++ F482             KEY_UP          .EQU    128
0356++ F482             KEY_DOWN        .EQU    129
0357++ F482             KEY_LEFT        .EQU    130
0358++ F482             KEY_RIGHT       .EQU    131
0359++ F482             KEY_SHIFT       .EQU    132
0360++ F482             KEY_CTRL        .EQU    134
0361++ F482             
0362++ F482             ; 144 = 90h
0363++ F482             ;
0364++ F482             CTRL_KEY_MASK   .EQU    0F8h
0365++ F482             CTRL_KEY_CHECK  .EQU    090h
0366++ F482             
0367++ F482             KEY_CTRL_UP     .EQU    144             ; These characters start on an exact multiple of 8 so they 
0368++ F482             KEY_CTRL_DOWN   .EQU    145             ; Can easily be detected
0369++ F482             KEY_CTRL_LEFT   .EQU    146
0370++ F482             KEY_CTRL_RIGHT  .EQU    147
0371++ F482             KEY_CTRL_ENTER  .EQU    148
0372++ F482             KEY_CTRL_SPACE  .EQU    149 
0373++ F482             KEY_CTRL_D      .EQU    150
0374++ F482             
0375++ F482             _keyboard_size  .EQU    48
0376++ F482             
0377++ F482             KEY_SHIFT_BIT   .EQU    1
0378++ F482             KEY_CTRL_BIT    .EQU    2
0379++ F482             
0380++ F482             KEY_REPEAT_DELAY .EQU   40
0381++ F482             KEY_REPEAT_AFTER .EQU   KEY_REPEAT_DELAY+7
0382++ F482             
0383++ F482 76 63 78 7A keyboard        .DB    "vcxz", 0, 0
0383++ F486 00 00 
0384++ F488 67 66 64 73                 .DB    "gfdsa", 0
0384++ F48C 61 00 
0385++ F48E 74 72 65 77                 .DB    "trewq", KEY_DOWN
0385++ F492 71 81 
0386++ F494 35 34 33 32                 .DB    "54321", KEY_UP  
0386++ F498 31 80 
0387++ F49A 36 37 38 39                 .DB    "67890", KEY_BACKSPACE
0387++ F49E 30 08 
0388++ F4A0 79 75 69 6F                 .DB    "yuiop:"
0388++ F4A4 70 3A 
0389++ F4A6 68 6A 6B 6C                 .DB    "hjkl.", KEY_ENTER
0389++ F4AA 2E 0D 
0390++ F4AC 62 6E 6D 20                 .DB    "bnm ", KEY_LEFT, KEY_RIGHT
0390++ F4B0 82 83 
0391++ F4B2             
0392++ F4B2 56 43 58 5A _shifted        .DB     "VCXZ", 0, 0
0392++ F4B6 00 00 
0393++ F4B8 47 46 44 53                 .DB     "GFDSA", 0
0393++ F4BC 41 00 
0394++ F4BE 54 52 45 57                 .DB     "TREWQ", 0              ; Shift + down?
0394++ F4C2 51 00 
0395++ F4C4 25 24 23 22                 .DB     "%$", 35, 34, "!", 0    ; Shift + up
0395++ F4C8 21 00 
0396++ F4CA 5E 26 2A 28                 .DB     "^&*()", KEY_DELETE     ; Shift + delete
0396++ F4CE 29 7F 
0397++ F4D0 59 55 49 4F                 .DB     "YUIOP;"
0397++ F4D4 50 3B 
0398++ F4D6 48 4A 4B 4C                 .DB     "HJKL,", 0              ; Shift + enter
0398++ F4DA 2C 00 
0399++ F4DC 42 4E 4D 00                 .DB     "BNM", 0,0,0            ; Shift left + right
0399++ F4E0 00 00 
0400++ F4E2             
0401++ F4E2 00 03 18 1A _ctrl           .DB    0,KEY_CTRL_C,KEY_CTRL_X,KEY_CTRL_Z,0,0
0401++ F4E6 00 00 
0402++ F4E8 00 00 96 13                 .DB    0,0,KEY_CTRL_D,KEY_CTRL_S,0,0
0402++ F4EC 00 00 
0403++ F4EE 00 12 05 00                 .DB    0,KEY_CTRL_R,KEY_CTRL_E,0,0,KEY_CTRL_DOWN
0403++ F4F2 00 91 
0404++ F4F4 00 00 00 27                 .DB    0,0,0,27h,7Ch,KEY_CTRL_UP ; Vertical bar, single quote
0404++ F4F8 7C 90 
0405++ F4FA 7B 7D 60 5B                 .DB    "{}`[]", KEY_ESCAPE
0405++ F4FE 5D 1B 
0406++ F500 00 15 2B 3D                 .DB    0,KEY_CTRL_U, "+=-", 0
0406++ F504 2D 00 
0407++ F506 00 3C 40 3E                 .DB    0, "<@>_", KEY_CTRL_ENTER
0407++ F50A 5F 94 
0408++ F50C 5C 3F 2F 95                 .DB    "\\?/", KEY_CTRL_SPACE,KEY_CTRL_LEFT,KEY_CTRL_RIGHT
0408++ F510 92 93 
0409++ F512             
0410++ F512 00 00 00 00 _shift_ctrl     .DB    0,0,0,0,0,0
0410++ F516 00 00 
0411++ F518 00 00 00 00                 .DB    0,0,0,0,0,0
0411++ F51C 00 00 
0412++ F51E 00 00 00 00                 .DB    0,0,0,0,0,0
0412++ F522 00 00 
0413++ F524 00 00 00 00                 .DB    0,0,0,0,0,0
0413++ F528 00 00 
0414++ F52A 00 00 00 00                 .DB    0,0,0,0,0,0
0414++ F52E 00 00 
0415++ F530 00 00 00 00                 .DB    0,0,0,0,KEY_CTRL_P,0
0415++ F534 10 00 
0416++ F536 00 00 00 00                 .DB    0,0,0,0,0,0
0416++ F53A 00 00 
0417++ F53C 00 00 00 00                 .DB    0,0,0,0,0,0
0417++ F540 00 00 
1535+  F542                                 .INCLUDE "../uart.asm"
0001++ F542             ;
0002++ F542             ; UART routines..
0003++ F542             ;
0004++ F542             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ F542             ;
0006++ F542             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ F542             ;
0008++ F542             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ F542             ; of this software and associated documentation files (the "Software"), to deal
0010++ F542             ; in the Software without restriction, including without limitation the rights
0011++ F542             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ F542             ; copies of the Software, and to permit persons to whom the Software is
0013++ F542             ; furnished to do so, subject to the following conditions:
0014++ F542             ; 
0015++ F542             ; The above copyright notice and this permission notice shall be included in all
0016++ F542             ; copies or substantial portions of the Software.
0017++ F542             ; 
0018++ F542             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ F542             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ F542             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ F542             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ F542             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ F542             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ F542             ; SOFTWARE.
0025++ F542             ;
0026++ F542                                 .MODULE     uart
0027++ F542             
0028++ F542             ;
0029++ F542             ; Baud rates, assuming 1.8432Mhz crystal
0030++ F542             ;
0031++ F542             UART_9600           .EQU    12
0032++ F542             UART_19200          .EQU    6
0033++ F542             UART_38400          .EQU    3
0034++ F542             
0035++ F542             UART_MODE_AUTO      .EQU    022h   ; Auto flow mode
0036++ F542             UART_MODE_NO_FLOW   .EQU    000h   ; Auto RTS and CTS disabled
0037++ F542             UART_MODE_DIAG      .EQU    030h   ; Loopback mode
0038++ F542             
0039++ F542             ;
0040++ F542             ; Various constants
0041++ F542             ;
0042++ F542             UART_8N1            .EQU    003h
0043++ F542             UART_TIMEOUT        .EQU    50000
0044++ F542             
0045++ F542             _CTS_STATUS_MASK    .EQU    010h
0046++ F542             
0047++ F542             ;
0048++ F542             ; Set up the UART. Assume it has had time to settle after reset...
0049++ F542             ;
0050++ F542             ;
0051++ F542 01 06 00    uart_init           LD      BC, UART_19200              ; B is flow control, 0 -> No auto flow control
0052++ F545             
0053++ F545 DB 26                           IN      A,(UART_MODEM_STATUS)       ; If CTS is enabled, assume we can use flow control
0054++ F547 E6 10                           AND     _CTS_STATUS_MASK
0055++ F549 28 02                           JR      Z, _no_listener
0056++ F54B             
0057++ F54B 06 22                           LD      B, UART_MODE_AUTO
0058++ F54D                                     
0059++ F54D 3E 80       _no_listener        LD      A, 80h                      ; Divisor Latch Setting Mode
0060++ F54F D3 23                           OUT     (UART_LINE_CTRL), A         ;  - entered by writing 1 to bit 7 of LCR
0061++ F551 00                              NOP
0062++ F552 00                              NOP
0063++ F553 79                              LD      A, C
0064++ F554 D3 20                           OUT     (UART_TX_RX), A
0065++ F556 00                              NOP
0066++ F557 00                              NOP
0067++ F558 AF                              XOR     A
0068++ F559 D3 21                           OUT     (UART_INT_ENABLE), A
0069++ F55B 00                              NOP
0070++ F55C 00                              NOP
0071++ F55D             
0072++ F55D 3E 03                           LD      A, UART_8N1                 ; Set 8N1 and exit divisor latch setting mode
0073++ F55F D3 23                           OUT     (UART_LINE_CTRL), A
0074++ F561             
0075++ F561 3E 07                           LD      A, 07h                      ; Enable and clear FIFO registers
0076++ F563 D3 22                           OUT     (UART_FIFO_CTRL), A
0077++ F565             
0078++ F565 78                              LD      A, B
0079++ F566 A7                              AND     A
0080++ F567 28 02                           JR      Z, _no_flowcontrol
0081++ F569             
0082++ F569 D3 24                           OUT     (UART_MODEM_CTRL), A
0083++ F56B             
0084++ F56B 00          _no_flowcontrol     NOP
0085++ F56C 00                              NOP
0086++ F56D C9                              RET
0087++ F56E             
0088++ F56E             ;
0089++ F56E             ; Send character in A to UART
0090++ F56E             ; Preserves all registers
0091++ F56E             ;
0092++ F56E             ; Carry flag is set on return if the UART send succeeded, clear if it timed out
0093++ F56E             ;
0094++ F56E C5          uart_send           PUSH    BC
0095++ F56F F5                              PUSH    AF
0096++ F570 01 50 C3                        LD      BC, UART_TIMEOUT
0097++ F573 DB 25       _check_ready        IN      A, (UART_LINE_STATUS)
0098++ F575 CB 6F                           BIT     5, A
0099++ F577 C2 85 F5                        JP      NZ, _uart_ready             ; Bit 5 is set when the UART is ready
0100++ F57A 0B                              DEC     BC
0101++ F57B 78                              LD      A, B
0102++ F57C B1                              OR      C
0103++ F57D C2 73 F5                        JP      NZ, _check_ready
0104++ F580             
0105++ F580 F1                              POP     AF
0106++ F581 C1                              POP     BC
0107++ F582 37                              SCF
0108++ F583 3F                              CCF
0109++ F584 C9                              RET
0110++ F585             
0111++ F585 F1          _uart_ready         POP     AF
0112++ F586 C1                              POP     BC
0113++ F587 D3 20                           OUT     (UART_TX_RX), A
0114++ F589 37                              SCF
0115++ F58A C9                              RET
0116++ F58B             
0117++ F58B             ;
0118++ F58B             ; Check to see if there are any characters to receive
0119++ F58B             ; Preserves all registers
0120++ F58B             ;
0121++ F58B             ; Returns with carry set if there are characters ready, clear if not
0122++ F58B             ;
0123++ F58B F5          uart_ready          PUSH    AF
0124++ F58C DB 25                           IN      A, (UART_LINE_STATUS)
0125++ F58E CB 47                           BIT     0, A
0126++ F590 CA 96 F5                        JP      Z, _not_ready
0127++ F593 F1                              POP     AF
0128++ F594 37                              SCF
0129++ F595 C9                              RET
0130++ F596             
0131++ F596 F1          _not_ready          POP     AF
0132++ F597 37                              SCF
0133++ F598 3F                              CCF
0134++ F599 C9                              RET
0135++ F59A             
0136++ F59A             ;
0137++ F59A             ; Receive a character from the UART in A
0138++ F59A             ; 
0139++ F59A             ; Returns with a character in A and the carry flag set. If no characters
0140++ F59A             ; are available, returns with the carry flag clear.
0141++ F59A             ;
0142++ F59A DB 25       uart_receive        IN      A, (UART_LINE_STATUS)
0143++ F59C CB 47                           BIT     0, A
0144++ F59E CA A5 F5                        JP      Z, _no_character
0145++ F5A1 DB 20                           IN      A, (UART_TX_RX)
0146++ F5A3 37                              SCF
0147++ F5A4 C9                              RET
0148++ F5A5             
0149++ F5A5 37          _no_character       SCF
0150++ F5A6 3F                              CCF
0151++ F5A7 C9                              RET
0152++ F5A8             
0153++ F5A8                                 .MODULE main1536+  F5A8                                 .INCLUDE "../i2c.asm"
0001++ F5A8             ; ============================================ I2C Routines =================================================
0002++ F5A8             ; Software driven I2C for Z80 PIO
0003++ F5A8             ;
0004++ F5A8             ; Assume I2C clock is on Port B bit 6
0005++ F5A8             ;            data is on Port B bit 7
0006++ F5A8             ;
0007++ F5A8             ;
0008++ F5A8             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0009++ F5A8             ;
0010++ F5A8             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0011++ F5A8             ;
0012++ F5A8             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0013++ F5A8             ; of this software and associated documentation files (the "Software"), to deal
0014++ F5A8             ; in the Software without restriction, including without limitation the rights
0015++ F5A8             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0016++ F5A8             ; copies of the Software, and to permit persons to whom the Software is
0017++ F5A8             ; furnished to do so, subject to the following conditions:
0018++ F5A8             ; 
0019++ F5A8             ; The above copyright notice and this permission notice shall be included in all
0020++ F5A8             ; copies or substantial portions of the Software.
0021++ F5A8             ; 
0022++ F5A8             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0023++ F5A8             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0024++ F5A8             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0025++ F5A8             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0026++ F5A8             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0027++ F5A8             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0028++ F5A8             ; SOFTWARE.
0029++ F5A8             ;
0030++ F5A8                                 .MODULE i2c
0031++ F5A8             
0032++ F5A8 3E CF       init_portb          LD      A, PIO_MODE_3           ; Port B mode 3
0033++ F5AA 32 00 FF                        LD      (port_b_mode), A
0034++ F5AD D3 13                           OUT     (PIO_B_CTRL), A
0035++ F5AF             
0036++ F5AF 3E FF                           LD      A, PORT_B_IOMASK        ;
0037++ F5B1 32 01 FF                        LD      (port_b_dir), A
0038++ F5B4 D3 13                           OUT     (PIO_B_CTRL), A
0039++ F5B6             
0040++ F5B6 3E 3F                           LD      A, 03Fh                 ; All bits high apart from D7, D6
0041++ F5B8 32 02 FF                        LD      (port_b_data),A
0042++ F5BB D3 11                           OUT     (PIO_B_DATA), A         ; Changing D7 or D6 to an output will drive the lines low
0043++ F5BD C9                              RET
0044++ F5BE             
0045++ F5BE             ; Reset the bus
0046++ F5BE             ;
0047++ F5BE             ; Uses A, B, D
0048++ F5BE 06 0A       i2c_bus_reset       LD      B, 0ah          ; ten cycles
0049++ F5C0 CD CE F6    _loop_b             CALL    i2c_scl_cycle
0050++ F5C3 10 FB                           DJNZ    _loop_b
0051++ F5C5 CD BE F6                        CALL    i2c_scl_high
0052++ F5C8 06 F0                           LD      B, 0F0h
0053++ F5CA 10 FE                           DJNZ    $
0054++ F5CC C9                              RET
0055++ F5CD             
0056++ F5CD             ;
0057++ F5CD             ; Uses A
0058++ F5CD CD 9E F6    i2c_start           CALL    i2c_sda_high
0059++ F5D0 CD BE F6                        CALL    i2c_scl_high
0060++ F5D3 CD AE F6                        CALL    i2c_sda_low     ; Drive data low
0061++ F5D6 C3 8E F6                        JP      i2c_scl_low     ; Drive clock low
0062++ F5D9             
0063++ F5D9             
0064++ F5D9             ;
0065++ F5D9             ; Read a byte from Device address H, Register L into A
0066++ F5D9             ; Calls i2c_start, sets address, reads byte and then calls i2c_stop
0067++ F5D9             ; Returns With Carry SET and A containing the register value, or Carry CLEAR if no acknowledge
0068++ F5D9             ; Uses A, B, C, D, H, L
0069++ F5D9             ; Preserves H, L
0070++ F5D9 CD F3 F5    i2c_read_byte       CALL    i2c_read_from
0071++ F5DC                                 ; Fall through into stop
0072++ F5DC                             
0073++ F5DC             ;
0074++ F5DC             ; Uses A
0075++ F5DC CD AE F6    i2c_stop            CALL    i2c_sda_low     ; Drive data low
0076++ F5DF CD BE F6                        CALL    i2c_scl_high
0077++ F5E2 C3 9E F6                        JP      i2c_sda_high
0078++ F5E5             
0079++ F5E5             ; Write a byte in C to Device address H, register L
0080++ F5E5             ; Returns with Carry SET if OK, CLEAR if no acknowledgement
0081++ F5E5             ; Calls i2c_stop when done..
0082++ F5E5             ;
0083++ F5E5             ; Preserves H, L
0084++ F5E5 C5          i2c_write_byte      PUSH    BC
0085++ F5E6 CD 14 F6                        CALL    i2c_write_to
0086++ F5E9 C1                              POP     BC
0087++ F5EA D2 DC F5                        JP      NC, i2c_stop
0088++ F5ED 79                              LD      A, C
0089++ F5EE CD 28 F6                        CALL    i2c_write
0090++ F5F1 18 E9                           JR      i2c_stop
0091++ F5F3                                 
0092++ F5F3             ;
0093++ F5F3             ; Read a byte from Device address H, Register L
0094++ F5F3             ; Calls i2c_start, but does NOT call i2c_stop
0095++ F5F3             ; Returns With Carry SET and A containing the register value, or Carry CLEAR if no acknowledge
0096++ F5F3             ; Uses A, B, C, D, H, L
0097++ F5F3             ; Preserves H, L
0098++ F5F3 CD CD F5    i2c_read_from       CALL    i2c_start
0099++ F5F6 7C                              LD      A, H
0100++ F5F7 CD 26 F6                        CALL    i2c_address_w
0101++ F5FA 30 17                           JR      NC, _read_end
0102++ F5FC 7D                              LD      A, L
0103++ F5FD CD 28 F6                        CALL    i2c_write
0104++ F600 30 11                           JR      NC, _read_end
0105++ F602 06 32                           LD      B, 50
0106++ F604 10 FE       _read_pause         DJNZ    _read_pause
0107++ F606 CD CD F5                        CALL    i2c_start
0108++ F609 7C                              LD      A, H
0109++ F60A CD 20 F6                        CALL    i2c_address_r
0110++ F60D 30 04                           JR      NC, _read_end
0111++ F60F CD 73 F6                        CALL    i2c_read
0112++ F612 37                              SCF
0113++ F613 C9          _read_end           RET
0114++ F614             
0115++ F614             
0116++ F614             ;
0117++ F614             ; Prepare to write to Device address H, Register L
0118++ F614             ; Calls i2c_start, but does NOT call i2c_stop
0119++ F614             ; Returns with Carry SET if OK, CLEAR if no acknowledgement
0120++ F614             ;
0121++ F614             ; Preserves H, L
0122++ F614 CD CD F5    i2c_write_to        CALL    i2c_start
0123++ F617 7C                              LD      A, H
0124++ F618 CD 26 F6                        CALL    i2c_address_w
0125++ F61B D0                              RET     NC
0126++ F61C 7D                              LD      A, L
0127++ F61D C3 28 F6                        JP      i2c_write
0128++ F620             
0129++ F620             ; Start reading from device address held in A
0130++ F620             ;
0131++ F620             ; Uses A, B, C, D
0132++ F620 CB 27       i2c_address_r       SLA     A
0133++ F622 F6 01                           OR      1
0134++ F624 18 02                           JR      i2c_write
0135++ F626             
0136++ F626             ; Start writing to device address held in A
0137++ F626             ;
0138++ F626             ; Uses A, B, C, D
0139++ F626 CB 27       i2c_address_w       SLA     A
0140++ F628             
0141++ F628             ; Write A as a byte to i2c bus
0142++ F628             ; Returns Carry CLEAR if no acknowledge
0143++ F628             ;
0144++ F628             ; Uses A, B, C, D
0145++ F628 E5          i2c_write           PUSH    HL
0146++ F629 2A 00 FF                        LD      HL, (port_b_mode)           ; L = port_b_mode, H = port_b_dir
0147++ F62C 57                              LD      D, A
0148++ F62D                                 
0149++ F62D 3E 3F                           LD      A, ~(I2C_DATA_MASK|I2C_CLK_MASK)           ; Set SDA and SCL (port_b_dir bit) LOW
0150++ F62F A4                              AND     H
0151++ F630 CB 27                           SLA     A
0152++ F632 67                              LD      H, A
0153++ F633             
0154++ F633 0E 13                           LD      C, PIO_B_CTRL
0155++ F635 06 08                           LD      B, 8
0156++ F637             
0157++ F637 7C          _fast_loop          LD      A, H
0158++ F638 CB 22                           SLA     D
0159++ F63A CB 1F                           RR      A
0160++ F63C ED 69                           OUT     (C),L
0161++ F63E D3 13                           OUT     (PIO_B_CTRL), A
0162++ F640             
0163++ F640 F6 40                           OR      I2C_CLK_MASK
0164++ F642 ED 69                           OUT     (C), L
0165++ F644 D3 13                           OUT     (PIO_B_CTRL), A                 ; Clock high
0166++ F646             
0167++ F646 EE 40                           XOR     I2C_CLK_MASK
0168++ F648 ED 69                           OUT     (C), L
0169++ F64A D3 13                           OUT     (PIO_B_CTRL),A                  ; Clock low
0170++ F64C 10 E9                           DJNZ    _fast_loop
0171++ F64E             
0172++ F64E 7C                              LD      A, H
0173++ F64F 37                              SCF
0174++ F650 CB 1F                           RR      A
0175++ F652 ED 69                           OUT     (C),L                           ; Release SDA
0176++ F654 D3 13                           OUT     (PIO_B_CTRL), A
0177++ F656             
0178++ F656 F6 40                           OR      I2C_CLK_MASK
0179++ F658 ED 69                           OUT     (C), L
0180++ F65A D3 13                           OUT     (PIO_B_CTRL), A                 ; Clock high
0181++ F65C             
0182++ F65C ED 69                           OUT     (C), L
0183++ F65E EE 40                           XOR     I2C_CLK_MASK
0184++ F660 6F                              LD      L, A
0185++ F661 32 01 FF                        LD      (port_b_dir), A
0186++ F664             
0187++ F664 DB 11                           IN      A, (PIO_B_DATA)                 ; Read ACK
0188++ F666 ED 69                           OUT     (C),L                           ; Clock low
0189++ F668             
0190++ F668 E1                              POP     HL
0191++ F669             
0192++ F669 CB 7A                           BIT     I2C_DATA_BIT, D     ; D contains acknowledge bit
0193++ F66B 37                              SCF
0194++ F66C C8                              RET     Z               ; Return with carry set if acknowledge bit is low
0195++ F66D             
0196++ F66D CD DC F5                        CALL    i2c_stop        ; Stop bus if error
0197++ F670 37                              SCF
0198++ F671 3F                              CCF
0199++ F672 C9                              RET                     ; Clear carry if acknowledge is high
0200++ F673             
0201++ F673             ; Read byte from i2C into A, without ACK
0202++ F673             ;
0203++ F673             ; Uses A, B, C, D
0204++ F673 06 08       i2c_read            LD      B, 8h
0205++ F675 DB 11       _loop_r             IN      A, (PIO_B_DATA)
0206++ F677 37                              SCF
0207++ F678 CB 7F                           BIT     I2C_DATA_BIT, A
0208++ F67A 20 01                           JR      NZ, _data_high
0209++ F67C 3F                              CCF
0210++ F67D CB 11       _data_high          RL      C
0211++ F67F CD CE F6                        CALL    i2c_scl_cycle
0212++ F682 10 F1                           DJNZ    _loop_r
0213++ F684                                 ; CALL    i2c_scl_cycle
0214++ F684             
0215++ F684 79                              LD      A, C
0216++ F685 C9                              RET
0217++ F686             
0218++ F686             ;
0219++ F686             ; Send an ACK..
0220++ F686             ;
0221++ F686 CD AE F6    i2c_ack             CALL    i2c_sda_low
0222++ F689 CD CE F6                        CALL    i2c_scl_cycle
0223++ F68C 18 10                           JR      i2c_sda_high
0224++ F68E             
0225++ F68E             ; SCL/SDA toggle routines
0226++ F68E             ;
0227++ F68E             ; All use A
0228++ F68E 3A 00 FF    i2c_scl_low         LD      A, (port_b_mode)
0229++ F691 D3 13                           OUT     (PIO_B_CTRL), A
0230++ F693             
0231++ F693 3A 01 FF                        LD      A, (port_b_dir)
0232++ F696 CB B7                           RES     I2C_CLK_BIT, A
0233++ F698 D3 13                           OUT     (PIO_B_CTRL), A
0234++ F69A 32 01 FF                        LD      (port_b_dir), A
0235++ F69D C9                              RET
0236++ F69E             
0237++ F69E 3A 00 FF    i2c_sda_high        LD      A, (port_b_mode)
0238++ F6A1 D3 13                           OUT     (PIO_B_CTRL), A
0239++ F6A3             
0240++ F6A3 3A 01 FF                        LD      A, (port_b_dir)
0241++ F6A6 CB FF                           SET     I2C_DATA_BIT, A
0242++ F6A8 D3 13                           OUT     (PIO_B_CTRL), A
0243++ F6AA 32 01 FF                        LD      (port_b_dir), A
0244++ F6AD C9                              RET
0245++ F6AE             
0246++ F6AE 3A 00 FF    i2c_sda_low         LD      A, (port_b_mode)
0247++ F6B1 D3 13                           OUT     (PIO_B_CTRL), A
0248++ F6B3             
0249++ F6B3 3A 01 FF                        LD      A, (port_b_dir)
0250++ F6B6 CB BF                           RES     I2C_DATA_BIT, A
0251++ F6B8 D3 13                           OUT     (PIO_B_CTRL), A
0252++ F6BA 32 01 FF                        LD      (port_b_dir), A
0253++ F6BD C9                              RET
0254++ F6BE             
0255++ F6BE 3A 00 FF    i2c_scl_high        LD      A, (port_b_mode)
0256++ F6C1 D3 13                           OUT     (PIO_B_CTRL), A
0257++ F6C3             
0258++ F6C3 3A 01 FF                        LD      A, (port_b_dir)
0259++ F6C6 CB F7                           SET     I2C_CLK_BIT, A
0260++ F6C8 D3 13                           OUT     (PIO_B_CTRL), A
0261++ F6CA 32 01 FF                        LD      (port_b_dir), A
0262++ F6CD C9                              RET
0263++ F6CE             
0264++ F6CE C5          i2c_scl_cycle       PUSH   BC
0265++ F6CF 01 13 00                        LD     BC, PIO_B_CTRL
0266++ F6D2 3A 00 FF                        LD     A, (port_b_mode)
0267++ F6D5 57                              LD     D, A
0268++ F6D6 3A 01 FF                        LD     A, (port_b_dir)
0269++ F6D9             
0270++ F6D9 CB B7                           RES    I2C_CLK_BIT, A
0271++ F6DB 32 01 FF                        LD     (port_b_dir), A
0272++ F6DE ED 51                           OUT    (C), D
0273++ F6E0 D3 13                           OUT    (PIO_B_CTRL), A
0274++ F6E2                                 
0275++ F6E2 CB F7                           SET    I2C_CLK_BIT, A
0276++ F6E4 ED 51                           OUT    (C), D
0277++ F6E6 D3 13                           OUT    (PIO_B_CTRL), A
0278++ F6E8                                 
0279++ F6E8 DB 11                           IN     A, (PIO_B_DATA)
0280++ F6EA ED 51                           OUT    (C), D
0281++ F6EC 57                              LD     D, A
0282++ F6ED 3A 01 FF                        LD     A, (port_b_dir)
0283++ F6F0 D3 13                           OUT    (PIO_B_CTRL), A
0284++ F6F2 C1                              POP    BC
0285++ F6F3 C9                              RET
0286++ F6F4             
0287++ F6F4                                 .MODULE main
1537+  F6F4             
1538+  F6F4                                 .INCLUDE "../disp.asm"
0001++ F6F4             ; ========================================== Display Routines ===============================================
0002++ F6F4             ;
0003++ F6F4             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0004++ F6F4             ;
0005++ F6F4             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0006++ F6F4             ;
0007++ F6F4             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0008++ F6F4             ; of this software and associated documentation files (the "Software"), to deal
0009++ F6F4             ; in the Software without restriction, including without limitation the rights
0010++ F6F4             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0011++ F6F4             ; copies of the Software, and to permit persons to whom the Software is
0012++ F6F4             ; furnished to do so, subject to the following conditions:
0013++ F6F4             ; 
0014++ F6F4             ; The above copyright notice and this permission notice shall be included in all
0015++ F6F4             ; copies or substantial portions of the Software.
0016++ F6F4             ; 
0017++ F6F4             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0018++ F6F4             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0019++ F6F4             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0020++ F6F4             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0021++ F6F4             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0022++ F6F4             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0023++ F6F4             ; SOFTWARE.
0024++ F6F4             ;
0025++ F6F4                                 .MODULE disp
0026++ F6F4             
0027++ F6F4             CONFIG_PAGE         .EQU    3
0028++ F6F4             BRIGHT_PAGE         .EQU    1
0029++ F6F4             LED_PAGE            .EQU    0 
0030++ F6F4             
0031++ F6F4 CD 3E F8    display_init        CALL    disp_clear
0032++ F6F7 1E 80                           LD      E, DISP_DEFAULT_BRIGHTNESS
0033++ F6F9 CD 34 F7                        CALL    disp_brightness
0034++ F6FC             
0035++ F6FC CD 08 F7                        CALL    disp_select_l
0036++ F6FF CD 14 F7                        CALL    disp_config
0037++ F702             
0038++ F702 CD 0E F7                        CALL    disp_select_r
0039++ F705 CD 14 F7                        CALL    disp_config
0040++ F708             
0041++ F708 3E 50       disp_select_l       LD      A, DL_ADDRESS
0042++ F70A 32 D1 FF                        LD      (display_address), A
0043++ F70D C9                              RET
0044++ F70E             
0045++ F70E 3E 53       disp_select_r       LD      A, DR_ADDRESS
0046++ F710 32 D1 FF                        LD      (display_address), A
0047++ F713 C9                              RET
0048++ F714             
0049++ F714 2E 03       disp_config         LD      L, CONFIG_PAGE
0050++ F716 CD 6F F7                        CALL    disp_page
0051++ F719 CD CD F5                        CALL    i2c_start
0052++ F71C 3A D1 FF                        LD      A, (display_address)
0053++ F71F CD 26 F6                        CALL    i2c_address_w
0054++ F722 3E 00                           LD      A, 000h
0055++ F724 CD 28 F6                        CALL    i2c_write
0056++ F727 3E 01                           LD      A, 001h         ; Turn display on
0057++ F729 CD 28 F6                        CALL    i2c_write
0058++ F72C 3E 78                           LD      A, 078h         ; 0.020mA
0059++ F72E CD 28 F6                        CALL    i2c_write
0060++ F731 C3 DC F5                        JP      i2c_stop
0061++ F734             
0062++ F734             ;
0063++ F734             ; Sets the brightness for the display
0064++ F734             ; Enter with E set to the desired brightness for all segments
0065++ F734             ;
0066++ F734 CD 08 F7    disp_brightness     CALL    disp_select_l
0067++ F737 CD 3D F7                        CALL    _set_bright
0068++ F73A CD 0E F7                        CALL    disp_select_r
0069++ F73D 2E 01       _set_bright         LD      L, BRIGHT_PAGE
0070++ F73F CD 6F F7                        CALL    disp_page
0071++ F742 2E 0C                           LD      L, 12
0072++ F744 CD CD F5    _bright_loop        CALL    i2c_start
0073++ F747 3A D1 FF                        LD      A, (display_address)
0074++ F74A CD 26 F6                        CALL    i2c_address_w
0075++ F74D 7D                              LD      A, L
0076++ F74E 3D                              DEC     A
0077++ F74F CB 27                           SLA     A
0078++ F751 CB 27                           SLA     A
0079++ F753 CB 27                           SLA     A
0080++ F755 CB 27                           SLA     A
0081++ F757 CD 28 F6                        CALL    i2c_write
0082++ F75A 26 10                           LD      H, 010h
0083++ F75C 7B          _bright_byte        LD      A, E
0084++ F75D CD 28 F6                        CALL    i2c_write
0085++ F760 25                              DEC     H
0086++ F761 20 F9                           JR      NZ, _bright_byte
0087++ F763 CD DC F5                        CALL    i2c_stop
0088++ F766 2D                              DEC     L
0089++ F767 20 DB                           JR      NZ, _bright_loop
0090++ F769 2E 00                           LD      L, LED_PAGE
0091++ F76B CD 6F F7                        CALL    disp_page
0092++ F76E C9                              RET
0093++ F76F             
0094++ F76F             ; Set the Page number
0095++ F76F             ; Call with page number in L
0096++ F76F             ;
0097++ F76F             ; Uses A, B, C, D
0098++ F76F CD 87 F7    disp_page           CALL    disp_unlock
0099++ F772 CD CD F5                        CALL    i2c_start
0100++ F775 3A D1 FF                        LD      A, (display_address)
0101++ F778 CD 26 F6                        CALL    i2c_address_w
0102++ F77B 3E FD                           LD      A, 0FDh
0103++ F77D CD 28 F6                        CALL    i2c_write
0104++ F780 7D                              LD      A, L
0105++ F781 CD 28 F6                        CALL    i2c_write
0106++ F784 C3 DC F5                        JP      i2c_stop
0107++ F787             
0108++ F787 CD CD F5    disp_unlock         CALL    i2c_start           ; Must be called before switching pages
0109++ F78A 3A D1 FF                        LD      A, (display_address)
0110++ F78D CD 26 F6                        CALL    i2c_address_w
0111++ F790 3E FE                           LD      A, DISP_REG_CRWL
0112++ F792 CD 28 F6                        CALL    i2c_write
0113++ F795 3E C5                           LD      A, DISP_UNLOCK
0114++ F797 CD 28 F6                        CALL    i2c_write
0115++ F79A C3 DC F5                        JP      i2c_stop
0116++ F79D             
0117++ F79D             ; Set the character at column A to brightness C
0118++ F79D             ;
0119++ F79D             ;
0120++ F79D C5          disp_char_bright    PUSH    BC
0121++ F79E 06 50                           LD      B, DL_ADDRESS
0122++ F7A0 FE 0C                           CP      12
0123++ F7A2 DA A9 F7                        JP      C, _bright_left
0124++ F7A5 06 53                           LD      B, DR_ADDRESS
0125++ F7A7 D6 0C                           SUB     12
0126++ F7A9 5F          _bright_left        LD      E, A
0127++ F7AA 78                              LD      A, B
0128++ F7AB 32 D1 FF                        LD      (display_address), A
0129++ F7AE 2E 01                           LD      L, BRIGHT_PAGE
0130++ F7B0 CD 6F F7                        CALL    disp_page
0131++ F7B3             
0132++ F7B3 CD CD F5                        CALL    i2c_start
0133++ F7B6 3A D1 FF                        LD      A, (display_address)
0134++ F7B9 CD 26 F6                        CALL    i2c_address_w
0135++ F7BC 7B                              LD      A, E
0136++ F7BD CB 27                           SLA     A
0137++ F7BF CB 27                           SLA     A
0138++ F7C1 CB 27                           SLA     A
0139++ F7C3 CB 27                           SLA     A
0140++ F7C5 CD 28 F6                        CALL    i2c_write
0141++ F7C8 E1                              POP     HL
0142++ F7C9 26 10                           LD      H, 010h
0143++ F7CB 7D          _bright_char_loop   LD      A, L
0144++ F7CC CD 28 F6                        CALL    i2c_write
0145++ F7CF 25                              DEC     H
0146++ F7D0 20 F9                           JR      NZ, _bright_char_loop
0147++ F7D2 CD DC F5                        CALL    i2c_stop
0148++ F7D5             
0149++ F7D5 2E 00                           LD      L, LED_PAGE
0150++ F7D7 CD 6F F7                        CALL    disp_page
0151++ F7DA C9                              RET
0152++ F7DB                                 
0153++ F7DB             ; Display a single character A at column C
0154++ F7DB             ;
0155++ F7DB             ; Returns with A pointing to next column
0156++ F7DB             ;
0157++ F7DB FE 20       disp_character      CP      32
0158++ F7DD F2 E7 F7                        JP      P, _not_control
0159++ F7E0             
0160++ F7E0 21 61 48    _invalid_char       LD      HL, INVALID_CHAR_BITMASK
0161++ F7E3 79                              LD      A, C
0162++ F7E4 C3 FC F7                        JP      disp_bitmask
0163++ F7E7             
0164++ F7E7 CB 7F       _not_control        BIT     7, A
0165++ F7E9 C2 E0 F7                        JP      NZ, _invalid_char
0166++ F7EC D6 20                           SUB     32
0167++ F7EE             
0168++ F7EE 16 00                           LD      D, 0
0169++ F7F0 5F                              LD      E, A
0170++ F7F1 CB 23                           SLA     E                   ; Don't need to shift into D, since bit 7 is zero
0171++ F7F3 21 4C F8                        LD      HL, font  
0172++ F7F6 19                              ADD     HL, DE
0173++ F7F7 56                              LD      D, (HL)
0174++ F7F8 23                              INC     HL
0175++ F7F9 66                              LD      H, (HL)
0176++ F7FA 6A                              LD      L, D
0177++ F7FB 79                              LD      A, C
0178++ F7FC                                 ; Fall into disp_bitmask
0179++ F7FC             
0180++ F7FC             ; Display a bitmask in HL at column A (0 - 23)
0181++ F7FC             ;
0182++ F7FC             ; Returns with A pointing to next column
0183++ F7FC             ;
0184++ F7FC             ; Uses A, B, C, D, E
0185++ F7FC F5          disp_bitmask        PUSH    AF
0186++ F7FD 06 50                           LD      B, DL_ADDRESS
0187++ F7FF FE 0C                           CP      12
0188++ F801 DA 08 F8                        JP      C, _disp_left
0189++ F804 06 53                           LD      B, DR_ADDRESS
0190++ F806 D6 0C                           SUB     12
0191++ F808 5F          _disp_left          LD      E, A
0192++ F809 CD CD F5                        CALL    i2c_start
0193++ F80C 78                              LD      A, B
0194++ F80D CD 26 F6                        CALL    i2c_address_w
0195++ F810 7B                              LD      A, E
0196++ F811 CB 27                           SLA     A
0197++ F813 CD 28 F6                        CALL    i2c_write
0198++ F816 7D                              LD      A, L
0199++ F817 CD 28 F6                        CALL    i2c_write
0200++ F81A 7C                              LD      A, H
0201++ F81B CD 28 F6                        CALL    i2c_write
0202++ F81E CD DC F5                        CALL    i2c_stop
0203++ F821 F1                              POP     AF
0204++ F822 3C                              INC     A
0205++ F823 C9                              RET
0206++ F824             
0207++ F824             ;
0208++ F824             ; Clear the display and show an inline string from column 0
0209++ F824             ;
0210++ F824 CD 3E F8    disp_clear_inline   CALL    disp_clear
0211++ F827 AF                              XOR     A
0212++ F828             ;
0213++ F828             ; Display an inline string to column A->
0214++ F828             ;
0215++ F828 E3          disp_inline         EX      (SP), HL
0216++ F829 CD 2F F8                        CALL    disp_string
0217++ F82C 23                              INC     HL
0218++ F82D E3                              EX      (SP), HL
0219++ F82E C9                              RET
0220++ F82F             
0221++ F82F             ; Display a string pointed to by HL to column A->
0222++ F82F             ; Note string should be zero terminated...
0223++ F82F             ; Returns with HL pointing to the 0 terminator
0224++ F82F             ;
0225++ F82F 4F          disp_string         LD      C, A
0226++ F830 7E                              LD      A, (HL)
0227++ F831 B7                              OR      A
0228++ F832 C2 36 F8                        JP      NZ, _char_ok
0229++ F835 C9                              RET
0230++ F836             
0231++ F836 E5          _char_ok            PUSH    HL
0232++ F837 CD DB F7                        CALL    disp_character
0233++ F83A E1                              POP     HL
0234++ F83B 23                              INC     HL
0235++ F83C 18 F1                           JR      disp_string
0236++ F83E             
0237++ F83E             ; Clear the display
0238++ F83E             ;
0239++ F83E 3E 00       disp_clear          LD      A, 0
0240++ F840 21 00 00                        LD      HL, 0
0241++ F843 CD FC F7    _clear_loop         CALL    disp_bitmask
0242++ F846 FE 18                           CP      24
0243++ F848 C2 43 F8                        JP      NZ, _clear_loop
0244++ F84B C9                              RET
0245++ F84C             
0246++ F84C                                 .MODULE main1539+  F84C                                 .INCLUDE "../font.asm"
0001++ F84C             ;
0002++ F84C             ; Font definition
0003++ F84C             ;
0004++ F84C             ;
0005++ F84C             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006++ F84C             ;
0007++ F84C             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008++ F84C             ;
0009++ F84C             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010++ F84C             ; of this software and associated documentation files (the "Software"), to deal
0011++ F84C             ; in the Software without restriction, including without limitation the rights
0012++ F84C             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013++ F84C             ; copies of the Software, and to permit persons to whom the Software is
0014++ F84C             ; furnished to do so, subject to the following conditions:
0015++ F84C             ; 
0016++ F84C             ; The above copyright notice and this permission notice shall be included in all
0017++ F84C             ; copies or substantial portions of the Software.
0018++ F84C             ; 
0019++ F84C             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020++ F84C             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021++ F84C             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022++ F84C             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023++ F84C             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024++ F84C             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025++ F84C             ; SOFTWARE.
0026++ F84C             ;
0027++ F84C             
0028++ F84C             INVALID_CHAR_BITMASK    .EQU 04861h
0029++ F84C             
0030++ F84C             font
0031++ F84C 00 00                           .dw     0000h
0032++ F84E 00 49                           .dw     4900h   ; !
0033++ F850 02 02                           .dw     0202h   ; "
0034++ F852 CE 12                           .dw     12ceh   ; #
0035++ F854 ED 12                           .dw     12edh   ; $
0036++ F856 E4 2D                           .dw     2de4h   ; %
0037++ F858 59 0B                           .dw     0b59h   ; &
0038++ F85A 00 02                           .dw     0200h   ; '
0039++ F85C 00 0C                           .dw     0c00h   ; (
0040++ F85E 00 21                           .dw     2100h   ; )
0041++ F860 C0 3F                           .dw     3fc0h   ; *
0042++ F862 C0 12                           .dw     12c0h   ; +
0043++ F864 00 20                           .dw     2000h   ; ,
0044++ F866 C0 00                           .dw     00c0h   ; -
0045++ F868 00 40                           .dw     4000h   ; .
0046++ F86A 00 24                           .dw     2400h   ; /
0047++ F86C             
0048++ F86C 3F 24                           .dw     243fh   ; 0
0049++ F86E 06 04                           .dw     0406h   ; 1
0050++ F870 DB 00                           .dw     00dbh   ; 2
0051++ F872 8F 00                           .dw     008fh   ; 3
0052++ F874 E6 00                           .dw     00e6h   ; 4
0053++ F876 69 08                           .dw     0869h   ; 5
0054++ F878 FD 00                           .dw     00fdh   ; 6
0055++ F87A 01 14                           .dw     1401h   ; 7
0056++ F87C FF 00                           .dw     00ffh   ; 8
0057++ F87E EF 00                           .dw     00efh   ; 9
0058++ F880 40 00                           .dw     0040h   ; :
0059++ F882 00 22                           .dw     2200h   ; ;
0060++ F884 40 0C                           .dw     0c40h   ; <
0061++ F886 C8 00                           .dw     00c8h   ; = 
0062++ F888 80 21                           .dw     2180h   ; >
0063++ F88A 83 50                           .dw     5083h   ; ?
0064++ F88C             
0065++ F88C BB 02                           .dw     02bbh   ; @
0066++ F88E F7 00                           .dw     00f7h   ; A
0067++ F890 8F 12                           .dw     128fh   ; B
0068++ F892 39 00                           .dw     0039h   ; C
0069++ F894 0F 12                           .dw     120fh   ; D
0070++ F896 79 00                           .dw     0079h   ; E
0071++ F898 71 00                           .dw     0071h   ; F
0072++ F89A BD 00                           .dw     00bdh   ; G
0073++ F89C F6 00                           .dw     00f6h   ; H
0074++ F89E 09 12                           .dw     1209h   ; I
0075++ F8A0 1E 00                           .dw     001eh   ; J
0076++ F8A2 70 0C                           .dw     0c70h   ; K
0077++ F8A4 38 00                           .dw     0038h   ; L
0078++ F8A6 36 05                           .dw     0536h   ; M
0079++ F8A8 36 09                           .dw     0936h   ; N
0080++ F8AA 3F 00                           .dw     003fh   ; O
0081++ F8AC             
0082++ F8AC F3 00                           .dw     00f3h   ; P
0083++ F8AE 3F 08                           .dw     083fh   ; Q
0084++ F8B0 F3 08                           .dw     08f3h   ; R
0085++ F8B2 ED 00                           .dw     00edh   ; S
0086++ F8B4 01 12                           .dw     1201h   ; T
0087++ F8B6 3E 00                           .dw     003eh   ; U
0088++ F8B8 30 24                           .dw     2430h   ; V
0089++ F8BA 36 28                           .dw     2836h   ; W
0090++ F8BC 00 2D                           .dw     2d00h   ; X
0091++ F8BE EE 00                           .dw     00eeh   ; Y
0092++ F8C0 09 24                           .dw     2409h   ; Z
0093++ F8C2 39 00                           .dw     0039h   ; [
0094++ F8C4 00 09                           .dw     0900h   ; \
0095++ F8C6 0F 00                           .dw     000fh   ; ]
0096++ F8C8 00 28                           .dw     2800h   ; ^
0097++ F8CA 08 00                           .dw     0008h   ; _
0098++ F8CC             
0099++ F8CC 00 01                           .dw     0100h   ; `
0100++ F8CE 8C 20                           .dw     208ch   ; a
0101++ F8D0 78 08                           .dw     0878h   ; b
0102++ F8D2 D8 00                           .dw     00d8h   ; c
0103++ F8D4 8E 20                           .dw     208eh   ; d 
0104++ F8D6 58 20                           .dw     2058h   ; e 
0105++ F8D8 C0 14                           .dw     14c0h   ; f
0106++ F8DA 8E 04                           .dw     048eh   ; g
0107++ F8DC 70 10                           .dw     1070h   ; h
0108++ F8DE 00 10                           .dw     1000h   ; i
0109++ F8E0 10 22                           .dw     2210h   ; j
0110++ F8E2 00 1E                           .dw     1e00h   ; k
0111++ F8E4 00 12                           .dw     1200h   ; l
0112++ F8E6 D4 10                           .dw     10d4h   ; m
0113++ F8E8 50 10                           .dw     1050h   ; n
0114++ F8EA DC 00                           .dw     00dch   ; o
0115++ F8EC             
0116++ F8EC 70 01                           .dw     0170h   ; p
0117++ F8EE 86 04                           .dw     0486h   ; q
0118++ F8F0 50 00                           .dw     0050h   ; r
0119++ F8F2 88 08                           .dw     0888h   ; s
0120++ F8F4 78 00                           .dw     0078h   ; t
0121++ F8F6 1C 00                           .dw     001ch   ; u
0122++ F8F8 10 20                           .dw     2010h   ; v
0123++ F8FA 14 28                           .dw     2814h   ; w
0124++ F8FC 00 2D                           .dw     2d00h   ; x
0125++ F8FE 8E 02                           .dw     028eh   ; y
0126++ F900 48 20                           .dw     2048h   ; z
0127++ F902 49 21                           .dw     2149h   ; {
0128++ F904 00 12                           .dw     1200h   ; |
0129++ F906 89 0C                           .dw     0c89h   ; }
0130++ F908 C0 24                           .dw     24c0h   ; ~
0131++ F90A 00 00                           .dw     0000h   ; 1540+  F90C                                 .INCLUDE "bios_rtc.asm"
0001++ F90C             ; RTC Routines
0002++ F90C             ;
0003++ F90C             ;
0004++ F90C             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ F90C             ;
0006++ F90C             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ F90C             ;
0008++ F90C             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ F90C             ; of this software and associated documentation files (the "Software"), to deal
0010++ F90C             ; in the Software without restriction, including without limitation the rights
0011++ F90C             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ F90C             ; copies of the Software, and to permit persons to whom the Software is
0013++ F90C             ; furnished to do so, subject to the following conditions:
0014++ F90C             ; 
0015++ F90C             ; The above copyright notice and this permission notice shall be included in all
0016++ F90C             ; copies or substantial portions of the Software.
0017++ F90C             ; 
0018++ F90C             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ F90C             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ F90C             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ F90C             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ F90C             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ F90C             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ F90C             ; SOFTWARE.
0025++ F90C             ;
0026++ F90C             ;
0027++ F90C                                     .MODULE rtc
0028++ F90C             
0029++ F90C             ; Set the initial time and start the clock
0030++ F90C             ;
0031++ F90C             ;
0032++ F90C CD 3E F0    rtc_init                CALL    m_print_inline
0033++ F90F 0A 0D 43 68                         .DB     "\n\rCheck RTC",0
0033++ F913 65 63 6B 20 
0033++ F917 52 54 43 00 
0034++ F91B             
0035++ F91B CD 90 F9                            CALL    _read_seconds
0036++ F91E CD 8B F9                            CALL    _pause
0037++ F921 CB 7B                               BIT     7, E                ; Check to see if the clock is running
0038++ F923 C0                                  RET     NZ                  ; Return if it is..
0039++ F924             
0040++ F924 CD 3E F0    _do_reset               CALL    m_print_inline
0041++ F927 0A 0D 52 65                         .DB     "\n\rReset RTC",0
0041++ F92B 73 65 74 20 
0041++ F92F 52 54 43 00 
0042++ F933             
0043++ F933 26 6F                               LD      H, RTC_ADDRESS      ; Clock isn't running, reset to default time
0044++ F935 2E 00                               LD      L, RTC_REG_SEC
0045++ F937 CD 14 F6                            CALL    i2c_write_to
0046++ F93A D2 9E F9                            JP      NC, rtc_ack_error
0047++ F93D             
0048++ F93D 21 DD F9                            LD      HL, time_scratch
0049++ F940 7E          _reset_loop             LD      A, (HL)
0050++ F941 23                                  INC     HL
0051++ F942 FE FF                               CP      0ffh
0052++ F944 CA 4F F9                            JP      Z, _start_clock
0053++ F947 CD 28 F6                            CALL    i2c_write
0054++ F94A D2 9E F9                            JP      NC, rtc_ack_error
0055++ F94D 18 F1                               JR      _reset_loop
0056++ F94F             
0057++ F94F CD DC F5    _start_clock            CALL    i2c_stop            ; Enable VBAT and start the clock
0058++ F952             
0059++ F952 26 6F                               LD      H, RTC_ADDRESS      ; Enable VBAT
0060++ F954 2E 03                               LD      L, RTC_REG_WKDAY
0061++ F956 CD F3 F5                            CALL    i2c_read_from
0062++ F959 D2 9E F9                            JP      NC, rtc_ack_error
0063++ F95C 5F                                  LD      E, A
0064++ F95D CD DC F5                            CALL    i2c_stop
0065++ F960 CB DB                               SET     3, E
0066++ F962 CD 8B F9                            CALL    _pause
0067++ F965             
0068++ F965 CD 14 F6                            CALL    i2c_write_to
0069++ F968 D2 9E F9                            JP      NC, rtc_ack_error
0070++ F96B 7B                                  LD      A, E
0071++ F96C CD 28 F6                            CALL    i2c_write
0072++ F96F D2 9E F9                            JP      NC, rtc_ack_error
0073++ F972 CD DC F5                            CALL    i2c_stop
0074++ F975             
0075++ F975 CD 90 F9                            CALL    _read_seconds
0076++ F978 CB FB                               SET     7, E                ; Set bit 7 to enable clock
0077++ F97A                                     
0078++ F97A CD 14 F6                            CALL    i2c_write_to
0079++ F97D D2 9E F9                            JP      NC, rtc_ack_error
0080++ F980 7B                                  LD      A, E
0081++ F981 CD 28 F6                            CALL    i2c_write
0082++ F984 D2 9E F9                            JP      NC, rtc_ack_error
0083++ F987 CD DC F5                            CALL    i2c_stop
0084++ F98A C9                                  RET
0085++ F98B             
0086++ F98B 06 00       _pause                  LD      B, 0
0087++ F98D 10 FE                               DJNZ    $
0088++ F98F C9                                  RET
0089++ F990             
0090++ F990             ;
0091++ F990             ; Read seconds register in E
0092++ F990             ;
0093++ F990 26 6F       _read_seconds           LD      H, RTC_ADDRESS      
0094++ F992 2E 00                               LD      L, RTC_REG_SEC      
0095++ F994 CD F3 F5                            CALL    i2c_read_from
0096++ F997 D2 9E F9                            JP      NC, rtc_ack_error
0097++ F99A 5F                                  LD      E, A
0098++ F99B C3 DC F5                            JP     i2c_stop
0099++ F99E             
0100++ F99E CD DC F5    rtc_ack_error           CALL    i2c_stop
0101++ F9A1                                     
0102++ F9A1 CD 3E F0                            CALL    m_print_inline
0103++ F9A4 0A 0D 52 54                         .DB     "\n\rRTC Panic",0
0103++ F9A8 43 20 50 61 
0103++ F9AC 6E 69 63 00 
0104++ F9B0 C9                                  RET
0105++ F9B1             
0106++ F9B1             ;
0107++ F9B1             ; Read the time to the 7 bytes starting at HL
0108++ F9B1             ; Returns with Carry SET if successful, else Carry CLEAR
0109++ F9B1             ;
0110++ F9B1 E5          rtc_get_time_hl         PUSH    HL
0111++ F9B2 26 6F                               LD      H, RTC_ADDRESS
0112++ F9B4 2E 00                               LD      L, RTC_REG_SEC
0113++ F9B6 CD F3 F5                            CALL    i2c_read_from
0114++ F9B9 C1                                  POP     BC
0115++ F9BA D0                                  RET     NC
0116++ F9BB 21 D5 F9                            LD      HL, _masktable
0117++ F9BE 18 08                               JR      _store_time
0118++ F9C0 C5          _get_loop               PUSH    BC 
0119++ F9C1 CD 86 F6                            CALL    i2c_ack
0120++ F9C4 CD 73 F6                            CALL    i2c_read
0121++ F9C7 C1                                  POP     BC
0122++ F9C8 A6          _store_time             AND     (HL)
0123++ F9C9 02                                  LD      (BC), A
0124++ F9CA 23                                  INC     HL
0125++ F9CB 03                                  INC     BC
0126++ F9CC 7E                                  LD      A, (HL)
0127++ F9CD A7                                  AND     A
0128++ F9CE 20 F0                               JR      NZ, _get_loop
0129++ F9D0 CD DC F5                            CALL    i2c_stop
0130++ F9D3 37                                  SCF
0131++ F9D4 C9                                  RET
0132++ F9D5             
0133++ F9D5 7F          _masktable              .db     07fh        ; Seconds
0134++ F9D6 7F                                  .db     07fh        ; Minutes
0135++ F9D7 3F                                  .db     03fh        ; Hours
0136++ F9D8 07                                  .db     007h        ; Weekday
0137++ F9D9 3F                                  .db     03Fh        ; Date
0138++ F9DA 1F                                  .db     01fh        ; Month
0139++ F9DB FF                                  .db     0ffh        ; Year
0140++ F9DC 00                                  .db     000h        ; End of mask marker
0141++ F9DD             
0142++ F9DD             
0143++ F9DD                                     ;  Initial time on power up..
0144++ F9DD 23          time_scratch            .db  23h            ; Seconds
0145++ F9DE 59                                  .db  59h            ; Minutes
0146++ F9DF 08                                  .db  08h            ; Hours    (24 hr clock)
0147++ F9E0 06                                  .db  06h            ; Weekday  (1-7. Monday=1)
0148++ F9E1 05                                  .db  05h            ; Date
0149++ F9E2 11                                  .db  11h            ; Month
0150++ F9E3 22                                  .db  22h            ; Year 
0151++ F9E4 FF                                  .db  0ffh           ; 0ffh end marker
0152++ F9E5             
0153++ F9E5                                     .MODULE main
1541+  F9E5                                 .INCLUDE "../flash.asm"
0001++ F9E5             ;
0002++ F9E5             ; Flash update routines
0003++ F9E5             ;
0004++ F9E5             ; Note that any memory write operations *at all* during flash updates will cancel the current operation.
0005++ F9E5             ; That means no data can be stored to memory, no stack operations (call, push), no interrupts.
0006++ F9E5             ; 
0007++ F9E5             ;
0008++ F9E5             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0009++ F9E5             ;
0010++ F9E5             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0011++ F9E5             ;
0012++ F9E5             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0013++ F9E5             ; of this software and associated documentation files (the "Software"), to deal
0014++ F9E5             ; in the Software without restriction, including without limitation the rights
0015++ F9E5             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0016++ F9E5             ; copies of the Software, and to permit persons to whom the Software is
0017++ F9E5             ; furnished to do so, subject to the following conditions:
0018++ F9E5             ; 
0019++ F9E5             ; The above copyright notice and this permission notice shall be included in all
0020++ F9E5             ; copies or substantial portions of the Software.
0021++ F9E5             ; 
0022++ F9E5             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0023++ F9E5             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0024++ F9E5             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0025++ F9E5             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0026++ F9E5             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0027++ F9E5             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0028++ F9E5             ; SOFTWARE.
0029++ F9E5             ;
0030++ F9E5                                 .MODULE     flash
0031++ F9E5             
0032++ F9E5             _cmd_1_addr         .EQU  05555h
0033++ F9E5             _cmd_2_addr         .EQU  02AAAh
0034++ F9E5             
0035++ F9E5             _bank_mask          .EQU  03FFFh                ; One memory bank is 14 bits -> 16Kb
0036++ F9E5             _sector_mask        .EQU  00FFFh                ; A sector is 12 bits -> 4Kb
0037++ F9E5             
0038++ F9E5             _cmd_1_addr_bank    .EQU  _cmd_1_addr >> 14
0039++ F9E5             _cmd_2_addr_bank    .EQU  _cmd_2_addr >> 14
0040++ F9E5             _cmd_3_addr_bank    .EQU  _cmd_1_addr_bank
0041++ F9E5             _cmd_4_addr_bank    .EQU  _cmd_1_addr_bank
0042++ F9E5             _cmd_5_addr_bank    .EQU  _cmd_2_addr_bank
0043++ F9E5             
0044++ F9E5             _cmd_1_logical_addr .EQU  _cmd_1_addr & _bank_mask
0045++ F9E5             _cmd_2_logical_addr .EQU  _cmd_2_addr & _bank_mask
0046++ F9E5             _cmd_3_logical_addr .EQU  _cmd_1_logical_addr
0047++ F9E5             _cmd_4_logical_addr .EQU  _cmd_1_logical_addr
0048++ F9E5             _cmd_5_logical_addr .EQU  _cmd_2_logical_addr
0049++ F9E5             
0050++ F9E5             _cmd_1_data         .EQU  0AAh
0051++ F9E5             _cmd_2_data         .EQU  055h
0052++ F9E5             _cmd_3_data_write   .EQU  0A0h
0053++ F9E5             _cmd_3_data_erase   .EQU  080h
0054++ F9E5             _cmd_4_data         .EQU  0AAh
0055++ F9E5             _cmd_5_data         .EQU  055h
0056++ F9E5             
0057++ F9E5             _cmd_6_data_erase   .EQU  030h
0058++ F9E5             
0059++ F9E5             ;
0060++ F9E5             ; Enter with A -> 7 bit index of 4K sector to be erased.
0061++ F9E5             ;
0062++ F9E5             ; Preserves BC, DE, HL
0063++ F9E5             ;
0064++ F9E5             ; Note this uses bank 0, and leaves it configured for the page containing the erased sector
0065++ F9E5             ;
0066++ F9E5             ; Typical time to erase sector ~18ms
0067++ F9E5             ;
0068++ F9E5 F3          flash_sector_erase  DI                          ; Disable interrupts
0069++ F9E6 E5                              PUSH    HL
0070++ F9E7 C5                              PUSH    BC
0071++ F9E8 D5                              PUSH    DE
0072++ F9E9             
0073++ F9E9 E6 7F                           AND     07fh
0074++ F9EB 57                              LD      D, A
0075++ F9EC CB 3A                           SRL     D
0076++ F9EE CB 3A                           SRL     D                   ; D is now the bank number
0077++ F9F0             
0078++ F9F0 CB 27                           SLA     A
0079++ F9F2 CB 27                           SLA     A
0080++ F9F4 CB 27                           SLA     A
0081++ F9F6 CB 27                           SLA     A
0082++ F9F8 E6 30                           AND     030h
0083++ F9FA 5F                              LD      E, A                ; E is the sector within the bank shifted into bits 13 & 12
0084++ F9FB             
0085++ F9FB 0E 70                           LD      C, IO_MEM_0         ; Use bank 0 to write to
0086++ F9FD 3E 01                           LD      A, _cmd_1_addr_bank
0087++ F9FF ED 79                           OUT     (C), A
0088++ FA01 21 55 15                        LD      HL, _cmd_1_logical_addr
0089++ FA04 36 AA                           LD      (HL), _cmd_1_data
0090++ FA06             
0091++ FA06 3E 00                           LD      A, _cmd_2_addr_bank
0092++ FA08 ED 79                           OUT     (C), A
0093++ FA0A 21 AA 2A                        LD      HL, _cmd_2_logical_addr
0094++ FA0D 36 55                           LD      (HL), _cmd_2_data
0095++ FA0F             
0096++ FA0F 3E 01                           LD      A, _cmd_3_addr_bank
0097++ FA11 ED 79                           OUT     (C), A
0098++ FA13 21 55 15                        LD      HL, _cmd_3_logical_addr
0099++ FA16 36 80                           LD      (HL), _cmd_3_data_erase
0100++ FA18             
0101++ FA18 3E 01                           LD      A, _cmd_4_addr_bank
0102++ FA1A ED 79                           OUT     (C), A
0103++ FA1C 21 55 15                        LD      HL, _cmd_4_logical_addr
0104++ FA1F 36 AA                           LD      (HL), _cmd_4_data
0105++ FA21             
0106++ FA21 3E 00                           LD      A, _cmd_5_addr_bank
0107++ FA23 ED 79                           OUT     (C), A
0108++ FA25 21 AA 2A                        LD      HL, _cmd_5_logical_addr
0109++ FA28 36 55                           LD      (HL), _cmd_5_data
0110++ FA2A             
0111++ FA2A ED 51                           OUT     (C), D                  ; Switch to the bank containing our sector
0112++ FA2C 63                              LD      H, E                    ; And write the sector bits as an address (bits 0-11 are ignored)
0113++ FA2D 36 30                           LD      (HL), _cmd_6_data_erase
0114++ FA2F             
0115++ FA2F 7E          _wait_erase         LD      A,(HL)
0116++ FA30 CB 07                           RLC     A
0117++ FA32 30 FB                           JR      NC, _wait_erase
0118++ FA34             
0119++ FA34 D1                              POP     DE
0120++ FA35 C1                              POP     BC
0121++ FA36 E1                              POP     HL
0122++ FA37 FB                              EI
0123++ FA38 C9                              RET
0124++ FA39             
0125++ FA39             ;
0126++ FA39             ; Enter with A -> Byte to write
0127++ FA39             ;            D -> 7 bit index of 4K sector being written
0128++ FA39             ;            HL -> 12 bit address of byte within sector
0129++ FA39             ;
0130++ FA39             ; Preserves D, HL
0131++ FA39             ; Uses A, BC, E
0132++ FA39             ;
0133++ FA39             ; Typical time to erase byte ~14us
0134++ FA39             ;
0135++ FA39 F3          flash_write_byte    DI
0136++ FA3A 5F                              LD      E, A                ; Preserve our byte
0137++ FA3B                                 
0138++ FA3B 7C                              LD      A, H                ; Make sure HL is within our sector
0139++ FA3C E6 0F                           AND     _sector_mask >> 8
0140++ FA3E 67                              LD      H, A
0141++ FA3F             
0142++ FA3F 7A                              LD      A, D                ; Make sure D is a valid sector index
0143++ FA40 E6 7F                           AND     07fh
0144++ FA42 57                              LD      D, A
0145++ FA43 47                              LD      B, A
0146++ FA44             
0147++ FA44 7A                              LD      A, D                ; Get the bottom 2 bits of our sector index..
0148++ FA45 E6 03                           AND     03h
0149++ FA47 CB 27                           SLA     A
0150++ FA49 CB 27                           SLA     A
0151++ FA4B CB 27                           SLA     A
0152++ FA4D CB 27                           SLA     A
0153++ FA4F B4                              OR      H
0154++ FA50 67                              LD      H, A                ; ..and OR them into H to get a 14 bit address within our bank
0155++ FA51             
0156++ FA51 CB 3A                           SRL     D
0157++ FA53 CB 3A                           SRL     D                   ; D is now our bank number
0158++ FA55             
0159++ FA55 E5                              PUSH    HL
0160++ FA56             
0161++ FA56 0E 70                           LD      C, IO_MEM_0         ; Use bank 0 to write to
0162++ FA58 3E 01                           LD      A, _cmd_1_addr_bank
0163++ FA5A ED 79                           OUT     (C), A
0164++ FA5C 21 55 15                        LD      HL, _cmd_1_logical_addr
0165++ FA5F 36 AA                           LD      (HL), _cmd_1_data
0166++ FA61             
0167++ FA61 3E 00                           LD      A, _cmd_2_addr_bank
0168++ FA63 ED 79                           OUT     (C), A
0169++ FA65 21 AA 2A                        LD      HL, _cmd_2_logical_addr
0170++ FA68 36 55                           LD      (HL), _cmd_2_data
0171++ FA6A             
0172++ FA6A 3E 01                           LD      A, _cmd_3_addr_bank
0173++ FA6C ED 79                           OUT     (C), A
0174++ FA6E 21 55 15                        LD      HL, _cmd_3_logical_addr
0175++ FA71 36 A0                           LD      (HL), _cmd_3_data_write
0176++ FA73             
0177++ FA73 ED 51                           OUT     (C), D
0178++ FA75 E1                              POP     HL
0179++ FA76 73                              LD      (HL), E
0180++ FA77             
0181++ FA77 7E          _wait_byte          LD      A, (HL)
0182++ FA78 AB                              XOR     E
0183++ FA79 CB 07                           RLC     A
0184++ FA7B 30 FA                           JR      NC, _wait_byte
0185++ FA7D             
0186++ FA7D 7C                              LD      A, H                ; Clear bits 13 & 12 to restore HL to sector address..
0187++ FA7E E6 0F                           AND     _sector_mask >> 8
0188++ FA80 67                              LD      H, A
0189++ FA81                            
0190++ FA81 50                              LD      D, B                ; And restore D
0191++ FA82 FB                              EI
0192++ FA83 C9                              RET
0193++ FA84             
0194++ FA84             ;
0195++ FA84             ; Write a flash data block. This uses Page 0 to write the data, so the source must be above 3FFFh
0196++ FA84             ;
0197++ FA84             ;       D -> 7 bit index of 4K sector being written
0198++ FA84             ;       HL -> Address of source data
0199++ FA84             ;       BC -> bytes to write
0200++ FA84             ;
0201++ FA84             ; Returns D pointing to last sector written
0202++ FA84             ; Note: This means if BC is an exact multiple of sector size, D is returned as the previous sector
0203++ FA84             
0204++ FA84 DD E5       flash_write         PUSH    IX
0205++ FA86 E5                              PUSH    HL
0206++ FA87 DD E1                           POP     IX
0207++ FA89 21 00 00                        LD      HL, 0           ; Address in sector..
0208++ FA8C             
0209++ FA8C             _erase_sector       ; Lower 12 bits of HL are zero, erase sector before writing bytes
0210++ FA8C 7A                              LD      A, D
0211++ FA8D CD E5 F9                        CALL    flash_sector_erase
0212++ FA90 DD 7E 00    _write_loop         LD      A, (IX+0)
0213++ FA93 C5                              PUSH    BC
0214++ FA94 CD 39 FA                        CALL    flash_write_byte
0215++ FA97 C1                              POP     BC
0216++ FA98             
0217++ FA98 DD 23                           INC     IX
0218++ FA9A 0B                              DEC     BC
0219++ FA9B 78                              LD      A, B
0220++ FA9C B1                              OR      C
0221++ FA9D 28 0E                           JR      Z, _success
0222++ FA9F             
0223++ FA9F 23                              INC     HL
0224++ FAA0 7D                              LD      A, L
0225++ FAA1 A7                              AND     A
0226++ FAA2 20 EC                           JR      NZ, _write_loop
0227++ FAA4 7C                              LD      A, H
0228++ FAA5 E6 0F                           AND     _sector_mask >> 8
0229++ FAA7 67                              LD      H, A
0230++ FAA8 20 E6                           JR      NZ, _write_loop
0231++ FAAA             
0232++ FAAA 14                              INC     D
0233++ FAAB 18 DF                           JR      _erase_sector
0234++ FAAD             
0235++ FAAD DD E1       _success            POP     IX
0236++ FAAF C9                              RET
0237++ FAB0             
0238++ FAB0                                 .MODULE main
1542+  FAB0                                 .INCLUDE "videobeast.asm"
0001++ FAB0             ;
0002++ FAB0             ; VideoBeast includes for CP/M BIOS
0003++ FAB0             ;
0004++ FAB0             ;
0005++ FAB0             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006++ FAB0             ;
0007++ FAB0             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008++ FAB0             ;
0009++ FAB0             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010++ FAB0             ; of this software and associated documentation files (the "Software"), to deal
0011++ FAB0             ; in the Software without restriction, including without limitation the rights
0012++ FAB0             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013++ FAB0             ; copies of the Software, and to permit persons to whom the Software is
0014++ FAB0             ; furnished to do so, subject to the following conditions:
0015++ FAB0             ; 
0016++ FAB0             ; The above copyright notice and this permission notice shall be included in all
0017++ FAB0             ; copies or substantial portions of the Software.
0018++ FAB0             ; 
0019++ FAB0             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020++ FAB0             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021++ FAB0             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022++ FAB0             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023++ FAB0             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024++ FAB0             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025++ FAB0             ; SOFTWARE.
0026++ FAB0             ;
0027++ FAB0             
0028++ FAB0             VBASE               .EQU   04000h
0029++ FAB0             
0030++ FAB0             VB_MODE             .EQU   VBASE + 03FFFh
0031++ FAB0             VB_REGISTERS_LOCKED .EQU   VBASE + 03FFEh
0032++ FAB0             
0033++ FAB0             VB_PAGE_0           .EQU   VBASE + 03FF9h
0034++ FAB0             VB_PAGE_1           .EQU   VBASE + 03FF8h
0035++ FAB0             VB_PAGE_2           .EQU   VBASE + 03FF7h
0036++ FAB0             VB_PAGE_3           .EQU   VBASE + 03FF6h
0037++ FAB0             
0038++ FAB0             VB_LOWER_REGS       .EQU   VBASE + 03FF5h
0039++ FAB0             
0040++ FAB0             
0041++ FAB0             VB_LAYER_0          .EQU   VBASE + 03F80h
0042++ FAB0             VB_LAYER_1          .EQU   VBASE + 03F90h
0043++ FAB0             VB_LAYER_2          .EQU   VBASE + 03FA0h
0044++ FAB0             VB_LAYER_3          .EQU   VBASE + 03FB0h
0045++ FAB0             VB_LAYER_4          .EQU   VBASE + 03FC0h
0046++ FAB0             VB_LAYER_5          .EQU   VBASE + 03FD0h
0047++ FAB0             
0048++ FAB0             MODE_640            .EQU   0
0049++ FAB0             MODE_848            .EQU   1
0050++ FAB0             MODE_DOUBLE         .EQU   8
0051++ FAB0             MODE_TESTCARD       .EQU   010h
0052++ FAB0             
0053++ FAB0             MODE_MAP_16K        .EQU   0
0054++ FAB0             MODE_MAP_SINCLAIR   .EQU   080h
0055++ FAB0             
0056++ FAB0             LAYER_TYPE          .EQU   0
0057++ FAB0             LAYER_TOP           .EQU   1
0058++ FAB0             LAYER_BOTTOM        .EQU   2
0059++ FAB0             LAYER_LEFT          .EQU   3
0060++ FAB0             LAYER_RIGHT         .EQU   4
0061++ FAB0             LAYER_SCROLL_X      .EQU   5
0062++ FAB0             LAYER_SCROLL_XY     .EQU   6
0063++ FAB0             LAYER_SCROLL_Y      .EQU   7
0064++ FAB0             
0065++ FAB0             TYPE_NONE           .EQU   0
0066++ FAB0             TYPE_TEXT           .EQU   1
0067++ FAB0             TYPE_SPRITE         .EQU   2
0068++ FAB0             TYPE_TILE           .EQU   3
0069++ FAB0             TYPE_BITMAP_8       .EQU   4
0070++ FAB0             
0071++ FAB0             TEXT_MAP_BASE       .EQU   8       ; 16Kb character map
0072++ FAB0             TEXT_FONT_BASE      .EQU   9       ;  2Kb font offset
0073++ FAB0             TEXT_PALETTE        .EQU   10      ; Bits 0-3: Palette number   Bit 4: Use Sinclair bit pattern
0074++ FAB0             TEXT_BITMAP         .EQU   11      ; 16Kb 1bpp bitmap..
0075++ FAB0             
0076++ FAB0             VB_UNLOCK           .EQU   0F3h           ; Unlock register write
0077++ FAB0             
0078++ FAB0             VIDEOBEAST_PAGE     .EQU   40h 1543+  FAB0             ;
1544+  FAB0             ;
1545+  FAB0             ; Page mapping - since the BIOS uses other pages to manage disk and screen, it must also manage the expected page for the user 
1546+  FAB0             ; programs, to prevent them from being unexpectedly changed (eg. after interrupts).
1547+  FAB0             ;
1548+  FAB0             
1549+  FAB0             ;
1550+  FAB0             ;
1551+  FAB0             ; Page mapping - since the BIOS uses other pages to manage disk and screen, it must also manage the expected page for the user 
1552+  FAB0             ; programs, to prevent them from being unexpectedly changed (eg. after interrupts).
1553+  FAB0             ;
1554+  FAB0             ; Get the User page mapping. Sets A to the physical (RAM/ROM) page selelcted for logical page C (0-2)
1555+  FAB0             ; Returns 0FFh for invalid page values
1556+  FAB0 79          get_page_mapping    LD      A, C
1557+  FAB1 CD C5 FA                        CALL    _mapping_address
1558+  FAB4 3E FF                           LD      A, 0FFH
1559+  FAB6 D0                              RET     NC
1560+  FAB7 7E                              LD      A, (HL)
1561+  FAB8 C9                              RET
1562+  FAB9             
1563+  FAB9             ; Set the User page mapping. Sets page A (0-2) to the physical (RAM/ROM) page in E
1564+  FAB9             ; Returns with carry SET if successful. The given logical page will now point to the physical page in RAM or ROM
1565+  FAB9             ;
1566+  FAB9 CD C5 FA    set_page_mapping    CALL    _mapping_address
1567+  FABC D0                              RET     NC
1568+  FABD 73                              LD      (HL), E 
1569+  FABE             
1570+  FABE C6 70                           ADD     A, IO_MEM_0             ; NOTE: Order is important here. Interrupts may occur after the page is stored (above)
1571+  FAC0 4F                              LD      C, A                    ; This may result in the page being prematurely mapped, but that's OK.
1572+  FAC1 ED 59                           OUT     (C), E                  ; If we tried to set the page before storing the new default we'd have to disable interrupts
1573+  FAC3 37                              SCF                             ; To avoid a race condition
1574+  FAC4 C9                              RET
1575+  FAC5             
1576+  FAC5 FE 04       _mapping_address    CP      4
1577+  FAC7 D0                              RET     NC
1578+  FAC8 4F                              LD      C, A
1579+  FAC9 06 00                           LD      B, 0
1580+  FACB 21 39 FF                        LD      HL, page_0_mapping
1581+  FACE 09                              ADD     HL, BC
1582+  FACF 37                              SCF
1583+  FAD0 C9                              RET
1584+  FAD1             
1585+  FAD1             ; Get the page in memory being used as the base for the drive selected by A
1586+  FAD1             ; Returns A = Page in ROM/RAM for the given drive
1587+  FAD1             ;    or   A = 0 if the selected drive is not supported.
1588+  FAD1             ;
1589+  FAD1 FE 02       get_disk_page       CP      MAX_DRIVES
1590+  FAD3 30 09                           JR      NC, _disk_page_err
1591+  FAD5 4F                              LD      C, A
1592+  FAD6 06 00                           LD      B, 0
1593+  FAD8 21 37 FF                        LD      HL, drive_a_mem_page
1594+  FADB 09                              ADD     HL, BC
1595+  FADC 7E                              LD      A, (HL)
1596+  FADD C9                              RET
1597+  FADE AF          _disk_page_err      XOR     A
1598+  FADF C9                              RET
1599+  FAE0             
1600+  FAE0 3E 17       get_version         LD      A, 017h
1601+  FAE2 C9                              RET
1602+  FAE3             
1603+  FAE3             ;
1604+  FAE3             ; Erase and write flash data. Data is written to 4K sectors, which are erased before writing.
1605+  FAE3             ; This uses Page 0 to write the data, so the source must be above 3FFFh
1606+  FAE3             ;
1607+  FAE3             ;       D -> 7 bit index of 4K sector being written
1608+  FAE3             ;       HL -> Address of source data
1609+  FAE3             ;       BC -> bytes to write
1610+  FAE3             ;
1611+  FAE3             ; Returns D pointing to last sector written
1612+  FAE3             ; Note: This means if BC is an exact multiple of sector size, D is returned as the previous sector
1613+  FAE3             
1614+  FAE3 CD 84 FA    bios_flash_write    CALL    flash_write 
1615+  FAE6 3A 39 FF                        LD      A, (page_0_mapping)
1616+  FAE9 D3 70                           OUT     (IO_MEM_0), A
1617+  FAEB C9                              RET 
1618+  FAEC             
1619+  FAEC             ;
1620+  FAEC             ; Set or query the user interrupt. The specified routine will be called after keyboard polling, every 60th of a 
1621+  FAEC             ; second. The shadow register set is selected before the call (EXX), and AF is preserved. The routine should 
1622+  FAEC             ; RETurn normally. Interrupt routines survive warm reboots, but no special measures are taken to ensure the
1623+  FAEC             ; memory they occupy is preserved.
1624+  FAEC             ;
1625+  FAEC             ;   Parameters: 
1626+  FAEC             ;       HL = Address of user interrupt routine, or zero to disable. Call with 0FFFFh to query the current value
1627+  FAEC             ;   Returns:
1628+  FAEC             ;       The address of the current user interrupt routine, or zero if none is configured.
1629+  FAEC             ;
1630+  FAEC             ;
1631+  FAEC 7C          set_usr_interrupt   LD      A, H
1632+  FAED A5                              AND     L
1633+  FAEE 3C                              INC     A
1634+  FAEF 28 03                           JR      Z, _return_usr_int
1635+  FAF1 22 CF FF                        LD      (user_interrupt), HL
1636+  FAF4 2A CF FF    _return_usr_int     LD      HL, (user_interrupt)
1637+  FAF7 C9                              RET
1638+  FAF8             
1639+  FAF8             JUMP_TABLE_SIZE     .EQU    19
1640+  FAF8             
1641+  FAF8~            .IF $ > (BIOS_TOP - (3*JUMP_TABLE_SIZE))
1642+  FAF8~                .ECHO "BIOS No room for Jump Table ("
1643+  FAF8~                .ECHO $
1644+  FAF8~                .ECHO " > "
1645+  FAF8~                .ECHO (BIOS_TOP-(3*JUMP_TABLE_SIZE))
1646+  FAF8~                .ECHO ") \n\n"
1647+  FAF8~                .STOP
1648+  FAF8             .ENDIF
1649+  FAF8             
1650+  FAF8             BIOS_SPARE          .EQU    BIOS_TOP - $ - (3*JUMP_TABLE_SIZE)
1651+  FAF8 00 00 00 00                     .FILL   BIOS_SPARE, 0
1651+  FAFC 00 00 00 00 
1651+  FB00 00 00 00 00 
1651+  FB04 00 00 00 00 
1651+  FB08 00 00 00 00 
1651+  FB0C 00 00 00 00 
1651+  FB10 00 00 00 00 
1651+  FB14 00 00 00 00 
1651+  FB18 00 00 00 00 
1651+  FB1C 00 00 00 00 
1651+  FB20 00 00 00 00 
1651+  FB24 00 00 00 00 
1651+  FB28 00 00 00 00 
1651+  FB2C 00 00 00 00 
1651+  FB30 00 00 00 00 
1651+  FB34 00 00 00 00 
1651+  FB38 00 00 00 00 
1651+  FB3C 00 00 00 00 
1651+  FB40 00 00 00 00 
1651+  FB44 00 00 00 00 
1651+  FB48 00 00 00 00 
1651+  FB4C 00 00 00 00 
1651+  FB50 00 00 00 00 
1651+  FB54 00 00 00 00 
1651+  FB58 00 00 00 00 
1651+  FB5C 00 00 00 00 
1651+  FB60 00 00 00 00 
1651+  FB64 00 00 00 00 
1651+  FB68 00 00 00 00 
1651+  FB6C 00 00 00 00 
1651+  FB70 00 00 00 00 
1651+  FB74 00 00 00 00 
1651+  FB78 00 00 00 00 
1651+  FB7C 00 00 00 00 
1651+  FB80 00 00 00 00 
1651+  FB84 00 00 00 00 
1651+  FB88 00 00 00 00 
1651+  FB8C 00 00 00 00 
1651+  FB90 00 00 00 00 
1651+  FB94 00 00 00 00 
1651+  FB98 00 00 00 00 
1651+  FB9C 00 00 00 00 
1651+  FBA0 00 00 00 00 
1651+  FBA4 00 00 00 00 
1651+  FBA8 00 00 00 00 
1651+  FBAC 00 00 00 00 
1651+  FBB0 00 00 00 00 
1651+  FBB4 00 00 00 00 
1651+  FBB8 00 00 00 00 
1651+  FBBC 00 00 00 00 
1651+  FBC0 00 00 00 00 
1651+  FBC4 00 00 00 00 
1651+  FBC8 00 00 00 00 
1651+  FBCC 00 00 00 00 
1651+  FBD0 00 00 00 00 
1651+  FBD4 00 00 00 00 
1651+  FBD8 00 00 00 00 
1651+  FBDC 00 00 00 00 
1651+  FBE0 00 00 00 00 
1651+  FBE4 00 00 00 00 
1651+  FBE8 00 00 00 00 
1651+  FBEC 00 00 00 00 
1651+  FBF0 00 00 00 00 
1651+  FBF4 00 00 00 00 
1651+  FBF8 00 00 00 00 
1651+  FBFC 00 00 00 00 
1651+  FC00 00 00 00 00 
1651+  FC04 00 00 00 00 
1651+  FC08 00 00 00 00 
1651+  FC0C 00 00 00 00 
1651+  FC10 00 00 00 00 
1651+  FC14 00 00 00 00 
1651+  FC18 00 00 00 00 
1651+  FC1C 00 00 00 00 
1651+  FC20 00 00 00 00 
1651+  FC24 00 00 00 00 
1651+  FC28 00 00 00 00 
1651+  FC2C 00 00 00 00 
1651+  FC30 00 00 00 00 
1651+  FC34 00 00 00 00 
1651+  FC38 00 00 00 00 
1651+  FC3C 00 00 00 00 
1651+  FC40 00 00 00 00 
1651+  FC44 00 00 00 00 
1651+  FC48 00 00 00 00 
1651+  FC4C 00 00 00 00 
1651+  FC50 00 00 00 00 
1651+  FC54 00 00 00 00 
1651+  FC58 00 00 00 00 
1651+  FC5C 00 00 00 00 
1651+  FC60 00 00 00 00 
1651+  FC64 00 00 00 00 
1651+  FC68 00 00 00 00 
1651+  FC6C 00 00 00 00 
1651+  FC70 00 00 00 00 
1651+  FC74 00 00 00 00 
1651+  FC78 00 00 00 00 
1651+  FC7C 00 00 00 00 
1651+  FC80 00 00 00 00 
1651+  FC84 00 00 00 00 
1651+  FC88 00 00 00 00 
1651+  FC8C 00 00 00 00 
1651+  FC90 00 00 00 00 
1651+  FC94 00 00 00 00 
1651+  FC98 00 00 00 00 
1651+  FC9C 00 00 00 00 
1651+  FCA0 00 00 00 00 
1651+  FCA4 00 00 00 00 
1651+  FCA8 00 00 00 00 
1651+  FCAC 00 00 00 00 
1651+  FCB0 00 00 00 00 
1651+  FCB4 00 00 00 00 
1651+  FCB8 00 00 00 00 
1651+  FCBC 00 00 00 00 
1651+  FCC0 00 00 00 00 
1651+  FCC4 00 00 00 00 
1651+  FCC8 00 00 00 00 
1651+  FCCC 00 00 00 00 
1651+  FCD0 00 00 00 00 
1651+  FCD4 00 00 00 00 
1651+  FCD8 00 00 00 00 
1651+  FCDC 00 00 00 00 
1651+  FCE0 00 00 00 00 
1651+  FCE4 00 00 00 00 
1651+  FCE8 00 00 00 00 
1651+  FCEC 00 00 00 00 
1651+  FCF0 00 00 00 00 
1651+  FCF4 00 00 00 00 
1651+  FCF8 00 00 00 00 
1651+  FCFC 00 00 00 00 
1651+  FD00 00 00 00 00 
1651+  FD04 00 00 00 00 
1651+  FD08 00 00 00 00 
1651+  FD0C 00 00 00 00 
1651+  FD10 00 00 00 00 
1651+  FD14 00 00 00 00 
1651+  FD18 00 00 00 00 
1651+  FD1C 00 00 00 00 
1651+  FD20 00 00 00 00 
1651+  FD24 00 00 00 00 
1651+  FD28 00 00 00 00 
1651+  FD2C 00 00 00 00 
1651+  FD30 00 00 00 00 
1651+  FD34 00 00 00 00 
1651+  FD38 00 00 00 00 
1651+  FD3C 00 00 00 00 
1651+  FD40 00 00 00 00 
1651+  FD44 00 00 00 00 
1651+  FD48 00 00 00 00 
1651+  FD4C 00 00 00 00 
1651+  FD50 00 00 00 00 
1651+  FD54 00 00 00 00 
1651+  FD58 00 00 00 00 
1651+  FD5C 00 00 00 00 
1651+  FD60 00 00 00 00 
1651+  FD64 00 00 00 00 
1651+  FD68 00 00 00 00 
1651+  FD6C 00 00 00 00 
1651+  FD70 00 00 00 00 
1651+  FD74 00 00 00 00 
1651+  FD78 00 00 00 00 
1651+  FD7C 00 00 00 00 
1651+  FD80 00 00 00 00 
1651+  FD84 00 00 00 00 
1651+  FD88 00 00 00 00 
1651+  FD8C 00 00 00 00 
1651+  FD90 00 00 00 00 
1651+  FD94 00 00 00 00 
1651+  FD98 00 00 00 00 
1651+  FD9C 00 00 00 00 
1651+  FDA0 00 00 00 00 
1651+  FDA4 00 00 00 00 
1651+  FDA8 00 00 00 00 
1651+  FDAC 00 00 00 00 
1651+  FDB0 00 00 00 00 
1651+  FDB4 00 00 00 00 
1651+  FDB8 00 00 00 00 
1651+  FDBC 00 00 00 00 
1651+  FDC0 00 00 00 00 
1652+  FDC4             
1653+  FDC4 C3 86 F6                        JP          i2c_ack             ; 19 (0FDC4h) - Send an i2c ACK.
1654+  FDC7 C3 EC FA                        JP          set_usr_interrupt   ; 18 (0FDC7h) - Set the User interrupt vector. HL = 0 to clear, or address of user routine. HL= 0FFFFh to query.
1655+  FDCA C3 E3 FA                        JP          bios_flash_write    ; 17 (0FDCAh) - Erase and write flash data. Data is written to 4K sectors, which are erased before writing.
1656+  FDCD C3 D1 FA                        JP          get_disk_page       ; 16 (0FDCDh) - Get the page in RAM/ROM being used as the base for the drive selected by A, or zero if error.
1657+  FDD0 C3 B1 F9                        JP          rtc_get_time_hl     ; 15 (0FDD0h) - Get the time to the 7 bytes pointed to by HL. Returns carry set if sucessful
1658+  FDD3 C3 9D F7                        JP          disp_char_bright    ; 14 (0FDD3h) - Set LED Digit A to brightness C
1659+  FDD6 C3 FC F7                        JP          disp_bitmask        ; 13 (0FDD6h) - Directly write bitmask in HL to display column A
1660+  FDD9 C3 3E F0                        JP          m_print_inline      ; 12 (0FDD9h) - Print the characters following the call instruction
1661+  FDDC C3 B0 FA                        JP          get_page_mapping    ; 11 (0FDDCh) - Return the logical (cpu) page C (0-2) in A
1662+  FDDF C3 B9 FA                        JP          set_page_mapping    ; 10 (0FDDFh) - Set the logical (cpu) page in A (0-2) to the physical (RAM/ROM) page in E
1663+  FDE2 C3 CD F5                        JP          i2c_start           ; 9  (0FDE2h) - Sends I2C start sequence
1664+  FDE5 C3 DC F5                        JP          i2c_stop            ; 8  (0FDE5h) - Sends I2C stop sequence
1665+  FDE8 C3 28 F6                        JP          i2c_write           ; 7  (0FDE8h) - Write A as a byte to i2c bus. Carry SET if success. i2c_stop is not called.
1666+  FDEB C3 73 F6                        JP          i2c_read            ; 6  (0FDEBh) - Read byte from i2C into A, without ACK
1667+  FDEE C3 14 F6                        JP          i2c_write_to        ; 5  (0FDEEh) - Prepare to write to Device address H, Register L. Carry SET if success. i2c_stop is not called.
1668+  FDF1 C3 F3 F5                        JP          i2c_read_from       ; 4  (0FDF1h) - Read a byte int A from Device address H, Register L. Carry SET if success. i2c_stop is not called.
1669+  FDF4 C3 68 F4                        JP          wait_for_key        ; 3  (0FDF4h) - Waits for until a key is pressed and released
1670+  FDF7 C3 FD F3                        JP          play_note           ; 2  (0FDF7h) - Plays the note defined by DE (octave, note) and C (duration, tenths)
1671+  FDFA C3 E0 FA                        JP          get_version         ; 1  (0FDFAh) - Returns the Bios version in A
1672+  FDFD             
1673+  FDFD             
1674+  FDFD~            .IF $ > BIOS_TOP
1675+  FDFD~                .ECHO "End of BIOS is too high ("
1676+  FDFD~                .ECHO $
1677+  FDFD~                .ECHO " > "
1678+  FDFD~                .ECHO BIOS_TOP
1679+  FDFD~                .ECHO ") \n\n"
1680+  FDFD~                .STOP
1681+  FDFD             .ENDIF
1682+  FDFD             
1683+  FDFD             .ECHO "Bios Size is "
1684+  FDFD             .ECHO BIOS_TOP-BIOS_START-BIOS_SPARE
1685+  FDFD             .ECHO ". Limit is "
1686+  FDFD             .ECHO BIOS_TOP-BIOS_START
1687+  FDFD             .ECHO ". Spare "
1688+  FDFD             .ECHO BIOS_SPARE
1689+  FDFD             .ECHO "\n\n"
1690+  FDFD             
1691+  FDFD                                 .INCLUDE shared_data.asm
0001++ FDFD             ;
0002++ FDFD             ; Shared data - common state data for routines
0003++ FDFD             ;
0004++ FDFD             ; [] show default/initial values stored at the location
0005++ FDFD             ;
0006++ FDFD             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0007++ FDFD             ;
0008++ FDFD             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0009++ FDFD             ;
0010++ FDFD             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0011++ FDFD             ; of this software and associated documentation files (the "Software"), to deal
0012++ FDFD             ; in the Software without restriction, including without limitation the rights
0013++ FDFD             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0014++ FDFD             ; copies of the Software, and to permit persons to whom the Software is
0015++ FDFD             ; furnished to do so, subject to the following conditions:
0016++ FDFD             ; 
0017++ FDFD             ; The above copyright notice and this permission notice shall be included in all
0018++ FDFD             ; copies or substantial portions of the Software.
0019++ FDFD             ; 
0020++ FDFD             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0021++ FDFD             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0022++ FDFD             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0023++ FDFD             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0024++ FDFD             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0025++ FDFD             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0026++ FDFD             ; SOFTWARE.
0027++ FDFD             ;
0028++ FDFD             
0029++ FF00                                 .ORG    0FF00h
0030++ FF00             
0031++ FF00             ; I2C/Port B routines
0032++ FF00             port_b_mode         .BLOCK  1
0033++ FF01             port_b_dir          .BLOCK  1
0034++ FF02             port_b_data         .BLOCK  1
0035++ FF03             
0036++ FF03             boot_mode           .BLOCK  1              ; Set during boot. 
0037++ FF04             
0038++ FF04             ;
0039++ FF04             ; Stuff
0040++ FF04             timer               .BLOCK  4              ; 2 Words - counts up by 1 every 64th of a second. Rollover ~2 years.
0041++ FF08                                     
0042++ FF08             ; General I/O
0043++ FF08             ;
0044++ FF08             ; This MUST start with keyboard_state, and will all be reset to zero when io_init is called
0045++ FF08             ;
0046++ FF08             _key_state_size     .EQU    8               ; 8 key rollover
0047++ FF08             
0048++ FF08             keyboard_state      .BLOCK  _key_state_size ; state buffer - 8 bytes containing raw key codes for keys currently pressed
0049++ FF10             keyboard_pos        .BLOCK  2               ; Internal state
0050++ FF12             key_shift_state     .BLOCK  1               ; Holds state of shift and control keys in bits 0 and 1 respectively
0051++ FF13             control_key_pressed .BLOCK  1               ; If special control keys are pressed, they are stored here..
0052++ FF14             last_keycode        .BLOCK  1               ; The last keycode that was pressed, for repeats..
0053++ FF15             key_repeat_time     .BLOCK  1               ; How many poll events since the key state last changed
0054++ FF16             
0055++ FF16             _input_buffer_size  .EQU    16
0056++ FF16             input_buffer        .BLOCK _input_buffer_size          ; 16 byte input buffer. Note wraparound is handled by bitmasks, so don't change this length
0057++ FF26             input_pos           .BLOCK  1               ; Next read position in input buffer
0058++ FF27             input_free          .BLOCK  1               ; Next write position in input buffer
0059++ FF28             input_size          .BLOCK  1               ; Bytes occupied in the input buffer
0060++ FF29             
0061++ FF29             io_data_end         .EQU  input_size        ; Byte after IO data block, used to reset values to zero
0062++ FF29             
0063++ FF29             ;------------------------------- Console output and screen data ------------------------------------------------
0064++ FF29             screen_page         .BLOCK  1               ; [30?]  1 Byte, screen buffer page address
0065++ FF2A             screen_offset       .BLOCK  1               ; [0]    1 Byte, row offset (0-63) of virtual screen in screen buffer (high byte of screen address).
0066++ FF2B             
0067++ FF2B             ; *** ROW AND COL MUST BE IN THIS ORDER - READ BY bios_conout ***
0068++ FF2B             display_row         .BLOCK  1               ; [0]    1 Byte, current row being shown by the LED display
0069++ FF2C             display_col         .BLOCK  1               ; [0]    1 Byte, current column being shown by the LED display - Note, 0 based
0070++ FF2D             
0071++ FF2D             ; *** ROW AND COL MUST BE IN THIS ORDER - READ BY bios_conout ***
0072++ FF2D             cursor_row          .BLOCK  1               ; [1]    1 Byte, cursor row on virtual console. Top of page is row 1.   
0073++ FF2E             cursor_col          .BLOCK  1               ; [1]    1 Byte, cursor column on virtual console. Left of page is column 1.
0074++ FF2F             
0075++ FF2F             console_height      .BLOCK  1               ; [24]   1 Byte, virtual console height (rows)
0076++ FF30             console_width       .BLOCK  1               ; [40]   1 byte, virtual console width (columns)
0077++ FF31             
0078++ FF31             console_colour      .BLOCK  1               ; [0x0F] 1 Byte, current colour. Top 4 bits [7:4] are background, bottom 4 [3:0] are foreground
0079++ FF32             console_flags       .BLOCK  1               ;        1 Byte, bit flags for console
0080++ FF33             
0081++ FF33             console_timer       .BLOCK  1               ;        1 Byte, used to blink cursor, clear movement indicator etc.
0082++ FF34             console_escape      .BLOCK  1               ;        1 Byte, escape value (0 if not received yet)
0083++ FF35             console_param1      .BLOCK  1               ;        1 Byte, first character after escape (0 if not recieved yet)
0084++ FF36             
0085++ FF36             console_identify    .BLOCK  1               ; [0]    1 Byte, indicates console identifier sequence to be returned..
0086++ FF37             
0087++ FF37             CFLAGS_SHOW_CURSOR  .EQU    1               ; Awaiting input - show (blink) the cursor
0088++ FF37             CFLAGS_TRACK_CURSOR .EQU    2               ; LED display is tracking cursor position
0089++ FF37             CFLAGS_SHOW_MOVED   .EQU    4               ; Show display as being moved by user
0090++ FF37             CFLAGS_ESCAPE       .EQU    8               ; Escape sequence started
0091++ FF37             CFLAGS_CURSOR_ON    .EQU    16              ; Cursor is currently displayed
0092++ FF37             CFLAGS_LED_OFF      .EQU    32              ; If set, don't echo to the LED display
0093++ FF37             
0094++ FF37             SHOW_MOVE_DELAY     .EQU    60              ; How long to show the display has been moved
0095++ FF37             
0096++ FF37             ;------------------------------- BIOS customisation  ------------------------------------------------
0097++ FF37             
0098++ FF37             drive_a_mem_page    .BLOCK  1               ; First page in RAM/ROM for the Drive A image  - NOTE: These values must be in order of drive number
0099++ FF38             drive_b_mem_page    .BLOCK  1               ; First page in RAM/ROM for the Drive B image
0100++ FF39             
0101++ FF39             page_0_mapping      .BLOCK  1               ; Stores the user mapping for these pages, so they can be correctly restored after interrupts
0102++ FF3A             page_1_mapping      .BLOCK  1
0103++ FF3B             page_2_mapping      .BLOCK  1
0104++ FF3C             page_3_mapping      .BLOCK  1
0105++ FF3D             
0106++ FF3D             ;------------------------------- BDOS variables ------------------------------------------------
0107++ FF3D             ; *** TRACK AND SECTOR MUST BE IN THIS ORDER - READ BY _get_memdisc_addr ***
0108++ FF3D             sys_track           .BLOCK  1               ; 1 Byte, Current disk track 
0109++ FF3E             sys_sector          .BLOCK  2               ; Word, current disk sector
0110++ FF40             sys_dmaaddr         .BLOCK  2               ; Word, DMA address - Disc will read data to this address, or write from this address
0111++ FF42             sys_disk_dph        .BLOCK  2               ; Word, points to current disk parameter header (DPH) 
0112++ FF44             sys_seldsk          .BLOCK  1               ; Byte, current selected disk drive (A=0, B=1..)
0113++ FF45             
0114++ FF45             sys_alv0            .BLOCK  32              ; 32 bytes, allocation vector 0 (max 255 blocks)
0115++ FF65             sys_alv1            .BLOCK  32              ; 32 bytes, allocation vector 1 (max 255 blocks)
0116++ FF85             
0117++ FF85             display_buffer      .BLOCK  24*2            ; 48 byte scratch area used for composing display output (eg. rtc time display etc.)
0118++ FFB5             
0119++ FFB5             intr_stackarea      .BLOCK  24              ; Interrupt handler stack
0120++ FFCD             intr_stack          .BLOCK  2
0121++ FFCF             
0122++ FFCF             user_interrupt      .BLOCK  2               ; Address of user interrupt routine, or zero
0123++ FFD1             
0124++ FFD1             ; Display functions
0125++ FFD1             display_address     .BLOCK  1              ; byte - I/O address of the display driver (right or left) being written to
0126++ FFD2             
0127++ FFD2             ; Panic codes
0128++ FFD2             ;
0129++ FFD2             PANIC_0001          .EQU    0F001h
0130++ FFD2             PANIC_0002          .EQU    0F002h
0131++ FFD2             PANIC_0003          .EQU    0F003h
0132++ FFD2             PANIC_0004          .EQU    0F004h
0133++ FFD2             
0134++ FFD2             ; Boot options
0135++ FFD2             BOOT_TO_CPM         .EQU    001h
0136++ FFD2             BOOT_NO_LED         .EQU    002h
0137++ FFD2             BOOT_RESTORE_B      .EQU    004h
0138++ FFD2             BOOT_TTY_INPUT      .EQU    008h1692+  FFD2                                 .END1199   FFD2                                 .END
tasm: Number of errors = 0
