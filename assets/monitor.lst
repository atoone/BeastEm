0001   0000             ;
0002   0000             ; Monitor using CP/M BIOS
0003   0000             ;
0004   0000             ;
0005   0000             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006   0000             ;
0007   0000             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008   0000             ;
0009   0000             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010   0000             ; of this software and associated documentation files (the "Software"), to deal
0011   0000             ; in the Software without restriction, including without limitation the rights
0012   0000             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013   0000             ; copies of the Software, and to permit persons to whom the Software is
0014   0000             ; furnished to do so, subject to the following conditions:
0015   0000             ; 
0016   0000             ; The above copyright notice and this permission notice shall be included in all
0017   0000             ; copies or substantial portions of the Software.
0018   0000             ; 
0019   0000             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020   0000             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021   0000             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022   0000             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023   0000             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024   0000             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025   0000             ; SOFTWARE.
0026   0000             ;
0027   0000                                 .MODULE  main
0028   0000             
0029   0000             MONITOR_START       .EQU   0DB00h
0030   0000             
0031   DB00                                 .ORG   MONITOR_START
0032   DB00 CD 48 F0                        CALL   configure_hardware           ; Interrupts are configured and enabled here
0033   DB03             
0034   DB03 3A 03 FF                        LD      A, (boot_mode)
0035   DB06 E6 08                           AND     BOOT_TTY_INPUT
0036   DB08 3E 01                           LD      A, 1
0037   DB0A 28 01                           JR      Z, _set_iobyte
0038   DB0C AF                              XOR     A
0039   DB0D 32 03 00    _set_iobyte         LD      (iobyte), A
0040   DB10             
0041   DB10 3E 25                           LD      A, DRIVE_B_PAGE
0042   DB12 32 38 FF                        LD      (drive_b_mem_page), A
0043   DB15             
0044   DB15 21 A9 E5    _clock_check        LD      HL, timer_int
0045   DB18 22 FE FD                        LD      (0FDFEh), HL
0046   DB1B             
0047   DB1B 3E 01                           LD      A, 1
0048   DB1D 32 04 FF                        LD      (timer), A
0049   DB20 3E 03                           LD      A, 3
0050   DB22 CD 9A E5                        CALL    detect_int
0051   DB25             
0052   DB25 79                              LD      A, C
0053   DB26 B0                              OR      B
0054   DB27 20 0A                           JR      NZ, _clock_detected
0055   DB29             
0056   DB29 CD 30 F0    _no_clock           CALL    m_print_inline
0057   DB2C 2E 00                           .DB     ".", 0
0058   DB2E             
0059   DB2E CD CD F1                        CALL    _do_reti
0060   DB31 18 E2                           JR      _clock_check
0061   DB33             
0062   DB33 3E 07       _clock_detected     LD      A, 7
0063   DB35 CD 9A E5                        CALL    detect_int
0064   DB38 79                              LD      A, C
0065   DB39 B0                              OR      B 
0066   DB3A 28 ED                           JR      Z, _no_clock
0067   DB3C             
0068   DB3C                                 ; At this point BC ~= 13 * (clock * 100)
0069   DB3C                                 ; Divide by 13, round lowest digit up/down
0070   DB3C             
0071   DB3C C5                              PUSH    BC
0072   DB3D E1                              POP     HL
0073   DB3E 0E 0D                           LD      C, 13
0074   DB40 CD B6 E5                        CALL    divide_hl_c
0075   DB43             
0076   DB43 E5                              PUSH    HL
0077   DB44 D1                              POP     DE
0078   DB45 CD C3 E5                        CALL    de_to_bcd
0079   DB48             
0080   DB48 3A FB E5                        LD      A, (bcd_scratch)         ; Units
0081   DB4B FE 06                           CP      6
0082   DB4D 38 11                           JR      C, _display_speed
0083   DB4F             
0084   DB4F 2A FC E5                        LD      HL, (bcd_scratch+1)
0085   DB52 06 04                           LD      B,  4
0086   DB54             
0087   DB54 7E          _increment_bcd      LD      A, (HL)
0088   DB55 3C                              INC     A
0089   DB56 77                              LD      (HL), A
0090   DB57 FE 0A                           CP      10
0091   DB59 38 05                           JR      C, _display_speed        ; No carry here
0092   DB5B AF                              XOR     A
0093   DB5C 77                              LD      (HL), A
0094   DB5D 23                              INC     HL
0095   DB5E 10 F4                           DJNZ    _increment_bcd
0096   DB60             
0097   DB60 3A FE E5    _display_speed      LD      A, (bcd_scratch+3)
0098   DB63 A7                              AND     A
0099   DB64 28 05                           JR      Z, _skip_leading
0100   DB66 C6 30                           ADD     A, '0'
0101   DB68 32 92 DB                        LD      (_speed_value),A
0102   DB6B 3A FD E5    _skip_leading       LD       A, (bcd_scratch+2)
0103   DB6E C6 30                           ADD     A, '0'
0104   DB70 32 93 DB                        LD      (_speed_value+1), A
0105   DB73 3A FC E5                        LD      A, (bcd_scratch+1)
0106   DB76 C6 30                           ADD     A, '0'
0107   DB78 32 95 DB                        LD      (_speed_value+3), A
0108   DB7B             
0109   DB7B 01 30 00                        LD      BC, 30h
0110   DB7E CD 83 E5                        CALL    pause_for_ticks
0111   DB81             
0112   DB81 CD 30 F0                        CALL    m_print_inline
0113   DB84 0A 0D 43 6C                     .DB     NEWLINE, CARRIAGE_RETURN, "Clock speed "
0113   DB88 6F 63 6B 20 
0113   DB8C 73 70 65 65 
0113   DB90 64 20 
0114   DB92 20 30 2C 30 _speed_value        .DB     " 0,0Mhz", 0
0114   DB96 4D 68 7A 00 
0115   DB9A             
0116   DB9A 21 6E F1                        LD      HL, interrupt_handler
0117   DB9D 22 FE FD                        LD      (0FDFEh), HL
0118   DBA0             
0119   DBA0                                 ; Everything is now set up and running as we expect. Now handle boot options.
0120   DBA0             
0121   DBA0 3A 03 FF                        LD      A, (boot_mode)
0122   DBA3 E6 02                           AND     BOOT_NO_LED
0123   DBA5 28 18                           JR      Z, _keep_led_on
0124   DBA7             
0125   DBA7 CD 30 F0                        CALL    m_print_inline
0126   DBAA 0A 0D 4C 45                     .DB     NEWLINE, CARRIAGE_RETURN, "LED Off", 0
0126   DBAE 44 20 4F 66 
0126   DBB2 66 00 
0127   DBB4             
0128   DBB4 3A 5D F1                        LD      A, (default_screen_flags)
0129   DBB7 F6 20                           OR      CFLAGS_LED_OFF
0130   DBB9 32 5D F1                        LD      (default_screen_flags), A
0131   DBBC 32 32 FF                        LD      (console_flags), A
0132   DBBF             
0133   DBBF 3A 03 FF    _keep_led_on        LD      A, (boot_mode)
0134   DBC2 E6 01                           AND     BOOT_TO_CPM
0135   DBC4 20 47                           JR      NZ, boot_cpm
0136   DBC6             
0137   DBC6 01 60 00                        LD      BC, 60h
0138   DBC9 CD 83 E5                        CALL    pause_for_ticks
0139   DBCC             
0140   DBCC CD 30 F0                        CALL    m_print_inline
0141   DBCF 0A 0D 4D 69                     .DB     NEWLINE, CARRIAGE_RETURN, "MicroBeast Monitor 1.7", 0
0141   DBD3 63 72 6F 42 
0141   DBD7 65 61 73 74 
0141   DBDB 20 4D 6F 6E 
0141   DBDF 69 74 6F 72 
0141   DBE3 20 31 2E 37 
0141   DBE7 00 
0142   DBE8             
0143   DBE8 01 60 00                        LD      BC, 60h
0144   DBEB CD 83 E5                        CALL    pause_for_ticks
0145   DBEE             
0146   DBEE 0E 0A                           LD      C, NEWLINE
0147   DBF0 CD 2C EC                        CALL    bios_conout
0148   DBF3             
0149   DBF3 CD 00 E6    _monitor_menu       CALL    rtc_display_time
0150   DBF6             
0151   DBF6 01 40 00                        LD      BC, 040h
0152   DBF9 CD 83 E5                        CALL    pause_for_ticks
0153   DBFC             
0154   DBFC CD 9D EB    _monitor_read       CALL    bios_conist
0155   DBFF A7                              AND     A
0156   DC00 28 F1                           JR      Z, _monitor_menu
0157   DC02             
0158   DC02 CD C6 EB                        CALL    bios_conin
0159   DC05             
0160   DC05 21 2C DC                        LD      HL, main_menu
0161   DC08 CD 76 E4                        CALL    start_menu
0162   DC0B 18 E6                           JR      _monitor_menu
0163   DC0D             
0164   DC0D             
0165   DC0D CD 30 F0    boot_cpm            CALL    m_print_inline
0166   DC10 0A 0D 46 6F                     .DB     NEWLINE, CARRIAGE_RETURN, "Format RAM disk", 0
0166   DC14 72 6D 61 74 
0166   DC18 20 52 41 4D 
0166   DC1C 20 64 69 73 
0166   DC20 6B 00 
0167   DC22             
0168   DC22 CD A7 E3                        CALL    format_memdisk
0169   DC25             
0170   DC25 21 F1 EA    boot_without_format LD      HL, bios_boot
0171   DC28 E5                              PUSH    HL
0172   DC29 C3 5D EB                        JP      load_ccp
0173   DC2C             
0174   DC2C             
0175   DC2C 53 65 6C 65 main_menu           .DB     "Select action", 0
0175   DC30 63 74 20 61 
0175   DC34 63 74 69 6F 
0175   DC38 6E 00 
0176   DC3A             
0177   DC3A 0D DC                           .DW     boot_cpm
0178   DC3C 4C 61 75 6E                     .DB     "Launch CP/M", 0
0178   DC40 63 68 20 43 
0178   DC44 50 2F 4D 00 
0179   DC48             
0180   DC48 A6 E1                           .DW     memory_view
0181   DC4A 4D 65 6D 6F                     .DB     "Memory Editor", 0
0181   DC4E 72 79 20 45 
0181   DC52 64 69 74 6F 
0181   DC56 72 00 
0182   DC58             
0183   DC58 E0 DD                           .DW     ymodem_loader
0184   DC5A 59 2D 4D 6F                     .DB     "Y-Modem Transfer", 0
0184   DC5E 64 65 6D 20 
0184   DC62 54 72 61 6E 
0184   DC66 73 66 65 72 
0184   DC6A 00 
0185   DC6B             
0186   DC6B 83 DC                           .DW     set_date
0187   DC6D 53 65 74 20                     .DB     "Set Date", 0
0187   DC71 44 61 74 65 
0187   DC75 00 
0188   DC76             
0189   DC76 4A DD                           .DW     set_time
0190   DC78 53 65 74 20                     .DB     "Set Time", 0
0190   DC7C 54 69 6D 65 
0190   DC80 00 
0191   DC81 00 00                           .DW     0
0192   DC83             
0193   DC83             
0194   DC83                                 .INCLUDE monitor_dates.asm
0001+  DC83             ;
0002+  DC83             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0003+  DC83             ;
0004+  DC83             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0005+  DC83             ;
0006+  DC83             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0007+  DC83             ; of this software and associated documentation files (the "Software"), to deal
0008+  DC83             ; in the Software without restriction, including without limitation the rights
0009+  DC83             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0010+  DC83             ; copies of the Software, and to permit persons to whom the Software is
0011+  DC83             ; furnished to do so, subject to the following conditions:
0012+  DC83             ; 
0013+  DC83             ; The above copyright notice and this permission notice shall be included in all
0014+  DC83             ; copies or substantial portions of the Software.
0015+  DC83             ; 
0016+  DC83             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0017+  DC83             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0018+  DC83             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0019+  DC83             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0020+  DC83             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0021+  DC83             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0022+  DC83             ; SOFTWARE.
0023+  DC83             ;
0024+  DC83             
0025+  DC83 3A 2D FF    set_date            LD      A, (cursor_row)
0026+  DC86 C6 1F                           ADD     A, 31
0027+  DC88 32 A3 DC                        LD      (_set_date_row), A
0028+  DC8B 32 B6 DC                        LD      (_set_week_row), A
0029+  DC8E CD 30 F0                        CALL    m_print_inline
0030+  DC91 0D 44 61 74                     .DB     CARRIAGE_RETURN, "Date YY/MM/DD", ESCAPE_CHAR, "K", ESCAPE_CHAR, "Y",
0030+  DC95 65 20 59 59 
0030+  DC99 2F 4D 4D 2F 
0030+  DC9D 44 44 1B 4B 
0030+  DCA1 1B 59 
0031+  DCA3 00          _set_date_row       .DB     0
0032+  DCA4 25 00                           .DB     31+6, 0
0033+  DCA6 21 91 DD                        LD      HL, date_limits
0034+  DCA9 CD 9F DD                        CALL    get_date_time
0035+  DCAC             
0036+  DCAC 3E 01                           LD      A, 1
0037+  DCAE 32 97 DD    _select_loop        LD      (day_of_week), A
0038+  DCB1             
0039+  DCB1 CD 30 F0                        CALL    m_print_inline
0040+  DCB4 1B 59                           .DB     ESCAPE_CHAR, "Y", 
0041+  DCB6 00          _set_week_row       .DB     0
0042+  DCB7 2F 00                           .DB     31+16, 0
0043+  DCB9             
0044+  DCB9 3A 97 DD                        LD      A, (day_of_week)
0045+  DCBC 47                              LD      B, A
0046+  DCBD 21 8A E6                        LD      HL, weekdays
0047+  DCC0 10 0A       _week_loop          DJNZ    _next_week
0048+  DCC2             
0049+  DCC2 7E          _print_week         LD      A, (HL)
0050+  DCC3 23                              INC     HL
0051+  DCC4 A7                              AND     A
0052+  DCC5 28 0C                           JR      Z, _select_week
0053+  DCC7 CD 3D F0                        CALL    m_print_a_safe
0054+  DCCA 18 F6                           JR      _print_week
0055+  DCCC             
0056+  DCCC 7E          _next_week          LD      A, (HL)
0057+  DCCD 23                              INC     HL
0058+  DCCE A7                              AND     A
0059+  DCCF 20 FB                           JR      NZ, _next_week
0060+  DCD1 18 ED                           JR      _week_loop
0061+  DCD3             
0062+  DCD3 CD 9D EB    _select_week        CALL    bios_conist
0063+  DCD6 A7                              AND     A
0064+  DCD7 28 FA                           JR      Z, _select_week
0065+  DCD9 CD C6 EB                        CALL    bios_conin
0066+  DCDC FE 80                           CP      KEY_UP
0067+  DCDE 20 0A                           JR      NZ, _test_down
0068+  DCE0 3A 97 DD                        LD      A, (day_of_week)
0069+  DCE3 FE 07                           CP      7
0070+  DCE5 28 EC                           JR      Z, _select_week
0071+  DCE7 3C                              INC     A
0072+  DCE8 18 C4                           JR      _select_loop
0073+  DCEA FE 81       _test_down          CP      KEY_DOWN
0074+  DCEC 20 0A                           JR      NZ, _test_enter 
0075+  DCEE 3A 97 DD                        LD      A, (day_of_week)
0076+  DCF1 FE 01                           CP      1
0077+  DCF3 28 DE                           JR      Z, _select_week
0078+  DCF5 3D                              DEC     A
0079+  DCF6 18 B6                           JR      _select_loop
0080+  DCF8 FE 0D       _test_enter         CP      KEY_ENTER
0081+  DCFA 20 D7                           JR      NZ, _select_week
0082+  DCFC             
0083+  DCFC F3                              DI
0084+  DCFD 26 6F                           LD      H, RTC_ADDRESS      
0085+  DCFF 2E 03                           LD      L, RTC_REG_WKDAY
0086+  DD01 CD 06 F6                        CALL    i2c_write_to
0087+  DD04 D2 33 DD                        JP      NC, _clock_error
0088+  DD07             
0089+  DD07 21 97 DD                        LD      HL, day_of_week
0090+  DD0A 7E                              LD      A, (HL)
0091+  DD0B 23                              INC     HL
0092+  DD0C             
0093+  DD0C F6 08                           OR      RTC_WEEKDAY_RUNNING
0094+  DD0E CD 1A F6                        CALL    i2c_write
0095+  DD11 D2 33 DD                        JP      NC, _clock_error
0096+  DD14             
0097+  DD14 46          _write_date_loop    LD      B, (HL)
0098+  DD15 23                              INC     HL
0099+  DD16             
0100+  DD16 7E                              LD      A, (HL)
0101+  DD17 23                              INC     HL
0102+  DD18 CB 27                           SLA     A
0103+  DD1A CB 27                           SLA     A
0104+  DD1C CB 27                           SLA     A
0105+  DD1E CB 27                           SLA     A
0106+  DD20             
0107+  DD20 B0                              OR      B
0108+  DD21 FE FF                           CP      0ffh
0109+  DD23 CA 2E DD                        JP      Z, _start_clock
0110+  DD26 CD 1A F6                        CALL    i2c_write
0111+  DD29 D2 33 DD                        JP      NC, _clock_error
0112+  DD2C 18 E6                           JR      _write_date_loop
0113+  DD2E             
0114+  DD2E CD CE F5    _start_clock        CALL    i2c_stop
0115+  DD31 FB                              EI
0116+  DD32 C9                              RET
0117+  DD33             
0118+  DD33 CD CE F5    _clock_error        CALL    i2c_stop
0119+  DD36 FB                              EI
0120+  DD37 CD 30 F0                        CALL    m_print_inline
0121+  DD3A 0D 52 54 43                     .DB     CARRIAGE_RETURN, "RTC Error", ESCAPE_CHAR, "K", 0
0121+  DD3E 20 45 72 72 
0121+  DD42 6F 72 1B 4B 
0121+  DD46 00 
0122+  DD47 C3 C6 EB                        JP      bios_conin
0123+  DD4A             
0124+  DD4A 3A 2D FF    set_time            LD      A, (cursor_row)
0125+  DD4D C6 1F                           ADD     A, 31
0126+  DD4F 32 67 DD                        LD      (_set_time_row), A
0127+  DD52 CD 30 F0                        CALL    m_print_inline
0128+  DD55 0D 54 69 6D                     .DB     CARRIAGE_RETURN, "Time HH/mm/ss", ESCAPE_CHAR, "K", ESCAPE_CHAR, "Y",
0128+  DD59 65 20 48 48 
0128+  DD5D 2F 6D 6D 2F 
0128+  DD61 73 73 1B 4B 
0128+  DD65 1B 59 
0129+  DD67 00          _set_time_row       .DB     0
0130+  DD68 25 00                           .DB     31+6, 0
0131+  DD6A 21 8B DD                        LD      HL, time_limits
0132+  DD6D CD 9F DD                        CALL    get_date_time
0133+  DD70             
0134+  DD70 3A 99 DD                        LD      A, (digit_values+1)
0135+  DD73 F6 08                           OR      08h
0136+  DD75 32 99 DD                        LD      (digit_values+1), A
0137+  DD78 CD C6 EB                        CALL    bios_conin
0138+  DD7B             
0139+  DD7B F3                              DI
0140+  DD7C 26 6F                           LD      H, RTC_ADDRESS      
0141+  DD7E 2E 00                           LD      L, RTC_REG_SEC
0142+  DD80 CD 06 F6                        CALL    i2c_write_to
0143+  DD83 D2 33 DD                        JP      NC, _clock_error
0144+  DD86             
0145+  DD86 21 98 DD                        LD      HL, digit_values
0146+  DD89 18 89                           JR      _write_date_loop
0147+  DD8B                                 
0148+  DD8B 09 05 09 05 time_limits         .DB     9,5,9,5,3,2
0148+  DD8F 03 02 
0149+  DD91             
0150+  DD91 01 03 02 01 date_limits         .DB     1,3,2,1,9,9
0150+  DD95 09 09 
0151+  DD97             
0152+  DD97 01          day_of_week         .DB     1
0153+  DD98 00 00 00 00 digit_values        .DB     0,0,0,0,0,0
0153+  DD9C 00 00 
0154+  DD9E FF                              .DB     0FFh
0155+  DD9F             
0156+  DD9F 11 98 DD    get_date_time       LD      DE, digit_values
0157+  DDA2 01 06 00                        LD      BC, 6
0158+  DDA5 ED B0                           LDIR
0159+  DDA7 2B                              DEC     HL
0160+  DDA8 1B                              DEC     DE
0161+  DDA9 06 06                           LD      B, 6
0162+  DDAB             
0163+  DDAB E5          _get_digit          PUSH    HL
0164+  DDAC D5                              PUSH    DE
0165+  DDAD C5                              PUSH    BC
0166+  DDAE CD C6 EB                        CALL    bios_conin
0167+  DDB1 C1                              POP     BC
0168+  DDB2 D1                              POP     DE
0169+  DDB3 E1                              POP     HL
0170+  DDB4 D6 30                           SUB     '0'
0171+  DDB6 38 F3                           JR      C, _get_digit
0172+  DDB8 4F                              LD      C, A
0173+  DDB9 1A                              LD      A, (DE)
0174+  DDBA 32 CF DD                        LD      (_digit_compare+1),A
0175+  DDBD B9                              CP      C
0176+  DDBE 38 EB                           JR      C, _get_digit
0177+  DDC0             
0178+  DDC0 79                              LD      A, C
0179+  DDC1 12                              LD      (DE), A
0180+  DDC2 C6 30                           ADD     A,'0'
0181+  DDC4 CD 3D F0                        CALL    m_print_a_safe
0182+  DDC7             
0183+  DDC7 1A                              LD      A,(DE)
0184+  DDC8 2B                              DEC     HL
0185+  DDC9 1B                              DEC     DE
0186+  DDCA CB 40                           BIT     0, B
0187+  DDCC 20 0A                           JR      NZ, _next_tuple
0188+  DDCE FE 00       _digit_compare      CP      0
0189+  DDD0 28 03                           JR      Z, _next_digit
0190+  DDD2 3E 09                           LD      A, 9
0191+  DDD4 12                              LD      (DE), A
0192+  DDD5 10 D4       _next_digit         DJNZ    _get_digit
0193+  DDD7 C9                              RET
0194+  DDD8 CD 30 F0    _next_tuple         CALL    m_print_inline
0195+  DDDB 1B 43 00                        .DB     ESCAPE_CHAR, 'C', 0
0196+  DDDE 18 F5                           JR      _next_digit0195   DDE0             
0196   DDE0             
0197   DDE0 AF          ymodem_loader       XOR     A
0198   DDE1 32 32 E0                        LD      (_ymodem_set), A
0199   DDE4 21 AB E0                        LD      HL, ymodem_menu
0200   DDE7 CD 76 E4                        CALL    start_menu
0201   DDEA                                 
0202   DDEA 3A 32 E0                        LD      A, (_ymodem_set)
0203   DDED A7                              AND     A
0204   DDEE C8                              RET     Z
0205   DDEF             
0206   DDEF ED 5B 2F E0                     LD      DE, (_ymodem_address)
0207   DDF3 3A 31 E0                        LD      A, (_ymodem_page)
0208   DDF6 21 6F DA                        LD      HL, MONITOR_START-YMODEM_BUFFER
0209   DDF9 F3                              DI
0210   DDFA CD F3 E6                        CALL    ymodem
0211   DDFD FB                              EI
0212   DDFE A7                              AND     A
0213   DDFF CA B1 DE                        JP      Z, _ymodem_success
0214   DE02             
0215   DE02 3D                              DEC     A
0216   DE03 5F                              LD      E, A
0217   DE04 16 00                           LD      D, 0
0218   DE06 21 31 DE                        LD      HL, _ymodem_errors
0219   DE09 19                              ADD     HL, DE
0220   DE0A 19                              ADD     HL, DE
0221   DE0B             
0222   DE0B 7E                              LD      A, (HL)
0223   DE0C 23                              INC     HL
0224   DE0D 66                              LD      H, (HL)
0225   DE0E 6F                              LD      L, A
0226   DE0F             
0227   DE0F 79                              LD      A, C
0228   DE10 C6 30                           ADD     A, '0'
0229   DE12 32 6D DE                        LD      (_packet_err_code), A
0230   DE15             
0231   DE15 E5                              PUSH    HL
0232   DE16 CD 30 F0                        CALL    m_print_inline
0233   DE19 0D 45 52 52                     .DB     CARRIAGE_RETURN, "ERROR: ", 0
0233   DE1D 4F 52 3A 20 
0233   DE21 00 
0234   DE22             
0235   DE22 E1                              POP     HL
0236   DE23             
0237   DE23 7E          _ymodem_err_loop    LD      A, (HL)
0238   DE24 23                              INC     HL
0239   DE25 A7                              AND     A
0240   DE26 CA C6 EB                        JP      Z, bios_conin                   ; Wait for a key then go to main menu..
0241   DE29 4F                              LD      C, A
0242   DE2A E5                              PUSH    HL
0243   DE2B CD 2C EC                        CALL    bios_conout
0244   DE2E E1                              POP     HL
0245   DE2F 18 F2                           JR      _ymodem_err_loop
0246   DE31             
0247   DE31 41 DE       _ymodem_errors      .DW     _y_msg_timeout
0248   DE33 4B DE                           .DW     _y_msg_unknown
0249   DE35 5C DE                           .DW     _y_msg_cancel     
0250   DE37 65 DE                           .DW     _y_msg_packet
0251   DE39 72 DE                           .DW     _y_msg_length
0252   DE3B 80 DE                           .DW     _y_msg_no_dest
0253   DE3D 91 DE                           .DW     _y_msg_send
0254   DE3F A0 DE                           .DW     _y_msg_files
0255   DE41             
0256   DE41 54 69 6D 65 _y_msg_timeout      .DB     "Timeout", ESCAPE_CHAR, "K", 0
0256   DE45 6F 75 74 1B 
0256   DE49 4B 00 
0257   DE4B 55 6E 6B 6E _y_msg_unknown      .DB     "Unknown packet", ESCAPE_CHAR, "K", 0
0257   DE4F 6F 77 6E 20 
0257   DE53 70 61 63 6B 
0257   DE57 65 74 1B 4B 
0257   DE5B 00 
0258   DE5C 43 61 6E 63 _y_msg_cancel       .DB     "Cancel", ESCAPE_CHAR, "K", 0
0258   DE60 65 6C 1B 4B 
0258   DE64 00 
0259   DE65 50 61 63 6B _y_msg_packet       .DB     "Packet (", 
0259   DE69 65 74 20 28 
0260   DE6D             
0261   DE6D 30 29 1B 4B _packet_err_code    .DB     "0)", ESCAPE_CHAR, "K", 0
0261   DE71 00 
0262   DE72             
0263   DE72 46 69 6C 65 _y_msg_length       .DB     "File length", ESCAPE_CHAR, "K", 0
0263   DE76 20 6C 65 6E 
0263   DE7A 67 74 68 1B 
0263   DE7E 4B 00 
0264   DE80 4E 6F 20 64 _y_msg_no_dest      .DB     "No destination", ESCAPE_CHAR, "K", 0
0264   DE84 65 73 74 69 
0264   DE88 6E 61 74 69 
0264   DE8C 6F 6E 1B 4B 
0264   DE90 00 
0265   DE91 53 65 6E 64 _y_msg_send         .DB     "Send Timeout", ESCAPE_CHAR, "K", 0
0265   DE95 20 54 69 6D 
0265   DE99 65 6F 75 74 
0265   DE9D 1B 4B 00 
0266   DEA0 4D 75 6C 74 _y_msg_files        .DB     "Multiple files", ESCAPE_CHAR, "K", 0
0266   DEA4 69 70 6C 65 
0266   DEA8 20 66 69 6C 
0266   DEAC 65 73 1B 4B 
0266   DEB0 00 
0267   DEB1             
0268   DEB1 CD 30 F0    _ymodem_success     CALL    m_print_inline           
0269   DEB4 0D 4F 4B 20                     .DB     CARRIAGE_RETURN, "OK ",0
0269   DEB8 00 
0270   DEB9 3A 73 DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_high)
0271   DEBC FE FF                           CP      0FFh
0272   DEBE 28 06                           JR      Z, _ymodem_no_high
0273   DEC0 C6 30                           ADD     A, '0'
0274   DEC2 4F                              LD      C, A
0275   DEC3 CD 2C EC                        CALL    bios_conout
0276   DEC6 3A 72 DA    _ymodem_no_high     LD      A, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0277   DEC9 CD 42 E5                        CALL    hex_out
0278   DECC 3A 71 DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_low)
0279   DECF CD 42 E5                        CALL    hex_out
0280   DED2 CD 30 F0                        CALL    m_print_inline
0281   DED5 20 42 59 54                     .DB     " BYTES @ ", 0
0281   DED9 45 53 20 40 
0281   DEDD 20 00 
0282   DEDF 3A 6F DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)
0283   DEE2 17                              RLA
0284   DEE3 38 10                           JR      C, _ymodem_show_addr
0285   DEE5 1F                              RRA
0286   DEE6 CD 42 E5                        CALL    hex_out
0287   DEE9 0E 2F                           LD      C, '/'
0288   DEEB CD 2C EC                        CALL    bios_conout
0289   DEEE 3A 79 DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_high)
0290   DEF1 D6 40                           SUB     40h
0291   DEF3 18 03                           JR      _ymodem_addr
0292   DEF5             
0293   DEF5 3A 79 DA    _ymodem_show_addr   LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_high)
0294   DEF8 CD 42 E5    _ymodem_addr        CALL    hex_out
0295   DEFB 3A 78 DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0296   DEFE CD 42 E5                        CALL    hex_out
0297   DF01 CD 30 F0                        CALL    m_print_inline
0298   DF04 1B 4B 00                        .DB     ESCAPE_CHAR, "K", 0
0299   DF07 CD 9D EB    _ymodem_waitkey     CALL    bios_conist                  
0300   DF0A A7                              AND     A
0301   DF0B 28 FA                           JR      Z, _ymodem_waitkey
0302   DF0D             
0303   DF0D CD C6 EB                        CALL    bios_conin
0304   DF10             
0305   DF10             
0306   DF10 3A 6F DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)      ; Do something with the file.
0307   DF13 17                              RLA
0308   DF14 30 06                           JR      NC, _ymodem_handle_page
0309   DF16             
0310   DF16 21 33 E0                        LD      HL, ymodem_mem_menu
0311   DF19 C3 76 E4                        JP      start_menu
0312   DF1C             
0313   DF1C             
0314   DF1C 21 60 E0    _ymodem_handle_page LD      HL, ymodem_page_menu
0315   DF1F C3 76 E4                        JP      start_menu
0316   DF22             
0317   DF22 2A 78 DA    _ymodem_view        LD      HL, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0318   DF25 22 A0 E1                        LD      (monitor_address), HL
0319   DF28 C3 82 E2                        JP      edit_memory
0320   DF2B             
0321   DF2B 2A 78 DA    _ymodem_exec        LD      HL, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0322   DF2E E5                              PUSH    HL
0323   DF2F C9          _ymodem_exit        RET
0324   DF30             
0325   DF30 CD 30 F0    _ymodem_flash       CALL    m_print_inline
0326   DF33 0D 0A 50 61                     .DB     CARRIAGE_RETURN, NEWLINE, "Page 00-1f >", ESCAPE_CHAR, "K", 0
0326   DF37 67 65 20 30 
0326   DF3B 30 2D 31 66 
0326   DF3F 20 3E 1B 4B 
0326   DF43 00 
0327   DF44             
0328   DF44 06 02                           LD      B, 2
0329   DF46 CD F0 E3                        CALL    hex_input
0330   DF49 CD 62 E4                        CALL    delete_or_enter
0331   DF4C 3A 60 E4                        LD      A, (hex_input_result)
0332   DF4F FE 1F                           CP      1fh
0333   DF51 30 DD                           JR      NC, _ymodem_flash
0334   DF53             
0335   DF53 CD 30 F0                        CALL    m_print_inline
0336   DF56 20 59 2F 4E                     .DB     " Y/N?", 0
0336   DF5A 3F 00 
0337   DF5C CD C6 EB                        CALL    bios_conin
0338   DF5F FE 79                           CP      'y'
0339   DF61 20 B9                           JR      NZ, _ymodem_handle_page
0340   DF63             
0341   DF63 CD 30 F0                        CALL    m_print_inline
0342   DF66 0D 0A 57 72                     .DB     CARRIAGE_RETURN, NEWLINE, "Writing", ESCAPE_CHAR, "K", 0
0342   DF6A 69 74 69 6E 
0342   DF6E 67 1B 4B 00 
0343   DF72             
0344   DF72 3A 60 E4                        LD      A, (hex_input_result)
0345   DF75 17                              RLA
0346   DF76 17                              RLA
0347   DF77 57                              LD      D, A
0348   DF78             
0349   DF78 3A 6F DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)         ; Page loaded
0350   DF7B 32 31 E0    _next_page          LD      (_ymodem_page), A
0351   DF7E D3 71                           OUT     (IO_MEM_1), A
0352   DF80             
0353   DF80 2A 72 DA                        LD      HL, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0354   DF83 7D                              LD      A, L
0355   DF84 E6 C0                           AND     0c0h
0356   DF86 B4                              OR      H
0357   DF87 20 22                           JR      NZ, _full_page
0358   DF89             
0359   DF89 ED 4B 71 DA                     LD      BC, (MONITOR_START-YMODEM_INFO+ym_length_low)
0360   DF8D 78                              LD      A, B
0361   DF8E B1                              OR      C
0362   DF8F 28 06                           JR      Z, _flash_done
0363   DF91 21 00 40                        LD      HL, 4000h
0364   DF94 CD 76 FA                        CALL    flash_write
0365   DF97             
0366   DF97 3E 20       _flash_done         LD      A, RAM_PAGE_0
0367   DF99 D3 70                           OUT     (IO_MEM_0), A
0368   DF9B             
0369   DF9B CD 30 F0                        CALL    m_print_inline
0370   DF9E 0D 0A 44 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Done ", ESCAPE_CHAR, "K", 0           
0370   DFA2 6E 65 20 1B 
0370   DFA6 4B 00 
0371   DFA8 C3 C6 EB                        JP      bios_conin
0372   DFAB             
0373   DFAB 01 40 00    _full_page          LD      BC, 0040h
0374   DFAE AF                              XOR     A
0375   DFAF ED 42                           SBC     HL, BC
0376   DFB1 22 72 DA                        LD      (MONITOR_START-YMODEM_INFO+ym_length_mid), HL
0377   DFB4 21 00 40                        LD      HL, 4000h
0378   DFB7 44                              LD      B, H
0379   DFB8 4D                              LD      C, L
0380   DFB9 CD 76 FA                        CALL    flash_write
0381   DFBC 14                              INC     D
0382   DFBD 3A 31 E0                        LD      A,(_ymodem_page)
0383   DFC0 3C                              INC     A
0384   DFC1 18 B8                           JR      _next_page
0385   DFC3             
0386   DFC3 3A 73 DA    _ymodem_firmware    LD      A, (MONITOR_START-YMODEM_INFO+ym_length_high)
0387   DFC6 A7                              AND     A
0388   DFC7 20 52                           JR      NZ, _not_firmware
0389   DFC9 3A 72 DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0390   DFCC FE 40                           CP      040h
0391   DFCE 30 4B                           JR      NC, _not_firmware
0392   DFD0             
0393   DFD0 CD 30 F0                        CALL    m_print_inline
0394   DFD3 0D 57 72 69                     .DB     CARRIAGE_RETURN, "Write firmware, Y/N?", ESCAPE_CHAR, "K", 0
0394   DFD7 74 65 20 66 
0394   DFDB 69 72 6D 77 
0394   DFDF 61 72 65 2C 
0394   DFE3 20 59 2F 4E 
0394   DFE7 3F 1B 4B 00 
0395   DFEB CD C6 EB                        CALL    bios_conin
0396   DFEE FE 79                           CP      'y'
0397   DFF0 C2 1C DF                        JP      NZ, _ymodem_handle_page
0398   DFF3             
0399   DFF3 ED 4B 71 DA                     LD      BC, (MONITOR_START-YMODEM_INFO+ym_length_low)
0400   DFF7 3A 6F DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)         ; Page loaded
0401   DFFA D3 71                           OUT     (IO_MEM_1), A
0402   DFFC                                 
0403   DFFC 21 00 40                        LD      HL, 4000h
0404   DFFF 16 00                           LD      D, 0
0405   E001 CD 76 FA                        CALL    flash_write
0406   E004             
0407   E004 CD 30 F0                        CALL    m_print_inline
0408   E007 0D 0A 44 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Done ", ESCAPE_CHAR, "K", 0
0408   E00B 6E 65 20 1B 
0408   E00F 4B 00 
0409   E011 ED 5B 71 DA                     LD      DE, (MONITOR_START-YMODEM_INFO+ym_length_low)
0410   E015 CD 3B E5                        CALL    hex_word
0411   E018 C3 C6 EB                        JP      bios_conin
0412   E01B             
0413   E01B CD 30 F0    _not_firmware       CALL    m_print_inline
0414   E01E 0D 0A 54 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Too large", ESCAPE_CHAR, "K", 0
0414   E022 6F 20 6C 61 
0414   E026 72 67 65 1B 
0414   E02A 4B 00 
0415   E02C C3 C6 EB                        JP      bios_conin
0416   E02F             
0417   E02F             
0418   E02F 00 00       _ymodem_address     .DW     0
0419   E031 00          _ymodem_page        .DB     0
0420   E032 00          _ymodem_set         .DB     0
0421   E033             
0422   E033 46 69 6C 65 ymodem_mem_menu     .DB     "File actions", 0
0422   E037 20 61 63 74 
0422   E03B 69 6F 6E 73 
0422   E03F 00 
0423   E040 22 DF                           .DW     _ymodem_view
0424   E042 56 69 65 77                     .DB     "View file", 0
0424   E046 20 66 69 6C 
0424   E04A 65 00 
0425   E04C 2B DF                           .DW     _ymodem_exec
0426   E04E 52 75 6E 00                     .DB     "Run", 0
0427   E052 2F DF                           .DW     _ymodem_exit
0428   E054 4D 61 69 6E                     .DB     "Main menu", 0
0428   E058 20 6D 65 6E 
0428   E05C 75 00 
0429   E05E 00 00                           .DW     0
0430   E060             
0431   E060 46 69 6C 65 ymodem_page_menu    .DB     "File actions", 0
0431   E064 20 61 63 74 
0431   E068 69 6F 6E 73 
0431   E06C 00 
0432   E06D 30 DF                           .DW     _ymodem_flash
0433   E06F 43 6F 70 79                     .DB     "Copy to flash", 0
0433   E073 20 74 6F 20 
0433   E077 66 6C 61 73 
0433   E07B 68 00 
0434   E07D 25 DC                           .DW     boot_without_format
0435   E07F 43 50 4D 20                     .DB     "CPM Drive B", 0
0435   E083 44 72 69 76 
0435   E087 65 20 42 00 
0436   E08B C3 DF                           .DW     _ymodem_firmware
0437   E08D 55 70 64 61                     .DB     "Update firmware", 0
0437   E091 74 65 20 66 
0437   E095 69 72 6D 77 
0437   E099 61 72 65 00 
0438   E09D 2F DF                           .DW     _ymodem_exit
0439   E09F 4D 61 69 6E                     .DB     "Main menu", 0
0439   E0A3 20 6D 65 6E 
0439   E0A7 75 00 
0440   E0A9 00 00                           .DW     0
0441   E0AB             
0442   E0AB 44 6F 77 6E ymodem_menu         .DB     "Download options", 0
0442   E0AF 6C 6F 61 64 
0442   E0B3 20 6F 70 74 
0442   E0B7 69 6F 6E 73 
0442   E0BB 00 
0443   E0BC FD E0                           .DW     _ymodem_from_file
0444   E0BE 41 64 64 72                     .DB     "Address from file", 0
0444   E0C2 65 73 73 20 
0444   E0C6 66 72 6F 6D 
0444   E0CA 20 66 69 6C 
0444   E0CE 65 00 
0445   E0D0 1E E1                           .DW     _ymodem_logical
0446   E0D2 43 50 55 20                     .DB     "CPU (Logical) address",0
0446   E0D6 28 4C 6F 67 
0446   E0DA 69 63 61 6C 
0446   E0DE 29 20 61 64 
0446   E0E2 64 72 65 73 
0446   E0E6 73 00 
0447   E0E8 54 E1                           .DW     _ymodem_physical
0448   E0EA 50 68 79 73                     .DB     "Physical address", 0
0448   E0EE 69 63 61 6C 
0448   E0F2 20 61 64 64 
0448   E0F6 72 65 73 73 
0448   E0FA 00 
0449   E0FB 00 00                           .DW     0
0450   E0FD             
0451   E0FD 11 FF FF    _ymodem_from_file   LD      DE, 0FFFFh
0452   E100 ED 53 2F E0                     LD      (_ymodem_address), DE
0453   E104 ED 53 31 E0                     LD      (_ymodem_page), DE
0454   E108 CD 30 F0    _ymodem_transfer    CALL    m_print_inline
0455   E10B 0D 53 74 61                     .DB     CARRIAGE_RETURN, "Start transfer", ESCAPE_CHAR, "K", 0
0455   E10F 72 74 20 74 
0455   E113 72 61 6E 73 
0455   E117 66 65 72 1B 
0455   E11B 4B 00 
0456   E11D C9                              RET
0457   E11E             
0458   E11E CD 30 F0    _ymodem_logical     CALL    m_print_inline
0459   E121 0D 41 64 64                     .DB     CARRIAGE_RETURN, "Address 0000-FFFF >", ESCAPE_CHAR, "K", 0
0459   E125 72 65 73 73 
0459   E129 20 30 30 30 
0459   E12D 30 2D 46 46 
0459   E131 46 46 20 3E 
0459   E135 1B 4B 00 
0460   E138 06 04                           LD      B, 4
0461   E13A CD F0 E3                        CALL    hex_input
0462   E13D CD 62 E4                        CALL    delete_or_enter
0463   E140 3E FF                           LD      A, 0FFh
0464   E142 32 31 E0                        LD      (_ymodem_page), A
0465   E145             
0466   E145 ED 5B 60 E4 _ymodem_set_and_go  LD      DE, (hex_input_result)
0467   E149 ED 53 2F E0                     LD      (_ymodem_address), DE
0468   E14D 3E FF                           LD      A, 0FFh
0469   E14F 32 32 E0                        LD      (_ymodem_set), A
0470   E152 18 B4                           JR      _ymodem_transfer
0471   E154             
0472   E154 CD 30 F0    _ymodem_physical    CALL    m_print_inline
0473   E157 0D 50 61 67                     .DB     CARRIAGE_RETURN, "Page 20-3F >", ESCAPE_CHAR, "K", 0
0473   E15B 65 20 32 30 
0473   E15F 2D 33 46 20 
0473   E163 3E 1B 4B 00 
0474   E167 06 02                           LD      B, 2
0475   E169 CD F0 E3                        CALL    hex_input
0476   E16C CD 62 E4                        CALL    delete_or_enter
0477   E16F 3A 60 E4                        LD      A, (hex_input_result)
0478   E172 32 31 E0                        LD      (_ymodem_page), A
0479   E175 CD 30 F0                        CALL    m_print_inline
0480   E178 0D 4F 66 66                     .DB     CARRIAGE_RETURN, "Offset 0000-3FFF >", ESCAPE_CHAR, "K", 0
0480   E17C 73 65 74 20 
0480   E180 30 30 30 30 
0480   E184 2D 33 46 46 
0480   E188 46 20 3E 1B 
0480   E18C 4B 00 
0481   E18E 06 04                           LD      B, 4
0482   E190 CD F0 E3                        CALL    hex_input
0483   E193 CD 62 E4                        CALL    delete_or_enter
0484   E196 3A 61 E4                        LD      A, (hex_input_result+1)         ; YModem loads to page 1, so allow for offset..
0485   E199 F6 40                           OR      040h
0486   E19B 32 61 E4                        LD      (hex_input_result+1), A
0487   E19E 18 A5                           JR      _ymodem_set_and_go
0488   E1A0             
0489   E1A0             ;------------------------------ Memory Editor --------------------------------------------
0490   E1A0             
0491   E1A0 00 80       monitor_address     .DW     08000h              ; Default address is 0x8000
0492   E1A2 00          monitor_mode        .DB     0                   ; 0 = show address + 3 characters, ~0 = hide address + 8 characters
0493   E1A3 00          edit_col            .DB     0                   ; Column currently being edited..
0494   E1A4 00 00       edit_digit          .DW     0
0495   E1A6             
0496   E1A6 CD 42 E3    memory_view         CALL    display_mem_row
0497   E1A9             
0498   E1A9 CD 9D EB    _wait_key           CALL    bios_conist
0499   E1AC A7                              AND     A
0500   E1AD 28 FA                           JR      Z, _wait_key
0501   E1AF CD C6 EB                        CALL    bios_conin
0502   E1B2 CD C6 E4                        CALL    translate_cursors
0503   E1B5             
0504   E1B5 FE 80                           CP      KEY_UP
0505   E1B7 20 0D                           JR      NZ, _not_up
0506   E1B9 2A A0 E1    memory_up           LD      HL, (monitor_address)
0507   E1BC 11 08 00                        LD      DE, 8
0508   E1BF ED 52                           SBC     HL, DE
0509   E1C1 22 A0 E1                        LD      (monitor_address), HL
0510   E1C4 18 E0                           JR      memory_view
0511   E1C6             
0512   E1C6 FE 81       _not_up             CP      KEY_DOWN
0513   E1C8 20 0C                           JR      NZ, _not_down
0514   E1CA 2A A0 E1    memory_down         LD      HL, (monitor_address)
0515   E1CD 11 08 00                        LD      DE, 8
0516   E1D0 19                              ADD     HL, DE
0517   E1D1 22 A0 E1                        LD      (monitor_address), HL
0518   E1D4 18 D0                           JR      memory_view
0519   E1D6             
0520   E1D6 FE 20       _not_down           CP      ' '
0521   E1D8 20 09                           JR      NZ, _not_space
0522   E1DA 3A A2 E1                        LD      A, (monitor_mode)
0523   E1DD 2F                              CPL
0524   E1DE 32 A2 E1                        LD      (monitor_mode), A
0525   E1E1 18 C3                           JR      memory_view
0526   E1E3             
0527   E1E3 FE 0D       _not_space          CP      CARRIAGE_RETURN
0528   E1E5 28 0E                           JR      Z, _input_address
0529   E1E7             
0530   E1E7 FE 83                           CP      KEY_RIGHT
0531   E1E9 CA 82 E2                        JP      Z, edit_memory
0532   E1EC FE 08                           CP      KEY_BACKSPACE
0533   E1EE C8                              RET     Z
0534   E1EF             
0535   E1EF FE 78                           CP      'x'
0536   E1F1 28 1C                           JR      Z, execute
0537   E1F3 18 B4                           JR      _wait_key
0538   E1F5             
0539   E1F5 AF          _input_address      XOR     A
0540   E1F6 32 A2 E1                        LD      (monitor_mode), A
0541   E1F9 CD 42 E3                        CALL    display_mem_row
0542   E1FC 0E 0D                           LD      C, CARRIAGE_RETURN
0543   E1FE CD 2C EC                        CALL    bios_conout
0544   E201             
0545   E201 06 04                           LD      B, 4
0546   E203 CD F0 E3                        CALL    hex_input
0547   E206 2A 60 E4                        LD      HL, (hex_input_result)
0548   E209 22 A0 E1                        LD      (monitor_address), HL
0549   E20C C3 A6 E1                        JP      memory_view
0550   E20F             
0551   E20F AF          execute             XOR     A
0552   E210 32 A3 E1                        LD      (edit_col), A
0553   E213 CD 30 F0    execute_col         CALL    m_print_inline
0554   E216 0D 1B 62 2E                     .DB     CARRIAGE_RETURN, ESCAPE_CHAR, 'b', CPM_NUM+15, "Execute from ", 0
0554   E21A 45 78 65 63 
0554   E21E 75 74 65 20 
0554   E222 66 72 6F 6D 
0554   E226 20 00 
0555   E228 21 66 E2                        LD      HL, _exec_done
0556   E22B E5                              PUSH    HL
0557   E22C 2A A0 E1                        LD      HL, (monitor_address)
0558   E22F 3A A3 E1                        LD      A, (edit_col)
0559   E232 5F                              LD      E, A
0560   E233 16 00                           LD      D, 0
0561   E235 19                              ADD     HL, DE
0562   E236                                 
0563   E236 E5                              PUSH    HL
0564   E237 EB                              EX      DE, HL
0565   E238 CD 3B E5                        CALL    hex_word
0566   E23B CD 30 F0                        CALL    m_print_inline
0567   E23E 20 59 2F 4E                     .DB     " Y/N?", ESCAPE_CHAR, "K", 0
0567   E242 3F 1B 4B 00 
0568   E246             
0569   E246 CD C6 EB    _exec_loop          CALL    bios_conin
0570   E249 FE 79                           CP      'y'
0571   E24B 28 09                           JR      Z, _exec_go
0572   E24D FE 6E                           CP      'n'
0573   E24F 20 F5                           JR      NZ, _exec_loop
0574   E251 E1                              POP     HL
0575   E252 E1                              POP     HL
0576   E253 C3 A6 E1                        JP      memory_view
0577   E256             
0578   E256 CD 30 F0    _exec_go            CALL    m_print_inline
0579   E259 0A 0D 52 75                     .DB     NEWLINE, CARRIAGE_RETURN, "Running", ESCAPE_CHAR, "K", 0
0579   E25D 6E 6E 69 6E 
0579   E261 67 1B 4B 00 
0580   E265 C9                              RET
0581   E266             
0582   E266 F5          _exec_done          PUSH    AF
0583   E267 CD 30 F0                        CALL    m_print_inline
0584   E26A 0A 0D 44 6F                     .DB     NEWLINE, CARRIAGE_RETURN, "Done. A=",0
0584   E26E 6E 65 2E 20 
0584   E272 41 3D 00 
0585   E275 F1                              POP     AF
0586   E276 CD 42 E5                        CALL    hex_out
0587   E279 CD 30 F0                        CALL    m_print_inline
0588   E27C 1B 4B 00                        .DB     ESCAPE_CHAR, "K", 0
0589   E27F CD C6 EB                        CALL    bios_conin ;pause for a key, then return to memory edit at the execution location
0590   E282             
0591   E282             
0592   E282 AF          edit_memory         XOR     A
0593   E283 32 A3 E1    _set_col_and_edit   LD      (edit_col), A
0594   E286 CD 42 E3    _edit_loop          CALL    display_mem_row
0595   E289 3A A3 E1                        LD      A, (edit_col)
0596   E28C 87                              ADD     A, A
0597   E28D 4F                              LD      C, A
0598   E28E 3A A2 E1                        LD      A, (monitor_mode)
0599   E291 A7                              AND     A
0600   E292 20 04                           JR      NZ, _address_hidden
0601   E294 3E 05                           LD      A, 5
0602   E296 81                              ADD     A, C
0603   E297 4F                              LD      C, A
0604   E298 3A 2D FF    _address_hidden     LD      A, (cursor_row)
0605   E29B C6 1F                           ADD     A, 31
0606   E29D 32 AE E2                        LD      (_edit_set_row), A
0607   E2A0 79                              LD      A, C
0608   E2A1 C6 20                           ADD     A, 32
0609   E2A3 32 AF E2                        LD      (_edit_set_col), A
0610   E2A6             
0611   E2A6 CD 30 F0                        CALL    m_print_inline
0612   E2A9 1B 62 27                        .DB     ESCAPE_CHAR, 'b', CPM_NUM+8         ; Set the correct brightness
0613   E2AC 1B 59                           .DB     ESCAPE_CHAR, 'Y'                    ; And position the cursor
0614   E2AE 00          _edit_set_row       .DB     0
0615   E2AF 00          _edit_set_col       .DB     0
0616   E2B0 00                              .DB     0
0617   E2B1             
0618   E2B1 11 00 02                        LD      DE, 0200h
0619   E2B4 ED 53 A4 E1 _edit_next_digit    LD      (edit_digit), DE
0620   E2B8             
0621   E2B8 CD C6 EB    _edit_input         CALL    bios_conin
0622   E2BB CD C6 E4                        CALL    translate_cursors
0623   E2BE             
0624   E2BE FE 78                           CP      'x'
0625   E2C0 CA 13 E2                        JP      Z, execute_col
0626   E2C3             
0627   E2C3 FE 83                           CP      KEY_RIGHT
0628   E2C5 20 1B                           JR      NZ, _not_right
0629   E2C7 3A A3 E1    _edit_right         LD      A, (edit_col)
0630   E2CA FE 07                           CP      7
0631   E2CC 28 03                           JR      Z, _edit_wrap_down
0632   E2CE 3C                              INC     A
0633   E2CF 18 B2                           JR      _set_col_and_edit
0634   E2D1             
0635   E2D1 AF          _edit_wrap_down     XOR     A
0636   E2D2 32 A3 E1                        LD      (edit_col),A
0637   E2D5 11 08 00    _edit_down          LD      DE, 08h
0638   E2D8 2A A0 E1    _edit_move          LD      HL, (monitor_address)
0639   E2DB 19                              ADD     HL, DE
0640   E2DC 22 A0 E1                        LD      (monitor_address), HL
0641   E2DF C3 86 E2                        JP      _edit_loop
0642   E2E2             
0643   E2E2 FE 82       _not_right          CP      KEY_LEFT
0644   E2E4 20 13                           JR      NZ, _not_left
0645   E2E6 3A A3 E1                        LD      A, (edit_col)
0646   E2E9 A7                              AND     A
0647   E2EA 28 03                           JR      Z, _edit_wrap_up
0648   E2EC 3D                              DEC     A
0649   E2ED 18 94                           JR      _set_col_and_edit
0650   E2EF             
0651   E2EF 3E 07       _edit_wrap_up       LD      A, 7
0652   E2F1 32 A3 E1                        LD      (edit_col),A
0653   E2F4 11 F8 FF    _edit_up            LD      DE, 0FFF8h
0654   E2F7 18 DF                           JR      _edit_move
0655   E2F9             
0656   E2F9 FE 80       _not_left           CP      KEY_UP
0657   E2FB CA F4 E2                        JP      Z, _edit_up
0658   E2FE FE 81                           CP      KEY_DOWN
0659   E300 CA D5 E2                        JP      Z, _edit_down
0660   E303 FE 08                           CP      KEY_BACKSPACE
0661   E305 C2 13 E3                        JP      NZ, _not_delete
0662   E308             
0663   E308 3A A5 E1                        LD      A, (edit_digit+1)
0664   E30B FE 02                           CP      2
0665   E30D CA A6 E1                        JP      Z, memory_view
0666   E310 C3 86 E2                        JP      _edit_loop
0667   E313             
0668   E313 CD 69 E5    _not_delete         CALL    valid_hex_char
0669   E316 38 A0                           JR      C, _edit_input
0670   E318             
0671   E318 4F                              LD      C, A
0672   E319 CD 79 E5                        CALL    hex_char_to_num
0673   E31C F5                              PUSH    AF
0674   E31D CD 2C EC                        CALL    bios_conout
0675   E320 F1                              POP     AF
0676   E321                                 
0677   E321 ED 5B A4 E1                     LD      DE, (edit_digit)
0678   E325 CB 23                           SLA     E
0679   E327 CB 23                           SLA     E
0680   E329 CB 23                           SLA     E
0681   E32B CB 23                           SLA     E
0682   E32D B3                              OR      E
0683   E32E 5F                              LD      E, A
0684   E32F 15                              DEC     D
0685   E330 20 82                           JR      NZ, _edit_next_digit
0686   E332             
0687   E332 3A A3 E1                        LD      A, (edit_col)
0688   E335 4F                              LD      C, A
0689   E336 06 00                           LD      B, 0
0690   E338 2A A0 E1                        LD      HL, (monitor_address)
0691   E33B 09                              ADD     HL, BC
0692   E33C 73                              LD      (HL), E
0693   E33D CD 42 E3                        CALL    display_mem_row
0694   E340 18 85                           JR      _edit_right
0695   E342             
0696   E342 0E 0D       display_mem_row     LD      C, CARRIAGE_RETURN
0697   E344 CD 2C EC                        CALL    bios_conout
0698   E347 3A A2 E1                        LD      A, (monitor_mode)
0699   E34A A7                              AND     A
0700   E34B 20 14                           JR      NZ, _hex_values
0701   E34D             
0702   E34D CD 30 F0                        CALL    m_print_inline
0703   E350 0D 1B 62 2E                     .DB     CARRIAGE_RETURN, ESCAPE_CHAR, 'b', CPM_NUM+15, 0
0703   E354 00 
0704   E355             
0705   E355 ED 5B A0 E1                     LD      DE, (monitor_address)
0706   E359 CD 3B E5                        CALL    hex_word
0707   E35C             
0708   E35C 0E 20                           LD      C, ' '
0709   E35E CD 2C EC                        CALL    bios_conout
0710   E361             
0711   E361 CD 30 F0    _hex_values         CALL    m_print_inline
0712   E364 1B 62 26 00                     .DB     ESCAPE_CHAR, 'b', CPM_NUM+7, 0
0713   E368             
0714   E368 2A A0 E1                        LD      HL, (monitor_address)
0715   E36B 06 08                           LD      B, 8
0716   E36D 7E          _mem_hex            LD      A, (HL)
0717   E36E E5                              PUSH    HL
0718   E36F C5                              PUSH    BC
0719   E370 CD 42 E5                        CALL    hex_out
0720   E373 C1                              POP     BC
0721   E374 E1                              POP     HL
0722   E375 23                              INC     HL
0723   E376 10 F5                           DJNZ    _mem_hex
0724   E378             
0725   E378 CD 30 F0                        CALL    m_print_inline
0726   E37B 1B 62 2E 00                     .DB     ESCAPE_CHAR, 'b', CPM_NUM+15, 0
0727   E37F             
0728   E37F 2A A0 E1                        LD      HL, (monitor_address)
0729   E382 06 03                           LD      B, 3
0730   E384 3A A2 E1                        LD      A, (monitor_mode)
0731   E387 A7                              AND     A
0732   E388 28 02                           JR      Z, _mem_char
0733   E38A 06 08                           LD      B, 8
0734   E38C             
0735   E38C 7E          _mem_char           LD      A, (HL)
0736   E38D FE 20                           CP      ' '
0737   E38F D2 94 E3                        JP      NC, _not_control_char
0738   E392 3E 2E                           LD      A, '.'
0739   E394 FE 80       _not_control_char   CP      128
0740   E396 DA 9B E3                        JP      C, _not_extended_char
0741   E399 3E 2E                           LD      A, '.'
0742   E39B E5          _not_extended_char  PUSH    HL
0743   E39C C5                              PUSH    BC
0744   E39D 4F                              LD      C, A
0745   E39E CD 2C EC                        CALL    bios_conout
0746   E3A1 C1                              POP     BC
0747   E3A2 E1                              POP     HL
0748   E3A3 23                              INC     HL
0749   E3A4 10 E6                           DJNZ    _mem_char
0750   E3A6 C9                              RET
0751   E3A7             
0752   E3A7             ; Format memory disk
0753   E3A7             ;
0754   E3A7 3E 01       format_memdisk      LD      A, 1
0755   E3A9 4F                              LD      C, A
0756   E3AA CD 5B EF                        CALL    bios_seldsk
0757   E3AD             
0758   E3AD 21 80 00                        LD      HL, BIOS_SECTOR_ADDRESS     ; Sector buffer
0759   E3B0 22 EE E3                        LD      (_fmt_address),HL
0760   E3B3             
0761   E3B3 54                              LD      D, H                        ; Fill sector buffer with 0E5h (blank byte)
0762   E3B4 5D                              LD      E, L
0763   E3B5 13                              INC     DE
0764   E3B6 3E E5                           LD      A, 0E5h
0765   E3B8 77                              LD      (HL),A
0766   E3B9 01 7F 00                        LD      BC, 07fh
0767   E3BC ED B0                           LDIR
0768   E3BE             
0769   E3BE 3E 02                           LD      A,BIOS_BOOT_TRACKS          ; First track (Offset = 2)
0770   E3C0 32 EC E3    _fmt_track_loop     LD      (_fmt_track),A
0771   E3C3 4F                              LD      C,A                         ; Set track
0772   E3C4 CD 76 EF                        CALL    bios_settrk
0773   E3C7             
0774   E3C7 AF                              XOR     A                           ; Initial sector
0775   E3C8 32 ED E3    _fmt_sector_loop    LD      (_fmt_sector),A
0776   E3CB             
0777   E3CB FE 1A                           CP      MEMDISK_SECTORS
0778   E3CD 28 14                           JR      Z,_fmt_next_track
0779   E3CF 4F                              LD      C,A                         ; Set sector
0780   E3D0 CD 7B EF                        CALL    bios_setsec
0781   E3D3 ED 4B EE E3                     LD      BC,(_fmt_address)           ; Address to write from
0782   E3D7 CD 80 EF                        CALL    bios_setdma
0783   E3DA CD BE EF                        CALL    bios_write
0784   E3DD 3A ED E3                        LD      A,(_fmt_sector)
0785   E3E0             
0786   E3E0 3C                              INC     A
0787   E3E1 18 E5                           JR      _fmt_sector_loop
0788   E3E3             
0789   E3E3 3A EC E3    _fmt_next_track     LD      A,(_fmt_track)
0790   E3E6 FE 4F                           CP      MEMDISK_TRACKS
0791   E3E8 C8                              RET     Z
0792   E3E9 3C                              INC     A
0793   E3EA 18 D4                           JR      _fmt_track_loop
0794   E3EC             
0795   E3EC 00          _fmt_track          .DB     0
0796   E3ED 00          _fmt_sector         .DB     0
0797   E3EE 00 00       _fmt_address        .DW     0
0798   E3F0             
0799   E3F0             ;------------------------------------------------------
0800   E3F0             ; Read hex input into the (input_hex) address
0801   E3F0             ; Params - B = number of characters to input
0802   E3F0             ;
0803   E3F0 78          hex_input           LD      A, B
0804   E3F1 32 35 E4                        LD      (_hi_size), A
0805   E3F4 21 00 00                        LD      HL, 0
0806   E3F7 22 60 E4                        LD      (hex_input_result), HL
0807   E3FA             
0808   E3FA C5          _hi_loop            PUSH    BC
0809   E3FB CD 5D E5    _hi_loop_join       CALL    hex_char_in
0810   E3FE FE 08                           CP      KEY_BACKSPACE
0811   E400 28 34                           JR      Z, _hi_delete
0812   E402 4F                              LD      C, A
0813   E403 F5                              PUSH    AF
0814   E404 CD 2C EC                        CALL    bios_conout
0815   E407 F1                              POP     AF
0816   E408 CD 79 E5                        CALL    hex_char_to_num
0817   E40B 2A 60 E4                        LD      HL, (hex_input_result)
0818   E40E CB 27                           SLA     A
0819   E410 CB 27                           SLA     A
0820   E412 CB 27                           SLA     A
0821   E414 CB 27                           SLA     A
0822   E416             
0823   E416 CB 27                           SLA     A
0824   E418 CB 15                           RL      L
0825   E41A CB 14                           RL      H
0826   E41C CB 27                           SLA     A
0827   E41E CB 15                           RL      L
0828   E420 CB 14                           RL      H
0829   E422 CB 27                           SLA     A
0830   E424 CB 15                           RL      L
0831   E426 CB 14                           RL      H
0832   E428 CB 27                           SLA     A
0833   E42A CB 15                           RL      L
0834   E42C CB 14                           RL      H
0835   E42E 22 60 E4                        LD      (hex_input_result), HL
0836   E431 C1                              POP     BC
0837   E432 10 C6                           DJNZ    _hi_loop
0838   E434 C9                              RET
0839   E435             
0840   E435 00          _hi_size            .DB     0
0841   E436             
0842   E436 C1          _hi_delete          POP     BC
0843   E437 3A 35 E4    _hi_delete_join     LD      A, (_hi_size)
0844   E43A B8                              CP      B
0845   E43B 28 BD                           JR      Z, _hi_loop
0846   E43D 04                              INC     B
0847   E43E C5                              PUSH    BC
0848   E43F             
0849   E43F 2A 60 E4                        LD      HL, (hex_input_result)
0850   E442 CB 3C                           SRL     H
0851   E444 CB 1D                           RR      L
0852   E446 CB 3C                           SRL     H
0853   E448 CB 1D                           RR      L
0854   E44A CB 3C                           SRL     H
0855   E44C CB 1D                           RR      L
0856   E44E CB 3C                           SRL     H
0857   E450 CB 1D                           RR      L
0858   E452 22 60 E4                        LD      (hex_input_result), HL
0859   E455             
0860   E455 CD 30 F0                        CALL    m_print_inline
0861   E458 1B 44 20 1B                     .DB     ESCAPE_CHAR, "D ", ESCAPE_CHAR, "D", 0
0861   E45C 44 00 
0862   E45E 18 9B                           JR      _hi_loop_join
0863   E460             
0864   E460 00 00       hex_input_result    .DW     0
0865   E462             
0866   E462             delete_or_enter     ; Wait for Delete or enter keys and handle..
0867   E462 CD C6 EB                        CALL    bios_conin
0868   E465 FE 0D                           CP      CARRIAGE_RETURN
0869   E467 C8                              RET     Z
0870   E468 06 00                           LD      B, 0
0871   E46A FE 08                           CP      KEY_BACKSPACE
0872   E46C CC 37 E4                        CALL    Z, _hi_delete_join
0873   E46F 18 F1                           JR      delete_or_enter
0874   E471             
0875   E471             
0876   E471             ;------------------------------------------------------
0877   E471             ; Menu system
0878   E471 00          menu_index          .DB     0
0879   E472 00 00       menu_address        .DW     0
0880   E474 00 00       menu_current        .DW     0
0881   E476             
0882   E476 AF          start_menu          XOR    A
0883   E477 32 71 E4                        LD     (menu_index), A
0884   E47A 22 72 E4                        LD     (menu_address), HL
0885   E47D 32 C5 E4                        LD     (keyboard_escape), A
0886   E480             
0887   E480 CD FB E4    _menu_loop          CALL    _display_menu
0888   E483 01 58 02                        LD      BC, 600
0889   E486 CD 83 E5                        CALL    pause_for_ticks
0890   E489 CD 9D EB                        CALL    bios_conist
0891   E48C A7                              AND     A
0892   E48D C8                              RET     Z
0893   E48E             
0894   E48E CD C6 EB    _menu_key           CALL    bios_conin
0895   E491 CD C6 E4                        CALL    translate_cursors
0896   E494             
0897   E494 FE 81                           CP      KEY_DOWN
0898   E496 28 0D                           JR      Z, _menu_down
0899   E498 FE 80                           CP      KEY_UP
0900   E49A 28 12                           JR      Z, _menu_up
0901   E49C FE 08                           CP      KEY_BACKSPACE
0902   E49E C8                              RET     Z
0903   E49F FE 0D                           CP      KEY_ENTER
0904   E4A1 28 13                           JR      Z, _menu_enter
0905   E4A3 18 DB                           JR      _menu_loop
0906   E4A5             
0907   E4A5 3A 71 E4    _menu_down          LD      A, (menu_index)
0908   E4A8 3C                              INC     A
0909   E4A9 32 71 E4    _menu_set_index     LD      (menu_index),A
0910   E4AC 18 D2                           JR      _menu_loop
0911   E4AE             
0912   E4AE 3A 71 E4    _menu_up            LD      A, (menu_index)
0913   E4B1 3D                              DEC     A
0914   E4B2 28 CC                           JR      Z, _menu_loop
0915   E4B4 18 F3                           JR      _menu_set_index
0916   E4B6             
0917   E4B6 3A 71 E4    _menu_enter         LD      A, (menu_index)
0918   E4B9 A7                              AND     A
0919   E4BA 28 C4                           JR      Z, _menu_loop
0920   E4BC 2A 74 E4                        LD      HL, (menu_current)
0921   E4BF 7E                              LD      A, (HL)
0922   E4C0 23                              INC     HL
0923   E4C1 66                              LD      H, (HL)
0924   E4C2 6F                              LD      L, A
0925   E4C3 E5                              PUSH    HL
0926   E4C4 C9                              RET
0927   E4C5             
0928   E4C5 00          keyboard_escape     .DB     0
0929   E4C6             
0930   E4C6 FE 1B       translate_cursors   CP      KEY_ESCAPE
0931   E4C8 5F                              LD      E, A 
0932   E4C9 28 29                           JR      Z, _set_escape
0933   E4CB 3A C5 E4                        LD      A, (keyboard_escape)
0934   E4CE A7                              AND     A
0935   E4CF 7B                              LD      A, E                    ; Just return key code if escape hasn't been pressed
0936   E4D0 C8                              RET     Z
0937   E4D1                                                                 ; Handle VT Escape sequences
0938   E4D1 FE 5B                           CP      '['                     ; Ignore '[' (VT100 cursor sequence)
0939   E4D3 C8                              RET     Z
0940   E4D4 FE 41                           CP      'A'
0941   E4D6 16 80                           LD      D, KEY_UP
0942   E4D8 28 18                           JR      Z, _translate_key
0943   E4DA FE 42                           CP      'B'
0944   E4DC 16 81                           LD      D, KEY_DOWN
0945   E4DE 28 12                           JR      Z, _translate_key
0946   E4E0 FE 43                           CP      'C'
0947   E4E2 16 83                           LD      D, KEY_RIGHT
0948   E4E4 28 0C                           JR      Z, _translate_key
0949   E4E6 FE 44                           CP      'D'
0950   E4E8 16 82                           LD      D, KEY_LEFT
0951   E4EA 28 06                           JR      Z, _translate_key
0952   E4EC AF                              XOR     A                       ; Ignore rest of escape sequence
0953   E4ED 32 C5 E4                        LD      (keyboard_escape), A
0954   E4F0 7B          _return_e           LD      A, E
0955   E4F1 C9                              RET
0956   E4F2             
0957   E4F2 7A          _translate_key      LD      A, D
0958   E4F3 C9                              RET
0959   E4F4             
0960   E4F4 3E 01       _set_escape         LD      A, 1
0961   E4F6 32 C5 E4                        LD      (keyboard_escape), A
0962   E4F9 18 F5                           JR      _return_e
0963   E4FB             
0964   E4FB             
0965   E4FB 0E 0D       _display_menu       LD      C, CARRIAGE_RETURN
0966   E4FD CD 2C EC                        CALL    bios_conout
0967   E500             
0968   E500 3A 71 E4                        LD      A, (menu_index)
0969   E503 2A 72 E4                        LD      HL, (menu_address)
0970   E506 A7          _entry_loop         AND     A
0971   E507 28 12                           JR      Z, _display_entry
0972   E509 47                              LD      B, A
0973   E50A 7E          _next_menu          LD      A, (HL)
0974   E50B 23                              INC     HL
0975   E50C A7                              AND     A
0976   E50D 20 FB                           JR      NZ, _next_menu
0977   E50F             
0978   E50F 22 74 E4                        LD      (menu_current), HL
0979   E512 7E                              LD      A, (HL)
0980   E513 23                              INC     HL
0981   E514 5E                              LD      E, (HL)
0982   E515 23                              INC     HL
0983   E516 B3                              OR      E
0984   E517 28 19                           JR      Z, _menu_end
0985   E519 10 EF                           DJNZ    _next_menu
0986   E51B                                 
0987   E51B 7E          _display_entry      LD      A, (HL)
0988   E51C A7                              AND     A
0989   E51D 28 09                           JR      Z, _entry_end
0990   E51F 4F                              LD      C, A
0991   E520 E5                              PUSH    HL
0992   E521 CD 2C EC                        CALL    bios_conout
0993   E524 E1                              POP     HL
0994   E525 23                              INC     HL
0995   E526 18 F3                           JR      _display_entry
0996   E528 0E 1B       _entry_end          LD      C, ESCAPE_CHAR
0997   E52A CD 2C EC                        CALL    bios_conout
0998   E52D 0E 4B                           LD      C, 'K'
0999   E52F C3 2C EC                        JP      bios_conout
1000   E532             
1001   E532 3A 71 E4    _menu_end           LD      A, (menu_index)
1002   E535 3D                              DEC     A
1003   E536 32 71 E4                        LD      (menu_index), A
1004   E539 18 C0                           JR      _display_menu
1005   E53B             
1006   E53B             
1007   E53B             ;------------------------------------------------------
1008   E53B             ; Write the Hex value of DE as four characters to conout
1009   E53B             ;
1010   E53B D5          hex_word            PUSH    DE
1011   E53C 7A                              LD      A, D
1012   E53D CD 42 E5                        CALL    hex_out
1013   E540 D1                              POP     DE
1014   E541 7B                              LD      A, E                ; Fall into hex_out..
1015   E542             
1016   E542             ;------------------------------------------------------
1017   E542             ; Write the Hex value of A as two characters to conout
1018   E542             ;
1019   E542 4F          hex_out             LD      C, A
1020   E543 CB 3F                           SRL     A
1021   E545 CB 3F                           SRL     A
1022   E547 CB 3F                           SRL     A
1023   E549 CB 3F                           SRL     A
1024   E54B C5                              PUSH    BC
1025   E54C CD 51 E5                        CALL    _nibble
1026   E54F C1                              POP     BC
1027   E550 79                              LD      A, C
1028   E551             
1029   E551 E6 0F       _nibble             AND     $0F      ;LOW NIBBLE ONLY
1030   E553 C6 90                           ADD     A,$90
1031   E555 27                              DAA 
1032   E556 CE 40                           ADC     A,$40
1033   E558 27                              DAA 
1034   E559 4F                              LD      C,A
1035   E55A C3 2C EC                        JP      bios_conout
1036   E55D             
1037   E55D             
1038   E55D             ;------------------------------------------------------
1039   E55D             ; Only accept hex characters (0-9, a-f), or DELETE from the input
1040   E55D             ; Returns with character in A, a-f are capitalised
1041   E55D             ;
1042   E55D CD C6 EB    hex_char_in         CALL    bios_conin
1043   E560 FE 08                           CP      KEY_BACKSPACE
1044   E562 C8                              RET     Z
1045   E563 CD 69 E5                        CALL    valid_hex_char
1046   E566 38 F5                           JR      C, hex_char_in
1047   E568 C9                              RET
1048   E569             ;
1049   E569             ; Return with carry CLEAR if the character is a valid hex digit
1050   E569             ; Enter with A = character to test
1051   E569             ; Returns with A capitalised
1052   E569 FE 30       valid_hex_char      CP      '0'
1053   E56B D8                              RET     C
1054   E56C FE 3A                           CP      ':'
1055   E56E 3F                              CCF
1056   E56F D0                              RET     NC
1057   E570 FE 61                           CP      'a'
1058   E572 D8                              RET     C
1059   E573 FE 67                           CP      'g'
1060   E575 CB AF                           RES     5, a                ; Capitalise it..
1061   E577 3F                              CCF
1062   E578 C9                              RET
1063   E579             
1064   E579 FE 41       hex_char_to_num     CP      'A'
1065   E57B 30 03                           JR      NC, _alpha_char
1066   E57D D6 30                           SUB     '0'
1067   E57F C9                              RET
1068   E580 D6 37       _alpha_char         SUB     'A'-10
1069   E582 C9                              RET
1070   E583             
1071   E583             ;
1072   E583             ; Pause for BC ticks
1073   E583             ; Uses HL, DE
1074   E583             ;
1075   E583 ED 5B 04 FF pause_for_ticks     LD      DE, (timer)
1076   E587 C5          _pause_loop         PUSH    BC
1077   E588 D5                              PUSH    DE
1078   E589 CD 9D EB                        CALL    bios_conist
1079   E58C D1                              POP     DE
1080   E58D C1                              POP     BC
1081   E58E A7                              AND     A
1082   E58F C0                              RET     NZ
1083   E590 2A 04 FF                        LD      HL, (timer)
1084   E593 ED 52                           SBC     HL, DE
1085   E595 ED 42                           SBC     HL, BC
1086   E597 38 EE                           JR      C, _pause_loop
1087   E599 C9                              RET
1088   E59A             ;
1089   E59A             ; Detect (and time) interrupt
1090   E59A             ; Enter with A containing the mask for which bits of the timer byte we check for zero
1091   E59A             ; Return when the timer is zero, with BC containing 72 + 48*t-states taken
1092   E59A             ;
1093   E59A 01 00 00    detect_int          LD      BC, 0
1094   E59D 57                              LD      D, A
1095   E59E 3A 04 FF    _wait_for_tick      LD      A, (timer)               ; 13            ; Loop = 13+4+5+6+4+4+12 (=48) * BC + (13 + 4 + 11 + 13 + 4 + 17 + 10 (CALL)) = 72
1096   E5A1 A2                              AND     D                        ; 4
1097   E5A2 C8                              RET     Z                        ; 5 / 11
1098   E5A3 03                              INC     BC                       ; 6
1099   E5A4 79                              LD      A, C                     ; 4
1100   E5A5 B0                              OR      B                        ; 4
1101   E5A6 20 F6                           JR      NZ, _wait_for_tick       ; 7 / 12
1102   E5A8 C9                              RET
1103   E5A9             ;
1104   E5A9             ; Fast int routine to allow us to time CPU speed
1105   E5A9             ;
1106   E5A9 F3          timer_int           DI
1107   E5AA E5                              PUSH    HL
1108   E5AB 2A 04 FF                        LD      HL, (timer)
1109   E5AE 23                              INC     HL
1110   E5AF 22 04 FF                        LD      (timer), HL
1111   E5B2 E1                              POP     HL
1112   E5B3 FB                              EI
1113   E5B4 ED 4D                           RETI
1114   E5B6             
1115   E5B6             ; Divide HL by C (unsigned)
1116   E5B6             ;Inputs:
1117   E5B6             ;     HL is the numerator
1118   E5B6             ;     C is the denominator
1119   E5B6             ;Outputs:
1120   E5B6             ;     A is the remainder
1121   E5B6             ;     B is 0
1122   E5B6             ;     C is not changed
1123   E5B6             ;     DE is not changed
1124   E5B6             ;     HL is the quotient
1125   E5B6             ;
1126   E5B6             divide_hl_c
1127   E5B6 06 10                           LD      B, 16
1128   E5B8 AF                              XOR     A
1129   E5B9 29          _div0               ADD     HL, HL
1130   E5BA 17                              RLA
1131   E5BB B9                              CP      C
1132   E5BC 38 02                           JR      C,_div1
1133   E5BE 2C                              INC     L
1134   E5BF 91                              SUB     C
1135   E5C0 10 F7       _div1               DJNZ    _div0
1136   E5C2 C9                              RET
1137   E5C3             
1138   E5C3             ;
1139   E5C3             ; Convert DE to a five digit BCD value stored in bcd_scratch
1140   E5C3             ; 
1141   E5C3 AF          de_to_bcd           XOR     A
1142   E5C4 21 FB E5                        LD      HL, bcd_scratch
1143   E5C7 06 05                           LD      B, 5
1144   E5C9 77          _clear_scratch      LD      (HL), A
1145   E5CA 23                              INC     HL
1146   E5CB 10 FC                           DJNZ    _clear_scratch
1147   E5CD                 
1148   E5CD 06 10                           LD      B, 16           ; Convert 16 bits
1149   E5CF 0E 05       _bcd_loop           LD      C, 5
1150   E5D1 21 FB E5                        LD      HL, bcd_scratch
1151   E5D4 7E          _correct_digits     LD      A, (HL)
1152   E5D5 FE 05                           CP      5
1153   E5D7 38 03                           JR      C, _digit_ok
1154   E5D9 C6 03                           ADD     A, 3
1155   E5DB 77                              LD      (HL), A
1156   E5DC 23          _digit_ok           INC     HL
1157   E5DD 0D                              DEC     C
1158   E5DE 20 F4                           JR      NZ, _correct_digits                   
1159   E5E0             
1160   E5E0 21 FB E5                        LD      HL, bcd_scratch
1161   E5E3 0E 05                           LD      C, 5
1162   E5E5 CB 23                           SLA     E
1163   E5E7 CB 12                           RL      D
1164   E5E9             
1165   E5E9 7E          _shift_digits       LD      A, (HL)
1166   E5EA CB 17                           RL      A
1167   E5EC CB 67                           BIT     4, A
1168   E5EE 28 03                           JR      Z, _skip_carry
1169   E5F0 E6 0F                           AND     0Fh
1170   E5F2 37                              SCF
1171   E5F3 77          _skip_carry         LD      (HL), A
1172   E5F4 23                              INC     HL
1173   E5F5 0D                              DEC     C
1174   E5F6 20 F1                           JR      NZ, _shift_digits
1175   E5F8 10 D5                           DJNZ    _bcd_loop
1176   E5FA C9                              RET
1177   E5FB             
1178   E5FB 00 00 00 00 bcd_scratch         .DB      0,0,0,0,0      ; Five bytes - 0 to 99,999. Smallest digit (units) first
1178   E5FF 00 
1179   E600             
1180   E600                                 .INCLUDE  "monitor_rtc.asm"
0001+  E600             ;
0002+  E600             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0003+  E600             ;
0004+  E600             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0005+  E600             ;
0006+  E600             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0007+  E600             ; of this software and associated documentation files (the "Software"), to deal
0008+  E600             ; in the Software without restriction, including without limitation the rights
0009+  E600             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0010+  E600             ; copies of the Software, and to permit persons to whom the Software is
0011+  E600             ; furnished to do so, subject to the following conditions:
0012+  E600             ; 
0013+  E600             ; The above copyright notice and this permission notice shall be included in all
0014+  E600             ; copies or substantial portions of the Software.
0015+  E600             ; 
0016+  E600             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0017+  E600             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0018+  E600             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0019+  E600             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0020+  E600             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0021+  E600             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0022+  E600             ; SOFTWARE.
0023+  E600             ;
0024+  E600                                     .MODULE monitor_rtc
0025+  E600             
0026+  E600             _offset_sec             .EQU    0
0027+  E600             _offset_min             .EQU    1
0028+  E600             _offset_hour            .EQU    2
0029+  E600             _offset_wkday           .EQU    3
0030+  E600             _offset_date            .EQU    4
0031+  E600             _offset_month           .EQU    5
0032+  E600             _offset_year            .EQU    6
0033+  E600             
0034+  E600             
0035+  E600 21 CF F9    rtc_display_time        LD      HL, time_scratch
0036+  E603 CD A3 F9                            CALL    rtc_get_time_hl
0037+  E606 D2 D6 E6                            JP      NC, _get_error
0038+  E609             
0039+  E609 0E 0D                               LD      C, CARRIAGE_RETURN
0040+  E60B CD 2C EC                            CALL    bios_conout
0041+  E60E                                     
0042+  E60E 3A D2 F9                            LD      A, (time_scratch+_offset_wkday)
0043+  E611 21 8A E6                            LD      HL, weekdays
0044+  E614 4F                                  LD      C, A
0045+  E615             
0046+  E615 CD 74 E6                            CALL    _search_word
0047+  E618                                     
0048+  E618 CD 55 E6    _get_date               CALL    _space
0049+  E61B 3A D3 F9                            LD      A, (time_scratch+_offset_date)
0050+  E61E CD 52 E6                            CALL    _two_chars_space
0051+  E621             
0052+  E621 3A D4 F9                            LD      A, (time_scratch+_offset_month)
0053+  E624 21 A6 E6                            LD      HL, _months
0054+  E627 CB 67                               BIT     4, A
0055+  E629 28 02                               JR      Z, _month_ok
0056+  E62B D6 06                               SUB     6
0057+  E62D 4F          _month_ok               LD      C,A
0058+  E62E             
0059+  E62E CD 74 E6                            CALL    _search_word
0060+  E631 CD 55 E6                            CALL    _space
0061+  E634 3E 20                               LD      A, 20h
0062+  E636 CD 5A E6                            CALL    _two_chars
0063+  E639             
0064+  E639 3A D5 F9                            LD      A, (time_scratch+_offset_year)
0065+  E63C CD 52 E6                            CALL    _two_chars_space
0066+  E63F             
0067+  E63F 3A D1 F9                            LD      A, (time_scratch+_offset_hour)
0068+  E642 CD 52 E6                            CALL    _two_chars_space
0069+  E645             
0070+  E645 3A D0 F9                            LD      A, (time_scratch+_offset_min)
0071+  E648 CD 52 E6                            CALL    _two_chars_space
0072+  E64B             
0073+  E64B 3A CF F9                            LD      A, (time_scratch+_offset_sec)
0074+  E64E CD 5A E6                            CALL    _two_chars
0075+  E651 C9                                  RET
0076+  E652             
0077+  E652 CD 5A E6    _two_chars_space       CALL    _two_chars
0078+  E655 0E 20       _space                  LD      C, ' '
0079+  E657 C3 2C EC                            JP      bios_conout
0080+  E65A             
0081+  E65A 4F          _two_chars              LD      C,A
0082+  E65B CB 3F                               SRL     A
0083+  E65D CB 3F                               SRL     A
0084+  E65F CB 3F                               SRL     A
0085+  E661 CB 3F                               SRL     A
0086+  E663 C6 30                               ADD     A, '0'
0087+  E665 C5                                  PUSH    BC
0088+  E666 4F                                  LD      C, A
0089+  E667 CD 2C EC                            CALL    bios_conout
0090+  E66A C1                                  POP     BC
0091+  E66B 79                                  LD      A,C
0092+  E66C E6 0F                               AND     0fh
0093+  E66E C6 30                               ADD     A, '0'
0094+  E670 4F                                  LD      C, A
0095+  E671 C3 2C EC                            JP      bios_conout
0096+  E674             ;
0097+  E674             ; Search table pointed to by HL for the C'th word (1-based)
0098+  E674             ; Prints the chosen word to conout
0099+  E674             ;
0100+  E674 0D          _search_word            DEC     C
0101+  E675 20 0C                               JR      NZ, _next_char
0102+  E677                                     
0103+  E677 7E          _print_word             LD      A, (HL)
0104+  E678 23                                  INC     HL
0105+  E679 A7                                  AND     A
0106+  E67A C8                                  RET     Z
0107+  E67B 4F                                  LD      C, A
0108+  E67C E5                                  PUSH    HL
0109+  E67D CD 2C EC                            CALL    bios_conout
0110+  E680 E1                                  POP     HL
0111+  E681 18 F4                               JR      _print_word
0112+  E683             
0113+  E683 7E          _next_char              LD      A, (HL)
0114+  E684 23                                  INC     HL
0115+  E685 A7                                  AND     A
0116+  E686 20 FB                               JR      NZ, _next_char
0117+  E688 18 EA                               JR      _search_word
0118+  E68A             
0119+  E68A             
0120+  E68A 4D 6F 6E 00 weekdays                .DB "Mon",0
0121+  E68E 54 75 65 00                         .DB "Tue",0
0122+  E692 57 65 64 00                         .DB "Wed",0
0123+  E696 54 68 75 00                         .DB "Thu",0
0124+  E69A 46 72 69 00                         .DB "Fri",0
0125+  E69E 53 61 74 00                         .DB "Sat",0
0126+  E6A2 53 75 6E 00                         .DB "Sun",0
0127+  E6A6             
0128+  E6A6 4A 61 6E 00 _months                 .DB "Jan",0
0129+  E6AA 46 65 62 00                         .DB "Feb",0
0130+  E6AE 4D 61 72 00                         .DB "Mar",0
0131+  E6B2 41 70 72 00                         .DB "Apr",0
0132+  E6B6 4D 61 79 00                         .DB "May",0
0133+  E6BA 4A 75 6E 00                         .DB "Jun",0
0134+  E6BE 4A 75 6C 00                         .DB "Jul",0
0135+  E6C2 41 75 67 00                         .DB "Aug",0
0136+  E6C6 53 65 70 00                         .DB "Sep",0
0137+  E6CA 4F 63 74 00                         .DB "Oct",0
0138+  E6CE 4E 6F 76 00                         .DB "Nov",0
0139+  E6D2 44 65 63 00                         .DB "Dec",0
0140+  E6D6             
0141+  E6D6             
0142+  E6D6 CD CE F5    _get_error              CALL    i2c_stop
0143+  E6D9 CD 30 F0                            CALL    m_print_inline 
0144+  E6DC 45 72 72 6F                         .DB     "Error getting time\r\n", 0
0144+  E6E0 72 20 67 65 
0144+  E6E4 74 74 69 6E 
0144+  E6E8 67 20 74 69 
0144+  E6EC 6D 65 0D 0A 
0144+  E6F0 00 
0145+  E6F1 AF                                  XOR     A
0146+  E6F2 C9                                  RET
0147+  E6F3             
0148+  E6F3                                     .MODULE main1181   E6F3                                 .INCLUDE "ymodem.asm"
0001+  E6F3             ;
0002+  E6F3             ; YModem implementation.
0003+  E6F3             ; File format: The filename MAY indicate the load address in memory for the file. If so, the format is:
0004+  E6F3             ;       filename_mHHHH.suffix
0005+  E6F3             ;    or filename_pHH.suffix
0006+  E6F3             ;
0007+  E6F3             ; Where:  _mHHHH indicates a preferred destination address of HHHH (in memory) - four digits hexadecimal value (uppercase).
0008+  E6F3             ;   or    _pHH   indicates the page in memory that the file is intended for (assumes start at offset 0 in page..)
0009+  E6F3             ;
0010+  E6F3             ; When _p is used, the file is always written to bank 1 - address 4000h. It is expected that the calling program will
0011+  E6F3             ; then copy the data to the target page, which can be retrieved from the ym_file_mode return value.
0012+  E6F3             ; 
0013+  E6F3             ;
0014+  E6F3             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0015+  E6F3             ;
0016+  E6F3             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0017+  E6F3             ;
0018+  E6F3             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0019+  E6F3             ; of this software and associated documentation files (the "Software"), to deal
0020+  E6F3             ; in the Software without restriction, including without limitation the rights
0021+  E6F3             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0022+  E6F3             ; copies of the Software, and to permit persons to whom the Software is
0023+  E6F3             ; furnished to do so, subject to the following conditions:
0024+  E6F3             ; 
0025+  E6F3             ; The above copyright notice and this permission notice shall be included in all
0026+  E6F3             ; copies or substantial portions of the Software.
0027+  E6F3             ; 
0028+  E6F3             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0029+  E6F3             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0030+  E6F3             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0031+  E6F3             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0032+  E6F3             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0033+  E6F3             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0034+  E6F3             ; SOFTWARE.
0035+  E6F3             ;
0036+  E6F3             
0037+  E6F3                                 .MODULE ymodem
0038+  E6F3             
0039+  E6F3             _PAGE_PREFIX        .EQU    'p'
0040+  E6F3             _DEST_PREFIX        .EQU    'm'
0041+  E6F3             
0042+  E6F3             ; Return values
0043+  E6F3             YMODEM_SUCCESS      .EQU    000h
0044+  E6F3             YMODEM_TIMEOUT      .EQU    001h
0045+  E6F3             YMODEM_UNKNOWN      .EQU    002h            ; Unknown packet type (Packet byte in C)
0046+  E6F3             YMODEM_CANCEL       .EQU    003h            ; Cancelled by sender
0047+  E6F3             YMODEM_PACKET_ERROR .EQU    004h            ; Packet data error (Error code in C)
0048+  E6F3             YMODEM_LENGTH_ERROR .EQU    005h            ; Length data in zeroth packet is invalid
0049+  E6F3             YMODEM_NO_DEST      .EQU    006h            ; No destination provided
0050+  E6F3             YMODEM_SEND_TIMEOUT .EQU    007h
0051+  E6F3             YMODEM_MULTI_FILES  .EQU    008h            ; Cannot receive more than one file 
0052+  E6F3             
0053+  E6F3             _SOH                .EQU    001h            ; 128 byte data packet header
0054+  E6F3             _STX                .EQU    002h            ; 1024 byte data packet header
0055+  E6F3             _EOT                .EQU    004h            ; End transfer
0056+  E6F3             _ACK                .EQU    006h            ; Respond
0057+  E6F3             _NAK                .EQU    015h            ; No response
0058+  E6F3             _CAN                .EQU    018h            ; Transmission aborted
0059+  E6F3             _C                  .EQU    043h            ; Request packet
0060+  E6F3             
0061+  E6F3             _SOH_PACKET_SIZE    .EQU    128
0062+  E6F3             _STX_PACKET_SIZE    .EQU    1024
0063+  E6F3             _FRAME_OVERHEAD     .EQU    5               ; Three byte header + two byte CRC (high byte first)
0064+  E6F3             
0065+  E6F3             _TIMEOUT_COUNT      .EQU    50000
0066+  E6F3             
0067+  E6F3             _ERR_PACKET_COUNT   .EQU    1               ; Wrong packet index
0068+  E6F3             _ERR_CHECK_HIGH     .EQU    2               ; High byte of CRC failed
0069+  E6F3             _ERR_CHECK_LOW      .EQU    3               ; Low byte of CRC failed
0070+  E6F3             _ERR_CANCEL         .EQU    4               ; Got a cancel request without second cancel
0071+  E6F3             _ERR_ZERO_PACKET    .EQU    5               ; Zeroth packet must be SOH
0072+  E6F3             
0073+  E6F3             YM_DEST_FROM_FILE   .EQU    0FEh            ; File destination set from filename
0074+  E6F3             
0075+  E6F3             ymodem_data_length  .EQU    17              ; Size of data block before buffer
0076+  E6F3             
0077+  E6F3             ym_file_mode        .EQU    -17             ; FFh : Normal transfer,  FEh : Destination set by file, 0-7Fh : Page write 
0078+  E6F3             ym_file_count       .EQU    -16
0079+  E6F3             ym_length_low       .EQU    -15             ; Length specified in header packet
0080+  E6F3             ym_length_mid       .EQU    -14
0081+  E6F3             ym_length_high      .EQU    -13
0082+  E6F3             ym_loaded_high      .EQU    -12             ; Tracks high byte of length during load.
0083+  E6F3             ym_soh_saved_len    .EQU    -11             ; We have to copy part of a final SOH packet from the buffer - track actual length needed
0084+  E6F3             ym_soh_saved_len_h  .EQU    -10 
0085+  E6F3             ym_current_page     .EQU    -9              ; FFh if no paging, otherwise page to send data to
0086+  E6F3             ym_dest_low         .EQU    -8              ; If specified in file header - the destination address of the file
0087+  E6F3             ym_dest_high        .EQU    -7
0088+  E6F3             ym_current_packet   .EQU    -6              ; Expected packet number
0089+  E6F3             ym_packet_type      .EQU    -5              ; Packet type - SOH/STX
0090+  E6F3             ym_packet_num       .EQU    -4              ; Packet number we're currently receiving
0091+  E6F3             ym_packet_num_cpl   .EQU    -3              ; Complement..
0092+  E6F3             ym_crc_low          .EQU    -2              ; CRC Low byte
0093+  E6F3             ym_crc_high         .EQU    -1              ; CRC High byte
0094+  E6F3             
0095+  E6F3             YMODEM_BUFFER       .EQU    _SOH_PACKET_SIZE + ymodem_data_length
0096+  E6F3             YMODEM_INFO         .EQU    _SOH_PACKET_SIZE
0097+  E6F3             
0098+  E6F3             ;
0099+  E6F3             ; ymodem - Main entry point. Call with:
0100+  E6F3             ;     HL = Address of YMODEM_BUFFER (=128 + ymodem_data_length) byte buffer for receiving data
0101+  E6F3             ;     DE = (Optional) address to write data. 0xFFFF to accept destination from filename otherwise
0102+  E6F3             ;      A = Page to write data. 0xFF to disable paging/accept page from filename otherwise
0103+  E6F3             ;
0104+  E6F3             ; If using A to set a Page destination, DE should be an offset within Bank 1 (ie 4000h - 7FFFh)
0105+  E6F3             ; If the file specifies a page destination, DE is initialised to 4000h - the start of the page
0106+  E6F3             ;
0107+  E6F3             ; Returns status code in A:
0108+  E6F3             ;     YMODEM_SUCCESS : (=0) If the file was successfully received
0109+  E6F3             ;     YMODEM_xxxx    : (Non zero) If the receiver timed out waiting for a byte
0110+  E6F3             ;
0111+  E6F3             ; Note Bank 1 may have been set to a new page destination if one was specified.
0112+  E6F3             
0113+  E6F3 01 11 00    ymodem              LD      BC, ymodem_data_length      ; Skip data block at start of buffer
0114+  E6F6 09                              ADD     HL, BC
0115+  E6F7 E5                              PUSH    HL
0116+  E6F8 DD E1                           POP     IX
0117+  E6FA DD 77 F7                        LD      (IX+ym_current_page), A
0118+  E6FD DD 77 EF                        LD      (IX+ym_file_mode), A           ; Default normal transfer, 0FFh, else page 
0119+  E700 AF                              XOR     A                           
0120+  E701 DD 77 F0                        LD      (IX+ym_file_count), A
0121+  E704 3D                              DEC     A
0122+  E705 DD 73 F8                        LD      (IX+ym_dest_low), E
0123+  E708 DD 72 F9                        LD      (IX+ym_dest_high), D
0124+  E70B             
0125+  E70B AF          _ymodem_start       XOR     A                           ; Set initial packet number
0126+  E70C DD 77 FA                        LD      (IX+ym_current_packet), A
0127+  E70F FD 21 FF FF                     LD      IY, 0FFFFh                  ; IY - bytes to load. Default - load all bytes
0128+  E713             
0129+  E713                                 ; Now we can load.
0130+  E713                                 ; DE = destination
0131+  E713                                 ; IY = low 16 bits of length
0132+  E713                                 ; IX = load buffer
0133+  E713             
0134+  E713 CD A0 E9    _packet_loop        CALL    _recieve_safe
0135+  E716 20 07                           JR      NZ, _packet_byte
0136+  E718 3E 43       _send_crc_and_loop  LD      A, _C
0137+  E71A CD CB E9                        CALL    _send_byte
0138+  E71D 18 F4                           JR      _packet_loop
0139+  E71F             
0140+  E71F FE 01       _packet_byte        CP      _SOH
0141+  E721 C2 2C E7                        JP      NZ, _check_stx
0142+  E724             
0143+  E724 DD E5                           PUSH    IX                          ; SOH - May be zero'th or last packet
0144+  E726 E1                              POP     HL
0145+  E727 01 80 00                        LD      BC, _SOH_PACKET_SIZE
0146+  E72A 18 40                           JR      _receive_packet
0147+  E72C             
0148+  E72C FE 02       _check_stx          CP      _STX
0149+  E72E 20 07                           JR      NZ, _check_eot
0150+  E730                                                                     
0151+  E730 62                              LD      H, D                        ; STX packets go straight to DE
0152+  E731 6B                              LD      L, E
0153+  E732 01 00 04                        LD      BC, _STX_PACKET_SIZE    
0154+  E735 18 35                           JR      _receive_packet
0155+  E737             
0156+  E737 FE 04       _check_eot          CP      _EOT
0157+  E739 20 0A                           JR      NZ, _check_can
0158+  E73B                                                                     ; End of transmission
0159+  E73B 3E 06                           LD      A, _ACK 
0160+  E73D CD CB E9                        CALL    _send_byte
0161+  E740             
0162+  E740 DD 34 F0                        INC     (IX+ym_file_count)      
0163+  E743 18 C6                           JR      _ymodem_start  
0164+  E745             
0165+  E745 FE 18       _check_can          CP      _CAN
0166+  E747 20 1E                           JR      NZ, _unknown_packet
0167+  E749                                                                     ; Single cancel request. Check for another
0168+  E749 CD AB E9                        CALL    _receive_byte
0169+  E74C FE 18                           CP      _CAN
0170+  E74E 3E 04                           LD      A, _ERR_CANCEL
0171+  E750 20 10                           JR      NZ, _packet_error
0172+  E752             
0173+  E752 3E 06                           LD      A, _ACK 
0174+  E754 CD CB E9                        CALL    _send_byte
0175+  E757 CD A0 E9    _purge              CALL    _recieve_safe               ; Purge remains of any cancel request
0176+  E75A 20 FB                           JR      NZ, _purge
0177+  E75C             
0178+  E75C 3E 03                           LD      A, YMODEM_CANCEL
0179+  E75E A7                              AND     A
0180+  E75F C9                              RET
0181+  E760             
0182+  E760 3E 05       _zero_error         LD      A, _ERR_ZERO_PACKET
0183+  E762 4F          _packet_error       LD      C, A                        ; Packet data error - return error code in C
0184+  E763 3E 04                           LD      A, YMODEM_PACKET_ERROR
0185+  E765 A7                              AND     A
0186+  E766 C9                              RET
0187+  E767             
0188+  E767 4F          _unknown_packet     LD      C, A                        ; Unknown packet type - return header byte in C
0189+  E768 3E 02                           LD      A, YMODEM_UNKNOWN
0190+  E76A A7                              AND     A
0191+  E76B C9                              RET     
0192+  E76C             
0193+  E76C             ; Receive data for both SOH and STX packets..
0194+  E76C             ; At this point HL is destination (either DE or IX-buffer), and BC is a byte count
0195+  E76C             ;
0196+  E76C DD 77 FB    _receive_packet     LD      (IX+ym_packet_type), A   
0197+  E76F             
0198+  E76F DD 7E F7                        LD      A, (IX+ym_current_page)
0199+  E772 FE FF                           CP      0FFh
0200+  E774 28 02                           JR      Z, _no_page_specified
0201+  E776 D3 71                           OUT     (IO_MEM_1), A
0202+  E778             
0203+  E778 AF          _no_page_specified  XOR     A
0204+  E779 DD 77 F5                        LD      (IX+ym_soh_saved_len), A     ; Reset how many bytes of an SOH packet we actually loaded..
0205+  E77C DD 77 F6                        LD      (IX+ym_soh_saved_len_h), A
0206+  E77F             
0207+  E77F DD BE FA                        CP      (IX+ym_current_packet)         ; If this is the zeroth packet, it must be SOH
0208+  E782 20 07                           JR      NZ, _not_zeroth_packet
0209+  E784 3E 01                           LD      A, _SOH
0210+  E786 DD 96 FB                        SUB     (IX+ym_packet_type)            ; Leave A as zero if this is OK
0211+  E789 20 D5                           JR      NZ, _zero_error
0212+  E78B             
0213+  E78B DD 77 FF    _not_zeroth_packet  LD      (IX+ym_crc_high), A
0214+  E78E DD 77 FE                        LD      (IX+ym_crc_low), A
0215+  E791             
0216+  E791 CD AB E9                        CALL    _receive_byte   
0217+  E794 DD 77 FC                        LD      (IX+ym_packet_num), A
0218+  E797 CD AB E9                        CALL    _receive_byte   
0219+  E79A DD 77 FD                        LD      (IX+ym_packet_num_cpl), A
0220+  E79D             
0221+  E79D 7D          _data_loop          LD      A, L                        ; Handle paging if we're loading into paged memory..
0222+  E79E A7                              AND     A
0223+  E79F 20 12                           JR      NZ, _data_receive
0224+  E7A1 7C                              LD      A, H
0225+  E7A2 FE 80                           CP      80h
0226+  E7A4 20 0D                           JR      NZ, _data_receive
0227+  E7A6 DD 7E F7                        LD      A, (IX+ym_current_page)
0228+  E7A9 3C                              INC     A
0229+  E7AA 28 07                           JR      Z, _data_receive           ; Paging disabled
0230+  E7AC             
0231+  E7AC DD 77 F7                        LD      (IX+ym_current_page), A        ; Move to next page
0232+  E7AF D3 71                           OUT     (IO_MEM_1), A
0233+  E7B1 26 40                           LD      H, 40h
0234+  E7B3                                 
0235+  E7B3 CD AB E9    _data_receive       CALL    _receive_byte
0236+  E7B6             
0237+  E7B6 77                              LD      (HL), A
0238+  E7B7             
0239+  E7B7 CD 6D E9                        CALL    _calc_checksum  
0240+  E7BA             
0241+  E7BA C5                              PUSH    BC                          ; Count down the bytes remaining, and once we get to zero, send bytes to _dev_null
0242+  E7BB 01 FF FF                        LD      BC, -1
0243+  E7BE FD 09                           ADD     IY, BC                      ; Carry set if IY not zero
0244+  E7C0 C1                              POP     BC
0245+  E7C1 38 10                           JR      C, _in_range
0246+  E7C3             
0247+  E7C3 DD 35 F4                        DEC     (IX+ym_loaded_high)
0248+  E7C6 F2 D3 E7                        JP      P, _in_range
0249+  E7C9                  
0250+  E7C9 DD 34 F4                        INC     (IX+ym_loaded_high)      ; Keep resetting counter...
0251+  E7CC FD 23                           INC     IY
0252+  E7CE 21 9F E9                        LD      HL, _dev_null
0253+  E7D1 18 09                           JR      _do_next
0254+  E7D3             
0255+  E7D3 DD 34 F5    _in_range           INC     (IX+ym_soh_saved_len)
0256+  E7D6 20 03                           JR      NZ, _packet_part_ok
0257+  E7D8 DD 34 F6                        INC     (IX+ym_soh_saved_len_h)
0258+  E7DB 23          _packet_part_ok     INC     HL
0259+  E7DC             
0260+  E7DC 0B          _do_next            DEC     BC
0261+  E7DD             
0262+  E7DD 78                              LD      A, B
0263+  E7DE B1                              OR      C
0264+  E7DF 20 BC                           JR      NZ, _data_loop
0265+  E7E1             
0266+  E7E1 AF                              XOR     A
0267+  E7E2 CD 6D E9                        CALL    _calc_checksum  
0268+  E7E5 AF                              XOR     A
0269+  E7E6 CD 6D E9                        CALL    _calc_checksum  
0270+  E7E9             
0271+  E7E9 CD AB E9                        CALL    _receive_byte
0272+  E7EC 47                              LD      B, A
0273+  E7ED CD AB E9                        CALL    _receive_byte   
0274+  E7F0 4F                              LD      C, A
0275+  E7F1             ;
0276+  E7F1             ; Now do checks...
0277+  E7F1             
0278+  E7F1 DD 7E FC                        LD      A, (IX+ym_packet_num)
0279+  E7F4 2F                              CPL
0280+  E7F5 DD BE FD                        CP      (IX+ym_packet_num_cpl)
0281+  E7F8 3E 01                           LD      A, _ERR_PACKET_COUNT
0282+  E7FA C2 62 E7                        JP      NZ, _packet_error
0283+  E7FD DD 7E FF                        LD      A, (IX+ym_crc_high)
0284+  E800 B8                              CP      B
0285+  E801 3E 02                           LD      A, _ERR_CHECK_HIGH
0286+  E803 C2 62 E7                        JP      NZ, _packet_error
0287+  E806 DD 7E FE                        LD      A, (IX+ym_crc_low)
0288+  E809 B9                              CP      C
0289+  E80A 3E 03                           LD      A, _ERR_CHECK_LOW
0290+  E80C C2 62 E7                        JP      NZ, _packet_error
0291+  E80F             
0292+  E80F             ; CRC and packet number check out... 
0293+  E80F DD 7E FC                        LD      A, (IX+ym_packet_num)
0294+  E812 DD BE FA                        CP      (IX+ym_current_packet)
0295+  E815 20 23                           JR      NZ, _retry_packet               ; We need to restore IY (length) if we wish to survive.. DE is not updated until later, so OK
0296+  E817 DD 34 FA                        INC     (IX+ym_current_packet)
0297+  E81A A7                              AND     A
0298+  E81B 28 4A                           JR      Z, _header_packet
0299+  E81D             
0300+  E81D DD 7E FB                        LD      A, (IX+ym_packet_type)
0301+  E820 FE 01                           CP      _SOH
0302+  E822 20 0C                           JR      NZ, _not_soh
0303+  E824             
0304+  E824             ; SOH packets must be copied to DE -> 
0305+  E824 DD 4E F5                        LD      C, (IX+ym_soh_saved_len)
0306+  E827 06 00                           LD      B, 0
0307+  E829 DD E5                           PUSH    IX
0308+  E82B E1                              POP     HL
0309+  E82C ED B0                           LDIR
0310+  E82E 18 02                           JR      _send_ack
0311+  E830             
0312+  E830 54          _not_soh            LD      D, H
0313+  E831 5D                              LD      E, L
0314+  E832 3E 06       _send_ack           LD      A, _ACK 
0315+  E834 CD CB E9    _send_and_loop      CALL    _send_byte
0316+  E837 C3 18 E7                        JP      _send_crc_and_loop      
0317+  E83A             
0318+  E83A AF          _retry_packet       XOR     A                           ; Clear carry
0319+  E83B ED 52                           SBC     HL, DE
0320+  E83D 30 0D                           JR      NC, _retry_page_ok          
0321+  E83F             
0322+  E83F DD 7E F7                        LD      A,(IX+ym_current_page)         ; If HL (latest write dest) is less than DE (write dest at start of packet) assume we've changed pages..
0323+  E842 FE FF                           CP      0FFH
0324+  E844 28 06                           JR      Z, _retry_page_ok           ; We're not paging anyway...
0325+  E846 3D                              DEC     A 
0326+  E847 DD 77 F7                        LD      (IX+ym_current_page), A
0327+  E84A D3 71                           OUT     (IO_MEM_1),A
0328+  E84C             
0329+  E84C DD 4E F5    _retry_page_ok      LD      C, (IX+ym_soh_saved_len)     ; Restore IY (length)
0330+  E84F DD 46 F6                        LD      B, (IX+ym_soh_saved_len_h)
0331+  E852 FD E5                           PUSH    IY
0332+  E854 E1                              POP     HL
0333+  E855 09                              ADD     HL, BC
0334+  E856 30 03                           JR      NC, _retry_iy_ok
0335+  E858 DD 34 F4                        INC     (IX+ym_loaded_high)
0336+  E85B E5          _retry_iy_ok        PUSH    HL
0337+  E85C FD E1                           POP     IY
0338+  E85E                                                                     ; TODO: If we've changed the page, that needs to be restored as well
0339+  E85E             
0340+  E85E             
0341+  E85E CD A0 E9    _retry_drain        CALL   _recieve_safe                ; Drain the incoming stream before sending nak
0342+  E861 20 FB                           JR      NZ, _retry_drain
0343+  E863             
0344+  E863 3E 15                           LD      A, _NAK
0345+  E865 18 CD                           JR      _send_and_loop
0346+  E867             
0347+  E867             
0348+  E867 DD E5       _header_packet      PUSH    IX
0349+  E869 E1                              POP     HL
0350+  E86A 7E                              LD      A, (HL)                     ; Empty zeroth packet means end of batch send
0351+  E86B A7                              AND     A
0352+  E86C 20 09                           JR      NZ, _check_filecount
0353+  E86E             
0354+  E86E 3E 06                           LD      A, _ACK 
0355+  E870 CD CB E9                        CALL    _send_byte
0356+  E873 3E 00                           LD      A, YMODEM_SUCCESS   
0357+  E875 A7                              AND     A
0358+  E876 C9                              RET
0359+  E877             
0360+  E877 DD 7E F0    _check_filecount    LD      A, (IX+ym_file_count)
0361+  E87A A7                              AND     A
0362+  E87B 28 04                           JR      Z, _next_filechar
0363+  E87D             
0364+  E87D 3E 08                           LD      A, YMODEM_MULTI_FILES
0365+  E87F A7                              AND     A
0366+  E880 C9                              RET
0367+  E881             
0368+  E881 7E          _next_filechar      LD      A, (HL)
0369+  E882 23                              INC     HL
0370+  E883 A7          _check_char         AND     A
0371+  E884 28 71                           JR      Z, _read_length
0372+  E886 FE 5F                           CP      '_'                     ; Check for special transfer modes
0373+  E888 20 F7                           JR      NZ, _next_filechar
0374+  E88A 7E                              LD      A, (HL)
0375+  E88B 4F                              LD      C, A                    ; Remember the prefix char in C
0376+  E88C 23                              INC     HL
0377+  E88D FE 6D                           CP      _DEST_PREFIX
0378+  E88F 20 07                           JR      NZ, _check_flash
0379+  E891 06 04                           LD      B, 4
0380+  E893 11 00 00                        LD      DE, 0
0381+  E896 18 09                           JR      _parse_dest
0382+  E898             
0383+  E898 FE 70       _check_flash        CP      _PAGE_PREFIX
0384+  E89A 20 E7                           JR      NZ, _check_char
0385+  E89C 06 02                           LD      B, 2
0386+  E89E 11 00 00                        LD      DE, 0
0387+  E8A1             
0388+  E8A1 7E          _parse_dest         LD      A, (HL)
0389+  E8A2 23                              INC     HL
0390+  E8A3 D6 30                           SUB     '0'
0391+  E8A5 38 48                           JR      C, _invalid_dest
0392+  E8A7 FE 0A                           CP      10
0393+  E8A9 38 08                           JR      C, _digit_checked
0394+  E8AB D6 07                           SUB     7
0395+  E8AD 38 40                           JR      C, _invalid_dest
0396+  E8AF FE 10                           CP      16
0397+  E8B1 30 3C                           JR      NC, _invalid_dest
0398+  E8B3             
0399+  E8B3 E5          _digit_checked      PUSH    HL                          ; Shift existing dest left 4 bits and merge new hex digit
0400+  E8B4 62                              LD      H, D
0401+  E8B5 6B                              LD      L, E
0402+  E8B6 29                              ADD     HL, HL
0403+  E8B7 29                              ADD     HL, HL
0404+  E8B8 29                              ADD     HL, HL
0405+  E8B9 29                              ADD     HL, HL
0406+  E8BA B5                              OR      L
0407+  E8BB 54                              LD      D, H
0408+  E8BC 5F                              LD      E, A
0409+  E8BD E1                              POP     HL
0410+  E8BE 10 E1                           DJNZ    _parse_dest
0411+  E8C0             
0412+  E8C0 79                              LD      A, C                        ; Which char did we start with?
0413+  E8C1 FE 70                           CP      _PAGE_PREFIX
0414+  E8C3 20 12                           JR      NZ, _memory_dest
0415+  E8C5             
0416+  E8C5 DD 7E F7                        LD      A, (IX+ym_current_page)        ; Page prefix. Use original value if set when ymodem was called
0417+  E8C8 FE FF                           CP      0FFh
0418+  E8CA 20 B5                           JR      NZ, _next_filechar
0419+  E8CC             
0420+  E8CC DD 73 EF                        LD      (IX+ym_file_mode), E           ; Otherwise use the file specified value and load from 4000h
0421+  E8CF DD 73 F7                        LD      (IX+ym_current_page), E
0422+  E8D2 11 00 40                        LD      DE,04000h    
0423+  E8D5 18 10                           JR      _store_dest
0424+  E8D7             
0425+  E8D7 3E FF       _memory_dest        LD      A, 0FFh                     ; Only set the dest from the filename if 
0426+  E8D9 DD BE F8                        CP      (IX+ym_dest_low)               ; the routine was called with a destination of 0FFFFh
0427+  E8DC 20 A3                           JR      NZ, _next_filechar
0428+  E8DE DD BE F9                        CP      (IX+ym_dest_high)
0429+  E8E1 20 9E                           JR      NZ, _next_filechar
0430+  E8E3             
0431+  E8E3 DD 36 EF FE                     LD      (IX+ym_file_mode), YM_DEST_FROM_FILE
0432+  E8E7             
0433+  E8E7 DD 73 F8    _store_dest         LD      (IX+ym_dest_low), E
0434+  E8EA DD 72 F9                        LD      (IX+ym_dest_high), D
0435+  E8ED             
0436+  E8ED 18 92                           JR      _next_filechar
0437+  E8EF             
0438+  E8EF DD 5E F8    _invalid_dest       LD      E, (IX+ym_dest_low)            ; We silently skip invalid destination values
0439+  E8F2 DD 56 F9                        LD      D, (IX+ym_dest_high)
0440+  E8F5 18 8A                           JR      _next_filechar
0441+  E8F7             
0442+  E8F7 3E FF       _read_length        LD      A, 0FFh                     ; At this point we should have a valid destination
0443+  E8F9 DD BE F8                        CP      (IX+ym_dest_low)               
0444+  E8FC 20 09                           JR      NZ, _dest_ok
0445+  E8FE DD BE F9                        CP      (IX+ym_dest_high)
0446+  E901 20 04                           JR      NZ, _dest_ok
0447+  E903             
0448+  E903 3E 06                           LD      A, YMODEM_NO_DEST
0449+  E905 A7                              AND     A
0450+  E906 C9                              RET
0451+  E907             
0452+  E907 3E FF       _dest_ok            LD      A, 0FFh
0453+  E909 DD 77 F1                        LD      (IX+ym_length_low), A       ; Reset the length counter///
0454+  E90C DD 77 F2                        LD      (IX+ym_length_mid), A
0455+  E90F DD 77 F3                        LD      (IX+ym_length_high), A         
0456+  E912 DD 77 F4                        LD      (IX+ym_loaded_high), A
0457+  E915 FD 21 FF FF                     LD      IY, 0FFFFh 
0458+  E919 44                              LD      B, H
0459+  E91A 4D                              LD      C, L               
0460+  E91B 21 00 00                        LD      HL, 0
0461+  E91E 0A                              LD      A, (BC)                     ; Length is optional
0462+  E91F A7                              AND     A
0463+  E920 CA 32 E8                        JP      Z, _send_ack
0464+  E923             
0465+  E923 0A          _parse_length       LD      A, (BC)
0466+  E924 03                              INC     BC
0467+  E925 A7                              AND     A
0468+  E926 28 2F                           JR      Z, _length_end
0469+  E928 FE 20                           CP      ' '
0470+  E92A 28 2B                           JR      Z, _length_end
0471+  E92C D6 30                           SUB     '0'
0472+  E92E 38 39                           JR      C, _invalid_length
0473+  E930 FE 0A                           CP      10
0474+  E932 30 35                           JR      NC, _invalid_length
0475+  E934             
0476+  E934 C5                              PUSH    BC
0477+  E935 D5                              PUSH    DE
0478+  E936 F5                              PUSH    AF
0479+  E937             
0480+  E937 EB                              EX      DE, HL              ; HL into DE 
0481+  E938 3E 0A                           LD      A, 10
0482+  E93A             
0483+  E93A                                 ; DE x A  -> AHL  (from http://z80-heaven.wikidot.com/advanced-math#toc12)
0484+  E93A                                 ; preserves DE
0485+  E93A 01 00 08                        LD      BC, 0800h
0486+  E93D 61                              LD      H, C
0487+  E93E 69                              LD      L, C
0488+  E93F 29          _pl_loop            ADD     HL, HL
0489+  E940 17                              RLA
0490+  E941 30 02                           JR      NC, _pl_skip
0491+  E943 19                              ADD     HL, DE
0492+  E944 89                              ADC     A, C
0493+  E945 10 F8       _pl_skip            DJNZ    _pl_loop
0494+  E947             
0495+  E947 DD 77 F3                        LD      (IX+ym_length_high), A     ; Note we only handle overflow for one digit.. max value 655,359?
0496+  E94A F1                              POP     AF
0497+  E94B 5F                              LD      E, A
0498+  E94C 51                              LD      D, C
0499+  E94D 19                              ADD     HL, DE
0500+  E94E 30 03                           JR      NC, _pl_length_ok
0501+  E950 DD 34 F3                        INC     (IX+ym_length_high)
0502+  E953             
0503+  E953 D1          _pl_length_ok       POP     DE
0504+  E954 C1                              POP     BC
0505+  E955 18 CC                           JR      _parse_length
0506+  E957             
0507+  E957 E5          _length_end         PUSH    HL
0508+  E958 FD E1                           POP     IY
0509+  E95A DD 75 F1                        LD      (IX+ym_length_low), L
0510+  E95D DD 74 F2                        LD      (IX+ym_length_mid), H
0511+  E960 DD 7E F3                        LD      A, (IX+ym_length_high)
0512+  E963 DD 77 F4                        LD      (IX+ym_loaded_high), A
0513+  E966 C3 32 E8                        JP      _send_ack
0514+  E969             
0515+  E969 3E 05       _invalid_length     LD      A, YMODEM_LENGTH_ERROR      ; Hard fail on invalid length data
0516+  E96B A7                              AND     A
0517+  E96C C9                              RET
0518+  E96D             
0519+  E96D             ;-----
0520+  E96D             ; Calculate the checksum from A
0521+  E96D E5          _calc_checksum      PUSH    HL
0522+  E96E C5                              PUSH    BC
0523+  E96F             
0524+  E96F 06 01                           LD      B, 1
0525+  E971 4F                              LD      C, A
0526+  E972 DD 66 FF                        LD      H, (IX+ym_crc_high)
0527+  E975 DD 6E FE                        LD      L, (IX+ym_crc_low)
0528+  E978             
0529+  E978 29          _crc_loop           ADD     HL, HL
0530+  E979 F5                              PUSH    AF
0531+  E97A             
0532+  E97A CB 21                           SLA     C
0533+  E97C CB 10                           RL      B
0534+  E97E 30 02                           JR      NC, _no_in_overflow
0535+  E980 CB C1                           SET     0, C
0536+  E982             _no_in_overflow
0537+  E982 CB 40                           BIT     0, B
0538+  E984 28 01                           JR      Z, _no_in_bit
0539+  E986 23                              INC     HL
0540+  E987             _no_in_bit                    
0541+  E987 F1                              POP     AF
0542+  E988 30 08                           JR      NC, _no_crc_overflow
0543+  E98A 3E 21                           LD      A, 021h
0544+  E98C AD                              XOR     L 
0545+  E98D 6F                              LD      L,A
0546+  E98E 3E 10                           LD      A, 010h
0547+  E990 AC                              XOR     H 
0548+  E991 67                              LD      H, A
0549+  E992             _no_crc_overflow
0550+  E992 CB 41                           BIT     0, C
0551+  E994 28 E2                           JR      Z, _crc_loop    
0552+  E996             
0553+  E996 DD 74 FF                        LD      (IX+ym_crc_high), H
0554+  E999 DD 75 FE                        LD      (IX+ym_crc_low), L
0555+  E99C C1                              POP     BC
0556+  E99D E1                              POP     HL
0557+  E99E C9                              RET
0558+  E99F             
0559+  E99F 00          _dev_null           .DB     0
0560+  E9A0             
0561+  E9A0             ;
0562+  E9A0             ; Recieve a byte with timeout, without exiting ymodem
0563+  E9A0             ; If success, A contains byte, non-zero flag set
0564+  E9A0             ; Otherwise A is zero, Zero flag is set
0565+  E9A0             ;
0566+  E9A0 21 A9 E9    _recieve_safe       LD      HL, _back_safe
0567+  E9A3 E5                              PUSH    HL
0568+  E9A4 CD AB E9                        CALL    _receive_byte
0569+  E9A7 E1                              POP     HL
0570+  E9A8 C9                              RET
0571+  E9A9 AF          _back_safe          XOR     A
0572+  E9AA C9                              RET     
0573+  E9AB             
0574+  E9AB             ;
0575+  E9AB             ; Receive a byte with timeout
0576+  E9AB             ; If success: A contains byte, non-zero flag set
0577+  E9AB             ; Otherwise : Pops the return address off the stack and returns to the original caller with A containing YMODEM_TIMEOUT
0578+  E9AB             ;
0579+  E9AB C5          _receive_byte       PUSH    BC
0580+  E9AC 01 50 C3                        LD      BC, _TIMEOUT_COUNT
0581+  E9AF DB 25       _receive_loop       IN      A, (UART_LINE_STATUS)
0582+  E9B1 CB 47                           BIT     0, A
0583+  E9B3 20 12                           JR      NZ, _receive_ready
0584+  E9B5 78                              LD      A, B
0585+  E9B6 06 0A                           LD      B, 10
0586+  E9B8 A7          _rx_delay           AND     A
0587+  E9B9 10 FD                           DJNZ    _rx_delay
0588+  E9BB 47                              LD      B, A
0589+  E9BC 0B                              DEC     BC
0590+  E9BD 78                              LD      A, B
0591+  E9BE B1                              OR      C
0592+  E9BF 20 EE                           JR      NZ, _receive_loop
0593+  E9C1 C1                              POP     BC
0594+  E9C2 C1                              POP     BC
0595+  E9C3 3E 01                           LD      A, YMODEM_TIMEOUT
0596+  E9C5 A7                              AND     A
0597+  E9C6 C9                              RET
0598+  E9C7             
0599+  E9C7 DB 20       _receive_ready      IN      A, (UART_TX_RX)
0600+  E9C9 C1                              POP     BC
0601+  E9CA C9                              RET
0602+  E9CB             
0603+  E9CB             ;
0604+  E9CB             ; Send a byte with timeout
0605+  E9CB             ; If success: returns normally, no registers affected
0606+  E9CB             ; Otherwise : Pops the return address off the stack and returns to the original caller with A containing YMODEM_SEND_TIMEOUT
0607+  E9CB             ;
0608+  E9CB C5          _send_byte          PUSH    BC
0609+  E9CC F5                              PUSH    AF
0610+  E9CD 01 50 C3                        LD      BC, _TIMEOUT_COUNT
0611+  E9D0 DB 25       _send_loop          IN      A, (UART_LINE_STATUS)
0612+  E9D2 CB 6F                           BIT     5, A
0613+  E9D4 C2 E4 E9                        JP      NZ, _send_ready             ; Bit 5 is set when the UART is ready
0614+  E9D7 0B                              DEC     BC
0615+  E9D8 78                              LD      A, B
0616+  E9D9 B1                              OR      C
0617+  E9DA C2 D0 E9                        JP      NZ, _send_loop
0618+  E9DD             
0619+  E9DD F1                              POP     AF
0620+  E9DE C1                              POP     BC
0621+  E9DF C1                              POP     BC
0622+  E9E0             
0623+  E9E0 3E 07                           LD      A, YMODEM_SEND_TIMEOUT
0624+  E9E2 A7                              AND     A
0625+  E9E3 C9                              RET
0626+  E9E4             
0627+  E9E4 F1          _send_ready         POP     AF
0628+  E9E5 C1                              POP     BC
0629+  E9E6 D3 20                           OUT     (UART_TX_RX), A
0630+  E9E8 C9                              RET
0631+  E9E9             
0632+  E9E9                                 .MODULE main1182   E9E9             
1183   E9E9~            .IF $ >= BIOS_START
1184   E9E9~                .ECHO "End of Monitor is too high ("
1185   E9E9~                .ECHO $
1186   E9E9~                .ECHO " > "
1187   E9E9~                .ECHO BIOS_START
1188   E9E9~                .ECHO ") \n\n"
1189   E9E9~                .STOP
1190   E9E9             .ENDIF
1191   E9E9             
1192   E9E9             .ECHO "Spare after monitor "
1193   E9E9             .ECHO BIOS_START-$
1194   E9E9             .ECHO "\n\n"
1195   E9E9             
1196   E9E9 FF FF FF FF                     .FILL  BIOS_START-$
1196   E9ED FF FF FF FF 
1196   E9F1 FF FF FF FF 
1196   E9F5 FF FF FF FF 
1196   E9F9 FF FF FF FF 
1196   E9FD FF FF FF 
1197   EA00             
1198   EA00                                 .INCLUDE "bios.asm"
0001+  EA00             ;
0002+  EA00             ; Simple-ish CP/M compatible BIOS
0003+  EA00             ;
0004+  EA00             ; References - http://www.gaby.de/cpm/manuals/archive/cpm22htm/axb.htm - CPM Manual 'Simple skeletal BIOS'
0005+  EA00             ;
0006+  EA00             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0007+  EA00             ;
0008+  EA00             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0009+  EA00             ;
0010+  EA00             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0011+  EA00             ; of this software and associated documentation files (the "Software"), to deal
0012+  EA00             ; in the Software without restriction, including without limitation the rights
0013+  EA00             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0014+  EA00             ; copies of the Software, and to permit persons to whom the Software is
0015+  EA00             ; furnished to do so, subject to the following conditions:
0016+  EA00             ; 
0017+  EA00             ; The above copyright notice and this permission notice shall be included in all
0018+  EA00             ; copies or substantial portions of the Software.
0019+  EA00             ; 
0020+  EA00             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0021+  EA00             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0022+  EA00             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0023+  EA00             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0024+  EA00             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0025+  EA00             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0026+  EA00             ; SOFTWARE.
0027+  EA00             ;
0028+  EA00                                 .MODULE  main
0029+  EA00             
0030+  EA00             BIOS_START          .EQU    0EA00h   ; If this is changed, CP/M must be rebuilt and the disk image updated
0031+  EA00             BIOS_TOP            .EQU    0FDFDh
0032+  EA00             
0033+  EA00             CCP                 .EQU    BIOS_START - 01600h
0034+  EA00             BDOS                .EQU    CCP + 0806h
0035+  EA00             
0036+  EA00             CCP_SECTOR_COUNT    .EQU    (BIOS_START-CCP)/128
0037+  EA00             
0038+  EA00~            .IF (CCP_SECTOR_COUNT * 128) < (BIOS_START-CCP)
0039+  EA00~                .ECHO "CCP isn't an exact multiple of 128 byte sectors\n"
0040+  EA00~                .ECHO "  Got "
0041+  EA00~                .ECHO (BIOS_START-CCP)
0042+  EA00~                .ECHO "\n"
0043+  EA00~                .STOP
0044+  EA00             .ENDIF
0045+  EA00             
0046+  EA00             iobyte              .EQU    03h     ; Location of Intel standard I/O definition byte
0047+  EA00             usrdrv              .EQU    04h     ; Location of Current user number and drive
0048+  EA00             tpabuf              .EQU    0080h   ; Default I/O buffer and command line storage
0049+  EA00             
0050+  EA00             IO_BAT              .EQU    02h     ; CONsole IO defined by RDR for input, LST for output
0051+  EA00             
0052+  EA00             bios_start          .ORG    BIOS_START
0053+  EA00             
0054+  EA00 C3 F1 EA                        JP      bios_boot     ;  0 Initialize
0055+  EA03 C3 34 EB    wboote              JP      bios_wboot    ;  1 Warm boot
0056+  EA06 C3 9D EB                        JP      bios_conist   ;  2 Console status - Return A = 0FFH if character ready, 00H if not
0057+  EA09 C3 C6 EB                        JP      bios_conin    ;  3 Console input  - Wait for input, returning character in A
0058+  EA0C C3 2C EC                        JP      bios_conout   ;  4 Console OUTput - Write character in C to console
0059+  EA0F C3 56 EF                        JP      bios_list     ;  5 List OUTput
0060+  EA12 C3 58 EF                        JP      bios_punch    ;  6 punch OUTput
0061+  EA15 C3 5A EF                        JP      bios_reader   ;  7 Reader input
0062+  EA18 C3 74 EF                        JP      bios_home     ;  8 Home disk
0063+  EA1B C3 5B EF                        JP      bios_seldsk   ;  9 Select disk
0064+  EA1E C3 76 EF                        JP      bios_settrk   ; 10 Select track
0065+  EA21 C3 7B EF                        JP      bios_setsec   ; 11 Select sector
0066+  EA24 C3 80 EF                        JP      bios_setdma   ; 12 Set DMA ADDress
0067+  EA27 C3 85 EF                        JP      bios_read     ; 13 Read 128 bytes
0068+  EA2A C3 BE EF                        JP      bios_write    ; 14 Write 128 bytes
0069+  EA2D C3 2B F0                        JP      bios_listst   ; 15 List status
0070+  EA30 C3 2D F0                        JP      bios_sectrn   ; 16 Sector translate
0071+  EA33             
0072+  EA33             MEMDISK_SECTORS     .EQU    26
0073+  EA33             MEMDISK_TRACKS      .EQU    79
0074+  EA33             
0075+  EA33             BIOS_BOOT_TRACKS    .EQU    2
0076+  EA33             BIOS_SECTOR_ADDRESS .EQU    tpabuf
0077+  EA33             
0078+  EA33             DRIVE_A_PAGE        .EQU    04h     ; Page 4 of ROM - offset 010000h
0079+  EA33             DRIVE_B_PAGE        .EQU    25h     ; Page 5 of RAM
0080+  EA33             
0081+  EA33             CONSOLE_PAGE        .EQU    24h     ; Page 4 of RAM - Console emulation for non-VideoBeast systems
0082+  EA33             
0083+  EA33             ; Disk Parameter Headers -------------------------------------------------------
0084+  EA33             ; These are 256K discs, equivalent to this disc format (for cpmtools)
0085+  EA33             ; 
0086+  EA33             ; References : https://www.idealine.info/sharpmz/dpb.htm - Explanation of values
0087+  EA33             ;              https://jeelabs.org/article/1715b/        - Bootstrapping CP/M
0088+  EA33             ;
0089+  EA33             ; diskdef memotech-type50
0090+  EA33             ;  seclen 128
0091+  EA33             ;  tracks 79
0092+  EA33             ;  sectrk 26
0093+  EA33             ;  blocksize 1024
0094+  EA33             ;  maxdir 64
0095+  EA33             ;  skew 1
0096+  EA33             ;  boottrk 2
0097+  EA33             ;  os 2.2
0098+  EA33             ; end
0099+  EA33             ;
0100+  EA33             MAX_DRIVES          .EQU    2
0101+  EA33             
0102+  EA33 00 00 00 00 dpbase              .DW     0,0,0,0,dirbuf,dpb0,0,sys_alv0      ; Disk 0 is Flash
0102+  EA37 00 00 00 00 
0102+  EA3B 71 EA 53 EA 
0102+  EA3F 00 00 45 FF 
0103+  EA43 00 00 00 00                     .DW     0,0,0,0,dirbuf,dpb1,0,sys_alv1      ; Disk 1 is RAM
0103+  EA47 00 00 00 00 
0103+  EA4B 71 EA 62 EA 
0103+  EA4F 00 00 65 FF 
0104+  EA53             
0105+  EA53 1A 00       dpb0                .DW     MEMDISK_SECTORS     ; SPT - sectors per track
0106+  EA55 03                              .DB     3                   ; BSH - block shift factor  BSH+BLM together mean 1024 byte blocksize
0107+  EA56 07                              .DB     7                   ; BLM - block mask
0108+  EA57 00                              .DB     0                   ; EXM - Extent mask
0109+  EA58 F7 00                           .DW     247                 ; DSM - Storage size (blocks - 1)
0110+  EA5A 3F 00                           .DW     63                  ; DRM - Number of directory entries - 1
0111+  EA5C C0                              .DB     192                 ; AL0 - 1 bit set per directory block
0112+  EA5D 00                              .DB     0                   ; AL1 - ... 8 more bits
0113+  EA5E 00 00                           .DW     0                   ; CKS - DIR check vector size (DRM+1)/4 (0=fixed disk)
0114+  EA60 02 00                           .DW     BIOS_BOOT_TRACKS    ; OFF - Reserved tracks
0115+  EA62             
0116+  EA62 1A 00       dpb1                .DW     MEMDISK_SECTORS     ; SPT - sectors per track
0117+  EA64 03                              .DB     3                   ; BSH - block shift factor  BSH+BLM together mean 1024 byte blocksize
0118+  EA65 07                              .DB     7                   ; BLM - block mask
0119+  EA66 00                              .DB     0                   ; EXM - Extent mask
0120+  EA67 F7 00                           .DW     247                 ; DSM - Storage size (blocks - 1)
0121+  EA69 3F 00                           .DW     63                  ; DRM - Number of directory entries - 1
0122+  EA6B C0                              .DB     192                 ; AL0 - 1 bit set per directory block
0123+  EA6C 00                              .DB     0                   ; AL1 - ... 8 more bits
0124+  EA6D 00 00                           .DW     0                   ; CKS - DIR check vector size (DRM+1)/4 (0=fixed disk)
0125+  EA6F 02 00                           .DW     BIOS_BOOT_TRACKS    ; OFF - Reserved tracks
0126+  EA71             
0127+  EA71 00 00 00 00 dirbuf              .FILL   128, 0 ; disk directory scratch area
0127+  EA75 00 00 00 00 
0127+  EA79 00 00 00 00 
0127+  EA7D 00 00 00 00 
0127+  EA81 00 00 00 00 
0127+  EA85 00 00 00 00 
0127+  EA89 00 00 00 00 
0127+  EA8D 00 00 00 00 
0127+  EA91 00 00 00 00 
0127+  EA95 00 00 00 00 
0127+  EA99 00 00 00 00 
0127+  EA9D 00 00 00 00 
0127+  EAA1 00 00 00 00 
0127+  EAA5 00 00 00 00 
0127+  EAA9 00 00 00 00 
0127+  EAAD 00 00 00 00 
0127+  EAB1 00 00 00 00 
0127+  EAB5 00 00 00 00 
0127+  EAB9 00 00 00 00 
0127+  EABD 00 00 00 00 
0127+  EAC1 00 00 00 00 
0127+  EAC5 00 00 00 00 
0127+  EAC9 00 00 00 00 
0127+  EACD 00 00 00 00 
0127+  EAD1 00 00 00 00 
0127+  EAD5 00 00 00 00 
0127+  EAD9 00 00 00 00 
0127+  EADD 00 00 00 00 
0127+  EAE1 00 00 00 00 
0127+  EAE5 00 00 00 00 
0127+  EAE9 00 00 00 00 
0127+  EAED 00 00 00 00 
0128+  EAF1             
0129+  EAF1             ; BIOS Entry points ---------------------------------------------------------------
0130+  EAF1             
0131+  EAF1             bios_boot     ;  0 Initialize - This is called on first boot when CCP and BIOS have all been read into memory. Initialise hardware and start CCP
0132+  EAF1 F3                              DI
0133+  EAF2 31 00 00                        LD      SP,000h
0134+  EAF5 21 00 EA                        LD      HL,BIOS_START        ; Why are we doing this?
0135+  EAF8 22 FE FF                        LD      (0FFFEh),HL
0136+  EAFB CD 48 F0                        CALL    configure_hardware
0137+  EAFE AF                              XOR     A
0138+  EAFF 32 04 00                        LD      (usrdrv),A
0139+  EB02             
0140+  EB02 3A 03 FF                        LD      A, (boot_mode)
0141+  EB05 E6 08                           AND     BOOT_TTY_INPUT
0142+  EB07 3E 01                           LD      A, 1                 ; Input on keyboard, output on display
0143+  EB09 28 01                           JR      Z, _boot_iobyte
0144+  EB0B AF                              XOR     A                    ; Input from serial/tty, output on display
0145+  EB0C 32 03 00    _boot_iobyte        LD      (iobyte),A           
0146+  EB0F             
0147+  EB0F 3A 03 FF                        LD      A, (boot_mode)       ; If we need to restore the B drive on boot, patch the CCP command
0148+  EB12 E6 04                           AND     BOOT_RESTORE_B       ; See CP/M 2.2 Application Node 01 2/20/82 "The CCP Auto-Load Feature"
0149+  EB14 28 25                           JR      Z, start_cpm
0150+  EB16             
0151+  EB16 21 2B EB                        LD      HL, _restore_command ; Auto-run the RESTORE command
0152+  EB19 11 07 D4                        LD      DE, CCP+7
0153+  EB1C 01 09 00                        LD      BC, _restore_command_len
0154+  EB1F ED B0                           LDIR
0155+  EB21 3A 03 FF                        LD      A, (boot_mode)       ; Clear the boot_mode flag to prevent accidentally overwriting drive B
0156+  EB24 EE 04                           XOR     BOOT_RESTORE_B
0157+  EB26 32 03 FF                        LD      (boot_mode), A
0158+  EB29 18 10                           JR      start_cpm
0159+  EB2B             
0160+  EB2B 07 52 45 53 _restore_command     .DB     7, "RESTORE", 0
0160+  EB2F 54 4F 52 45 
0160+  EB33 00 
0161+  EB34             _restore_command_len .EQU   $-_restore_command
0162+  EB34             
0163+  EB34             ;------------------------------------------------------                    
0164+  EB34             bios_wboot    ;  1 Warm boot - Hardware is intialised, but CCP should be reloaded before being run
0165+  EB34 F3                              DI
0166+  EB35 31 00 00                        LD      SP,000h
0167+  EB38                                 ;CALL    setup_screen
0168+  EB38 CD 5D EB                        CALL    load_ccp
0169+  EB3B             
0170+  EB3B FB          start_cpm           EI                           ; Make sure interrupts are enabled
0171+  EB3C 21 80 00                        LD      HL,tpabuf            ; Address of BIOS DMA buffer
0172+  EB3F 22 40 FF                        LD      (sys_dmaaddr),hl
0173+  EB42 3E C3                           LD      A, 0C3h              ; Opcode for 'JP'
0174+  EB44 32 00 00                        LD      (00h),A              ; Load at start of RAM
0175+  EB47 21 03 EA                        LD      HL,wboote            ; Address of jump for a warm boot
0176+  EB4A 22 01 00                        LD      (01h),HL
0177+  EB4D 32 05 00                        LD      (05h),a              ; Opcode for 'JP'
0178+  EB50 21 06 DC                        LD      HL,BDOS              ; Address of jump for the BDOS
0179+  EB53 22 06 00                        LD      (06h),HL
0180+  EB56 3A 04 00                        LD      A,(usrdrv)           ; Save new drive number (0)  ; TODO: Ugh? Where is this set, what does it mean???
0181+  EB59 4F                              LD      C, A                 ; Pass drive number in C
0182+  EB5A C3 00 D4                        JP      CCP                  ; Start CP/M by jumping to the CCP
0183+  EB5D             
0184+  EB5D                                 ; Load CCP - Note we're doing this through BIOS calls, so if we move the OS to a different
0185+  EB5D                                 ;       drive, the code should still function...
0186+  EB5D 0E 00       load_ccp            LD      C, 0
0187+  EB5F CD 5B EF                        CALL    bios_seldsk
0188+  EB62 CD 74 EF                        CALL    bios_home            ; Go to track 0
0189+  EB65             
0190+  EB65 06 2C                           LD      B, CCP_SECTOR_COUNT
0191+  EB67 0E 00                           LD      C, 0                 ; Track number
0192+  EB69 16 00                           LD      D, 0                 ; Sector to read - start with sector 0 (TODO: Check sectors are 0 based)
0193+  EB6B 21 00 D4                        LD      HL, CCP
0194+  EB6E C5          _read_ccp           PUSH    BC
0195+  EB6F D5                              PUSH    DE
0196+  EB70 E5                              PUSH    HL
0197+  EB71 4A                              LD      C, D                 ; Set the sector to read
0198+  EB72 CD 7B EF                        CALL    bios_setsec
0199+  EB75 C1                              POP     BC
0200+  EB76 C5                              PUSH    BC
0201+  EB77 CD 80 EF                        CALL    bios_setdma
0202+  EB7A CD 85 EF                        CALL    bios_read
0203+  EB7D A7                              AND     A                    ; Reboot if error 
0204+  EB7E 20 B4                           JR      NZ, bios_wboot
0205+  EB80             
0206+  EB80 E1                              POP     HL                   ; Calculate next address to read
0207+  EB81 11 80 00                        LD      DE, 128
0208+  EB84 19                              ADD     HL, DE
0209+  EB85 D1                              POP     DE                   ; Count down the sectors
0210+  EB86 C1                              POP     BC
0211+  EB87 05                              DEC     B
0212+  EB88 C8                              RET     Z                    ; And return if we've read 'em all
0213+  EB89             
0214+  EB89 14                              INC     D                    ; Otherwise, increment sector   
0215+  EB8A 7A                              LD      A, D
0216+  EB8B FE 1B                           CP      27
0217+  EB8D 38 DF                           JR      C, _read_ccp
0218+  EB8F             
0219+  EB8F 16 01                           LD      D, 1                 ; Or, set sector back to 1 and increment track 
0220+  EB91 0C                              INC     C
0221+  EB92             
0222+  EB92 C5                              PUSH    BC
0223+  EB93 D5                              PUSH    DE
0224+  EB94 E5                              PUSH    HL
0225+  EB95 CD 76 EF                        CALL    bios_settrk
0226+  EB98 E1                              POP     HL
0227+  EB99 D1                              POP     DE
0228+  EB9A C1                              POP     BC
0229+  EB9B 18 D1                           JR      _read_ccp
0230+  EB9D             
0231+  EB9D             
0232+  EB9D                                 
0233+  EB9D             ;------------------------------------------------------  
0234+  EB9D             bios_conist   ; CONSOLE STATUS, - Return A = 0FFH if character ready, 00H if not
0235+  EB9D 3A 03 00                        LD      A, (iobyte)                ; Check input on CON
0236+  EBA0 E6 03                           AND     03h
0237+  EBA2 28 12                           JR      Z, _coninst_tty
0238+  EBA4 FE 02                           CP      IO_BAT
0239+  EBA6 28 15                           JR      Z, _coninst_rdr
0240+  EBA8             
0241+  EBA8 3A 36 FF    _coninst_kbd        LD      A, (console_identify)
0242+  EBAB A7                              AND     A
0243+  EBAC 20 05                           JR      NZ, _coninst_has_char
0244+  EBAE             
0245+  EBAE 3A 28 FF                        LD      A, (input_size)
0246+  EBB1 A7                              AND     A
0247+  EBB2 C8                              RET     Z
0248+  EBB3 3E FF       _coninst_has_char   LD      A, 0FFh
0249+  EBB5 C9                              RET
0250+  EBB6              
0251+  EBB6 AF          _coninst_tty        XOR     A
0252+  EBB7 CD 7D F5                        CALL    uart_ready
0253+  EBBA D0                              RET     NC
0254+  EBBB 3D                              DEC     A
0255+  EBBC C9                              RET     
0256+  EBBD 3A 03 00    _coninst_rdr        LD      A, (iobyte)                 ; Input is determined by RDR
0257+  EBC0 E6 0C                           AND     0Ch
0258+  EBC2 28 F2                           JR      Z, _coninst_tty
0259+  EBC4 18 E2                           JR      _coninst_kbd
0260+  EBC6             
0261+  EBC6             ;------------------------------------------------------  
0262+  EBC6             bios_conin    ;  3 Console input - Wait for input, returning character in A
0263+  EBC6 3A 03 00                        LD      A, (iobyte)
0264+  EBC9 E6 03                           AND     03h
0265+  EBCB 28 17                           JR      Z, _conin_tty
0266+  EBCD FE 02                           CP      02h
0267+  EBCF 28 19                           JR      Z, _conin_rdr
0268+  EBD1                                 
0269+  EBD1 3A 36 FF    _conin_kbd          LD      A, (console_identify)           ; If the terminal has been sent an identity request escape sequence, return the response
0270+  EBD4 3D                              DEC     A
0271+  EBD5 FA F3 EB                        JP      M, _conin_read_char
0272+  EBD8 32 36 FF                        LD      (console_identify), A
0273+  EBDB 21 29 EC                        LD      HL, _indentity_sequence
0274+  EBDE 4F                              LD      C, A
0275+  EBDF 06 00                           LD      B, 0
0276+  EBE1 09                              ADD     HL, BC
0277+  EBE2 7E                              LD      A, (HL) 
0278+  EBE3 C9                              RET        
0279+  EBE4             
0280+  EBE4 CD 8C F5    _conin_tty          CALL    uart_receive
0281+  EBE7 D8                              RET     C
0282+  EBE8 18 FA                           JR      _conin_tty
0283+  EBEA                  
0284+  EBEA 3A 03 00    _conin_rdr          LD      A, (iobyte)
0285+  EBED E6 0C                           AND     0ch
0286+  EBEF 28 F3                           JR      Z, _conin_tty
0287+  EBF1 18 DE                           JR      _conin_kbd
0288+  EBF3             
0289+  EBF3 3A 28 FF    _conin_read_char    LD      A, (input_size)                 ; Don't blink cursor if there is a character already waiting..
0290+  EBF6 A7                              AND     A
0291+  EBF7 28 03                           JR      Z, _conin_wait
0292+  EBF9 C3 50 F4                        JP      get_key
0293+  EBFC             
0294+  EBFC 3A 32 FF    _conin_wait         LD      A, (console_flags)              ; Turn the cursor on..
0295+  EBFF F6 01                           OR      CFLAGS_SHOW_CURSOR
0296+  EC01 32 32 FF                        LD      (console_flags), A
0297+  EC04 F3                              DI
0298+  EC05 ED 5B 2D FF                     LD      DE, (cursor_row)
0299+  EC09 7A                              LD      A, D                            ; Force cursor update...
0300+  EC0A 3D                              DEC     A
0301+  EC0B 32 2E FF                        LD      (cursor_col),A
0302+  EC0E CD 4C ED                        CALL    _conout_csr_update
0303+  EC11 FB                              EI
0304+  EC12 CD 50 F4                        CALL    get_key
0305+  EC15 47                              LD      B, A
0306+  EC16 3A 32 FF                        LD      A, (console_flags)
0307+  EC19 E6 FE                           AND     ~CFLAGS_SHOW_CURSOR
0308+  EC1B 32 32 FF                        LD      (console_flags), A
0309+  EC1E                                 ;
0310+  EC1E C5                              PUSH    BC
0311+  EC1F 1E 00                           LD      E, 0
0312+  EC21 F3                              DI
0313+  EC22 CD 6B F2                        CALL    update_cursor
0314+  EC25 FB                              EI
0315+  EC26 C1                              POP     BC
0316+  EC27 78                              LD      A, B
0317+  EC28 C9                              RET
0318+  EC29                  
0319+  EC29 4B 2F 1B    _indentity_sequence .DB     'K', '/', ESCAPE_CHAR           ; RETURNED BY VT-52 emulation - note sequence is reversed
0320+  EC2C             IDENTITY_LENGTH     .EQU    3
0321+  EC2C             
0322+  EC2C             ;------------------------------------------------------  
0323+  EC2C             bios_conout   ;  4 Console OUTput  - Write character in C to console
0324+  EC2C 3A 03 00                        LD      A, (iobyte)
0325+  EC2F E6 03                           AND     03h
0326+  EC31 FE 02                           CP      IO_BAT
0327+  EC33 20 0B                           JR      NZ, _conout_disp_tty
0328+  EC35             
0329+  EC35 3A 03 00                        LD      A, (iobyte)
0330+  EC38 E6 C0                           AND     0C0h
0331+  EC3A 20 08                           JR      NZ, _conout_disp 
0332+  EC3C 79                              LD      A, C
0333+  EC3D C3 60 F5                        JP      uart_send
0334+  EC40             
0335+  EC40 79          _conout_disp_tty    LD      A, C
0336+  EC41 CD 60 F5                        CALL    uart_send
0337+  EC44             
0338+  EC44 3A 34 FF    _conout_disp        LD      A, (console_escape)             ; Test to see if handling an escape sequence and expect more parameters
0339+  EC47 B7                              OR      A
0340+  EC48 C2 FD EC                        JP      NZ, _conout_escape_seq
0341+  EC4B             
0342+  EC4B 3A 32 FF                        LD      A, (console_flags)              ; Test to see if we're expecting an escape character
0343+  EC4E E6 08                           AND     CFLAGS_ESCAPE
0344+  EC50 CA EA EC                        JP      Z, _conout_check_esc
0345+  EC53             
0346+  EC53                                                                         ; If so, this is the first character after we got an escape...
0347+  EC53 ED 5B 2D FF                     LD      DE, (cursor_row)                ; Get cursor position in DE
0348+  EC57 3A 32 FF                        LD      A,(console_flags)               ; Reset the escape flag
0349+  EC5A E6 F7                           AND     ~CFLAGS_ESCAPE
0350+  EC5C 32 32 FF                        LD      (console_flags),A
0351+  EC5F             
0352+  EC5F 79                              LD      A, C
0353+  EC60             
0354+  EC60 FE 41                           CP      'A'
0355+  EC62 20 04                           JR      NZ, _conout_not_up
0356+  EC64 1D                              DEC     E
0357+  EC65 C3 4C ED                        JP      _conout_csr_update
0358+  EC68             
0359+  EC68 FE 42       _conout_not_up      CP      'B'
0360+  EC6A 20 04                           JR      NZ, _conout_not_down
0361+  EC6C 1C                              INC     E
0362+  EC6D C3 4C ED                        JP      _conout_csr_update
0363+  EC70             
0364+  EC70 FE 43       _conout_not_down    CP      'C'
0365+  EC72 20 09                           JR      NZ, _conout_not_right
0366+  EC74 3A 30 FF                        LD      A, (console_width)
0367+  EC77 BA                              CP      D
0368+  EC78 C8                              RET     Z                           
0369+  EC79 14                              INC     D
0370+  EC7A C3 4C ED                        JP      _conout_csr_update
0371+  EC7D             
0372+  EC7D FE 44       _conout_not_right   CP      'D'
0373+  EC7F 20 05                           JR      NZ, _conout_not_left
0374+  EC81 15                              DEC     D
0375+  EC82 C8                              RET     Z
0376+  EC83 C3 4C ED                        JP      _conout_csr_update
0377+  EC86             
0378+  EC86 FE 46       _conout_not_left    CP      'F'                         ; Enter graphics mode.. not supported
0379+  EC88 C8                              RET     Z
0380+  EC89             
0381+  EC89 FE 47                           CP      'G'                         ; Exit graphics mode
0382+  EC8B C8                              RET     Z
0383+  EC8C             
0384+  EC8C FE 48                           CP      'H'
0385+  EC8E 20 06                           JR      NZ, _conout_not_home
0386+  EC90 11 01 01                        LD      DE, 0101h
0387+  EC93 C3 4C ED                        JP      _conout_csr_update
0388+  EC96             
0389+  EC96 FE 49       _conout_not_home    CP      'I'                         ; Reverse line feed. Insert line above and move cursor up. Not supported
0390+  EC98 C8                              RET     Z                    
0391+  EC99             
0392+  EC99 FE 4A                           CP      'J'
0393+  EC9B 20 19                           JR      NZ, _conout_not_clr_sc
0394+  EC9D             
0395+  EC9D CD C0 EC                        CALL    _conout_clr_ln
0396+  ECA0 ED 4B 2D FF                     LD      BC, (cursor_row)
0397+  ECA4 0E 00                           LD      C, 0
0398+  ECA6 04          _conout_clr_scrn    INC     B
0399+  ECA7 3A 2F FF                        LD      A, (console_height)
0400+  ECAA B8                              CP      B
0401+  ECAB CA 01 EE                        JP      Z, _redraw_buffer
0402+  ECAE C5                              PUSH    BC
0403+  ECAF 78                              LD      A, B
0404+  ECB0 CD 2F EF                        CALL    clear_screen_row
0405+  ECB3 C1                              POP     BC
0406+  ECB4 18 F0                           JR      _conout_clr_scrn
0407+  ECB6             
0408+  ECB6 FE 4B       _conout_not_clr_sc  CP      'K'
0409+  ECB8 20 11                           JR      NZ, _conout_not_clr_ln
0410+  ECBA             
0411+  ECBA CD C0 EC                        CALL   _conout_clr_ln
0412+  ECBD C3 01 EE                        JP     _redraw_buffer
0413+  ECC0             
0414+  ECC0 ED 4B 2D FF _conout_clr_ln      LD      BC, (cursor_row)
0415+  ECC4 05                              DEC     B
0416+  ECC5 79                              LD      A, C
0417+  ECC6 3D                              DEC     A
0418+  ECC7 48                              LD      C, B
0419+  ECC8 C3 2F EF                        JP      clear_screen_row
0420+  ECCB             
0421+  ECCB FE 59       _conout_not_clr_ln  CP      'Y'
0422+  ECCD 20 08                           JR      NZ, _conout_not_pos
0423+  ECCF             
0424+  ECCF 32 34 FF    _conout_start_esc   LD      (console_escape), A         ; Start an escape sequence
0425+  ECD2 AF                              XOR     A
0426+  ECD3 32 35 FF                        LD      (console_param1), A
0427+  ECD6 C9                              RET
0428+  ECD7             
0429+  ECD7 FE 5A       _conout_not_pos     CP      'Z'
0430+  ECD9 20 06                           JR      NZ, _conout_not_ident
0431+  ECDB 3E 03                           LD      A, IDENTITY_LENGTH
0432+  ECDD 32 36 FF                        LD      (console_identify), A
0433+  ECE0 C9                              RET
0434+  ECE1             
0435+  ECE1 FE 62       _conout_not_ident   CP      'b'
0436+  ECE3 28 EA                           JR      Z, _conout_start_esc
0437+  ECE5 FE 63                           CP      'c'
0438+  ECE7 28 E6                           JR      Z, _conout_start_esc
0439+  ECE9             
0440+  ECE9                                 ; TODO: Any addtional escape sequences here...
0441+  ECE9 C9                              RET
0442+  ECEA             
0443+  ECEA 79          _conout_check_esc   LD      A, C                    
0444+  ECEB FE 1B                           CP      ESCAPE_CHAR
0445+  ECED C2 D8 EE                        JP      NZ, _conout_character
0446+  ECF0             
0447+  ECF0 3A 32 FF                        LD      A, (console_flags)
0448+  ECF3 F6 08                           OR      CFLAGS_ESCAPE
0449+  ECF5 32 32 FF                        LD      (console_flags), A
0450+  ECF8 AF                              XOR     A
0451+  ECF9 32 34 FF                        LD      (console_escape),A
0452+  ECFC C9                              RET
0453+  ECFD             
0454+  ECFD 3A 34 FF    _conout_escape_seq  LD      A,(console_escape)
0455+  ED00 FE 59                           CP      'Y'
0456+  ED02 28 0D                           JR      Z, _conout_esc_pos
0457+  ED04 FE 62                           CP      'b'
0458+  ED06 28 31                           JR      Z, _conout_esc_foreg
0459+  ED08 FE 63                           CP      'c'
0460+  ED0A 28 1C                           JR      Z, _conout_esc_backg
0461+  ED0C             
0462+  ED0C                                 ; All unknown sequences reset the escape sequence
0463+  ED0C AF          _conout_reset_seq   XOR     A
0464+  ED0D 32 34 FF                        LD      (console_escape),A
0465+  ED10 C9                              RET
0466+  ED11             
0467+  ED11 3A 35 FF    _conout_esc_pos     LD      A, (console_param1)
0468+  ED14 A7                              AND     A
0469+  ED15 20 05                           JR      NZ, _conout_pos_param
0470+  ED17 79                              LD      A, C
0471+  ED18 32 35 FF                        LD      (console_param1),A
0472+  ED1B C9                              RET
0473+  ED1C             
0474+  ED1C D6 1F       _conout_pos_param   SUB     31
0475+  ED1E 5F                              LD      E, A
0476+  ED1F 79                              LD      A, C
0477+  ED20 D6 1F                           SUB     31
0478+  ED22 57                              LD      D, A
0479+  ED23 CD 0C ED                        CALL    _conout_reset_seq
0480+  ED26 18 24                           JR      _conout_csr_update
0481+  ED28             
0482+  ED28 3A 31 FF    _conout_esc_backg   LD      A, (console_colour)
0483+  ED2B E6 F0                           AND     0F0h
0484+  ED2D 47                              LD      B, A
0485+  ED2E 79                              LD      A, C
0486+  ED2F D6 1F                           SUB     31
0487+  ED31 E6 0F                           AND     0Fh
0488+  ED33 B0          _conout_set_colour  OR      B
0489+  ED34 32 31 FF                        LD      (console_colour), A
0490+  ED37 18 D3                           JR      _conout_reset_seq
0491+  ED39             
0492+  ED39 3A 31 FF    _conout_esc_foreg   LD      A, (console_colour)
0493+  ED3C E6 0F                           AND     0Fh
0494+  ED3E 47                              LD      B, A
0495+  ED3F 79                              LD      A, C
0496+  ED40 D6 1F                           SUB     31
0497+  ED42 CB 27                           SLA     A
0498+  ED44 CB 27                           SLA     A
0499+  ED46 CB 27                           SLA     A
0500+  ED48 CB 27                           SLA     A
0501+  ED4A 18 E7                           JR      _conout_set_colour
0502+  ED4C             
0503+  ED4C             ; Cursor position has changed, check if we need to update the whole display.
0504+  ED4C             ; This is entered with DE as D = new cursor column, E = new cursor row
0505+  ED4C             ;         Writes new cursor poition to (cursor_row, cursor_column)
0506+  ED4C             ;         Returns HL = updated display column, row to track the cursor position..
0507+  ED4C             ; Assume column is always within range, row may be before start/after end of visible screen
0508+  ED4C             ;
0509+  ED4C 2A 2B FF    _conout_csr_update  LD      HL, (display_row)           ; HL = current display column, row..
0510+  ED4F ED 4B 2D FF                     LD      BC, (cursor_row)            ; BC = old values of cursor column, row
0511+  ED53 7B                              LD      A, E                        
0512+  ED54 B9                              CP      C
0513+  ED55 32 2D FF                        LD      (cursor_row), A
0514+  ED58 20 0A                           JR      NZ, _conout_check_row       ; If cursor row has changed, we must update display_row and optionally screen_offset
0515+  ED5A             
0516+  ED5A 7A          _conout_track_col   LD      A, D
0517+  ED5B B8                              CP      B
0518+  ED5C 32 2E FF                        LD      (cursor_col), A
0519+  ED5F 20 1A                           JR      NZ, _conout_check_col       ; If only column has changed, we may update display_col..
0520+  ED61 C3 01 EE                        JP      _redraw_buffer              ; Otherwise, nothing has changed. Make sure display is up to date
0521+  ED64             
0522+  ED64 A7          _conout_check_row   AND     A                           
0523+  ED65 20 05                           JR      NZ, _conout_chk_bottom         
0524+  ED67 3C                              INC     A                           ; We're above the screen, fix the cursor_row but set L (display row) to -1 
0525+  ED68 32 2D FF                        LD      (cursor_row), A
0526+  ED6B             
0527+  ED6B AF                              XOR     A
0528+  ED6C             
0529+  ED6C 3D          _conout_chk_bottom  DEC     A
0530+  ED6D 6F                              LD      L, A                        ; Update the display row in HL which will force refresh
0531+  ED6E 3A 2F FF                        LD      A, (console_height)
0532+  ED71 BD                              CP      L
0533+  ED72 20 03                           JR      NZ, _conout_not_bottom
0534+  ED74             
0535+  ED74 32 2D FF                        LD      (cursor_row), A
0536+  ED77             
0537+  ED77 7A          _conout_not_bottom  LD      A, D                        ; Write col here since it wasn't previously set...
0538+  ED78 32 2E FF                        LD      (cursor_col), A
0539+  ED7B             
0540+  ED7B 7C          _conout_check_col   LD      A, H                        ; Current display col
0541+  ED7C 3C                              INC     A
0542+  ED7D 92                              SUB     D                           ; Subtract new cursor col
0543+  ED7E 30 18                           JR      NC, _conout_scroll_l        ; Cursor col is before beginning of screen
0544+  ED80             
0545+  ED80 3A 32 FF                        LD      A, (console_flags)
0546+  ED83 E6 01                           AND     CFLAGS_SHOW_CURSOR
0547+  ED85 3E 01                           LD      A, 1
0548+  ED87 28 01                           JR      Z, _conout_keep_left
0549+  ED89 3D                              DEC     A
0550+  ED8A C6 18       _conout_keep_left   ADD     A, DISPLAY_WIDTH          
0551+  ED8C 47                              LD      B, A
0552+  ED8D 84                              ADD     A, H                        ; Right hand edge of display...
0553+  ED8E BA                              CP      D
0554+  ED8F 30 0A                           JR      NC, _conout_refresh
0555+  ED91             
0556+  ED91 7A                              LD      A, D                        ; Cursor col is after end of screen
0557+  ED92 90                              SUB     B
0558+  ED93 30 05                           JR      NC, _conout_scroll_done
0559+  ED95 AF                              XOR     A
0560+  ED96 18 02                           JR      _conout_scroll_done
0561+  ED98             
0562+  ED98 7A          _conout_scroll_l    LD      A, D
0563+  ED99 3D                              DEC     A
0564+  ED9A 67          _conout_scroll_done LD      H, A
0565+  ED9B             
0566+  ED9B             
0567+  ED9B             ; We enter with HL = new display column, row
0568+  ED9B             ; At this point one or both of display row or column may changed, so update the whole display...   
0569+  ED9B             ; If row is -1, we're before the beginning of the screen - need to scroll up
0570+  ED9B             ; And if row > console_height, we need to scroll down.. Display row stays constant, but screen_offset changes..
0571+  ED9B             
0572+  ED9B             ; Do scroll first, then only change display row/col if console_flags is set to track cursor..
0573+  ED9B             ; If display row/col have changed, compare screen buffer with display buffer and update whichever characters/brightnesses have changed..
0574+  ED9B             ;
0575+  ED9B             ; 
0576+  ED9B             _conout_refresh     
0577+  ED9B 7D                              LD      A, L
0578+  ED9C B7                              OR      A
0579+  ED9D F2 B4 ED                        JP      P, _conout_row_postv
0580+  EDA0             
0581+  EDA0                                 ; Display row negative
0582+  EDA0 AF                              XOR     A
0583+  EDA1 6F                              LD      L, A                        ; Reset display row to zero
0584+  EDA2 3A 2A FF                        LD      A, (screen_offset)
0585+  EDA5 3D                              DEC     A
0586+  EDA6 E6 3F                           AND     03Fh
0587+  EDA8 32 2A FF                        LD      (screen_offset), A
0588+  EDAB E5                              PUSH    HL
0589+  EDAC 0E 00                           LD      C, 0
0590+  EDAE CD 2F EF                        CALL    clear_screen_row
0591+  EDB1 E1                              POP     HL
0592+  EDB2 18 43                           JR      _conout_update_display
0593+  EDB4             
0594+  EDB4 3A 2F FF    _conout_row_postv   LD      A, (console_height)
0595+  EDB7 4F                              LD      C, A                        ; Remember for later on
0596+  EDB8 BD                              CP      L
0597+  EDB9 20 3C                           JR      NZ, _conout_update_display
0598+  EDBB             
0599+  EDBB                                 ; display row below screen
0600+  EDBB E5                              PUSH    HL
0601+  EDBC 3A 2A FF                        LD      A, (screen_offset)
0602+  EDBF 3C                              INC     A
0603+  EDC0 E6 3F                           AND     03Fh
0604+  EDC2 32 2A FF                        LD      (screen_offset), A
0605+  EDC5                                 ; SUB     C
0606+  EDC5 E6 3F                           AND     03Fh
0607+  EDC7 6F                              LD      L, A
0608+  EDC8             
0609+  EDC8 3A 29 FF                        LD      A, (screen_page)
0610+  EDCB FE 40                           CP      VIDEOBEAST_PAGE
0611+  EDCD 20 20                           JR      NZ, _not_videobeast
0612+  EDCF             
0613+  EDCF F3                              DI
0614+  EDD0 D3 71                           OUT     (IO_MEM_1), A
0615+  EDD2 3E F3                           LD      A, VB_UNLOCK
0616+  EDD4 32 FE 7F                        LD      (VB_REGISTERS_LOCKED), A
0617+  EDD7 7D                              LD      A, L
0618+  EDD8 87                              ADD     A, A
0619+  EDD9 87                              ADD     A, A
0620+  EDDA 87                              ADD     A, A
0621+  EDDB 32 C7 7F                        LD      (VB_LAYER_4+LAYER_SCROLL_Y), A
0622+  EDDE 3E 10                           LD      A, 010h
0623+  EDE0 38 01                           JR      C, _conout_scroll_xy
0624+  EDE2 AF                              XOR     A
0625+  EDE3 32 C6 7F    _conout_scroll_xy   LD      (VB_LAYER_4+LAYER_SCROLL_XY), A
0626+  EDE6 32 FE 7F                        LD      (VB_REGISTERS_LOCKED), A    ; Either value will re-lock registers..
0627+  EDE9             
0628+  EDE9 3A 3A FF                        LD      A, (page_1_mapping)
0629+  EDEC D3 71                           OUT     (IO_MEM_1), A
0630+  EDEE FB                              EI 
0631+  EDEF             
0632+  EDEF 79          _not_videobeast     LD      A, C
0633+  EDF0                                 
0634+  EDF0 0E 00                           LD      C, 0
0635+  EDF2 CD 2F EF                        CALL    clear_screen_row
0636+  EDF5 E1                              POP     HL 
0637+  EDF6 2D                              DEC     L
0638+  EDF7             
0639+  EDF7             _conout_update_display
0640+  EDF7                                 ; We've scrolled if necessary, update the display row if required..
0641+  EDF7 3A 32 FF                        LD      A, (console_flags)
0642+  EDFA E6 02                           AND     CFLAGS_TRACK_CURSOR         
0643+  EDFC 28 03                           JR      Z, _redraw_buffer
0644+  EDFE 22 2B FF                        LD      (display_row), HL           ; Only move display row if we're tracking the cursor
0645+  EE01             
0646+  EE01 F3          _redraw_buffer      DI
0647+  EE02 CD 07 EE                        CALL    unsafe_redraw
0648+  EE05 FB                              EI
0649+  EE06 C9                              RET
0650+  EE07             
0651+  EE07             ;----------------------------------------------------------------------------------------------------
0652+  EE07             ; Note that this uses Mem Page 1
0653+  EE07             ;
0654+  EE07 3A 32 FF    unsafe_redraw       LD      A, (console_flags)
0655+  EE0A E6 20                           AND     CFLAGS_LED_OFF
0656+  EE0C C0                              RET     NZ
0657+  EE0D             
0658+  EE0D 2A 2B FF    unsafe_led_redraw   LD      HL, (display_row)       ; Calculate our screen source in DE
0659+  EE10 3A 2A FF                        LD      A, (screen_offset)      
0660+  EE13 85                              ADD     A, L
0661+  EE14             
0662+  EE14 E6 3F                           AND     03Fh
0663+  EE16 F6 40                           OR      040h                    ; We're going to use page 1 for the screen buffer
0664+  EE18 57                              LD      D, A
0665+  EE19 7C                              LD      A, H
0666+  EE1A CB 27                           SLA     A
0667+  EE1C 5F                              LD      E, A
0668+  EE1D             
0669+  EE1D 21 85 FF                        LD      HL, display_buffer
0670+  EE20 06 18                           LD      B, DISPLAY_WIDTH
0671+  EE22 0E 00                           LD      C, 0
0672+  EE24             
0673+  EE24 3A 32 FF                        LD      A, (console_flags)      ; Don't draw last character if we've moved
0674+  EE27 E6 24                           AND     CFLAGS_SHOW_MOVED | CFLAGS_LED_OFF
0675+  EE29 28 01                           JR      Z, _full_redraw
0676+  EE2B 05                              DEC     B
0677+  EE2C             
0678+  EE2C 3A 29 FF    _full_redraw        LD      A, (screen_page)
0679+  EE2F D3 71                           OUT     (IO_MEM_1), A
0680+  EE31             
0681+  EE31 1A          _redraw_loop        LD      A, (DE)
0682+  EE32 BE                              CP      (HL)
0683+  EE33 28 0A                           JR      Z, _redraw_skip_char
0684+  EE35 77                              LD      (HL), A
0685+  EE36 C5                              PUSH    BC
0686+  EE37 E5                              PUSH    HL
0687+  EE38 D5                              PUSH    DE
0688+  EE39 CD CD F7                        CALL    disp_character
0689+  EE3C D1                              POP     DE
0690+  EE3D E1                              POP     HL
0691+  EE3E C1                              POP     BC
0692+  EE3F             
0693+  EE3F 23          _redraw_skip_char   INC     HL
0694+  EE40 13                              INC     DE
0695+  EE41             
0696+  EE41 3A 32 FF                        LD      A, (console_flags)
0697+  EE44 E6 24                           AND     CFLAGS_SHOW_MOVED | CFLAGS_LED_OFF
0698+  EE46 1A                              LD      A, (DE)  
0699+  EE47 28 05                           JR      Z, _redraw_normal
0700+  EE49             
0701+  EE49 CB 3F                           SRL     A
0702+  EE4B CB 3F                           SRL     A
0703+  EE4D 3C                              INC     A
0704+  EE4E             
0705+  EE4E BE          _redraw_normal      CP      (HL)
0706+  EE4F 28 12                           JR      Z, _redraw_skip_bri
0707+  EE51 77                              LD      (HL), A
0708+  EE52 C5                              PUSH    BC
0709+  EE53 E5                              PUSH    HL
0710+  EE54 D5                              PUSH    DE                
0711+  EE55 7E                              LD      A, (HL)             ; Ugh... disp_char_bright has parameters in other order..
0712+  EE56 CB 3F                           SRL     A
0713+  EE58 E6 78                           AND     078h
0714+  EE5A 47                              LD      B, A
0715+  EE5B 79                              LD      A, C
0716+  EE5C 48                              LD      C, B
0717+  EE5D CD 8F F7                        CALL    disp_char_bright    ; Column A, brightness C
0718+  EE60 D1                              POP     DE
0719+  EE61 E1                              POP     HL
0720+  EE62 C1                              POP     BC
0721+  EE63             
0722+  EE63 23          _redraw_skip_bri    INC     HL
0723+  EE64 13                              INC     DE
0724+  EE65 0C                              INC     C
0725+  EE66 10 C9                           DJNZ    _redraw_loop
0726+  EE68             
0727+  EE68 3A 32 FF                        LD      A, (console_flags)
0728+  EE6B 4F                              LD      C, A
0729+  EE6C E6 24                           AND     CFLAGS_SHOW_MOVED | CFLAGS_LED_OFF
0730+  EE6E 28 5D                           JR      Z, _redraw_done
0731+  EE70             
0732+  EE70                                 ; We've moved the cursor, so draw the last character as our location bitmap..
0733+  EE70 36 00       _redraw_moved       LD      (HL), 0
0734+  EE72 23                              INC     HL
0735+  EE73 36 80                           LD      (HL), DISP_DEFAULT_BRIGHTNESS
0736+  EE75 79                              LD      A, C
0737+  EE76 E6 20                           AND     CFLAGS_LED_OFF
0738+  EE78 79                              LD      A, C
0739+  EE79 28 05                           JR      Z, _led_normal
0740+  EE7B             
0741+  EE7B 21 07 09                        LD      HL, LED_OFF_BITMAP
0742+  EE7E 18 41                           JR      _redraw_map2
0743+  EE80             
0744+  EE80 E6 02       _led_normal         AND     CFLAGS_TRACK_CURSOR
0745+  EE82 20 4F                           JR      NZ, _redraw_tracking
0746+  EE84             
0747+  EE84 21 00 00                        LD      HL, 0
0748+  EE87 ED 4B 2D FF                     LD      BC, (cursor_row)
0749+  EE8B 0D                              DEC     C
0750+  EE8C                                 
0751+  EE8C ED 5B 2B FF                     LD      DE, (display_row)
0752+  EE90 7B                              LD      A, E
0753+  EE91 A7                              AND     A
0754+  EE92 20 05                           JR      NZ, _redraw_not_top
0755+  EE94 21 01 00                        LD      HL, MOVE_TOP_BITMAP
0756+  EE97 18 0A                           JR      _redraw_not_bottom
0757+  EE99             
0758+  EE99 3A 2F FF    _redraw_not_top     LD      A, (console_height)
0759+  EE9C 3D                              DEC     A
0760+  EE9D BB                              CP      E
0761+  EE9E 20 03                           JR      NZ, _redraw_not_bottom
0762+  EEA0 21 08 00                        LD      HL, MOVE_BOTTOM_BITMAP
0763+  EEA3             
0764+  EEA3 7B          _redraw_not_bottom  LD      A, E
0765+  EEA4 B9                              CP      C
0766+  EEA5 01 00 00                        LD      BC, 0
0767+  EEA8 20 04                           JR      NZ, _redraw_not_row
0768+  EEAA 0E C0                           LD      C, MOVE_ROW_BITMAP_L
0769+  EEAC 18 08                           JR      _redraw_map
0770+  EEAE             
0771+  EEAE 06 28       _redraw_not_row     LD      B, MOVE_BELOW_BITMAP_H
0772+  EEB0 38 02                           JR      C, _redraw_not_above
0773+  EEB2 18 02                           JR      _redraw_map
0774+  EEB4             
0775+  EEB4 06 05       _redraw_not_above   LD      B, MOVE_ABOVE_BITMAP_H
0776+  EEB6             
0777+  EEB6 09          _redraw_map         ADD     HL, BC
0778+  EEB7 3A 2C FF                        LD      A, (display_col)
0779+  EEBA A7                              AND     A
0780+  EEBB 20 04                           JR      NZ, _redraw_map2
0781+  EEBD 3E 30                           LD      A, MOVE_AT_LEFT_BITMAP
0782+  EEBF B5                              OR      L
0783+  EEC0 6F                              LD      L, A
0784+  EEC1 3E 17       _redraw_map2        LD      A, DISPLAY_WIDTH-1
0785+  EEC3 CD EE F7                        CALL    disp_bitmask
0786+  EEC6             
0787+  EEC6 3E 17                           LD      A, DISPLAY_WIDTH-1
0788+  EEC8 0E 80                           LD      C, DISP_DEFAULT_BRIGHTNESS
0789+  EECA CD 8F F7                        CALL    disp_char_bright
0790+  EECD             
0791+  EECD 3A 3A FF    _redraw_done        LD      A, (page_1_mapping)
0792+  EED0 D3 71                           OUT     (IO_MEM_1), A
0793+  EED2 C9                              RET
0794+  EED3             
0795+  EED3 21 3F 2D    _redraw_tracking    LD      HL, 2d3fh          ; Tracking symbol
0796+  EED6 18 E9                           JR      _redraw_map2
0797+  EED8             
0798+  EED8             MOVE_TOP_BITMAP     .EQU    0001h
0799+  EED8             MOVE_BOTTOM_BITMAP  .EQU    0008h
0800+  EED8             MOVE_ROW_BITMAP_L   .EQU    0c0h
0801+  EED8             MOVE_ABOVE_BITMAP_H .EQU    05h
0802+  EED8             MOVE_BELOW_BITMAP_H .EQU    28h
0803+  EED8             MOVE_AT_LEFT_BITMAP .EQU    030h
0804+  EED8             LED_OFF_BITMAP      .EQU    0907h
0805+  EED8             
0806+  EED8             ;---------------------------------------- Simple character output.. 
0807+  EED8 ED 5B 2D FF _conout_character   LD      DE, (cursor_row)
0808+  EEDC FE 0D                           CP      CARRIAGE_RETURN
0809+  EEDE 20 05                           JR      NZ, _conout_not_cr
0810+  EEE0                
0811+  EEE0 16 01                           LD      D, 1
0812+  EEE2 C3 4C ED                        JP      _conout_csr_update
0813+  EEE5             
0814+  EEE5 FE 0A       _conout_not_cr      CP      NEWLINE
0815+  EEE7 20 04                           JR      NZ, _conout_not_lf
0816+  EEE9             
0817+  EEE9 1C                              INC     E
0818+  EEEA C3 4C ED                        JP      _conout_csr_update
0819+  EEED             
0820+  EEED FE 08       _conout_not_lf      CP      BACKSPACE_CHAR
0821+  EEEF 20 05                           JR      NZ, _conout_visible
0822+  EEF1             
0823+  EEF1 15                              DEC     D
0824+  EEF2 C2 4C ED                        JP      NZ, _conout_csr_update
0825+  EEF5 C9                              RET
0826+  EEF6             
0827+  EEF6                                 ; Now, C is character to write,
0828+  EEF6 ED 5B 2D FF _conout_visible     LD      DE, (cursor_row)
0829+  EEFA 15                              DEC     D                       ; 1 based col
0830+  EEFB 1D                              DEC     E                       ; 1 based row
0831+  EEFC             
0832+  EEFC 3A 2A FF                        LD      A, (screen_offset)      ; Write the character and colour into our screen buffer
0833+  EEFF 83                              ADD     A, E
0834+  EF00             
0835+  EF00 E6 3F                           AND     03Fh
0836+  EF02 F6 40                           OR      040h                    ; We're going to use page 1 for the screen buffer
0837+  EF04 67                              LD      H, A
0838+  EF05 7A                              LD      A, D
0839+  EF06 CB 27                           SLA     A
0840+  EF08 6F                              LD      L, A
0841+  EF09 3A 29 FF                        LD      A, (screen_page)
0842+  EF0C D3 71                           OUT     (IO_MEM_1), A
0843+  EF0E 71                              LD      (HL), C
0844+  EF0F 3A 31 FF                        LD      A, (console_colour)
0845+  EF12 23                              INC     HL
0846+  EF13 77                              LD      (HL), A
0847+  EF14 3A 3A FF                        LD      A, (page_1_mapping)
0848+  EF17 D3 71                           OUT     (IO_MEM_1), A
0849+  EF19             
0850+  EF19 ED 5B 2D FF                     LD      DE, (cursor_row)
0851+  EF1D 3A 30 FF                        LD      A, (console_width)
0852+  EF20 6F                              LD      L, A
0853+  EF21 7A                              LD      A, D
0854+  EF22 BD                              CP      L
0855+  EF23 28 04                           JR      Z, _conout_wrap
0856+  EF25 14                              INC     D
0857+  EF26 C3 4C ED                        JP      _conout_csr_update
0858+  EF29             
0859+  EF29 16 01       _conout_wrap        LD      D, 1
0860+  EF2B 1C                              INC     E
0861+  EF2C C3 4C ED                        JP      _conout_csr_update          ; If we've wrapped, use the new wrap position..
0862+  EF2F             ;
0863+  EF2F             ;
0864+  EF2F             ; Fill the row of the screen buffer with space chars..
0865+  EF2F             ; Enter with A -> row of screen buffer, C -> start column
0866+  EF2F             ;          Uses HL, C
0867+  EF2F             ;
0868+  EF2F 67          clear_screen_row    LD      H, A
0869+  EF30 3A 2A FF                        LD      A, (screen_offset)
0870+  EF33 84                              ADD     A, H
0871+  EF34             
0872+  EF34 E6 3F                           AND    03Fh
0873+  EF36 F6 40                           OR     040h
0874+  EF38 67                              LD     H, A
0875+  EF39 79                              LD     A, C
0876+  EF3A 81                              ADD    A, C
0877+  EF3B 6F                              LD     L, A
0878+  EF3C             
0879+  EF3C 3A 31 FF                        LD      A, (console_colour)
0880+  EF3F 4F                              LD      C, A
0881+  EF40             
0882+  EF40 3A 29 FF                        LD      A, (screen_page)
0883+  EF43 D3 71                           OUT     (IO_MEM_1), A
0884+  EF45             
0885+  EF45 3E 20       _clear_loop         LD      A, ' '
0886+  EF47 77                              LD      (HL), A
0887+  EF48 2C                              INC     L
0888+  EF49 71                              LD      (HL), C
0889+  EF4A 2C                              INC     L
0890+  EF4B 3E FE                           LD      A, 0FEh
0891+  EF4D BD                              CP      L
0892+  EF4E 20 F5                           JR      NZ, _clear_loop
0893+  EF50             
0894+  EF50 3A 3A FF                        LD      A, (page_1_mapping)
0895+  EF53 D3 71                           OUT     (IO_MEM_1), A
0896+  EF55 C9                              RET
0897+  EF56             ;------------------------------------------------------  
0898+  EF56             bios_list     ;  5 List OUTput
0899+  EF56 AF                              XOR     A
0900+  EF57 C9                              RET
0901+  EF58                                 
0902+  EF58             ;------------------------------------------------------  
0903+  EF58             bios_punch    ;  6 punch OUTput
0904+  EF58 AF                              XOR     A
0905+  EF59 C9                              RET
0906+  EF5A                                 
0907+  EF5A             ;------------------------------------------------------  
0908+  EF5A             bios_reader   ;  7 Reader input
0909+  EF5A C9                              RET
0910+  EF5B                                 
0911+  EF5B             
0912+  EF5B                                 
0913+  EF5B             ;------------------------------------------------------  
0914+  EF5B             bios_seldsk   ;  9 Select disk - Select disc in C, returns HL =  address of DPH, or 0 if error
0915+  EF5B                                 ; Store C in A, Check drive is in range
0916+  EF5B 79                              LD      A, C
0917+  EF5C 21 00 00                        LD      HL, 0
0918+  EF5F FE 02                           CP      MAX_DRIVES
0919+  EF61 D0                              RET     NC
0920+  EF62             
0921+  EF62 06 00                           LD      B, 0
0922+  EF64 CB 21                           SLA     C
0923+  EF66 CB 21                           SLA     C
0924+  EF68 CB 21                           SLA     C
0925+  EF6A CB 21                           SLA     C
0926+  EF6C 21 33 EA                        LD      HL, dpbase
0927+  EF6F 09                              ADD     HL, BC
0928+  EF70 32 44 FF                        LD      (sys_seldsk), A
0929+  EF73 C9                              RET
0930+  EF74             
0931+  EF74             ;------------------------------------------------------  
0932+  EF74             bios_home     ;  8 Home disk
0933+  EF74 0E 00                           LD      C, 0            
0934+  EF76             ;------------------------------------------------------  
0935+  EF76             bios_settrk   ; 10 Select track - Move drive to track stored in C - 0 based (0-76)
0936+  EF76 79                              LD      A, C
0937+  EF77 32 3D FF                        LD      (sys_track), A
0938+  EF7A C9                              RET
0939+  EF7B                                 
0940+  EF7B             ;------------------------------------------------------  
0941+  EF7B             bios_setsec   ; 11 Select sector - Move drive to sector stored in BC - 1 based (1-26) - TODO: Confirm this, not sure if true..
0942+  EF7B ED 43 3E FF                     LD      (sys_sector), BC
0943+  EF7F C9                              RET
0944+  EF80                                 
0945+  EF80             ;------------------------------------------------------  
0946+  EF80             bios_setdma   ; 12 Set DMA ADDress - Set the DMA address to BC - source or destination for disk read/write
0947+  EF80                           ; Note: CP/M 2.2 appears to only set this to the DIRBUF address defined in the DPF, or the USER DMA address (0x80h)
0948+  EF80 ED 43 40 FF                     LD      (sys_dmaaddr), BC
0949+  EF84 C9                              RET
0950+  EF85                                 
0951+  EF85             ;------------------------------------------------------  
0952+  EF85             ;
0953+  EF85             ; Uses Mem Page 1, 2
0954+  EF85             ;
0955+  EF85             bios_read     ; 13 Read 128 bytes
0956+  EF85 CD F1 EF                        CALL    _get_memdisc_addr
0957+  EF88 F3                              DI
0958+  EF89 D3 71                           OUT     (IO_MEM_1), A
0959+  EF8B CB F0                           SET     6, B            ; Point B into page 1
0960+  EF8D C5                              PUSH    BC
0961+  EF8E E1                              POP     HL
0962+  EF8F 0E 80                           LD      C, 128
0963+  EF91             
0964+  EF91 ED 5B 40 FF                     LD      DE, (sys_dmaaddr)
0965+  EF95 7A                              LD      A, D
0966+  EF96 07                              RLCA
0967+  EF97 07                              RLCA
0968+  EF98 E6 03                           AND     03h             ; Bottom two bits
0969+  EF9A F6 20                           OR      RAM_PAGE_0
0970+  EF9C 47                              LD      B, A            ; B is destination page
0971+  EF9D D3 72       _read_page          OUT     (IO_MEM_2), A
0972+  EF9F             
0973+  EF9F CB FA                           SET     7, D            ; Point D to second page
0974+  EFA1 CB B2                           RES     6, D
0975+  EFA3             
0976+  EFA3 ED A0       _read_next          LDI
0977+  EFA5 79                              LD      A, C
0978+  EFA6 B7                              OR      A
0979+  EFA7 28 08                           JR      Z, _read_write_done
0980+  EFA9             
0981+  EFA9 CB 72                           BIT     6, D
0982+  EFAB 28 F6                           JR      Z, _read_next
0983+  EFAD             
0984+  EFAD 04                              INC     B
0985+  EFAE 78                              LD      A, B
0986+  EFAF 18 EC                           JR      _read_page
0987+  EFB1             
0988+  EFB1 3A 3A FF    _read_write_done    LD      A, (page_1_mapping)   ; Return page map to normal
0989+  EFB4 D3 71                           OUT     (IO_MEM_1), A
0990+  EFB6 3A 3B FF                        LD      A, (page_2_mapping)
0991+  EFB9 D3 72                           OUT     (IO_MEM_2), A
0992+  EFBB FB                              EI
0993+  EFBC AF                              XOR     A               ; No errors
0994+  EFBD C9                              RET
0995+  EFBE                                 
0996+  EFBE             ;------------------------------------------------------  
0997+  EFBE             ;
0998+  EFBE             ; Uses Mem Page 1, 2
0999+  EFBE             ;
1000+  EFBE             bios_write    ; 14 Write 128 bytes
1001+  EFBE 3A 44 FF                        LD      A, (sys_seldsk)
1002+  EFC1 B7                              OR      A
1003+  EFC2 20 02                           JR      NZ, _write_ok
1004+  EFC4 3C                              INC     A
1005+  EFC5 C9                              RET
1006+  EFC6             
1007+  EFC6 CD F1 EF    _write_ok           CALL    _get_memdisc_addr
1008+  EFC9 F3                              DI
1009+  EFCA D3 71                           OUT     (IO_MEM_1), A
1010+  EFCC CB F0                           SET     6, B
1011+  EFCE C5                              PUSH    BC
1012+  EFCF D1                              POP     DE
1013+  EFD0 0E 80                           LD      C, 128
1014+  EFD2             
1015+  EFD2 2A 40 FF                        LD      HL, (sys_dmaaddr)
1016+  EFD5 7C                              LD      A, H
1017+  EFD6 07                              RLCA
1018+  EFD7 07                              RLCA
1019+  EFD8 E6 03                           AND     03h              ; Bottom two bits
1020+  EFDA F6 20                           OR      RAM_PAGE_0
1021+  EFDC 47                              LD      B, A             ; B is source page
1022+  EFDD D3 72       _write_page         OUT     (IO_MEM_2), A
1023+  EFDF             
1024+  EFDF CB FC                           SET     7, H
1025+  EFE1 CB B4                           RES     6, H
1026+  EFE3             
1027+  EFE3 ED A0       _write_next         LDI
1028+  EFE5 79                              LD      A, C
1029+  EFE6 B7                              OR      A
1030+  EFE7 28 C8                           JR      Z, _read_write_done
1031+  EFE9             
1032+  EFE9 CB 74                           BIT     6, H
1033+  EFEB 28 F6                           JR      Z, _write_next
1034+  EFED             
1035+  EFED 04                              INC     B
1036+  EFEE 78                              LD      A, B
1037+  EFEF 18 EC                           JR      _write_page
1038+  EFF1                                 
1039+  EFF1             ; IN THIS CASE, WE HAVE SAVED THE DISK NUMBER IN 'DISKNO' (0, 1)
1040+  EFF1             ;           THE TRACK NUMBER IN 'TRACK' (0-76)
1041+  EFF1             ;           THE SECTOR NUMBER IN 'SECTOR' (1-26)
1042+  EFF1             ;           THE DMA ADDRESS IN 'DMAAD' (0-65535)
1043+  EFF1             ;
1044+  EFF1             ; Returns BC = address in page for sector
1045+  EFF1             ;          A = page number (ROM/RAM)
1046+  EFF1             ;
1047+  EFF1             ; Note: BC is always aligned to page boundaries, so a sector will never overlap the end of a page.
1048+  EFF1             ;
1049+  EFF1 21 00 00    _get_memdisc_addr   LD      HL, 0
1050+  EFF4 ED 4B 3D FF                     LD      BC, (sys_track)     ; C is track, B is sector (up to 256!)
1051+  EFF8 68                              LD      L, B
1052+  EFF9 44                              LD      B, H 
1053+  EFFA CB 21                           SLA     C                   ; x 2
1054+  EFFC CB 10                           RL      B
1055+  EFFE 09                              ADD     HL, BC
1056+  EFFF CB 21                           SLA     C                   ; x 4
1057+  F001 CB 10                           RL      B
1058+  F003 CB 21                           SLA     C                   ; x 8
1059+  F005 CB 10                           RL      B
1060+  F007 09                              ADD     HL, BC
1061+  F008 CB 21                           SLA     C                   ; x 16
1062+  F00A CB 10                           RL      B
1063+  F00C 09                              ADD     HL, BC              ; HL = Sector + BC * (2 + 8 + 16) = sector + track * 26
1064+  F00D             
1065+  F00D 7D                              LD      A, L
1066+  F00E E6 7F                           AND     07Fh
1067+  F010 47                              LD      B, A
1068+  F011 0E 00                           LD      C, 0
1069+  F013 CB 38                           SRL     B
1070+  F015 CB 19                           RR      C                   ; BC = Address in page of sector
1071+  F017             
1072+  F017 CB 25                           SLA     L
1073+  F019 CB 14                           RL      H                   ; H is now page number 
1074+  F01B             
1075+  F01B 3A 44 FF                        LD      A, (sys_seldsk)
1076+  F01E B7                              OR      A
1077+  F01F 28 05                           JR      Z, _get_memdisk_a
1078+  F021 3A 38 FF                        LD      A, (drive_b_mem_page)
1079+  F024 84                              ADD     A, H
1080+  F025 C9                              RET
1081+  F026 3A 37 FF    _get_memdisk_a      LD      A, (drive_a_mem_page)
1082+  F029 84                              ADD     A, H
1083+  F02A C9                              RET
1084+  F02B             
1085+  F02B             
1086+  F02B             ;------------------------------------------------------  
1087+  F02B             bios_listst   ; 15 List status
1088+  F02B AF                              XOR     A
1089+  F02C C9                              RET
1090+  F02D                                 
1091+  F02D             ;------------------------------------------------------  
1092+  F02D             bios_sectrn   ; 16 Sector translate - BC = logical sector number (zero based), DE = address of translation table. Return HL as physical sector number
1093+  F02D 69                              LD      L, C                ; No skewing needed, just return BC in HL
1094+  F02E 60                              LD      H, B
1095+  F02F C9                              RET
1096+  F030                                 
1097+  F030             ;------------------------------------------------------
1098+  F030             ; Inline print. Preserves HL, DE, BC
1099+  F030             ;
1100+  F030 E3          m_print_inline      EX      (SP), HL
1101+  F031 7E          _inline_loop        LD      A, (HL)
1102+  F032 23                              INC     HL
1103+  F033 A7                              AND     A
1104+  F034 28 05                           JR      Z, _inline_done
1105+  F036 CD 3D F0                        CALL    m_print_a_safe
1106+  F039 18 F6                           JR      _inline_loop
1107+  F03B             
1108+  F03B E3          _inline_done        EX      (SP), HL
1109+  F03C C9                              RET
1110+  F03D             
1111+  F03D             ;------------------------------------------------------
1112+  F03D             ; Print character in A. Preserves HL, DE, BC
1113+  F03D             ;
1114+  F03D E5          m_print_a_safe      PUSH    HL
1115+  F03E D5                              PUSH    DE
1116+  F03F C5                              PUSH    BC
1117+  F040 4F                              LD      C, A
1118+  F041 CD 2C EC                        CALL    bios_conout
1119+  F044 C1                              POP     BC
1120+  F045 D1                              POP     DE
1121+  F046 E1                              POP     HL
1122+  F047 C9                              RET
1123+  F048             
1124+  F048             ;------------------------------------------------------  
1125+  F048             
1126+  F048 F3          configure_hardware  DI     
1127+  F049 3E 20                           LD      A, RAM_PAGE_0
1128+  F04B D3 70                           OUT     (IO_MEM_0), A       ; Page 0 is RAM 0 
1129+  F04D 32 39 FF                        LD      (page_0_mapping), A
1130+  F050 3C                              INC     A
1131+  F051 D3 71                           OUT     (IO_MEM_1), A       ; Page 1 is RAM 1
1132+  F053 32 3A FF                        LD      (page_1_mapping), A
1133+  F056 3C                              INC      A
1134+  F057 D3 72                           OUT     (IO_MEM_2), A       ; Page 2 is RAM 2 
1135+  F059 32 3B FF                        LD      (page_2_mapping), A
1136+  F05C 3C                              INC     A                   ; Assume we're in RAM 3
1137+  F05D 32 3C FF                        LD      (page_3_mapping), A
1138+  F060             
1139+  F060 21 00 FE                        LD      HL, 0FE00h          ; Set up the IM 2 table
1140+  F063 06 00                           LD      B, 0
1141+  F065 36 FD       _fill_vector        LD      (HL), 0FDh
1142+  F067 23                              INC     HL
1143+  F068 10 FB                           DJNZ    _fill_vector
1144+  F06A             
1145+  F06A CD D1 F2                        CALL    keyboard_init       ; Set up the keyboard status tables
1146+  F06D             
1147+  F06D 3E C3                           LD      A, 0C3h             ; JP reset   instruction
1148+  F06F 32 FD FD                        LD      (0FDFDh), A
1149+  F072 21 6E F1                        LD      HL, interrupt_handler
1150+  F075 22 FE FD                        LD      (0FDFEh), HL
1151+  F078             
1152+  F078 21 00 00                        LD      HL, 0
1153+  F07B 22 CF FF                        LD      (user_interrupt), HL
1154+  F07E             
1155+  F07E 3E 02                           LD      A, 2
1156+  F080 D3 13                           OUT     (PIO_B_CTRL),A      ; Zero interrupt vector
1157+  F082             
1158+  F082 3E B7                           LD      A, 0B7h             ; Enable interrupts on any of the following bits
1159+  F084 D3 13                           OUT     (PIO_B_CTRL),A
1160+  F086 00                              NOP
1161+  F087 3E CF                           LD      A, 0CFh             ; Just B5 (RTC interrupt) 
1162+  F089 D3 13                           OUT     (PIO_B_CTRL),A
1163+  F08B             
1164+  F08B 3E FE                           LD      A, 0FEh
1165+  F08D ED 47                           LD      I, A
1166+  F08F ED 5E                           IM      2
1167+  F091             
1168+  F091 CD EB F0                        CALL    setup_screen
1169+  F094             
1170+  F094 3E 04                           LD      A, DRIVE_A_PAGE
1171+  F096 32 37 FF                        LD      (drive_a_mem_page), A
1172+  F099             
1173+  F099 FB                              EI
1174+  F09A             
1175+  F09A 3E 00                           LD      A, 0
1176+  F09C CD 34 F5                        CALL    uart_init           ; Reinitialise the UART to make sure we've not missed anything
1177+  F09F             
1178+  F09F CD FE F8                        CALL    rtc_init            ; Make sure clock is running and reset time if necesary
1179+  F0A2             
1180+  F0A2 06 04       _set_ctrl           LD      B, 4                ; Set RTC Coarse mode and Output Pin to Square wave - gives 64 Hz pulse
1181+  F0A4 C5          _set_ctrl_loop      PUSH    BC
1182+  F0A5 26 6F                           LD      H, RTC_ADDRESS      
1183+  F0A7 2E 07                           LD      L, RTC_REG_CTRL
1184+  F0A9 CD 06 F6                        CALL    i2c_write_to
1185+  F0AC 30 0B                           JR      NC, _rtc_ack_error
1186+  F0AE 3E 44                           LD      A, RTC_64HZ_ENABLED
1187+  F0B0 CD 1A F6                        CALL    i2c_write
1188+  F0B3 30 04                           JR      NC, _rtc_ack_error
1189+  F0B5 AF                              XOR     A
1190+  F0B6 CD 1A F6                        CALL    i2c_write
1191+  F0B9 CD CE F5    _rtc_ack_error      CALL    i2c_stop
1192+  F0BC             
1193+  F0BC CD C7 F0                        CALL    _pause
1194+  F0BF             
1195+  F0BF CD CC F0                        CALL    _check_ctrl
1196+  F0C2 C1                              POP     BC
1197+  F0C3 C8                              RET     Z
1198+  F0C4 10 DE                           DJNZ    _set_ctrl_loop
1199+  F0C6 C9                              RET
1200+  F0C7             
1201+  F0C7 06 00       _pause              LD      B, 0
1202+  F0C9 10 FE                           DJNZ    $
1203+  F0CB C9                              RET
1204+  F0CC             
1205+  F0CC             ; Check that the control is set to coarse trim and 0 offset
1206+  F0CC             ; Returns with Zero flag set if settings are good.
1207+  F0CC             ;
1208+  F0CC 26 6F       _check_ctrl         LD      H, RTC_ADDRESS      
1209+  F0CE 2E 07                           LD      L, RTC_REG_CTRL
1210+  F0D0 CD E5 F5                        CALL    i2c_read_from
1211+  F0D3 16 02                           LD      D, 2
1212+  F0D5 30 11                           JR      NC, _ctrl_error
1213+  F0D7 5F                              LD      E, A
1214+  F0D8 CD 78 F6                        CALL    i2c_ack
1215+  F0DB CD 65 F6                        CALL    i2c_read
1216+  F0DE 57                              LD      D, A
1217+  F0DF CD CE F5                        CALL    i2c_stop
1218+  F0E2 7B                              LD      A, E
1219+  F0E3 06 04                           LD      B, 4
1220+  F0E5 FE 44                           CP      RTC_64HZ_ENABLED
1221+  F0E7 C0                              RET     NZ
1222+  F0E8 7A          _ctrl_error         LD      A, D
1223+  F0E9 A7                              AND     A
1224+  F0EA C9                              RET 
1225+  F0EB             
1226+  F0EB             ; SHOULD NOT BE CALLED WITH INTERRUPTS ENABLED!
1227+  F0EB             ;
1228+  F0EB 3E 40       setup_screen        LD      A, VIDEOBEAST_PAGE
1229+  F0ED D3 71                           OUT     (IO_MEM_1), A
1230+  F0EF 21 00 40                        LD      HL, PAGE_1_START
1231+  F0F2 AF                              XOR     A
1232+  F0F3 47                              LD      B, A
1233+  F0F4 77          _videobeast_check   LD      (HL), A
1234+  F0F5 BE                              CP      (HL)
1235+  F0F6 20 2E                           JR      NZ, _no_videobeast
1236+  F0F8 C6 0D                           ADD     A, 13
1237+  F0FA 10 F8                           DJNZ    _videobeast_check
1238+  F0FC             
1239+  F0FC 3E 40                           LD      A, VIDEOBEAST_PAGE
1240+  F0FE 32 54 F1                        LD      (_screen_defaults), A
1241+  F101 21 1E 50                        LD      HL, 0501Eh          ; 80 x 30 screen
1242+  F104 22 5A F1                        LD      (_screen_size), HL
1243+  F107             
1244+  F107 3E F3                           LD      A, VB_UNLOCK
1245+  F109 32 FE 7F                        LD      (VB_REGISTERS_LOCKED), A
1246+  F10C 3E 01                           LD      A, MODE_848 | MODE_MAP_16K
1247+  F10E 32 FF 7F                        LD      (VB_MODE), A
1248+  F111 AF                              XOR     A
1249+  F112 32 F9 7F                        LD      (VB_PAGE_0), A
1250+  F115 32 D0 7F                        LD      (VB_LAYER_5), A             ; Clear page 'above' our console
1251+  F118             
1252+  F118 21 62 F1                        LD      HL, _videobeast
1253+  F11B 11 C0 7F                        LD      DE, VB_LAYER_4
1254+  F11E 01 0C 00                        LD      BC, _videobeast_length
1255+  F121 ED B0                           LDIR
1256+  F123 32 FE 7F                        LD      (VB_REGISTERS_LOCKED), A  ; Lock registers
1257+  F126             
1258+  F126 11 29 FF    _no_videobeast      LD      DE, screen_page     ; Copy the startup defaults to the shared_data area
1259+  F129 21 54 F1                        LD      HL, _screen_defaults
1260+  F12C 01 0E 00                        LD      BC, _defaults_length
1261+  F12F ED B0                           LDIR
1262+  F131 3A 29 FF                        LD      A, (screen_page)    ; Clear the screen buffer
1263+  F134 D3 71                           OUT     (IO_MEM_1), A       ; Screen buffer is in PAGE_1
1264+  F136 21 00 40                        LD      HL, PAGE_1_START
1265+  F139 11 02 40                        LD      DE, PAGE_1_START+2
1266+  F13C 0E 20                           LD      C, ' '
1267+  F13E 3A 31 FF                        LD      A, (console_colour)
1268+  F141 47                              LD      B, A
1269+  F142 ED 43 00 40                     LD      (PAGE_1_START), BC
1270+  F146 01 FA 3F                        LD      BC, 16378           ; Don't over write last couple of bytes (VideoBeast)
1271+  F149 ED B0                           LDIR
1272+  F14B             
1273+  F14B CD 30 F8                        CALL    disp_clear          ; Clear the LED screen
1274+  F14E             
1275+  F14E 3A 3A FF    restore_page_return LD      A, (page_1_mapping)       ; Return Page 1 to normal RAM
1276+  F151 D3 71                           OUT     (IO_MEM_1), A
1277+  F153 C9                              RET
1278+  F154             
1279+  F154 24          _screen_defaults    .DB     CONSOLE_PAGE        ; Screen buffer page
1280+  F155 00                              .DB     0                   ; Row offset in buffer
1281+  F156 00 00                           .DB     0,0                 ; Row, column being shown on LED Display
1282+  F158 01 01                           .DB     1,1                 ; Row, column of cursor
1283+  F15A 18 40       _screen_size        .DB     24,64               ; Console height (rows), width (columns)
1284+  F15C F0                              .DB     0F0h                ; Current colour [7:4] = background, [3:0] = foreground
1285+  F15D 02          default_screen_flags .DB     CFLAGS_TRACK_CURSOR ; Flags
1286+  F15E 00                              .DB     0                   ; Timer
1287+  F15F 00 00                           .DB     0, 0                ; Escape char and first parameter
1288+  F161 00                              .DB     0                   ; Disable identifier sequence
1289+  F162             _defaults_length    .EQU    $-_screen_defaults
1290+  F162             
1291+  F162 01 01 1E 02 _videobeast         .DB     TYPE_TEXT, 1, 30, 2, 81         ; Text, top, bottom, left, right
1291+  F166 51 
1292+  F167 00 00 00                        .DB     0, 0, 0                         ; No scroll
1293+  F16A 00 10                           .DB     0, 010h                         ; Char map in page 0, font 16x2K -> 32K
1294+  F16C 07 00                           .DB     7, 0                            ; Palette 0, no hi-res
1295+  F16E             _videobeast_length  .EQU    $-_videobeast
1296+  F16E             
1297+  F16E F3          interrupt_handler   DI
1298+  F16F ED 73 CD FF                     LD      (intr_stack), SP
1299+  F173 31 CD FF                        LD      SP, intr_stack
1300+  F176 F5                              PUSH    AF
1301+  F177 D9                              EXX
1302+  F178 CD E6 F2                        CALL    keyboard_poll
1303+  F17B             
1304+  F17B 3A 13 FF                        LD      A,(control_key_pressed)
1305+  F17E A7                              AND     A
1306+  F17F C4 D0 F1                        CALL    NZ, handle_screen_shift
1307+  F182             
1308+  F182 3A 33 FF                        LD      A, (console_timer)
1309+  F185 3D                              DEC     A
1310+  F186 FA 99 F1                        JP      M, _not_moved
1311+  F189 32 33 FF                        LD      (console_timer), A
1312+  F18C 20 0B                           JR      NZ, _not_moved
1313+  F18E             
1314+  F18E 3A 32 FF                        LD      A, (console_flags)
1315+  F191 E6 FB                           AND     ~CFLAGS_SHOW_MOVED
1316+  F193 32 32 FF                        LD      (console_flags), A
1317+  F196 CD 07 EE                        CALL    unsafe_redraw
1318+  F199             
1319+  F199 2A 04 FF    _not_moved          LD      HL, (timer)
1320+  F19C 5D                              LD      E, L                ; E is old low byte of timer - used to blink cursor
1321+  F19D 23                              INC     HL
1322+  F19E 22 04 FF                        LD      (timer), HL
1323+  F1A1 7C                              LD      A, H
1324+  F1A2 B5                              OR      L
1325+  F1A3 20 07                           JR      NZ, _timer_done
1326+  F1A5 2A 06 FF                        LD      HL, (timer+2)
1327+  F1A8 23                              INC     HL
1328+  F1A9 22 06 FF                        LD      (timer+2),HL   
1329+  F1AC             
1330+  F1AC 3A 32 FF    _timer_done         LD      A, (console_flags)
1331+  F1AF E6 01                           AND     CFLAGS_SHOW_CURSOR
1332+  F1B1 28 0B                           JR      Z, _int_done
1333+  F1B3             
1334+  F1B3 3A 04 FF                        LD      A, (timer)          ; Blink when timer bit changes
1335+  F1B6 AB                              XOR     E
1336+  F1B7 E6 20                           AND     020h
1337+  F1B9 28 03                           JR      Z, _int_done
1338+  F1BB CD 6B F2                        CALL    update_cursor
1339+  F1BE             
1340+  F1BE 2A CF FF    _int_done           LD      HL, (user_interrupt)
1341+  F1C1 7C                              LD      A, H
1342+  F1C2 B5                              OR      L
1343+  F1C3 C4 CF F1                        CALL    NZ, _do_usr_interrupt
1344+  F1C6             
1345+  F1C6 D9                              EXX
1346+  F1C7 F1                              POP     AF
1347+  F1C8 ED 7B CD FF                     LD      SP, (intr_stack)
1348+  F1CC FB                              EI
1349+  F1CD ED 4D       _do_reti            RETI
1350+  F1CF             
1351+  F1CF E9          _do_usr_interrupt   JP      (HL)
1352+  F1D0             
1353+  F1D0             ; Enter with A containing a special control character
1354+  F1D0             ;
1355+  F1D0             ;
1356+  F1D0 FE 90       handle_screen_shift CP      KEY_CTRL_UP
1357+  F1D2 20 25                           JR      NZ, _not_ctrl_up
1358+  F1D4             
1359+  F1D4 3A 2B FF                        LD      A, (display_row)
1360+  F1D7 3D                              DEC     A
1361+  F1D8 FA 66 F2                        JP      M, _shift_done
1362+  F1DB F5          _shift_row          PUSH    AF
1363+  F1DC 1E 00                           LD      E, 0
1364+  F1DE CD 6B F2                        CALL    update_cursor
1365+  F1E1 F1                              POP     AF
1366+  F1E2 32 2B FF                        LD      (display_row), A
1367+  F1E5             
1368+  F1E5 3A 32 FF    _shift_complete     LD      A, (console_flags)
1369+  F1E8 E6 FD                           AND     ~CFLAGS_TRACK_CURSOR
1370+  F1EA F6 04       _flags_and_redraw   OR      CFLAGS_SHOW_MOVED
1371+  F1EC 32 32 FF                        LD      (console_flags), A
1372+  F1EF 3E 3C                           LD      A, SHOW_MOVE_DELAY
1373+  F1F1 32 33 FF                        LD      (console_timer),A
1374+  F1F4 CD 0D EE                        CALL    unsafe_led_redraw       ; Always redraw regardless of LED status
1375+  F1F7 18 6D                           JR      _shift_done
1376+  F1F9             
1377+  F1F9 FE 91       _not_ctrl_up        CP      KEY_CTRL_DOWN
1378+  F1FB 20 0D                           JR      NZ, _not_ctrl_down
1379+  F1FD             
1380+  F1FD 3A 2F FF    _shift_down         LD      A, (console_height)
1381+  F200 4F                              LD      C, A
1382+  F201 3A 2B FF                        LD      A, (display_row)
1383+  F204 3C                              INC     A
1384+  F205 B9                              CP      C
1385+  F206 28 5E                           JR      Z, _shift_done
1386+  F208 18 D1                           JR      _shift_row
1387+  F20A             
1388+  F20A FE 93       _not_ctrl_down      CP      KEY_CTRL_RIGHT
1389+  F20C 20 0F                           JR      NZ, _not_ctrl_right
1390+  F20E             
1391+  F20E 3A 30 FF                        LD      A, (console_width)
1392+  F211 D6 17                           SUB     DISPLAY_WIDTH-1
1393+  F213 4F                              LD      C, A
1394+  F214 3A 2C FF                        LD      A, (display_col)
1395+  F217 3C                              INC     A
1396+  F218 B9                              CP      C
1397+  F219 28 4B                           JR      Z, _shift_done
1398+  F21B 18 0B                           JR      _shift_col
1399+  F21D             
1400+  F21D FE 92       _not_ctrl_right     CP      KEY_CTRL_LEFT
1401+  F21F 20 13                           JR      NZ, _not_ctrl_left
1402+  F221             
1403+  F221 3A 2C FF                        LD      A, (display_col)
1404+  F224 3D                              DEC     A
1405+  F225 FA 66 F2                        JP      M, _shift_done
1406+  F228 F5          _shift_col          PUSH    AF
1407+  F229 1E 00                           LD      E, 0
1408+  F22B CD 6B F2                        CALL    update_cursor
1409+  F22E F1                              POP     AF
1410+  F22F 32 2C FF                        LD      (display_col), A
1411+  F232 18 B1                           JR      _shift_complete
1412+  F234             
1413+  F234 FE 94       _not_ctrl_left      CP      KEY_CTRL_ENTER
1414+  F236 20 19                           JR      NZ, _not_ctrl_enter
1415+  F238 3A 2D FF                        LD      A, (cursor_row)
1416+  F23B 3D                              DEC     A
1417+  F23C 32 2B FF                        LD      (display_row), A
1418+  F23F 3A 2E FF                        LD      A, (cursor_col)
1419+  F242 D6 16                           SUB     DISPLAY_WIDTH-2
1420+  F244 30 01                           JR      NC, _col_ok
1421+  F246 AF                              XOR     A
1422+  F247             
1423+  F247 32 2C FF    _col_ok             LD      (display_col), A
1424+  F24A 3A 32 FF                        LD      A, (console_flags)
1425+  F24D F6 02                           OR      CFLAGS_TRACK_CURSOR
1426+  F24F 18 99                           JR      _flags_and_redraw
1427+  F251             
1428+  F251 FE 95       _not_ctrl_enter     CP      KEY_CTRL_SPACE
1429+  F253 20 06                           JR      NZ, _not_ctrl_space
1430+  F255             
1431+  F255 AF                              XOR     A
1432+  F256 32 2C FF                        LD      (display_col), A
1433+  F259 18 A2                           JR      _shift_down
1434+  F25B             
1435+  F25B FE 96       _not_ctrl_space     CP      KEY_CTRL_D
1436+  F25D 20 07                           JR      NZ, _shift_done
1437+  F25F             
1438+  F25F 3A 32 FF                        LD      A, (console_flags)
1439+  F262 EE 20                           XOR     CFLAGS_LED_OFF
1440+  F264 18 84                           JR      _flags_and_redraw
1441+  F266             
1442+  F266 AF          _shift_done         XOR     A
1443+  F267 32 13 FF                        LD      (control_key_pressed),A
1444+  F26A C9                              RET
1445+  F26B             
1446+  F26B             ;
1447+  F26B             ; Blinks the cursor 
1448+  F26B             ;  Enter with E = timer low byte. 
1449+  F26B             ;  If CURSOR_BIT is 1, show the cursor at the line, otherwise restore the existing character
1450+  F26B             ;
1451+  F26B 3A 2B FF    update_cursor       LD      A, (display_row)    ; Are we on the same row as the cursor?
1452+  F26E 47                              LD      B, A
1453+  F26F 3A 2D FF                        LD      A, (cursor_row)
1454+  F272 3D                              DEC     A
1455+  F273 B8                              CP      B
1456+  F274 C0                              RET     NZ
1457+  F275             
1458+  F275 3A 2C FF                        LD      A, (display_col)    ; Check the cursor column is within the display window
1459+  F278 47                              LD      B, A
1460+  F279 3A 2E FF                        LD      A, (cursor_col)
1461+  F27C 3D                              DEC     A
1462+  F27D 90                              SUB     B
1463+  F27E F8                              RET     M
1464+  F27F             
1465+  F27F 06 00                           LD      B, 0
1466+  F281 4F                              LD      C, A
1467+  F282             
1468+  F282 3A 29 FF                        LD      A, (screen_page)
1469+  F285 FE 40                           CP      VIDEOBEAST_PAGE
1470+  F287 20 2E                           JR      NZ, _skip_videobeast
1471+  F289             
1472+  F289 D3 71                           OUT     (IO_MEM_1), A
1473+  F28B             
1474+  F28B 3A 2A FF                        LD      A, (screen_offset)
1475+  F28E 67                              LD      H, A
1476+  F28F 3A 2D FF                        LD      A, (cursor_row)         ; 1 based
1477+  F292 3D                              DEC     A
1478+  F293 84                              ADD     A, H
1479+  F294 E6 3F                           AND     03Fh
1480+  F296 F6 40                           OR      040h                    ; Page 1 for videobeast
1481+  F298 67                              LD      H, A
1482+  F299 3A 2E FF                        LD      A, (cursor_col)
1483+  F29C 3D                              DEC     A
1484+  F29D 87                              ADD     A, A
1485+  F29E 6F                              LD      L, A
1486+  F29F 2C                              INC     L
1487+  F2A0             
1488+  F2A0 7B                              LD      A, E
1489+  F2A1 E6 20                           AND     20h
1490+  F2A3 3A 31 FF                        LD      A, (console_colour)
1491+  F2A6 28 08                           JR      Z, _normal
1492+  F2A8 CB 0F                           RRC     A 
1493+  F2AA CB 0F                           RRC     A
1494+  F2AC CB 0F                           RRC     A
1495+  F2AE CB 0F                           RRC     A
1496+  F2B0 77          _normal             LD      (HL), A
1497+  F2B1             
1498+  F2B1 2B                              DEC     HL
1499+  F2B2 3A 3A FF                        LD      A, (page_1_mapping)
1500+  F2B5 D3 71                           OUT     (IO_MEM_1), A
1501+  F2B7             
1502+  F2B7 79          _skip_videobeast    LD      A, C
1503+  F2B8 FE 18                           CP      DISPLAY_WIDTH
1504+  F2BA D0                              RET     NC
1505+  F2BB             
1506+  F2BB 3A 32 FF                        LD      A, (console_flags)
1507+  F2BE E6 20                           AND     CFLAGS_LED_OFF
1508+  F2C0 C0                              RET     NZ
1509+  F2C1             
1510+  F2C1                                 ; At this point, BC holds the current display column for the cursor..
1511+  F2C1 21 85 FF                        LD      HL, display_buffer
1512+  F2C4 09                              ADD     HL, BC
1513+  F2C5 09                              ADD     HL, BC
1514+  F2C6             
1515+  F2C6 7B                              LD      A, E
1516+  F2C7 E6 20                           AND     20h
1517+  F2C9 7E                              LD      A, (HL)
1518+  F2CA 28 02                           JR      Z, _unblink
1519+  F2CC 3E 5F                           LD      A, '_'
1520+  F2CE C3 CD F7    _unblink            JP    disp_character
1521+  F2D1             
1522+  F2D1                                 .INCLUDE "../ports.asm"
0001++ F2D1             ;
0002++ F2D1             ; Port definintions
0003++ F2D1             ;
0004++ F2D1             ;
0005++ F2D1             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006++ F2D1             ;
0007++ F2D1             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008++ F2D1             ;
0009++ F2D1             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010++ F2D1             ; of this software and associated documentation files (the "Software"), to deal
0011++ F2D1             ; in the Software without restriction, including without limitation the rights
0012++ F2D1             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013++ F2D1             ; copies of the Software, and to permit persons to whom the Software is
0014++ F2D1             ; furnished to do so, subject to the following conditions:
0015++ F2D1             ; 
0016++ F2D1             ; The above copyright notice and this permission notice shall be included in all
0017++ F2D1             ; copies or substantial portions of the Software.
0018++ F2D1             ; 
0019++ F2D1             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020++ F2D1             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021++ F2D1             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022++ F2D1             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023++ F2D1             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024++ F2D1             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025++ F2D1             ; SOFTWARE.
0026++ F2D1             ;
0027++ F2D1             
0028++ F2D1             BACKSPACE_CHAR      .EQU  08h
0029++ F2D1             CARRIAGE_RETURN     .EQU  0Dh
0030++ F2D1             NEWLINE             .EQU  0Ah
0031++ F2D1             ESCAPE_CHAR         .EQU  1Bh
0032++ F2D1             CPM_NUM             .EQU  1Fh
0033++ F2D1             
0034++ F2D1             ;=================================== UART ============================================
0035++ F2D1             UART_TX_RX          .EQU    020h    ; Read: receiver buffer, Write: transmitter buffer
0036++ F2D1             UART_INT_ENABLE     .EQU    021h    ; Interrupt enable register
0037++ F2D1             UART_INT_ID         .EQU    022h    ; Read: Interrupt identification register
0038++ F2D1             UART_FIFO_CTRL      .EQU    022h    ; Write: FIFO Control register
0039++ F2D1             UART_LINE_CTRL      .EQU    023h    ; Line control register
0040++ F2D1             UART_MODEM_CTRL     .EQU    024h    ; Modem control
0041++ F2D1             UART_LINE_STATUS    .EQU    025h    ; Line status
0042++ F2D1             UART_MODEM_STATUS   .EQU    026h    ; Modem status
0043++ F2D1             UART_SCRATCH        .EQU    027h    ; Scratch register
0044++ F2D1             
0045++ F2D1             ;==================================== PIO ============================================
0046++ F2D1             PIO_A_DATA          .EQU  010h
0047++ F2D1             PIO_A_CTRL          .EQU  012h
0048++ F2D1             
0049++ F2D1             PIO_B_DATA          .EQU  011h
0050++ F2D1             PIO_B_CTRL          .EQU  013h
0051++ F2D1             
0052++ F2D1             PIO_MODE_0          .EQU  00Fh      ; Mode 0: All outputs
0053++ F2D1             PIO_MODE_1          .EQU  04fh      ; Mode 1: All inputs
0054++ F2D1             PIO_MODE_2          .EQU  080h      ; Mode 2 (Port A only): Bi-directional
0055++ F2D1             PIO_MODE_3          .EQU  0CFh      ; Mode 3: Per-pin I/O on the given port - write an additional word with bits set (1) for input, reset (0) for output on the matching pin.
0056++ F2D1             
0057++ F2D1             PIO_SET_INTERRUPT   .EQU  007h      ; Set interrupt control world. By itself, this wil disable interrupts on the given port. OR with the following constants to change this
0058++ F2D1             PIO_ENABLE_INT      .EQU  080h      ; Enable interrupts on the given port, when OR'd with the PIO_SET_INTERRUPT control word.
0059++ F2D1             PIO_INT_MASK        .EQU  010h      ; When OR'd with the PIO_SET_INTERRUPT control word, the following word will enable interrupts for pins where the matching bit is zero
0060++ F2D1             
0061++ F2D1             ;================================== AUDIO ============================================
0062++ F2D1             ; Constants for Audio output
0063++ F2D1             AUDIO_PIO           .EQU  1         ; Audio on PIO (rev. 0.1 boards)
0064++ F2D1             AUDIO_UART          .EQU  2         ; Audio on UART (rev. 0.2 boards)
0065++ F2D1             
0066++ F2D1             AUDIO_VERSION       .EQU  AUDIO_UART
0067++ F2D1             
0068++ F2D1~            #IF AUDIO_VERSION = AUDIO_PIO
0069++ F2D1~            PORT_B_IOMASK       .EQU  0EFh      ; All inputs, apart from bit 4 (audio out)
0070++ F2D1~            AUDIO_MASK          .EQU  010h      ; Bitmask for audio output on Port B. The bit is set for the output pin.
0071++ F2D1~            AUDIO_PORT          .EQU  PIO_B_DATA
0072++ F2D1~            
0073++ F2D1             #ELSE
0074++ F2D1             PORT_B_IOMASK       .EQU  0FFh      ; All inputs
0075++ F2D1             AUDIO_MASK          .EQU  008h      ; Bitmask for audio output on UART Out 2. The bit is set for the output pin
0076++ F2D1             AUDIO_PORT          .EQU  UART_MODEM_CTRL
0077++ F2D1             
0078++ F2D1             #ENDIF
0079++ F2D1             
0080++ F2D1             
0081++ F2D1             ;=================================== MEMORY PAGING ===================================
0082++ F2D1             IO_MEM_0            .EQU    070h      ; Page 0: 0000h - 3fffh
0083++ F2D1             IO_MEM_1            .EQU    071h      ; Page 1: 4000h - 7fffh
0084++ F2D1             IO_MEM_2            .EQU    072h      ; Page 2: 8000h - bfffh
0085++ F2D1             IO_MEM_3            .EQU    073h      ; Page 3: c000h - ffffh
0086++ F2D1             
0087++ F2D1             IO_MEM_CTRL         .EQU    074h      ; Paging enable register
0088++ F2D1             IO_MEM_ENABLE       .EQU    1
0089++ F2D1             IO_MEM_DISABLE      .EQU    0 
0090++ F2D1             
0091++ F2D1             RAM_PAGE_0          .EQU    020h
0092++ F2D1             RAM_PAGE_1          .EQU    021h
0093++ F2D1             RAM_PAGE_2          .EQU    022h
0094++ F2D1             RAM_PAGE_3          .EQU    023h
0095++ F2D1             
0096++ F2D1             RAM_PAGE_16         .EQU    030h
0097++ F2D1             RAM_PAGE_31         .EQU    03Fh
0098++ F2D1             
0099++ F2D1             ROM_PAGE_0          .EQU    000h
0100++ F2D1             ROM_PAGE_16         .EQU    010h
0101++ F2D1             
0102++ F2D1             PAGE_1_START        .EQU    4000h
0103++ F2D1             
0104++ F2D1             ;====================================== I2C DEVICES ===================================
0105++ F2D1             I2C_DATA_BIT            .equ    7
0106++ F2D1             I2C_CLK_BIT             .equ    6
0107++ F2D1             
0108++ F2D1             I2C_DATA_MASK           .equ    1 << I2C_DATA_BIT
0109++ F2D1             I2C_CLK_MASK            .equ    1 << I2C_CLK_BIT
0110++ F2D1             
0111++ F2D1             ; Display
0112++ F2D1             ;==========
0113++ F2D1             DL_ADDRESS              .EQU    050h     ; Left  Matrix controller I2C address
0114++ F2D1             DR_ADDRESS              .EQU    053h     ; Right Matrix controller I2C address
0115++ F2D1             
0116++ F2D1             DISP_REG_CRWL           .EQU    0FEh     ; Command Register write lock
0117++ F2D1             DISP_UNLOCK             .EQU    0C5h     ; Unlock command
0118++ F2D1             
0119++ F2D1             DISP_DEFAULT_BRIGHTNESS .EQU    080h     ; Default brightness
0120++ F2D1             DISP_DIMMED             .EQU    018h     ; Dimmed
0121++ F2D1             
0122++ F2D1             DISPLAY_WIDTH           .EQU    24       ; 24 characters
0123++ F2D1             
0124++ F2D1             ; RTC
0125++ F2D1             ;==========
0126++ F2D1             RTC_ADDRESS             .EQU    06fh
0127++ F2D1             
0128++ F2D1             RTC_REG_SEC             .EQU    000h    ; Also has oscillator enable bit in B7, 1 = run
0129++ F2D1             RTC_REG_MIN             .EQU    001h
0130++ F2D1             RTC_REG_HOUR            .EQU    002h    ; B6: 1 = 12hr/ 0 = 24hr clock (r/w) 
0131++ F2D1                                                     ;        If 12 hr clock, B5: 1 = PM/ 0 = AM. B4: hour tens. Otherwise B5-4: hour tens, B3-0: hour units
0132++ F2D1             RTC_REG_WKDAY           .EQU    003h    ; Oscillator status bit in B5, 1 = enabled and running. 
0133++ F2D1                                                     ;   B4: 1 = power was lost, write 0 to clear (timestamp registers are set)
0134++ F2D1                                                     ;   B3: 1 = enable external battery supply (VBAT)
0135++ F2D1                                                     ;   B2-0: Weekday, from 1 to 7 
0136++ F2D1             RTC_REG_DATE            .EQU    004h    ; BCD Date (1 to 31)
0137++ F2D1             RTC_REG_MTH             .EQU    005h    ; B5: 1 = Leap year (read only). B4: month tens, B3-0: month units  (Month is 1 to 12)
0138++ F2D1             RTC_REG_YEAR            .EQU    006h    ; BCD Year
0139++ F2D1             
0140++ F2D1             RTC_REG_CTRL            .EQU    007h    ; B7: If Square wave and Alarm 0 and Alarm 1 are disabled, sets Output Pin level
0141++ F2D1                                                     ;   B6: SQWEN, 1 = Enable square wave on Output Pin, Alarms disabled
0142++ F2D1                                                     ;   B5, B4: Alarm 1, 0 Enable. 1 = Alarm is enabled
0143++ F2D1                                                     ;   B3: 1 = Use external oscillator
0144++ F2D1                                                     ;   B2: CRSTRIM, 1 = Coarse trim mode, Output pin is 64Hz
0145++ F2D1                                                     ;   B1-0: If SQWEN = 1 & CRSTRIM = 0, sets Output pin freq. 00 -> 1Hz, 01 -> 4.096kHz, 10 -> 8.192kHz, 11 -> 32.768kHz
0146++ F2D1             RTC_REG_TRIM            .EQU    008h    ; Trim, initially 0. B7: Sign, 1=Add, 0=Subtract clock cycles.  
0147++ F2D1                                                     ;   B6-0: Trim amount/2. Applied 1 every minute in fine trim, 128 times a second in coarse trim mode. 0 = disable trim
0148++ F2D1             
0149++ F2D1             RTC_64HZ_ENABLED        .EQU    044h    ; Value for RTC_REG_CTRL to enable 64Hz interrupt output
0150++ F2D1             
0151++ F2D1             RTC_WEEKDAY_RUNNING     .EQU    008h    ; Value for RTC_REG_WKDAY for normal running of clock
0152++ F2D1             
0153++ F2D1             RTC_SRAM_OPT            .EQU    020h    ; Start address of the 4 byte boot options settings in SRAM
1523+  F2D1             
1524+  F2D1                                 .INCLUDE "../io.asm"
0001++ F2D1             ;
0002++ F2D1             ; I/O routines.. specifically keyboard and serial
0003++ F2D1             ;
0004++ F2D1             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ F2D1             ;
0006++ F2D1             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ F2D1             ;
0008++ F2D1             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ F2D1             ; of this software and associated documentation files (the "Software"), to deal
0010++ F2D1             ; in the Software without restriction, including without limitation the rights
0011++ F2D1             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ F2D1             ; copies of the Software, and to permit persons to whom the Software is
0013++ F2D1             ; furnished to do so, subject to the following conditions:
0014++ F2D1             ; 
0015++ F2D1             ; The above copyright notice and this permission notice shall be included in all
0016++ F2D1             ; copies or substantial portions of the Software.
0017++ F2D1             ; 
0018++ F2D1             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ F2D1             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ F2D1             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ F2D1             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ F2D1             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ F2D1             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ F2D1             ; SOFTWARE.
0025++ F2D1             ;
0026++ F2D1             
0027++ F2D1             
0028++ F2D1 21 08 FF    keyboard_init       LD      HL, keyboard_state
0029++ F2D4 06 20                           LD      B, io_data_end - keyboard_state
0030++ F2D6 AF                              XOR     A
0031++ F2D7 77          _init_loop          LD      (HL),A
0032++ F2D8 23                              INC     HL
0033++ F2D9 10 FC                           DJNZ    _init_loop
0034++ F2DB AF                              XOR     A
0035++ F2DC 32 28 FF                        LD      (input_size),A
0036++ F2DF 32 27 FF                        LD      (input_free),A
0037++ F2E2 32 26 FF                        LD      (input_pos),A
0038++ F2E5 C9                              RET
0039++ F2E6             
0040++ F2E6             ; Poll the keyboard, adding raw codes to the keyboard_state buffer, and decoded characters to the input_buffer
0041++ F2E6             ;
0042++ F2E6 01 00 FD    keyboard_poll       LD      BC, 0FD00h          ; Check shift key
0043++ F2E9 3A 12 FF                        LD      A, (key_shift_state)
0044++ F2EC E6 FC                           AND     ~(KEY_SHIFT_BIT | KEY_CTRL_BIT)
0045++ F2EE 57                              LD      D, A
0046++ F2EF             
0047++ F2EF ED 78                           IN      A, (C)
0048++ F2F1 E6 20                           AND     020h
0049++ F2F3 20 04                           JR      NZ, _check_ctrl_key
0050++ F2F5 3E 01                           LD      A, KEY_SHIFT_BIT
0051++ F2F7 B2                              OR      D
0052++ F2F8 57                              LD      D, A
0053++ F2F9             
0054++ F2F9 01 00 FE    _check_ctrl_key     LD      BC, 0FE00h          ; Keyboard row 0
0055++ F2FC ED 78                           IN      A, (C)
0056++ F2FE E6 10                           AND     010h
0057++ F300 20 04                           JR      NZ, _store_modifiers
0058++ F302 3E 02                           LD      A, KEY_CTRL_BIT
0059++ F304 B2                              OR      D
0060++ F305 57                              LD      D, A
0061++ F306             
0062++ F306 7A          _store_modifiers    LD      A, D
0063++ F307 32 12 FF                        LD      (key_shift_state), A
0064++ F30A             
0065++ F30A             
0066++ F30A 21 74 F4                        LD      HL, keyboard
0067++ F30D ED 78       _poll_loop          IN      A, (C)              ; BC -> Keyboard row port..
0068++ F30F 16 01                           LD      D, 1                ; D -> Current Bit
0069++ F311 5F                              LD      E, A                ; E -> Key row bit set
0070++ F312 22 10 FF    _next_key           LD      (keyboard_pos), HL
0071++ F315 A2                              AND     D
0072++ F316 20 3F                           JR      NZ, _released
0073++ F318                                                             ; Key is pressed... add it to state buffer
0074++ F318 C5                              PUSH    BC
0075++ F319 7E                              LD      A, (HL)             ; Raw key code in A
0076++ F31A             
0077++ F31A 21 08 FF                        LD      HL, keyboard_state
0078++ F31D 06 08                           LD      B, _key_state_size
0079++ F31F BE          _check_pressed      CP      (HL)
0080++ F320 CA 70 F3                        JP      Z, _do_nothing      ; Key already in state table - nothing to do..
0081++ F323 23                              INC     HL
0082++ F324 05                              DEC     B
0083++ F325 20 F8                           JR      NZ, _check_pressed
0084++ F327                                                             ; Key wasn't pressed, so add it to the first free slot
0085++ F327 21 08 FF                        LD      HL, keyboard_state
0086++ F32A 06 08                           LD      B, _key_state_size
0087++ F32C 4F                              LD      C, A
0088++ F32D AF                              XOR     A
0089++ F32E BE          _find_free          CP      (HL)
0090++ F32F 28 07                           JR      Z, _key_pressed
0091++ F331 23                              INC     HL
0092++ F332 05                              DEC     B
0093++ F333 20 F9                           JR      NZ, _find_free
0094++ F335 C3 70 F3                        JP      _do_nothing         ; No free slots, so ignore the key
0095++ F338             
0096++ F338 71          _key_pressed        LD      (HL), C             ; Found free slot, store the raw key code
0097++ F339             
0098++ F339                                 ; Reset repeat counter       
0099++ F339             
0100++ F339 2A 10 FF                        LD      HL, (keyboard_pos)  ; Get the current keyboard character location
0101++ F33C 01 30 00                        LD      BC, _keyboard_size
0102++ F33F 3A 12 FF                        LD      A, (key_shift_state)
0103++ F342 A7                              AND     A
0104++ F343 28 04                           JR      Z, _got_keycode
0105++ F345 09          _modifier_offset    ADD     HL, BC
0106++ F346 3D                              DEC     A
0107++ F347 20 FC                           JR      NZ, _modifier_offset
0108++ F349             
0109++ F349 7E          _got_keycode        LD      A, (HL) 
0110++ F34A 32 14 FF                        LD      (last_keycode), A
0111++ F34D CD A0 F3                        CALL    _store_key
0112++ F350 AF                              XOR     A
0113++ F351 32 15 FF                        LD      (key_repeat_time), A
0114++ F354             
0115++ F354 C1                              POP     BC
0116++ F355 18 1A                           JR      _poll_next
0117++ F357             
0118++ F357                                                             ; Key is not pressed... remove it from the state buffer if it was pressed (key up event)
0119++ F357                                                             ; TODO: This is rather inefficient...
0120++ F357 C5          _released           PUSH    BC
0121++ F358 7E                              LD      A, (HL)             ; Raw key code in A
0122++ F359 A7                              AND     A
0123++ F35A 28 14                           JR      Z, _do_nothing      ; Ignore character zero
0124++ F35C             
0125++ F35C 21 08 FF                        LD      HL, keyboard_state
0126++ F35F 06 08                           LD      B, _key_state_size
0127++ F361 BE          _check_released     CP      (HL)
0128++ F362 28 06                           JR      Z, _handle_release
0129++ F364 23                              INC     HL
0130++ F365 05                              DEC     B
0131++ F366 20 F9                           JR      NZ, _check_released
0132++ F368 18 06                           JR      _do_nothing         ; Code not in state buffer, not released
0133++ F36A             
0134++ F36A 4F          _handle_release     LD      C, A
0135++ F36B AF                              XOR     A
0136++ F36C 77                              LD      (HL), A             ; Remove it from the buffer 
0137++ F36D 32 14 FF                        LD      (last_keycode), A
0138++ F370                                                             ; TODO: We should probably tell someone about this...
0139++ F370 C1          _do_nothing         POP     BC
0140++ F371             
0141++ F371 2A 10 FF    _poll_next          LD      HL, (keyboard_pos)
0142++ F374 7B                              LD      A, E                ; Get the bitmask back
0143++ F375 23                              INC     HL
0144++ F376 CB 22                           SLA     D
0145++ F378 CB 72                           BIT     6, D
0146++ F37A CA 12 F3                        JP      Z, _next_key
0147++ F37D             
0148++ F37D CB 00                           RLC     B                   ; Move to the next key row
0149++ F37F 3E FE                           LD      A, 0FEh
0150++ F381 B8                              CP      B
0151++ F382 C2 0D F3                        JP      NZ, _poll_loop
0152++ F385             
0153++ F385 3A 14 FF                        LD      A, (last_keycode)
0154++ F388 A7                              AND     A
0155++ F389 C8                              RET     Z
0156++ F38A 3A 15 FF                        LD      A, (key_repeat_time)
0157++ F38D 3C                              INC     A
0158++ F38E 32 15 FF                        LD      (key_repeat_time), A
0159++ F391 FE 28                           CP      KEY_REPEAT_DELAY
0160++ F393 28 08                           JR      Z, _do_repeat
0161++ F395 FE 2F                           CP      KEY_REPEAT_AFTER
0162++ F397 C0                              RET     NZ
0163++ F398 3E 28                           LD      A, KEY_REPEAT_DELAY
0164++ F39A 32 15 FF                        LD      (key_repeat_time),A
0165++ F39D 3A 14 FF    _do_repeat          LD      A, (last_keycode)
0166++ F3A0             
0167++ F3A0             
0168++ F3A0             ; Store the decoded keycode in A to the relevant buffer...
0169++ F3A0 4F          _store_key          LD      C, A
0170++ F3A1 E6 F8                           AND     CTRL_KEY_MASK       ; Check for special control characters 
0171++ F3A3 FE 90                           CP      CTRL_KEY_CHECK
0172++ F3A5 20 05                           JR      NZ, _get_key
0173++ F3A7             
0174++ F3A7 79                              LD      A, C                ; Store them in a separate location
0175++ F3A8 32 13 FF                        LD      (control_key_pressed), A
0176++ F3AB C9                              RET
0177++ F3AC                                                             ; Write the character to the input buffer
0178++ F3AC 79          _get_key            LD      A, C                ; Get the actual character...
0179++ F3AD A7                              AND     A                   ; Skip blank character codes
0180++ F3AE C8                              RET     Z
0181++ F3AF             
0182++ F3AF 6F                              LD      L, A                ; Store it in L
0183++ F3B0             
0184++ F3B0 3A 28 FF                        LD      A, (input_size)     ; Now check we have space
0185++ F3B3 FE 10                           CP      _input_buffer_size
0186++ F3B5 C8                              RET     Z
0187++ F3B6             
0188++ F3B6 3C                              INC     A
0189++ F3B7 32 28 FF                        LD      (input_size), A
0190++ F3BA             
0191++ F3BA 06 00                           LD      B, 0
0192++ F3BC 3A 27 FF                        LD      A, (input_free)
0193++ F3BF 4F                              LD      C, A
0194++ F3C0 7D                              LD      A, L                ; Get the character from L
0195++ F3C1 21 16 FF                        LD      HL, input_buffer
0196++ F3C4 09                              ADD     HL, BC
0197++ F3C5 77                              LD      (HL), A             ; Store the character
0198++ F3C6             
0199++ F3C6 0C                              INC     C                   ; Point to next byte in input
0200++ F3C7 3E 0F                           LD      A, 0Fh
0201++ F3C9 A1                              AND     C
0202++ F3CA 32 27 FF                        LD      (input_free), A
0203++ F3CD C9                              RET
0204++ F3CE             
0205++ F3CE             ;
0206++ F3CE             ; Reads the next available character in A, returning that or 0 if none are available
0207++ F3CE             ; Z flag is set if no character
0208++ F3CE             ; Uses HL, BC, A
0209++ F3CE 3A 28 FF    read_character      LD      A, (input_size)
0210++ F3D1 A7                              AND     A
0211++ F3D2 C8                              RET     Z
0212++ F3D3             
0213++ F3D3 F3                              DI                          ; Make sure we don't get into a race condition..
0214++ F3D4 3A 28 FF                        LD      A, (input_size)
0215++ F3D7 3D                              DEC     A
0216++ F3D8 32 28 FF                        LD      (input_size),A
0217++ F3DB 3A 26 FF                        LD      A, (input_pos)
0218++ F3DE 4F                              LD      C, A
0219++ F3DF 3C                              INC     A
0220++ F3E0 E6 0F                           AND     0Fh
0221++ F3E2 32 26 FF                        LD      (input_pos),A
0222++ F3E5 06 00                           LD      B, 0
0223++ F3E7 21 16 FF                        LD      HL, input_buffer
0224++ F3EA 09                              ADD     HL, BC
0225++ F3EB 7E                              LD      A, (HL)
0226++ F3EC B7                              OR      A
0227++ F3ED FB                              EI
0228++ F3EE C9                              RET
0229++ F3EF                                 
0230++ F3EF             ;;
0231++ F3EF             ; D = Octave 2-6
0232++ F3EF             ; E = Note 0-11
0233++ F3EF             ; C = 1-15 duration, ~tenths of a second
0234++ F3EF             ;
0235++ F3EF 3E 07       play_note           LD      A, 7
0236++ F3F1 92                              SUB     D
0237++ F3F2 16 00                           LD      D, 0
0238++ F3F4 21 36 F4                        LD      HL, _note_table
0239++ F3F7 19                              ADD     HL, DE
0240++ F3F8 19                              ADD     HL, DE
0241++ F3F9             
0242++ F3F9 5E                              LD      E, (HL)
0243++ F3FA 23                              INC     HL
0244++ F3FB 56                              LD      D, (HL)
0245++ F3FC             
0246++ F3FC A7          _note_octave        AND     A
0247++ F3FD 28 07                           JR      Z, _note_shifted
0248++ F3FF             
0249++ F3FF CB 3A                           SRL     D
0250++ F401 CB 1B                           RR      E
0251++ F403 3D                              DEC     A
0252++ F404 18 F6                           JR      _note_octave
0253++ F406             
0254++ F406 41          _note_shifted       LD      B, C
0255++ F407 4F                              LD      C, A        ; A is zero from previous octave calc
0256++ F408 CB 20                           SLA     B    
0257++ F40A CB 20                           SLA     B    
0258++ F40C CB 20                           SLA     B    
0259++ F40E CB 20                           SLA     B           ; Now BC = 4096 * C
0260++ F410             
0261++ F410 DB 24                           IN      A, (AUDIO_PORT)
0262++ F412 32 23 F4                        LD      (_tone_val+1), A
0263++ F415 F3                              DI
0264++ F416             
0265++ F416             _tone_loop          ; 186 T-states          
0266++ F416 19                              ADD     HL, DE              ; 11
0267++ F417 1F                              RRA                         ; 4   Carry into bit 7
0268++ F418 CB 2F                           SRA     A                   ; 8   Copy to bit 6
0269++ F41A CB 2F                           SRA     A                   ; 8   ..5
0270++ F41C CB 2F                           SRA     A                   ; 8   ..4
0271++ F41E CB 2F                           SRA     A                   ; 8   ..3
0272++ F420             
0273++ F420 E6 08                           AND     AUDIO_MASK          ; 7
0274++ F422 EE 00       _tone_val           XOR     0                   ; 7
0275++ F424 32 23 F4                        LD      (_tone_val+1), A    ; 13
0276++ F427             
0277++ F427 D3 24                           OUT     (AUDIO_PORT),A      ; 12
0278++ F429             
0279++ F429 78                              LD      A, B                ; 4
0280++ F42A 06 05                           LD      B, 5                ; 7
0281++ F42C 10 FE                           DJNZ    $                   ; 4 * 13 + 7 = 59
0282++ F42E 47                              LD      B, A                ; 4
0283++ F42F             
0284++ F42F 0B                              DEC     BC                  ; 6
0285++ F430 78                              LD      A, B                ; 4
0286++ F431 B1                              OR      C                   ; 4
0287++ F432 20 E2                           JR      NZ, _tone_loop      ; 12
0288++ F434             
0289++ F434 FB                              EI
0290++ F435 C9                              RET
0291++ F436             
0292++ F436 EB 18       _note_table         .DW 6379
0293++ F438 65 1A                           .DW 6757
0294++ F43A F6 1B                           .DW 7158
0295++ F43C A1 1D                           .DW 7585
0296++ F43E 63 1F                           .DW 8035
0297++ F440 40 21                           .DW 8512
0298++ F442 3F 23                           .DW 9023
0299++ F444 51 25                           .DW 9553
0300++ F446 8C 27                           .DW 10124
0301++ F448 EA 29                           .DW 10730
0302++ F44A 60 2C                           .DW 11360
0303++ F44C 0D 2F                           .DW 12045
0304++ F44E 00 00                           .DW 0
0305++ F450             
0306++ F450             ;
0307++ F450             ; Get the next key press
0308++ F450             ;
0309++ F450 CD CE F3    get_key             CALL    read_character
0310++ F453 06 00                           LD      B, 0
0311++ F455 10 FE                           DJNZ    $
0312++ F457 28 F7                           JR      Z, get_key
0313++ F459 C9                              RET
0314++ F45A             ;
0315++ F45A             ; Wait for a key to be pressed and released
0316++ F45A             ;
0317++ F45A             ;
0318++ F45A CD CE F3    wait_for_key        CALL    read_character
0319++ F45D 06 00                           LD      B, 0
0320++ F45F 10 FE                           DJNZ    $
0321++ F461 28 F7                           JR      Z, wait_for_key
0322++ F463             
0323++ F463             ;
0324++ F463             ; wait until there are no keys being pressed
0325++ F463             ;
0326++ F463             ;
0327++ F463 CD CE F3    wait_no_keys        CALL    read_character
0328++ F466 20 FB                           JR      NZ, wait_no_keys
0329++ F468 01 00 00                        LD      BC, 0h              ; Make sure key is released
0330++ F46B ED 78                           IN      A, (C)
0331++ F46D E6 3F                           AND     03Fh
0332++ F46F FE 3F                           CP      03Fh
0333++ F471 20 F0                           JR      NZ, wait_no_keys
0334++ F473 C9                              RET
0335++ F474             
0336++ F474             ; Non-printing key codes
0337++ F474             ;
0338++ F474             KEY_ENTER       .EQU    13
0339++ F474             KEY_DELETE      .EQU    127
0340++ F474             KEY_CTRL_C      .EQU    03h
0341++ F474             KEY_CTRL_E      .EQU    05h
0342++ F474             
0343++ F474             KEY_CTRL_P      .EQU    10h
0344++ F474             KEY_CTRL_R      .EQU    12h
0345++ F474             KEY_CTRL_S      .EQU    13h
0346++ F474             KEY_CTRL_U      .EQU    15h
0347++ F474             KEY_CTRL_X      .EQU    18h
0348++ F474             KEY_CTRL_Z      .EQU    1Ah
0349++ F474             KEY_ESCAPE      .EQU    1Bh
0350++ F474             
0351++ F474             KEY_BACKSPACE   .EQU    08h
0352++ F474             
0353++ F474             ; Modifier and special keys have key codes with the top bit set..
0354++ F474             ;
0355++ F474             KEY_UP          .EQU    128
0356++ F474             KEY_DOWN        .EQU    129
0357++ F474             KEY_LEFT        .EQU    130
0358++ F474             KEY_RIGHT       .EQU    131
0359++ F474             KEY_SHIFT       .EQU    132
0360++ F474             KEY_CTRL        .EQU    134
0361++ F474             
0362++ F474             ; 144 = 90h
0363++ F474             ;
0364++ F474             CTRL_KEY_MASK   .EQU    0F8h
0365++ F474             CTRL_KEY_CHECK  .EQU    090h
0366++ F474             
0367++ F474             KEY_CTRL_UP     .EQU    144             ; These characters start on an exact multiple of 8 so they 
0368++ F474             KEY_CTRL_DOWN   .EQU    145             ; Can easily be detected
0369++ F474             KEY_CTRL_LEFT   .EQU    146
0370++ F474             KEY_CTRL_RIGHT  .EQU    147
0371++ F474             KEY_CTRL_ENTER  .EQU    148
0372++ F474             KEY_CTRL_SPACE  .EQU    149 
0373++ F474             KEY_CTRL_D      .EQU    150
0374++ F474             
0375++ F474             _keyboard_size  .EQU    48
0376++ F474             
0377++ F474             KEY_SHIFT_BIT   .EQU    1
0378++ F474             KEY_CTRL_BIT    .EQU    2
0379++ F474             
0380++ F474             KEY_REPEAT_DELAY .EQU   40
0381++ F474             KEY_REPEAT_AFTER .EQU   KEY_REPEAT_DELAY+7
0382++ F474             
0383++ F474 76 63 78 7A keyboard        .DB    "vcxz", 0, 0
0383++ F478 00 00 
0384++ F47A 67 66 64 73                 .DB    "gfdsa", 0
0384++ F47E 61 00 
0385++ F480 74 72 65 77                 .DB    "trewq", KEY_DOWN
0385++ F484 71 81 
0386++ F486 35 34 33 32                 .DB    "54321", KEY_UP  
0386++ F48A 31 80 
0387++ F48C 36 37 38 39                 .DB    "67890", KEY_BACKSPACE
0387++ F490 30 08 
0388++ F492 79 75 69 6F                 .DB    "yuiop:"
0388++ F496 70 3A 
0389++ F498 68 6A 6B 6C                 .DB    "hjkl.", KEY_ENTER
0389++ F49C 2E 0D 
0390++ F49E 62 6E 6D 20                 .DB    "bnm ", KEY_LEFT, KEY_RIGHT
0390++ F4A2 82 83 
0391++ F4A4             
0392++ F4A4 56 43 58 5A _shifted        .DB     "VCXZ", 0, 0
0392++ F4A8 00 00 
0393++ F4AA 47 46 44 53                 .DB     "GFDSA", 0
0393++ F4AE 41 00 
0394++ F4B0 54 52 45 57                 .DB     "TREWQ", 0              ; Shift + down?
0394++ F4B4 51 00 
0395++ F4B6 25 24 23 22                 .DB     "%$", 35, 34, "!", 0    ; Shift + up
0395++ F4BA 21 00 
0396++ F4BC 5E 26 2A 28                 .DB     "^&*()", KEY_DELETE     ; Shift + delete
0396++ F4C0 29 7F 
0397++ F4C2 59 55 49 4F                 .DB     "YUIOP;"
0397++ F4C6 50 3B 
0398++ F4C8 48 4A 4B 4C                 .DB     "HJKL,", 0              ; Shift + enter
0398++ F4CC 2C 00 
0399++ F4CE 42 4E 4D 00                 .DB     "BNM", 0,0,0            ; Shift left + right
0399++ F4D2 00 00 
0400++ F4D4             
0401++ F4D4 00 03 18 1A _ctrl           .DB    0,KEY_CTRL_C,KEY_CTRL_X,KEY_CTRL_Z,0,0
0401++ F4D8 00 00 
0402++ F4DA 00 00 96 13                 .DB    0,0,KEY_CTRL_D,KEY_CTRL_S,0,0
0402++ F4DE 00 00 
0403++ F4E0 00 12 05 00                 .DB    0,KEY_CTRL_R,KEY_CTRL_E,0,0,KEY_CTRL_DOWN
0403++ F4E4 00 91 
0404++ F4E6 00 00 00 27                 .DB    0,0,0,27h,7Ch,KEY_CTRL_UP ; Vertical bar, single quote
0404++ F4EA 7C 90 
0405++ F4EC 7B 7D 60 5B                 .DB    "{}`[]", KEY_ESCAPE
0405++ F4F0 5D 1B 
0406++ F4F2 00 15 2B 3D                 .DB    0,KEY_CTRL_U, "+=-", 0
0406++ F4F6 2D 00 
0407++ F4F8 00 3C 40 3E                 .DB    0, "<@>_", KEY_CTRL_ENTER
0407++ F4FC 5F 94 
0408++ F4FE 5C 3F 2F 95                 .DB    "\\?/", KEY_CTRL_SPACE,KEY_CTRL_LEFT,KEY_CTRL_RIGHT
0408++ F502 92 93 
0409++ F504             
0410++ F504 00 00 00 00 _shift_ctrl     .DB    0,0,0,0,0,0
0410++ F508 00 00 
0411++ F50A 00 00 00 00                 .DB    0,0,0,0,0,0
0411++ F50E 00 00 
0412++ F510 00 00 00 00                 .DB    0,0,0,0,0,0
0412++ F514 00 00 
0413++ F516 00 00 00 00                 .DB    0,0,0,0,0,0
0413++ F51A 00 00 
0414++ F51C 00 00 00 00                 .DB    0,0,0,0,0,0
0414++ F520 00 00 
0415++ F522 00 00 00 00                 .DB    0,0,0,0,KEY_CTRL_P,0
0415++ F526 10 00 
0416++ F528 00 00 00 00                 .DB    0,0,0,0,0,0
0416++ F52C 00 00 
0417++ F52E 00 00 00 00                 .DB    0,0,0,0,0,0
0417++ F532 00 00 
1525+  F534                                 .INCLUDE "../uart.asm"
0001++ F534             ;
0002++ F534             ; UART routines..
0003++ F534             ;
0004++ F534             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ F534             ;
0006++ F534             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ F534             ;
0008++ F534             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ F534             ; of this software and associated documentation files (the "Software"), to deal
0010++ F534             ; in the Software without restriction, including without limitation the rights
0011++ F534             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ F534             ; copies of the Software, and to permit persons to whom the Software is
0013++ F534             ; furnished to do so, subject to the following conditions:
0014++ F534             ; 
0015++ F534             ; The above copyright notice and this permission notice shall be included in all
0016++ F534             ; copies or substantial portions of the Software.
0017++ F534             ; 
0018++ F534             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ F534             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ F534             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ F534             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ F534             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ F534             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ F534             ; SOFTWARE.
0025++ F534             ;
0026++ F534                                 .MODULE     uart
0027++ F534             
0028++ F534             ;
0029++ F534             ; Baud rates, assuming 1.8432Mhz crystal
0030++ F534             ;
0031++ F534             UART_9600           .EQU    12
0032++ F534             UART_19200          .EQU    6
0033++ F534             UART_38400          .EQU    3
0034++ F534             
0035++ F534             UART_MODE_AUTO      .EQU    022h   ; Auto flow mode
0036++ F534             UART_MODE_NO_FLOW   .EQU    000h   ; Auto RTS and CTS disabled
0037++ F534             UART_MODE_DIAG      .EQU    030h   ; Loopback mode
0038++ F534             
0039++ F534             ;
0040++ F534             ; Various constants
0041++ F534             ;
0042++ F534             UART_8N1            .EQU    003h
0043++ F534             UART_TIMEOUT        .EQU    50000
0044++ F534             
0045++ F534             _CTS_STATUS_MASK    .EQU    010h
0046++ F534             
0047++ F534             ;
0048++ F534             ; Set up the UART. Assume it has had time to settle after reset...
0049++ F534             ;
0050++ F534             ;
0051++ F534 01 06 00    uart_init           LD      BC, UART_19200              ; B is flow control, 0 -> No auto flow control
0052++ F537             
0053++ F537 DB 26                           IN      A,(UART_MODEM_STATUS)       ; If CTS is enabled, assume we can use flow control
0054++ F539 E6 10                           AND     _CTS_STATUS_MASK
0055++ F53B 28 02                           JR      Z, _no_listener
0056++ F53D             
0057++ F53D 06 22                           LD      B, UART_MODE_AUTO
0058++ F53F                                     
0059++ F53F 3E 80       _no_listener        LD      A, 80h                      ; Divisor Latch Setting Mode
0060++ F541 D3 23                           OUT     (UART_LINE_CTRL), A         ;  - entered by writing 1 to bit 7 of LCR
0061++ F543 00                              NOP
0062++ F544 00                              NOP
0063++ F545 79                              LD      A, C
0064++ F546 D3 20                           OUT     (UART_TX_RX), A
0065++ F548 00                              NOP
0066++ F549 00                              NOP
0067++ F54A AF                              XOR     A
0068++ F54B D3 21                           OUT     (UART_INT_ENABLE), A
0069++ F54D 00                              NOP
0070++ F54E 00                              NOP
0071++ F54F             
0072++ F54F 3E 03                           LD      A, UART_8N1                 ; Set 8N1 and exit divisor latch setting mode
0073++ F551 D3 23                           OUT     (UART_LINE_CTRL), A
0074++ F553             
0075++ F553 3E 07                           LD      A, 07h                      ; Enable and clear FIFO registers
0076++ F555 D3 22                           OUT     (UART_FIFO_CTRL), A
0077++ F557             
0078++ F557 78                              LD      A, B
0079++ F558 A7                              AND     A
0080++ F559 28 02                           JR      Z, _no_flowcontrol
0081++ F55B             
0082++ F55B D3 24                           OUT     (UART_MODEM_CTRL), A
0083++ F55D             
0084++ F55D 00          _no_flowcontrol     NOP
0085++ F55E 00                              NOP
0086++ F55F C9                              RET
0087++ F560             
0088++ F560             ;
0089++ F560             ; Send character in A to UART
0090++ F560             ; Preserves all registers
0091++ F560             ;
0092++ F560             ; Carry flag is set on return if the UART send succeeded, clear if it timed out
0093++ F560             ;
0094++ F560 C5          uart_send           PUSH    BC
0095++ F561 F5                              PUSH    AF
0096++ F562 01 50 C3                        LD      BC, UART_TIMEOUT
0097++ F565 DB 25       _check_ready        IN      A, (UART_LINE_STATUS)
0098++ F567 CB 6F                           BIT     5, A
0099++ F569 C2 77 F5                        JP      NZ, _uart_ready             ; Bit 5 is set when the UART is ready
0100++ F56C 0B                              DEC     BC
0101++ F56D 78                              LD      A, B
0102++ F56E B1                              OR      C
0103++ F56F C2 65 F5                        JP      NZ, _check_ready
0104++ F572             
0105++ F572 F1                              POP     AF
0106++ F573 C1                              POP     BC
0107++ F574 37                              SCF
0108++ F575 3F                              CCF
0109++ F576 C9                              RET
0110++ F577             
0111++ F577 F1          _uart_ready         POP     AF
0112++ F578 C1                              POP     BC
0113++ F579 D3 20                           OUT     (UART_TX_RX), A
0114++ F57B 37                              SCF
0115++ F57C C9                              RET
0116++ F57D             
0117++ F57D             ;
0118++ F57D             ; Check to see if there are any characters to receive
0119++ F57D             ; Preserves all registers
0120++ F57D             ;
0121++ F57D             ; Returns with carry set if there are characters ready, clear if not
0122++ F57D             ;
0123++ F57D F5          uart_ready          PUSH    AF
0124++ F57E DB 25                           IN      A, (UART_LINE_STATUS)
0125++ F580 CB 47                           BIT     0, A
0126++ F582 CA 88 F5                        JP      Z, _not_ready
0127++ F585 F1                              POP     AF
0128++ F586 37                              SCF
0129++ F587 C9                              RET
0130++ F588             
0131++ F588 F1          _not_ready          POP     AF
0132++ F589 37                              SCF
0133++ F58A 3F                              CCF
0134++ F58B C9                              RET
0135++ F58C             
0136++ F58C             ;
0137++ F58C             ; Receive a character from the UART in A
0138++ F58C             ; 
0139++ F58C             ; Returns with a character in A and the carry flag set. If no characters
0140++ F58C             ; are available, returns with the carry flag clear.
0141++ F58C             ;
0142++ F58C DB 25       uart_receive        IN      A, (UART_LINE_STATUS)
0143++ F58E CB 47                           BIT     0, A
0144++ F590 CA 97 F5                        JP      Z, _no_character
0145++ F593 DB 20                           IN      A, (UART_TX_RX)
0146++ F595 37                              SCF
0147++ F596 C9                              RET
0148++ F597             
0149++ F597 37          _no_character       SCF
0150++ F598 3F                              CCF
0151++ F599 C9                              RET
0152++ F59A             
0153++ F59A                                 .MODULE main1526+  F59A                                 .INCLUDE "../i2c.asm"
0001++ F59A             ; ============================================ I2C Routines =================================================
0002++ F59A             ; Software driven I2C for Z80 PIO
0003++ F59A             ;
0004++ F59A             ; Assume I2C clock is on Port B bit 6
0005++ F59A             ;            data is on Port B bit 7
0006++ F59A             ;
0007++ F59A             ;
0008++ F59A             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0009++ F59A             ;
0010++ F59A             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0011++ F59A             ;
0012++ F59A             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0013++ F59A             ; of this software and associated documentation files (the "Software"), to deal
0014++ F59A             ; in the Software without restriction, including without limitation the rights
0015++ F59A             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0016++ F59A             ; copies of the Software, and to permit persons to whom the Software is
0017++ F59A             ; furnished to do so, subject to the following conditions:
0018++ F59A             ; 
0019++ F59A             ; The above copyright notice and this permission notice shall be included in all
0020++ F59A             ; copies or substantial portions of the Software.
0021++ F59A             ; 
0022++ F59A             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0023++ F59A             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0024++ F59A             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0025++ F59A             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0026++ F59A             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0027++ F59A             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0028++ F59A             ; SOFTWARE.
0029++ F59A             ;
0030++ F59A                                 .MODULE i2c
0031++ F59A             
0032++ F59A 3E CF       init_portb          LD      A, PIO_MODE_3           ; Port B mode 3
0033++ F59C 32 00 FF                        LD      (port_b_mode), A
0034++ F59F D3 13                           OUT     (PIO_B_CTRL), A
0035++ F5A1             
0036++ F5A1 3E FF                           LD      A, PORT_B_IOMASK        ;
0037++ F5A3 32 01 FF                        LD      (port_b_dir), A
0038++ F5A6 D3 13                           OUT     (PIO_B_CTRL), A
0039++ F5A8             
0040++ F5A8 3E 3F                           LD      A, 03Fh                 ; All bits high apart from D7, D6
0041++ F5AA 32 02 FF                        LD      (port_b_data),A
0042++ F5AD D3 11                           OUT     (PIO_B_DATA), A         ; Changing D7 or D6 to an output will drive the lines low
0043++ F5AF C9                              RET
0044++ F5B0             
0045++ F5B0             ; Reset the bus
0046++ F5B0             ;
0047++ F5B0             ; Uses A, B, D
0048++ F5B0 06 0A       i2c_bus_reset       LD      B, 0ah          ; ten cycles
0049++ F5B2 CD C0 F6    _loop_b             CALL    i2c_scl_cycle
0050++ F5B5 10 FB                           DJNZ    _loop_b
0051++ F5B7 CD B0 F6                        CALL    i2c_scl_high
0052++ F5BA 06 F0                           LD      B, 0F0h
0053++ F5BC 10 FE                           DJNZ    $
0054++ F5BE C9                              RET
0055++ F5BF             
0056++ F5BF             ;
0057++ F5BF             ; Uses A
0058++ F5BF CD 90 F6    i2c_start           CALL    i2c_sda_high
0059++ F5C2 CD B0 F6                        CALL    i2c_scl_high
0060++ F5C5 CD A0 F6                        CALL    i2c_sda_low     ; Drive data low
0061++ F5C8 C3 80 F6                        JP      i2c_scl_low     ; Drive clock low
0062++ F5CB             
0063++ F5CB             
0064++ F5CB             ;
0065++ F5CB             ; Read a byte from Device address H, Register L into A
0066++ F5CB             ; Calls i2c_start, sets address, reads byte and then calls i2c_stop
0067++ F5CB             ; Returns With Carry SET and A containing the register value, or Carry CLEAR if no acknowledge
0068++ F5CB             ; Uses A, B, C, D, H, L
0069++ F5CB             ; Preserves H, L
0070++ F5CB CD E5 F5    i2c_read_byte       CALL    i2c_read_from
0071++ F5CE                                 ; Fall through into stop
0072++ F5CE                             
0073++ F5CE             ;
0074++ F5CE             ; Uses A
0075++ F5CE CD A0 F6    i2c_stop            CALL    i2c_sda_low     ; Drive data low
0076++ F5D1 CD B0 F6                        CALL    i2c_scl_high
0077++ F5D4 C3 90 F6                        JP      i2c_sda_high
0078++ F5D7             
0079++ F5D7             ; Write a byte in C to Device address H, register L
0080++ F5D7             ; Returns with Carry SET if OK, CLEAR if no acknowledgement
0081++ F5D7             ; Calls i2c_stop when done..
0082++ F5D7             ;
0083++ F5D7             ; Preserves H, L
0084++ F5D7 C5          i2c_write_byte      PUSH    BC
0085++ F5D8 CD 06 F6                        CALL    i2c_write_to
0086++ F5DB C1                              POP     BC
0087++ F5DC D2 CE F5                        JP      NC, i2c_stop
0088++ F5DF 79                              LD      A, C
0089++ F5E0 CD 1A F6                        CALL    i2c_write
0090++ F5E3 18 E9                           JR      i2c_stop
0091++ F5E5                                 
0092++ F5E5             ;
0093++ F5E5             ; Read a byte from Device address H, Register L
0094++ F5E5             ; Calls i2c_start, but does NOT call i2c_stop
0095++ F5E5             ; Returns With Carry SET and A containing the register value, or Carry CLEAR if no acknowledge
0096++ F5E5             ; Uses A, B, C, D, H, L
0097++ F5E5             ; Preserves H, L
0098++ F5E5 CD BF F5    i2c_read_from       CALL    i2c_start
0099++ F5E8 7C                              LD      A, H
0100++ F5E9 CD 18 F6                        CALL    i2c_address_w
0101++ F5EC 30 17                           JR      NC, _read_end
0102++ F5EE 7D                              LD      A, L
0103++ F5EF CD 1A F6                        CALL    i2c_write
0104++ F5F2 30 11                           JR      NC, _read_end
0105++ F5F4 06 32                           LD      B, 50
0106++ F5F6 10 FE       _read_pause         DJNZ    _read_pause
0107++ F5F8 CD BF F5                        CALL    i2c_start
0108++ F5FB 7C                              LD      A, H
0109++ F5FC CD 12 F6                        CALL    i2c_address_r
0110++ F5FF 30 04                           JR      NC, _read_end
0111++ F601 CD 65 F6                        CALL    i2c_read
0112++ F604 37                              SCF
0113++ F605 C9          _read_end           RET
0114++ F606             
0115++ F606             
0116++ F606             ;
0117++ F606             ; Prepare to write to Device address H, Register L
0118++ F606             ; Calls i2c_start, but does NOT call i2c_stop
0119++ F606             ; Returns with Carry SET if OK, CLEAR if no acknowledgement
0120++ F606             ;
0121++ F606             ; Preserves H, L
0122++ F606 CD BF F5    i2c_write_to        CALL    i2c_start
0123++ F609 7C                              LD      A, H
0124++ F60A CD 18 F6                        CALL    i2c_address_w
0125++ F60D D0                              RET     NC
0126++ F60E 7D                              LD      A, L
0127++ F60F C3 1A F6                        JP      i2c_write
0128++ F612             
0129++ F612             ; Start reading from device address held in A
0130++ F612             ;
0131++ F612             ; Uses A, B, C, D
0132++ F612 CB 27       i2c_address_r       SLA     A
0133++ F614 F6 01                           OR      1
0134++ F616 18 02                           JR      i2c_write
0135++ F618             
0136++ F618             ; Start writing to device address held in A
0137++ F618             ;
0138++ F618             ; Uses A, B, C, D
0139++ F618 CB 27       i2c_address_w       SLA     A
0140++ F61A             
0141++ F61A             ; Write A as a byte to i2c bus
0142++ F61A             ; Returns Carry CLEAR if no acknowledge
0143++ F61A             ;
0144++ F61A             ; Uses A, B, C, D
0145++ F61A E5          i2c_write           PUSH    HL
0146++ F61B 2A 00 FF                        LD      HL, (port_b_mode)           ; L = port_b_mode, H = port_b_dir
0147++ F61E 57                              LD      D, A
0148++ F61F                                 
0149++ F61F 3E 3F                           LD      A, ~(I2C_DATA_MASK|I2C_CLK_MASK)           ; Set SDA and SCL (port_b_dir bit) LOW
0150++ F621 A4                              AND     H
0151++ F622 CB 27                           SLA     A
0152++ F624 67                              LD      H, A
0153++ F625             
0154++ F625 0E 13                           LD      C, PIO_B_CTRL
0155++ F627 06 08                           LD      B, 8
0156++ F629             
0157++ F629 7C          _fast_loop          LD      A, H
0158++ F62A CB 22                           SLA     D
0159++ F62C CB 1F                           RR      A
0160++ F62E ED 69                           OUT     (C),L
0161++ F630 D3 13                           OUT     (PIO_B_CTRL), A
0162++ F632             
0163++ F632 F6 40                           OR      I2C_CLK_MASK
0164++ F634 ED 69                           OUT     (C), L
0165++ F636 D3 13                           OUT     (PIO_B_CTRL), A                 ; Clock high
0166++ F638             
0167++ F638 EE 40                           XOR     I2C_CLK_MASK
0168++ F63A ED 69                           OUT     (C), L
0169++ F63C D3 13                           OUT     (PIO_B_CTRL),A                  ; Clock low
0170++ F63E 10 E9                           DJNZ    _fast_loop
0171++ F640             
0172++ F640 7C                              LD      A, H
0173++ F641 37                              SCF
0174++ F642 CB 1F                           RR      A
0175++ F644 ED 69                           OUT     (C),L                           ; Release SDA
0176++ F646 D3 13                           OUT     (PIO_B_CTRL), A
0177++ F648             
0178++ F648 F6 40                           OR      I2C_CLK_MASK
0179++ F64A ED 69                           OUT     (C), L
0180++ F64C D3 13                           OUT     (PIO_B_CTRL), A                 ; Clock high
0181++ F64E             
0182++ F64E ED 69                           OUT     (C), L
0183++ F650 EE 40                           XOR     I2C_CLK_MASK
0184++ F652 6F                              LD      L, A
0185++ F653 32 01 FF                        LD      (port_b_dir), A
0186++ F656             
0187++ F656 DB 11                           IN      A, (PIO_B_DATA)                 ; Read ACK
0188++ F658 ED 69                           OUT     (C),L                           ; Clock low
0189++ F65A             
0190++ F65A E1                              POP     HL
0191++ F65B             
0192++ F65B CB 7A                           BIT     I2C_DATA_BIT, D     ; D contains acknowledge bit
0193++ F65D 37                              SCF
0194++ F65E C8                              RET     Z               ; Return with carry set if acknowledge bit is low
0195++ F65F             
0196++ F65F CD CE F5                        CALL    i2c_stop        ; Stop bus if error
0197++ F662 37                              SCF
0198++ F663 3F                              CCF
0199++ F664 C9                              RET                     ; Clear carry if acknowledge is high
0200++ F665             
0201++ F665             ; Read byte from i2C into A, without ACK
0202++ F665             ;
0203++ F665             ; Uses A, B, C, D
0204++ F665 06 08       i2c_read            LD      B, 8h
0205++ F667 DB 11       _loop_r             IN      A, (PIO_B_DATA)
0206++ F669 37                              SCF
0207++ F66A CB 7F                           BIT     I2C_DATA_BIT, A
0208++ F66C 20 01                           JR      NZ, _data_high
0209++ F66E 3F                              CCF
0210++ F66F CB 11       _data_high          RL      C
0211++ F671 CD C0 F6                        CALL    i2c_scl_cycle
0212++ F674 10 F1                           DJNZ    _loop_r
0213++ F676                                 ; CALL    i2c_scl_cycle
0214++ F676             
0215++ F676 79                              LD      A, C
0216++ F677 C9                              RET
0217++ F678             
0218++ F678             ;
0219++ F678             ; Send an ACK..
0220++ F678             ;
0221++ F678 CD A0 F6    i2c_ack             CALL    i2c_sda_low
0222++ F67B CD C0 F6                        CALL    i2c_scl_cycle
0223++ F67E 18 10                           JR      i2c_sda_high
0224++ F680             
0225++ F680             ; SCL/SDA toggle routines
0226++ F680             ;
0227++ F680             ; All use A
0228++ F680 3A 00 FF    i2c_scl_low         LD      A, (port_b_mode)
0229++ F683 D3 13                           OUT     (PIO_B_CTRL), A
0230++ F685             
0231++ F685 3A 01 FF                        LD      A, (port_b_dir)
0232++ F688 CB B7                           RES     I2C_CLK_BIT, A
0233++ F68A D3 13                           OUT     (PIO_B_CTRL), A
0234++ F68C 32 01 FF                        LD      (port_b_dir), A
0235++ F68F C9                              RET
0236++ F690             
0237++ F690 3A 00 FF    i2c_sda_high        LD      A, (port_b_mode)
0238++ F693 D3 13                           OUT     (PIO_B_CTRL), A
0239++ F695             
0240++ F695 3A 01 FF                        LD      A, (port_b_dir)
0241++ F698 CB FF                           SET     I2C_DATA_BIT, A
0242++ F69A D3 13                           OUT     (PIO_B_CTRL), A
0243++ F69C 32 01 FF                        LD      (port_b_dir), A
0244++ F69F C9                              RET
0245++ F6A0             
0246++ F6A0 3A 00 FF    i2c_sda_low         LD      A, (port_b_mode)
0247++ F6A3 D3 13                           OUT     (PIO_B_CTRL), A
0248++ F6A5             
0249++ F6A5 3A 01 FF                        LD      A, (port_b_dir)
0250++ F6A8 CB BF                           RES     I2C_DATA_BIT, A
0251++ F6AA D3 13                           OUT     (PIO_B_CTRL), A
0252++ F6AC 32 01 FF                        LD      (port_b_dir), A
0253++ F6AF C9                              RET
0254++ F6B0             
0255++ F6B0 3A 00 FF    i2c_scl_high        LD      A, (port_b_mode)
0256++ F6B3 D3 13                           OUT     (PIO_B_CTRL), A
0257++ F6B5             
0258++ F6B5 3A 01 FF                        LD      A, (port_b_dir)
0259++ F6B8 CB F7                           SET     I2C_CLK_BIT, A
0260++ F6BA D3 13                           OUT     (PIO_B_CTRL), A
0261++ F6BC 32 01 FF                        LD      (port_b_dir), A
0262++ F6BF C9                              RET
0263++ F6C0             
0264++ F6C0 C5          i2c_scl_cycle       PUSH   BC
0265++ F6C1 01 13 00                        LD     BC, PIO_B_CTRL
0266++ F6C4 3A 00 FF                        LD     A, (port_b_mode)
0267++ F6C7 57                              LD     D, A
0268++ F6C8 3A 01 FF                        LD     A, (port_b_dir)
0269++ F6CB             
0270++ F6CB CB B7                           RES    I2C_CLK_BIT, A
0271++ F6CD 32 01 FF                        LD     (port_b_dir), A
0272++ F6D0 ED 51                           OUT    (C), D
0273++ F6D2 D3 13                           OUT    (PIO_B_CTRL), A
0274++ F6D4                                 
0275++ F6D4 CB F7                           SET    I2C_CLK_BIT, A
0276++ F6D6 ED 51                           OUT    (C), D
0277++ F6D8 D3 13                           OUT    (PIO_B_CTRL), A
0278++ F6DA                                 
0279++ F6DA DB 11                           IN     A, (PIO_B_DATA)
0280++ F6DC ED 51                           OUT    (C), D
0281++ F6DE 57                              LD     D, A
0282++ F6DF 3A 01 FF                        LD     A, (port_b_dir)
0283++ F6E2 D3 13                           OUT    (PIO_B_CTRL), A
0284++ F6E4 C1                              POP    BC
0285++ F6E5 C9                              RET
0286++ F6E6             
0287++ F6E6                                 .MODULE main
1527+  F6E6             
1528+  F6E6                                 .INCLUDE "../disp.asm"
0001++ F6E6             ; ========================================== Display Routines ===============================================
0002++ F6E6             ;
0003++ F6E6             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0004++ F6E6             ;
0005++ F6E6             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0006++ F6E6             ;
0007++ F6E6             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0008++ F6E6             ; of this software and associated documentation files (the "Software"), to deal
0009++ F6E6             ; in the Software without restriction, including without limitation the rights
0010++ F6E6             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0011++ F6E6             ; copies of the Software, and to permit persons to whom the Software is
0012++ F6E6             ; furnished to do so, subject to the following conditions:
0013++ F6E6             ; 
0014++ F6E6             ; The above copyright notice and this permission notice shall be included in all
0015++ F6E6             ; copies or substantial portions of the Software.
0016++ F6E6             ; 
0017++ F6E6             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0018++ F6E6             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0019++ F6E6             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0020++ F6E6             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0021++ F6E6             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0022++ F6E6             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0023++ F6E6             ; SOFTWARE.
0024++ F6E6             ;
0025++ F6E6                                 .MODULE disp
0026++ F6E6             
0027++ F6E6             CONFIG_PAGE         .EQU    3
0028++ F6E6             BRIGHT_PAGE         .EQU    1
0029++ F6E6             LED_PAGE            .EQU    0 
0030++ F6E6             
0031++ F6E6 CD 30 F8    display_init        CALL    disp_clear
0032++ F6E9 1E 80                           LD      E, DISP_DEFAULT_BRIGHTNESS
0033++ F6EB CD 26 F7                        CALL    disp_brightness
0034++ F6EE             
0035++ F6EE CD FA F6                        CALL    disp_select_l
0036++ F6F1 CD 06 F7                        CALL    disp_config
0037++ F6F4             
0038++ F6F4 CD 00 F7                        CALL    disp_select_r
0039++ F6F7 CD 06 F7                        CALL    disp_config
0040++ F6FA             
0041++ F6FA 3E 50       disp_select_l       LD      A, DL_ADDRESS
0042++ F6FC 32 D1 FF                        LD      (display_address), A
0043++ F6FF C9                              RET
0044++ F700             
0045++ F700 3E 53       disp_select_r       LD      A, DR_ADDRESS
0046++ F702 32 D1 FF                        LD      (display_address), A
0047++ F705 C9                              RET
0048++ F706             
0049++ F706 2E 03       disp_config         LD      L, CONFIG_PAGE
0050++ F708 CD 61 F7                        CALL    disp_page
0051++ F70B CD BF F5                        CALL    i2c_start
0052++ F70E 3A D1 FF                        LD      A, (display_address)
0053++ F711 CD 18 F6                        CALL    i2c_address_w
0054++ F714 3E 00                           LD      A, 000h
0055++ F716 CD 1A F6                        CALL    i2c_write
0056++ F719 3E 01                           LD      A, 001h         ; Turn display on
0057++ F71B CD 1A F6                        CALL    i2c_write
0058++ F71E 3E 78                           LD      A, 078h         ; 0.020mA
0059++ F720 CD 1A F6                        CALL    i2c_write
0060++ F723 C3 CE F5                        JP      i2c_stop
0061++ F726             
0062++ F726             ;
0063++ F726             ; Sets the brightness for the display
0064++ F726             ; Enter with E set to the desired brightness for all segments
0065++ F726             ;
0066++ F726 CD FA F6    disp_brightness     CALL    disp_select_l
0067++ F729 CD 2F F7                        CALL    _set_bright
0068++ F72C CD 00 F7                        CALL    disp_select_r
0069++ F72F 2E 01       _set_bright         LD      L, BRIGHT_PAGE
0070++ F731 CD 61 F7                        CALL    disp_page
0071++ F734 2E 0C                           LD      L, 12
0072++ F736 CD BF F5    _bright_loop        CALL    i2c_start
0073++ F739 3A D1 FF                        LD      A, (display_address)
0074++ F73C CD 18 F6                        CALL    i2c_address_w
0075++ F73F 7D                              LD      A, L
0076++ F740 3D                              DEC     A
0077++ F741 CB 27                           SLA     A
0078++ F743 CB 27                           SLA     A
0079++ F745 CB 27                           SLA     A
0080++ F747 CB 27                           SLA     A
0081++ F749 CD 1A F6                        CALL    i2c_write
0082++ F74C 26 10                           LD      H, 010h
0083++ F74E 7B          _bright_byte        LD      A, E
0084++ F74F CD 1A F6                        CALL    i2c_write
0085++ F752 25                              DEC     H
0086++ F753 20 F9                           JR      NZ, _bright_byte
0087++ F755 CD CE F5                        CALL    i2c_stop
0088++ F758 2D                              DEC     L
0089++ F759 20 DB                           JR      NZ, _bright_loop
0090++ F75B 2E 00                           LD      L, LED_PAGE
0091++ F75D CD 61 F7                        CALL    disp_page
0092++ F760 C9                              RET
0093++ F761             
0094++ F761             ; Set the Page number
0095++ F761             ; Call with page number in L
0096++ F761             ;
0097++ F761             ; Uses A, B, C, D
0098++ F761 CD 79 F7    disp_page           CALL    disp_unlock
0099++ F764 CD BF F5                        CALL    i2c_start
0100++ F767 3A D1 FF                        LD      A, (display_address)
0101++ F76A CD 18 F6                        CALL    i2c_address_w
0102++ F76D 3E FD                           LD      A, 0FDh
0103++ F76F CD 1A F6                        CALL    i2c_write
0104++ F772 7D                              LD      A, L
0105++ F773 CD 1A F6                        CALL    i2c_write
0106++ F776 C3 CE F5                        JP      i2c_stop
0107++ F779             
0108++ F779 CD BF F5    disp_unlock         CALL    i2c_start           ; Must be called before switching pages
0109++ F77C 3A D1 FF                        LD      A, (display_address)
0110++ F77F CD 18 F6                        CALL    i2c_address_w
0111++ F782 3E FE                           LD      A, DISP_REG_CRWL
0112++ F784 CD 1A F6                        CALL    i2c_write
0113++ F787 3E C5                           LD      A, DISP_UNLOCK
0114++ F789 CD 1A F6                        CALL    i2c_write
0115++ F78C C3 CE F5                        JP      i2c_stop
0116++ F78F             
0117++ F78F             ; Set the character at column A to brightness C
0118++ F78F             ;
0119++ F78F             ;
0120++ F78F C5          disp_char_bright    PUSH    BC
0121++ F790 06 50                           LD      B, DL_ADDRESS
0122++ F792 FE 0C                           CP      12
0123++ F794 DA 9B F7                        JP      C, _bright_left
0124++ F797 06 53                           LD      B, DR_ADDRESS
0125++ F799 D6 0C                           SUB     12
0126++ F79B 5F          _bright_left        LD      E, A
0127++ F79C 78                              LD      A, B
0128++ F79D 32 D1 FF                        LD      (display_address), A
0129++ F7A0 2E 01                           LD      L, BRIGHT_PAGE
0130++ F7A2 CD 61 F7                        CALL    disp_page
0131++ F7A5             
0132++ F7A5 CD BF F5                        CALL    i2c_start
0133++ F7A8 3A D1 FF                        LD      A, (display_address)
0134++ F7AB CD 18 F6                        CALL    i2c_address_w
0135++ F7AE 7B                              LD      A, E
0136++ F7AF CB 27                           SLA     A
0137++ F7B1 CB 27                           SLA     A
0138++ F7B3 CB 27                           SLA     A
0139++ F7B5 CB 27                           SLA     A
0140++ F7B7 CD 1A F6                        CALL    i2c_write
0141++ F7BA E1                              POP     HL
0142++ F7BB 26 10                           LD      H, 010h
0143++ F7BD 7D          _bright_char_loop   LD      A, L
0144++ F7BE CD 1A F6                        CALL    i2c_write
0145++ F7C1 25                              DEC     H
0146++ F7C2 20 F9                           JR      NZ, _bright_char_loop
0147++ F7C4 CD CE F5                        CALL    i2c_stop
0148++ F7C7             
0149++ F7C7 2E 00                           LD      L, LED_PAGE
0150++ F7C9 CD 61 F7                        CALL    disp_page
0151++ F7CC C9                              RET
0152++ F7CD                                 
0153++ F7CD             ; Display a single character A at column C
0154++ F7CD             ;
0155++ F7CD             ; Returns with A pointing to next column
0156++ F7CD             ;
0157++ F7CD FE 20       disp_character      CP      32
0158++ F7CF F2 D9 F7                        JP      P, _not_control
0159++ F7D2             
0160++ F7D2 21 61 48    _invalid_char       LD      HL, INVALID_CHAR_BITMASK
0161++ F7D5 79                              LD      A, C
0162++ F7D6 C3 EE F7                        JP      disp_bitmask
0163++ F7D9             
0164++ F7D9 CB 7F       _not_control        BIT     7, A
0165++ F7DB C2 D2 F7                        JP      NZ, _invalid_char
0166++ F7DE D6 20                           SUB     32
0167++ F7E0             
0168++ F7E0 16 00                           LD      D, 0
0169++ F7E2 5F                              LD      E, A
0170++ F7E3 CB 23                           SLA     E                   ; Don't need to shift into D, since bit 7 is zero
0171++ F7E5 21 3E F8                        LD      HL, font  
0172++ F7E8 19                              ADD     HL, DE
0173++ F7E9 56                              LD      D, (HL)
0174++ F7EA 23                              INC     HL
0175++ F7EB 66                              LD      H, (HL)
0176++ F7EC 6A                              LD      L, D
0177++ F7ED 79                              LD      A, C
0178++ F7EE                                 ; Fall into disp_bitmask
0179++ F7EE             
0180++ F7EE             ; Display a bitmask in HL at column A (0 - 23)
0181++ F7EE             ;
0182++ F7EE             ; Returns with A pointing to next column
0183++ F7EE             ;
0184++ F7EE             ; Uses A, B, C, D, E
0185++ F7EE F5          disp_bitmask        PUSH    AF
0186++ F7EF 06 50                           LD      B, DL_ADDRESS
0187++ F7F1 FE 0C                           CP      12
0188++ F7F3 DA FA F7                        JP      C, _disp_left
0189++ F7F6 06 53                           LD      B, DR_ADDRESS
0190++ F7F8 D6 0C                           SUB     12
0191++ F7FA 5F          _disp_left          LD      E, A
0192++ F7FB CD BF F5                        CALL    i2c_start
0193++ F7FE 78                              LD      A, B
0194++ F7FF CD 18 F6                        CALL    i2c_address_w
0195++ F802 7B                              LD      A, E
0196++ F803 CB 27                           SLA     A
0197++ F805 CD 1A F6                        CALL    i2c_write
0198++ F808 7D                              LD      A, L
0199++ F809 CD 1A F6                        CALL    i2c_write
0200++ F80C 7C                              LD      A, H
0201++ F80D CD 1A F6                        CALL    i2c_write
0202++ F810 CD CE F5                        CALL    i2c_stop
0203++ F813 F1                              POP     AF
0204++ F814 3C                              INC     A
0205++ F815 C9                              RET
0206++ F816             
0207++ F816             ;
0208++ F816             ; Clear the display and show an inline string from column 0
0209++ F816             ;
0210++ F816 CD 30 F8    disp_clear_inline   CALL    disp_clear
0211++ F819 AF                              XOR     A
0212++ F81A             ;
0213++ F81A             ; Display an inline string to column A->
0214++ F81A             ;
0215++ F81A E3          disp_inline         EX      (SP), HL
0216++ F81B CD 21 F8                        CALL    disp_string
0217++ F81E 23                              INC     HL
0218++ F81F E3                              EX      (SP), HL
0219++ F820 C9                              RET
0220++ F821             
0221++ F821             ; Display a string pointed to by HL to column A->
0222++ F821             ; Note string should be zero terminated...
0223++ F821             ; Returns with HL pointing to the 0 terminator
0224++ F821             ;
0225++ F821 4F          disp_string         LD      C, A
0226++ F822 7E                              LD      A, (HL)
0227++ F823 B7                              OR      A
0228++ F824 C2 28 F8                        JP      NZ, _char_ok
0229++ F827 C9                              RET
0230++ F828             
0231++ F828 E5          _char_ok            PUSH    HL
0232++ F829 CD CD F7                        CALL    disp_character
0233++ F82C E1                              POP     HL
0234++ F82D 23                              INC     HL
0235++ F82E 18 F1                           JR      disp_string
0236++ F830             
0237++ F830             ; Clear the display
0238++ F830             ;
0239++ F830 3E 00       disp_clear          LD      A, 0
0240++ F832 21 00 00                        LD      HL, 0
0241++ F835 CD EE F7    _clear_loop         CALL    disp_bitmask
0242++ F838 FE 18                           CP      24
0243++ F83A C2 35 F8                        JP      NZ, _clear_loop
0244++ F83D C9                              RET
0245++ F83E             
0246++ F83E                                 .MODULE main1529+  F83E                                 .INCLUDE "../font.asm"
0001++ F83E             ;
0002++ F83E             ; Font definition
0003++ F83E             ;
0004++ F83E             ;
0005++ F83E             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006++ F83E             ;
0007++ F83E             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008++ F83E             ;
0009++ F83E             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010++ F83E             ; of this software and associated documentation files (the "Software"), to deal
0011++ F83E             ; in the Software without restriction, including without limitation the rights
0012++ F83E             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013++ F83E             ; copies of the Software, and to permit persons to whom the Software is
0014++ F83E             ; furnished to do so, subject to the following conditions:
0015++ F83E             ; 
0016++ F83E             ; The above copyright notice and this permission notice shall be included in all
0017++ F83E             ; copies or substantial portions of the Software.
0018++ F83E             ; 
0019++ F83E             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020++ F83E             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021++ F83E             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022++ F83E             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023++ F83E             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024++ F83E             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025++ F83E             ; SOFTWARE.
0026++ F83E             ;
0027++ F83E             
0028++ F83E             INVALID_CHAR_BITMASK    .EQU 04861h
0029++ F83E             
0030++ F83E             font
0031++ F83E 00 00                           .dw     0000h
0032++ F840 00 49                           .dw     4900h   ; !
0033++ F842 02 02                           .dw     0202h   ; "
0034++ F844 CE 12                           .dw     12ceh   ; #
0035++ F846 ED 12                           .dw     12edh   ; $
0036++ F848 E4 2D                           .dw     2de4h   ; %
0037++ F84A 59 0B                           .dw     0b59h   ; &
0038++ F84C 00 02                           .dw     0200h   ; '
0039++ F84E 00 0C                           .dw     0c00h   ; (
0040++ F850 00 21                           .dw     2100h   ; )
0041++ F852 C0 3F                           .dw     3fc0h   ; *
0042++ F854 C0 12                           .dw     12c0h   ; +
0043++ F856 00 20                           .dw     2000h   ; ,
0044++ F858 C0 00                           .dw     00c0h   ; -
0045++ F85A 00 40                           .dw     4000h   ; .
0046++ F85C 00 24                           .dw     2400h   ; /
0047++ F85E             
0048++ F85E 3F 24                           .dw     243fh   ; 0
0049++ F860 06 04                           .dw     0406h   ; 1
0050++ F862 DB 00                           .dw     00dbh   ; 2
0051++ F864 8F 00                           .dw     008fh   ; 3
0052++ F866 E6 00                           .dw     00e6h   ; 4
0053++ F868 69 08                           .dw     0869h   ; 5
0054++ F86A FD 00                           .dw     00fdh   ; 6
0055++ F86C 01 14                           .dw     1401h   ; 7
0056++ F86E FF 00                           .dw     00ffh   ; 8
0057++ F870 EF 00                           .dw     00efh   ; 9
0058++ F872 40 00                           .dw     0040h   ; :
0059++ F874 00 22                           .dw     2200h   ; ;
0060++ F876 40 0C                           .dw     0c40h   ; <
0061++ F878 C8 00                           .dw     00c8h   ; = 
0062++ F87A 80 21                           .dw     2180h   ; >
0063++ F87C 83 50                           .dw     5083h   ; ?
0064++ F87E             
0065++ F87E BB 02                           .dw     02bbh   ; @
0066++ F880 F7 00                           .dw     00f7h   ; A
0067++ F882 8F 12                           .dw     128fh   ; B
0068++ F884 39 00                           .dw     0039h   ; C
0069++ F886 0F 12                           .dw     120fh   ; D
0070++ F888 79 00                           .dw     0079h   ; E
0071++ F88A 71 00                           .dw     0071h   ; F
0072++ F88C BD 00                           .dw     00bdh   ; G
0073++ F88E F6 00                           .dw     00f6h   ; H
0074++ F890 09 12                           .dw     1209h   ; I
0075++ F892 1E 00                           .dw     001eh   ; J
0076++ F894 70 0C                           .dw     0c70h   ; K
0077++ F896 38 00                           .dw     0038h   ; L
0078++ F898 36 05                           .dw     0536h   ; M
0079++ F89A 36 09                           .dw     0936h   ; N
0080++ F89C 3F 00                           .dw     003fh   ; O
0081++ F89E             
0082++ F89E F3 00                           .dw     00f3h   ; P
0083++ F8A0 3F 08                           .dw     083fh   ; Q
0084++ F8A2 F3 08                           .dw     08f3h   ; R
0085++ F8A4 ED 00                           .dw     00edh   ; S
0086++ F8A6 01 12                           .dw     1201h   ; T
0087++ F8A8 3E 00                           .dw     003eh   ; U
0088++ F8AA 30 24                           .dw     2430h   ; V
0089++ F8AC 36 28                           .dw     2836h   ; W
0090++ F8AE 00 2D                           .dw     2d00h   ; X
0091++ F8B0 EE 00                           .dw     00eeh   ; Y
0092++ F8B2 09 24                           .dw     2409h   ; Z
0093++ F8B4 39 00                           .dw     0039h   ; [
0094++ F8B6 00 09                           .dw     0900h   ; \
0095++ F8B8 0F 00                           .dw     000fh   ; ]
0096++ F8BA 00 28                           .dw     2800h   ; ^
0097++ F8BC 08 00                           .dw     0008h   ; _
0098++ F8BE             
0099++ F8BE 00 01                           .dw     0100h   ; `
0100++ F8C0 8C 20                           .dw     208ch   ; a
0101++ F8C2 78 08                           .dw     0878h   ; b
0102++ F8C4 D8 00                           .dw     00d8h   ; c
0103++ F8C6 8E 20                           .dw     208eh   ; d 
0104++ F8C8 58 20                           .dw     2058h   ; e 
0105++ F8CA C0 14                           .dw     14c0h   ; f
0106++ F8CC 8E 04                           .dw     048eh   ; g
0107++ F8CE 70 10                           .dw     1070h   ; h
0108++ F8D0 00 10                           .dw     1000h   ; i
0109++ F8D2 10 22                           .dw     2210h   ; j
0110++ F8D4 00 1E                           .dw     1e00h   ; k
0111++ F8D6 00 12                           .dw     1200h   ; l
0112++ F8D8 D4 10                           .dw     10d4h   ; m
0113++ F8DA 50 10                           .dw     1050h   ; n
0114++ F8DC DC 00                           .dw     00dch   ; o
0115++ F8DE             
0116++ F8DE 70 01                           .dw     0170h   ; p
0117++ F8E0 86 04                           .dw     0486h   ; q
0118++ F8E2 50 00                           .dw     0050h   ; r
0119++ F8E4 88 08                           .dw     0888h   ; s
0120++ F8E6 78 00                           .dw     0078h   ; t
0121++ F8E8 1C 00                           .dw     001ch   ; u
0122++ F8EA 10 20                           .dw     2010h   ; v
0123++ F8EC 14 28                           .dw     2814h   ; w
0124++ F8EE 00 2D                           .dw     2d00h   ; x
0125++ F8F0 8E 02                           .dw     028eh   ; y
0126++ F8F2 48 20                           .dw     2048h   ; z
0127++ F8F4 49 21                           .dw     2149h   ; {
0128++ F8F6 00 12                           .dw     1200h   ; |
0129++ F8F8 89 0C                           .dw     0c89h   ; }
0130++ F8FA C0 24                           .dw     24c0h   ; ~
0131++ F8FC 00 00                           .dw     0000h   ; 1530+  F8FE                                 .INCLUDE "bios_rtc.asm"
0001++ F8FE             ; RTC Routines
0002++ F8FE             ;
0003++ F8FE             ;
0004++ F8FE             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ F8FE             ;
0006++ F8FE             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ F8FE             ;
0008++ F8FE             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ F8FE             ; of this software and associated documentation files (the "Software"), to deal
0010++ F8FE             ; in the Software without restriction, including without limitation the rights
0011++ F8FE             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ F8FE             ; copies of the Software, and to permit persons to whom the Software is
0013++ F8FE             ; furnished to do so, subject to the following conditions:
0014++ F8FE             ; 
0015++ F8FE             ; The above copyright notice and this permission notice shall be included in all
0016++ F8FE             ; copies or substantial portions of the Software.
0017++ F8FE             ; 
0018++ F8FE             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ F8FE             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ F8FE             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ F8FE             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ F8FE             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ F8FE             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ F8FE             ; SOFTWARE.
0025++ F8FE             ;
0026++ F8FE             ;
0027++ F8FE                                     .MODULE rtc
0028++ F8FE             
0029++ F8FE             ; Set the initial time and start the clock
0030++ F8FE             ;
0031++ F8FE             ;
0032++ F8FE CD 30 F0    rtc_init                CALL    m_print_inline
0033++ F901 0A 0D 43 68                         .DB     "\n\rCheck RTC",0
0033++ F905 65 63 6B 20 
0033++ F909 52 54 43 00 
0034++ F90D             
0035++ F90D CD 82 F9                            CALL    _read_seconds
0036++ F910 CD 7D F9                            CALL    _pause
0037++ F913 CB 7B                               BIT     7, E                ; Check to see if the clock is running
0038++ F915 C0                                  RET     NZ                  ; Return if it is..
0039++ F916             
0040++ F916 CD 30 F0    _do_reset               CALL    m_print_inline
0041++ F919 0A 0D 52 65                         .DB     "\n\rReset RTC",0
0041++ F91D 73 65 74 20 
0041++ F921 52 54 43 00 
0042++ F925             
0043++ F925 26 6F                               LD      H, RTC_ADDRESS      ; Clock isn't running, reset to default time
0044++ F927 2E 00                               LD      L, RTC_REG_SEC
0045++ F929 CD 06 F6                            CALL    i2c_write_to
0046++ F92C D2 90 F9                            JP      NC, rtc_ack_error
0047++ F92F             
0048++ F92F 21 CF F9                            LD      HL, time_scratch
0049++ F932 7E          _reset_loop             LD      A, (HL)
0050++ F933 23                                  INC     HL
0051++ F934 FE FF                               CP      0ffh
0052++ F936 CA 41 F9                            JP      Z, _start_clock
0053++ F939 CD 1A F6                            CALL    i2c_write
0054++ F93C D2 90 F9                            JP      NC, rtc_ack_error
0055++ F93F 18 F1                               JR      _reset_loop
0056++ F941             
0057++ F941 CD CE F5    _start_clock            CALL    i2c_stop            ; Enable VBAT and start the clock
0058++ F944             
0059++ F944 26 6F                               LD      H, RTC_ADDRESS      ; Enable VBAT
0060++ F946 2E 03                               LD      L, RTC_REG_WKDAY
0061++ F948 CD E5 F5                            CALL    i2c_read_from
0062++ F94B D2 90 F9                            JP      NC, rtc_ack_error
0063++ F94E 5F                                  LD      E, A
0064++ F94F CD CE F5                            CALL    i2c_stop
0065++ F952 CB DB                               SET     3, E
0066++ F954 CD 7D F9                            CALL    _pause
0067++ F957             
0068++ F957 CD 06 F6                            CALL    i2c_write_to
0069++ F95A D2 90 F9                            JP      NC, rtc_ack_error
0070++ F95D 7B                                  LD      A, E
0071++ F95E CD 1A F6                            CALL    i2c_write
0072++ F961 D2 90 F9                            JP      NC, rtc_ack_error
0073++ F964 CD CE F5                            CALL    i2c_stop
0074++ F967             
0075++ F967 CD 82 F9                            CALL    _read_seconds
0076++ F96A CB FB                               SET     7, E                ; Set bit 7 to enable clock
0077++ F96C                                     
0078++ F96C CD 06 F6                            CALL    i2c_write_to
0079++ F96F D2 90 F9                            JP      NC, rtc_ack_error
0080++ F972 7B                                  LD      A, E
0081++ F973 CD 1A F6                            CALL    i2c_write
0082++ F976 D2 90 F9                            JP      NC, rtc_ack_error
0083++ F979 CD CE F5                            CALL    i2c_stop
0084++ F97C C9                                  RET
0085++ F97D             
0086++ F97D 06 00       _pause                  LD      B, 0
0087++ F97F 10 FE                               DJNZ    $
0088++ F981 C9                                  RET
0089++ F982             
0090++ F982             ;
0091++ F982             ; Read seconds register in E
0092++ F982             ;
0093++ F982 26 6F       _read_seconds           LD      H, RTC_ADDRESS      
0094++ F984 2E 00                               LD      L, RTC_REG_SEC      
0095++ F986 CD E5 F5                            CALL    i2c_read_from
0096++ F989 D2 90 F9                            JP      NC, rtc_ack_error
0097++ F98C 5F                                  LD      E, A
0098++ F98D C3 CE F5                            JP     i2c_stop
0099++ F990             
0100++ F990 CD CE F5    rtc_ack_error           CALL    i2c_stop
0101++ F993                                     
0102++ F993 CD 30 F0                            CALL    m_print_inline
0103++ F996 0A 0D 52 54                         .DB     "\n\rRTC Panic",0
0103++ F99A 43 20 50 61 
0103++ F99E 6E 69 63 00 
0104++ F9A2 C9                                  RET
0105++ F9A3             
0106++ F9A3             ;
0107++ F9A3             ; Read the time to the 7 bytes starting at HL
0108++ F9A3             ; Returns with Carry SET if successful, else Carry CLEAR
0109++ F9A3             ;
0110++ F9A3 E5          rtc_get_time_hl         PUSH    HL
0111++ F9A4 26 6F                               LD      H, RTC_ADDRESS
0112++ F9A6 2E 00                               LD      L, RTC_REG_SEC
0113++ F9A8 CD E5 F5                            CALL    i2c_read_from
0114++ F9AB C1                                  POP     BC
0115++ F9AC D0                                  RET     NC
0116++ F9AD 21 C7 F9                            LD      HL, _masktable
0117++ F9B0 18 08                               JR      _store_time
0118++ F9B2 C5          _get_loop               PUSH    BC 
0119++ F9B3 CD 78 F6                            CALL    i2c_ack
0120++ F9B6 CD 65 F6                            CALL    i2c_read
0121++ F9B9 C1                                  POP     BC
0122++ F9BA A6          _store_time             AND     (HL)
0123++ F9BB 02                                  LD      (BC), A
0124++ F9BC 23                                  INC     HL
0125++ F9BD 03                                  INC     BC
0126++ F9BE 7E                                  LD      A, (HL)
0127++ F9BF A7                                  AND     A
0128++ F9C0 20 F0                               JR      NZ, _get_loop
0129++ F9C2 CD CE F5                            CALL    i2c_stop
0130++ F9C5 37                                  SCF
0131++ F9C6 C9                                  RET
0132++ F9C7             
0133++ F9C7 7F          _masktable              .db     07fh        ; Seconds
0134++ F9C8 7F                                  .db     07fh        ; Minutes
0135++ F9C9 3F                                  .db     03fh        ; Hours
0136++ F9CA 07                                  .db     007h        ; Weekday
0137++ F9CB 3F                                  .db     03Fh        ; Date
0138++ F9CC 1F                                  .db     01fh        ; Month
0139++ F9CD FF                                  .db     0ffh        ; Year
0140++ F9CE 00                                  .db     000h        ; End of mask marker
0141++ F9CF             
0142++ F9CF             
0143++ F9CF                                     ;  Initial time on power up..
0144++ F9CF 23          time_scratch            .db  23h            ; Seconds
0145++ F9D0 59                                  .db  59h            ; Minutes
0146++ F9D1 08                                  .db  08h            ; Hours    (24 hr clock)
0147++ F9D2 06                                  .db  06h            ; Weekday  (1-7. Monday=1)
0148++ F9D3 05                                  .db  05h            ; Date
0149++ F9D4 11                                  .db  11h            ; Month
0150++ F9D5 22                                  .db  22h            ; Year 
0151++ F9D6 FF                                  .db  0ffh           ; 0ffh end marker
0152++ F9D7             
0153++ F9D7                                     .MODULE main
1531+  F9D7                                 .INCLUDE "../flash.asm"
0001++ F9D7             ;
0002++ F9D7             ; Flash update routines
0003++ F9D7             ;
0004++ F9D7             ; Note that any memory write operations *at all* during flash updates will cancel the current operation.
0005++ F9D7             ; That means no data can be stored to memory, no stack operations (call, push), no interrupts.
0006++ F9D7             ; 
0007++ F9D7             ;
0008++ F9D7             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0009++ F9D7             ;
0010++ F9D7             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0011++ F9D7             ;
0012++ F9D7             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0013++ F9D7             ; of this software and associated documentation files (the "Software"), to deal
0014++ F9D7             ; in the Software without restriction, including without limitation the rights
0015++ F9D7             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0016++ F9D7             ; copies of the Software, and to permit persons to whom the Software is
0017++ F9D7             ; furnished to do so, subject to the following conditions:
0018++ F9D7             ; 
0019++ F9D7             ; The above copyright notice and this permission notice shall be included in all
0020++ F9D7             ; copies or substantial portions of the Software.
0021++ F9D7             ; 
0022++ F9D7             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0023++ F9D7             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0024++ F9D7             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0025++ F9D7             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0026++ F9D7             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0027++ F9D7             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0028++ F9D7             ; SOFTWARE.
0029++ F9D7             ;
0030++ F9D7                                 .MODULE     flash
0031++ F9D7             
0032++ F9D7             _cmd_1_addr         .EQU  05555h
0033++ F9D7             _cmd_2_addr         .EQU  02AAAh
0034++ F9D7             
0035++ F9D7             _bank_mask          .EQU  03FFFh                ; One memory bank is 14 bits -> 16Kb
0036++ F9D7             _sector_mask        .EQU  00FFFh                ; A sector is 12 bits -> 4Kb
0037++ F9D7             
0038++ F9D7             _cmd_1_addr_bank    .EQU  _cmd_1_addr >> 14
0039++ F9D7             _cmd_2_addr_bank    .EQU  _cmd_2_addr >> 14
0040++ F9D7             _cmd_3_addr_bank    .EQU  _cmd_1_addr_bank
0041++ F9D7             _cmd_4_addr_bank    .EQU  _cmd_1_addr_bank
0042++ F9D7             _cmd_5_addr_bank    .EQU  _cmd_2_addr_bank
0043++ F9D7             
0044++ F9D7             _cmd_1_logical_addr .EQU  _cmd_1_addr & _bank_mask
0045++ F9D7             _cmd_2_logical_addr .EQU  _cmd_2_addr & _bank_mask
0046++ F9D7             _cmd_3_logical_addr .EQU  _cmd_1_logical_addr
0047++ F9D7             _cmd_4_logical_addr .EQU  _cmd_1_logical_addr
0048++ F9D7             _cmd_5_logical_addr .EQU  _cmd_2_logical_addr
0049++ F9D7             
0050++ F9D7             _cmd_1_data         .EQU  0AAh
0051++ F9D7             _cmd_2_data         .EQU  055h
0052++ F9D7             _cmd_3_data_write   .EQU  0A0h
0053++ F9D7             _cmd_3_data_erase   .EQU  080h
0054++ F9D7             _cmd_4_data         .EQU  0AAh
0055++ F9D7             _cmd_5_data         .EQU  055h
0056++ F9D7             
0057++ F9D7             _cmd_6_data_erase   .EQU  030h
0058++ F9D7             
0059++ F9D7             ;
0060++ F9D7             ; Enter with A -> 7 bit index of 4K sector to be erased.
0061++ F9D7             ;
0062++ F9D7             ; Preserves BC, DE, HL
0063++ F9D7             ;
0064++ F9D7             ; Note this uses bank 0, and leaves it configured for the page containing the erased sector
0065++ F9D7             ;
0066++ F9D7             ; Typical time to erase sector ~18ms
0067++ F9D7             ;
0068++ F9D7 F3          flash_sector_erase  DI                          ; Disable interrupts
0069++ F9D8 E5                              PUSH    HL
0070++ F9D9 C5                              PUSH    BC
0071++ F9DA D5                              PUSH    DE
0072++ F9DB             
0073++ F9DB E6 7F                           AND     07fh
0074++ F9DD 57                              LD      D, A
0075++ F9DE CB 3A                           SRL     D
0076++ F9E0 CB 3A                           SRL     D                   ; D is now the bank number
0077++ F9E2             
0078++ F9E2 CB 27                           SLA     A
0079++ F9E4 CB 27                           SLA     A
0080++ F9E6 CB 27                           SLA     A
0081++ F9E8 CB 27                           SLA     A
0082++ F9EA E6 30                           AND     030h
0083++ F9EC 5F                              LD      E, A                ; E is the sector within the bank shifted into bits 13 & 12
0084++ F9ED             
0085++ F9ED 0E 70                           LD      C, IO_MEM_0         ; Use bank 0 to write to
0086++ F9EF 3E 01                           LD      A, _cmd_1_addr_bank
0087++ F9F1 ED 79                           OUT     (C), A
0088++ F9F3 21 55 15                        LD      HL, _cmd_1_logical_addr
0089++ F9F6 36 AA                           LD      (HL), _cmd_1_data
0090++ F9F8             
0091++ F9F8 3E 00                           LD      A, _cmd_2_addr_bank
0092++ F9FA ED 79                           OUT     (C), A
0093++ F9FC 21 AA 2A                        LD      HL, _cmd_2_logical_addr
0094++ F9FF 36 55                           LD      (HL), _cmd_2_data
0095++ FA01             
0096++ FA01 3E 01                           LD      A, _cmd_3_addr_bank
0097++ FA03 ED 79                           OUT     (C), A
0098++ FA05 21 55 15                        LD      HL, _cmd_3_logical_addr
0099++ FA08 36 80                           LD      (HL), _cmd_3_data_erase
0100++ FA0A             
0101++ FA0A 3E 01                           LD      A, _cmd_4_addr_bank
0102++ FA0C ED 79                           OUT     (C), A
0103++ FA0E 21 55 15                        LD      HL, _cmd_4_logical_addr
0104++ FA11 36 AA                           LD      (HL), _cmd_4_data
0105++ FA13             
0106++ FA13 3E 00                           LD      A, _cmd_5_addr_bank
0107++ FA15 ED 79                           OUT     (C), A
0108++ FA17 21 AA 2A                        LD      HL, _cmd_5_logical_addr
0109++ FA1A 36 55                           LD      (HL), _cmd_5_data
0110++ FA1C             
0111++ FA1C ED 51                           OUT     (C), D                  ; Switch to the bank containing our sector
0112++ FA1E 63                              LD      H, E                    ; And write the sector bits as an address (bits 0-11 are ignored)
0113++ FA1F 36 30                           LD      (HL), _cmd_6_data_erase
0114++ FA21             
0115++ FA21 7E          _wait_erase         LD      A,(HL)
0116++ FA22 CB 07                           RLC     A
0117++ FA24 30 FB                           JR      NC, _wait_erase
0118++ FA26             
0119++ FA26 D1                              POP     DE
0120++ FA27 C1                              POP     BC
0121++ FA28 E1                              POP     HL
0122++ FA29 FB                              EI
0123++ FA2A C9                              RET
0124++ FA2B             
0125++ FA2B             ;
0126++ FA2B             ; Enter with A -> Byte to write
0127++ FA2B             ;            D -> 7 bit index of 4K sector being written
0128++ FA2B             ;            HL -> 12 bit address of byte within sector
0129++ FA2B             ;
0130++ FA2B             ; Preserves D, HL
0131++ FA2B             ; Uses A, BC, E
0132++ FA2B             ;
0133++ FA2B             ; Typical time to erase byte ~14us
0134++ FA2B             ;
0135++ FA2B F3          flash_write_byte    DI
0136++ FA2C 5F                              LD      E, A                ; Preserve our byte
0137++ FA2D                                 
0138++ FA2D 7C                              LD      A, H                ; Make sure HL is within our sector
0139++ FA2E E6 0F                           AND     _sector_mask >> 8
0140++ FA30 67                              LD      H, A
0141++ FA31             
0142++ FA31 7A                              LD      A, D                ; Make sure D is a valid sector index
0143++ FA32 E6 7F                           AND     07fh
0144++ FA34 57                              LD      D, A
0145++ FA35 47                              LD      B, A
0146++ FA36             
0147++ FA36 7A                              LD      A, D                ; Get the bottom 2 bits of our sector index..
0148++ FA37 E6 03                           AND     03h
0149++ FA39 CB 27                           SLA     A
0150++ FA3B CB 27                           SLA     A
0151++ FA3D CB 27                           SLA     A
0152++ FA3F CB 27                           SLA     A
0153++ FA41 B4                              OR      H
0154++ FA42 67                              LD      H, A                ; ..and OR them into H to get a 14 bit address within our bank
0155++ FA43             
0156++ FA43 CB 3A                           SRL     D
0157++ FA45 CB 3A                           SRL     D                   ; D is now our bank number
0158++ FA47             
0159++ FA47 E5                              PUSH    HL
0160++ FA48             
0161++ FA48 0E 70                           LD      C, IO_MEM_0         ; Use bank 0 to write to
0162++ FA4A 3E 01                           LD      A, _cmd_1_addr_bank
0163++ FA4C ED 79                           OUT     (C), A
0164++ FA4E 21 55 15                        LD      HL, _cmd_1_logical_addr
0165++ FA51 36 AA                           LD      (HL), _cmd_1_data
0166++ FA53             
0167++ FA53 3E 00                           LD      A, _cmd_2_addr_bank
0168++ FA55 ED 79                           OUT     (C), A
0169++ FA57 21 AA 2A                        LD      HL, _cmd_2_logical_addr
0170++ FA5A 36 55                           LD      (HL), _cmd_2_data
0171++ FA5C             
0172++ FA5C 3E 01                           LD      A, _cmd_3_addr_bank
0173++ FA5E ED 79                           OUT     (C), A
0174++ FA60 21 55 15                        LD      HL, _cmd_3_logical_addr
0175++ FA63 36 A0                           LD      (HL), _cmd_3_data_write
0176++ FA65             
0177++ FA65 ED 51                           OUT     (C), D
0178++ FA67 E1                              POP     HL
0179++ FA68 73                              LD      (HL), E
0180++ FA69             
0181++ FA69 7E          _wait_byte          LD      A, (HL)
0182++ FA6A AB                              XOR     E
0183++ FA6B CB 07                           RLC     A
0184++ FA6D 30 FA                           JR      NC, _wait_byte
0185++ FA6F             
0186++ FA6F 7C                              LD      A, H                ; Clear bits 13 & 12 to restore HL to sector address..
0187++ FA70 E6 0F                           AND     _sector_mask >> 8
0188++ FA72 67                              LD      H, A
0189++ FA73                            
0190++ FA73 50                              LD      D, B                ; And restore D
0191++ FA74 FB                              EI
0192++ FA75 C9                              RET
0193++ FA76             
0194++ FA76             ;
0195++ FA76             ; Write a flash data block. This uses Page 0 to write the data, so the source must be above 3FFFh
0196++ FA76             ;
0197++ FA76             ;       D -> 7 bit index of 4K sector being written
0198++ FA76             ;       HL -> Address of source data
0199++ FA76             ;       BC -> bytes to write
0200++ FA76             ;
0201++ FA76             ; Returns D pointing to last sector written
0202++ FA76             ; Note: This means if BC is an exact multiple of sector size, D is returned as the previous sector
0203++ FA76             
0204++ FA76 DD E5       flash_write         PUSH    IX
0205++ FA78 E5                              PUSH    HL
0206++ FA79 DD E1                           POP     IX
0207++ FA7B 21 00 00                        LD      HL, 0           ; Address in sector..
0208++ FA7E             
0209++ FA7E             _erase_sector       ; Lower 12 bits of HL are zero, erase sector before writing bytes
0210++ FA7E 7A                              LD      A, D
0211++ FA7F CD D7 F9                        CALL    flash_sector_erase
0212++ FA82 DD 7E 00    _write_loop         LD      A, (IX+0)
0213++ FA85 C5                              PUSH    BC
0214++ FA86 CD 2B FA                        CALL    flash_write_byte
0215++ FA89 C1                              POP     BC
0216++ FA8A             
0217++ FA8A DD 23                           INC     IX
0218++ FA8C 0B                              DEC     BC
0219++ FA8D 78                              LD      A, B
0220++ FA8E B1                              OR      C
0221++ FA8F 28 0E                           JR      Z, _success
0222++ FA91             
0223++ FA91 23                              INC     HL
0224++ FA92 7D                              LD      A, L
0225++ FA93 A7                              AND     A
0226++ FA94 20 EC                           JR      NZ, _write_loop
0227++ FA96 7C                              LD      A, H
0228++ FA97 E6 0F                           AND     _sector_mask >> 8
0229++ FA99 67                              LD      H, A
0230++ FA9A 20 E6                           JR      NZ, _write_loop
0231++ FA9C             
0232++ FA9C 14                              INC     D
0233++ FA9D 18 DF                           JR      _erase_sector
0234++ FA9F             
0235++ FA9F DD E1       _success            POP     IX
0236++ FAA1 C9                              RET
0237++ FAA2             
0238++ FAA2                                 .MODULE main
1532+  FAA2                                 .INCLUDE "videobeast.asm"
0001++ FAA2             ;
0002++ FAA2             ; VideoBeast includes for CP/M BIOS
0003++ FAA2             ;
0004++ FAA2             ;
0005++ FAA2             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006++ FAA2             ;
0007++ FAA2             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008++ FAA2             ;
0009++ FAA2             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010++ FAA2             ; of this software and associated documentation files (the "Software"), to deal
0011++ FAA2             ; in the Software without restriction, including without limitation the rights
0012++ FAA2             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013++ FAA2             ; copies of the Software, and to permit persons to whom the Software is
0014++ FAA2             ; furnished to do so, subject to the following conditions:
0015++ FAA2             ; 
0016++ FAA2             ; The above copyright notice and this permission notice shall be included in all
0017++ FAA2             ; copies or substantial portions of the Software.
0018++ FAA2             ; 
0019++ FAA2             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020++ FAA2             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021++ FAA2             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022++ FAA2             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023++ FAA2             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024++ FAA2             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025++ FAA2             ; SOFTWARE.
0026++ FAA2             ;
0027++ FAA2             
0028++ FAA2             VBASE               .EQU   04000h
0029++ FAA2             
0030++ FAA2             VB_MODE             .EQU   VBASE + 03FFFh
0031++ FAA2             VB_REGISTERS_LOCKED .EQU   VBASE + 03FFEh
0032++ FAA2             
0033++ FAA2             VB_PAGE_0           .EQU   VBASE + 03FF9h
0034++ FAA2             VB_PAGE_1           .EQU   VBASE + 03FF8h
0035++ FAA2             VB_PAGE_2           .EQU   VBASE + 03FF7h
0036++ FAA2             VB_PAGE_3           .EQU   VBASE + 03FF6h
0037++ FAA2             
0038++ FAA2             VB_LOWER_REGS       .EQU   VBASE + 03FF5h
0039++ FAA2             
0040++ FAA2             
0041++ FAA2             VB_LAYER_0          .EQU   VBASE + 03F80h
0042++ FAA2             VB_LAYER_1          .EQU   VBASE + 03F90h
0043++ FAA2             VB_LAYER_2          .EQU   VBASE + 03FA0h
0044++ FAA2             VB_LAYER_3          .EQU   VBASE + 03FB0h
0045++ FAA2             VB_LAYER_4          .EQU   VBASE + 03FC0h
0046++ FAA2             VB_LAYER_5          .EQU   VBASE + 03FD0h
0047++ FAA2             
0048++ FAA2             MODE_640            .EQU   0
0049++ FAA2             MODE_848            .EQU   1
0050++ FAA2             MODE_DOUBLE         .EQU   8
0051++ FAA2             MODE_TESTCARD       .EQU   010h
0052++ FAA2             
0053++ FAA2             MODE_MAP_16K        .EQU   0
0054++ FAA2             MODE_MAP_SINCLAIR   .EQU   080h
0055++ FAA2             
0056++ FAA2             LAYER_TYPE          .EQU   0
0057++ FAA2             LAYER_TOP           .EQU   1
0058++ FAA2             LAYER_BOTTOM        .EQU   2
0059++ FAA2             LAYER_LEFT          .EQU   3
0060++ FAA2             LAYER_RIGHT         .EQU   4
0061++ FAA2             LAYER_SCROLL_X      .EQU   5
0062++ FAA2             LAYER_SCROLL_XY     .EQU   6
0063++ FAA2             LAYER_SCROLL_Y      .EQU   7
0064++ FAA2             
0065++ FAA2             TYPE_NONE           .EQU   0
0066++ FAA2             TYPE_TEXT           .EQU   1
0067++ FAA2             TYPE_SPRITE         .EQU   2
0068++ FAA2             TYPE_TILE           .EQU   3
0069++ FAA2             TYPE_BITMAP_8       .EQU   4
0070++ FAA2             
0071++ FAA2             TEXT_MAP_BASE       .EQU   8       ; 16Kb character map
0072++ FAA2             TEXT_FONT_BASE      .EQU   9       ;  2Kb font offset
0073++ FAA2             TEXT_PALETTE        .EQU   10      ; Bits 0-3: Palette number   Bit 4: Use Sinclair bit pattern
0074++ FAA2             TEXT_BITMAP         .EQU   11      ; 16Kb 1bpp bitmap..
0075++ FAA2             
0076++ FAA2             VB_UNLOCK           .EQU   0F3h           ; Unlock register write
0077++ FAA2             
0078++ FAA2             VIDEOBEAST_PAGE     .EQU   40h 1533+  FAA2             ;
1534+  FAA2             ;
1535+  FAA2             ; Page mapping - since the BIOS uses other pages to manage disk and screen, it must also manage the expected page for the user 
1536+  FAA2             ; programs, to prevent them from being unexpectedly changed (eg. after interrupts).
1537+  FAA2             ;
1538+  FAA2             
1539+  FAA2             ;
1540+  FAA2             ;
1541+  FAA2             ; Page mapping - since the BIOS uses other pages to manage disk and screen, it must also manage the expected page for the user 
1542+  FAA2             ; programs, to prevent them from being unexpectedly changed (eg. after interrupts).
1543+  FAA2             ;
1544+  FAA2             ; Get the User page mapping. Sets A to the physical (RAM/ROM) page selelcted for logical page C (0-2)
1545+  FAA2             ; Returns 0FFh for invalid page values
1546+  FAA2 79          get_page_mapping    LD      A, C
1547+  FAA3 CD B7 FA                        CALL    _mapping_address
1548+  FAA6 3E FF                           LD      A, 0FFH
1549+  FAA8 D0                              RET     NC
1550+  FAA9 7E                              LD      A, (HL)
1551+  FAAA C9                              RET
1552+  FAAB             
1553+  FAAB             ; Set the User page mapping. Sets page A (0-2) to the physical (RAM/ROM) page in E
1554+  FAAB             ; Returns with carry SET if successful. The given logical page will now point to the physical page in RAM or ROM
1555+  FAAB             ;
1556+  FAAB CD B7 FA    set_page_mapping    CALL    _mapping_address
1557+  FAAE D0                              RET     NC
1558+  FAAF 73                              LD      (HL), E 
1559+  FAB0             
1560+  FAB0 C6 70                           ADD     A, IO_MEM_0             ; NOTE: Order is important here. Interrupts may occur after the page is stored (above)
1561+  FAB2 4F                              LD      C, A                    ; This may result in the page being prematurely mapped, but that's OK.
1562+  FAB3 ED 59                           OUT     (C), E                  ; If we tried to set the page before storing the new default we'd have to disable interrupts
1563+  FAB5 37                              SCF                             ; To avoid a race condition
1564+  FAB6 C9                              RET
1565+  FAB7             
1566+  FAB7 FE 04       _mapping_address    CP      4
1567+  FAB9 D0                              RET     NC
1568+  FABA 4F                              LD      C, A
1569+  FABB 06 00                           LD      B, 0
1570+  FABD 21 39 FF                        LD      HL, page_0_mapping
1571+  FAC0 09                              ADD     HL, BC
1572+  FAC1 37                              SCF
1573+  FAC2 C9                              RET
1574+  FAC3             
1575+  FAC3             ; Get the page in memory being used as the base for the drive selected by A
1576+  FAC3             ; Returns A = Page in ROM/RAM for the given drive
1577+  FAC3             ;    or   A = 0 if the selected drive is not supported.
1578+  FAC3             ;
1579+  FAC3 FE 02       get_disk_page       CP      MAX_DRIVES
1580+  FAC5 30 09                           JR      NC, _disk_page_err
1581+  FAC7 4F                              LD      C, A
1582+  FAC8 06 00                           LD      B, 0
1583+  FACA 21 37 FF                        LD      HL, drive_a_mem_page
1584+  FACD 09                              ADD     HL, BC
1585+  FACE 7E                              LD      A, (HL)
1586+  FACF C9                              RET
1587+  FAD0 AF          _disk_page_err      XOR     A
1588+  FAD1 C9                              RET
1589+  FAD2             
1590+  FAD2 3E 17       get_version         LD      A, 017h
1591+  FAD4 C9                              RET
1592+  FAD5             
1593+  FAD5             ;
1594+  FAD5             ; Erase and write flash data. Data is written to 4K sectors, which are erased before writing.
1595+  FAD5             ; This uses Page 0 to write the data, so the source must be above 3FFFh
1596+  FAD5             ;
1597+  FAD5             ;       D -> 7 bit index of 4K sector being written
1598+  FAD5             ;       HL -> Address of source data
1599+  FAD5             ;       BC -> bytes to write
1600+  FAD5             ;
1601+  FAD5             ; Returns D pointing to last sector written
1602+  FAD5             ; Note: This means if BC is an exact multiple of sector size, D is returned as the previous sector
1603+  FAD5             
1604+  FAD5 CD 76 FA    bios_flash_write    CALL    flash_write 
1605+  FAD8 3A 39 FF                        LD      A, (page_0_mapping)
1606+  FADB D3 70                           OUT     (IO_MEM_0), A
1607+  FADD C9                              RET 
1608+  FADE             
1609+  FADE             ;
1610+  FADE             ; Set or query the user interrupt. The specified routine will be called after keyboard polling, every 60th of a 
1611+  FADE             ; second. The shadow register set is selected before the call (EXX), and AF is preserved. The routine should 
1612+  FADE             ; RETurn normally. Interrupt routines survive warm reboots, but no special measures are taken to ensure the
1613+  FADE             ; memory they occupy is preserved.
1614+  FADE             ;
1615+  FADE             ;   Parameters: 
1616+  FADE             ;       HL = Address of user interrupt routine, or zero to disable. Call with 0FFFFh to query the current value
1617+  FADE             ;   Returns:
1618+  FADE             ;       The address of the current user interrupt routine, or zero if none is configured.
1619+  FADE             ;
1620+  FADE             ;
1621+  FADE 7C          set_usr_interrupt   LD      A, H
1622+  FADF A5                              AND     L
1623+  FAE0 3C                              INC     A
1624+  FAE1 28 03                           JR      Z, _return_usr_int
1625+  FAE3 22 CF FF                        LD      (user_interrupt), HL
1626+  FAE6 2A CF FF    _return_usr_int     LD      HL, (user_interrupt)
1627+  FAE9 C9                              RET
1628+  FAEA             
1629+  FAEA             JUMP_TABLE_SIZE     .EQU    19
1630+  FAEA             
1631+  FAEA~            .IF $ > (BIOS_TOP - (3*JUMP_TABLE_SIZE))
1632+  FAEA~                .ECHO "BIOS No room for Jump Table ("
1633+  FAEA~                .ECHO $
1634+  FAEA~                .ECHO " > "
1635+  FAEA~                .ECHO (BIOS_TOP-(3*JUMP_TABLE_SIZE))
1636+  FAEA~                .ECHO ") \n\n"
1637+  FAEA~                .STOP
1638+  FAEA             .ENDIF
1639+  FAEA             
1640+  FAEA             BIOS_SPARE          .EQU    BIOS_TOP - $ - (3*JUMP_TABLE_SIZE)
1641+  FAEA 00 00 00 00                     .FILL   BIOS_SPARE, 0
1641+  FAEE 00 00 00 00 
1641+  FAF2 00 00 00 00 
1641+  FAF6 00 00 00 00 
1641+  FAFA 00 00 00 00 
1641+  FAFE 00 00 00 00 
1641+  FB02 00 00 00 00 
1641+  FB06 00 00 00 00 
1641+  FB0A 00 00 00 00 
1641+  FB0E 00 00 00 00 
1641+  FB12 00 00 00 00 
1641+  FB16 00 00 00 00 
1641+  FB1A 00 00 00 00 
1641+  FB1E 00 00 00 00 
1641+  FB22 00 00 00 00 
1641+  FB26 00 00 00 00 
1641+  FB2A 00 00 00 00 
1641+  FB2E 00 00 00 00 
1641+  FB32 00 00 00 00 
1641+  FB36 00 00 00 00 
1641+  FB3A 00 00 00 00 
1641+  FB3E 00 00 00 00 
1641+  FB42 00 00 00 00 
1641+  FB46 00 00 00 00 
1641+  FB4A 00 00 00 00 
1641+  FB4E 00 00 00 00 
1641+  FB52 00 00 00 00 
1641+  FB56 00 00 00 00 
1641+  FB5A 00 00 00 00 
1641+  FB5E 00 00 00 00 
1641+  FB62 00 00 00 00 
1641+  FB66 00 00 00 00 
1641+  FB6A 00 00 00 00 
1641+  FB6E 00 00 00 00 
1641+  FB72 00 00 00 00 
1641+  FB76 00 00 00 00 
1641+  FB7A 00 00 00 00 
1641+  FB7E 00 00 00 00 
1641+  FB82 00 00 00 00 
1641+  FB86 00 00 00 00 
1641+  FB8A 00 00 00 00 
1641+  FB8E 00 00 00 00 
1641+  FB92 00 00 00 00 
1641+  FB96 00 00 00 00 
1641+  FB9A 00 00 00 00 
1641+  FB9E 00 00 00 00 
1641+  FBA2 00 00 00 00 
1641+  FBA6 00 00 00 00 
1641+  FBAA 00 00 00 00 
1641+  FBAE 00 00 00 00 
1641+  FBB2 00 00 00 00 
1641+  FBB6 00 00 00 00 
1641+  FBBA 00 00 00 00 
1641+  FBBE 00 00 00 00 
1641+  FBC2 00 00 00 00 
1641+  FBC6 00 00 00 00 
1641+  FBCA 00 00 00 00 
1641+  FBCE 00 00 00 00 
1641+  FBD2 00 00 00 00 
1641+  FBD6 00 00 00 00 
1641+  FBDA 00 00 00 00 
1641+  FBDE 00 00 00 00 
1641+  FBE2 00 00 00 00 
1641+  FBE6 00 00 00 00 
1641+  FBEA 00 00 00 00 
1641+  FBEE 00 00 00 00 
1641+  FBF2 00 00 00 00 
1641+  FBF6 00 00 00 00 
1641+  FBFA 00 00 00 00 
1641+  FBFE 00 00 00 00 
1641+  FC02 00 00 00 00 
1641+  FC06 00 00 00 00 
1641+  FC0A 00 00 00 00 
1641+  FC0E 00 00 00 00 
1641+  FC12 00 00 00 00 
1641+  FC16 00 00 00 00 
1641+  FC1A 00 00 00 00 
1641+  FC1E 00 00 00 00 
1641+  FC22 00 00 00 00 
1641+  FC26 00 00 00 00 
1641+  FC2A 00 00 00 00 
1641+  FC2E 00 00 00 00 
1641+  FC32 00 00 00 00 
1641+  FC36 00 00 00 00 
1641+  FC3A 00 00 00 00 
1641+  FC3E 00 00 00 00 
1641+  FC42 00 00 00 00 
1641+  FC46 00 00 00 00 
1641+  FC4A 00 00 00 00 
1641+  FC4E 00 00 00 00 
1641+  FC52 00 00 00 00 
1641+  FC56 00 00 00 00 
1641+  FC5A 00 00 00 00 
1641+  FC5E 00 00 00 00 
1641+  FC62 00 00 00 00 
1641+  FC66 00 00 00 00 
1641+  FC6A 00 00 00 00 
1641+  FC6E 00 00 00 00 
1641+  FC72 00 00 00 00 
1641+  FC76 00 00 00 00 
1641+  FC7A 00 00 00 00 
1641+  FC7E 00 00 00 00 
1641+  FC82 00 00 00 00 
1641+  FC86 00 00 00 00 
1641+  FC8A 00 00 00 00 
1641+  FC8E 00 00 00 00 
1641+  FC92 00 00 00 00 
1641+  FC96 00 00 00 00 
1641+  FC9A 00 00 00 00 
1641+  FC9E 00 00 00 00 
1641+  FCA2 00 00 00 00 
1641+  FCA6 00 00 00 00 
1641+  FCAA 00 00 00 00 
1641+  FCAE 00 00 00 00 
1641+  FCB2 00 00 00 00 
1641+  FCB6 00 00 00 00 
1641+  FCBA 00 00 00 00 
1641+  FCBE 00 00 00 00 
1641+  FCC2 00 00 00 00 
1641+  FCC6 00 00 00 00 
1641+  FCCA 00 00 00 00 
1641+  FCCE 00 00 00 00 
1641+  FCD2 00 00 00 00 
1641+  FCD6 00 00 00 00 
1641+  FCDA 00 00 00 00 
1641+  FCDE 00 00 00 00 
1641+  FCE2 00 00 00 00 
1641+  FCE6 00 00 00 00 
1641+  FCEA 00 00 00 00 
1641+  FCEE 00 00 00 00 
1641+  FCF2 00 00 00 00 
1641+  FCF6 00 00 00 00 
1641+  FCFA 00 00 00 00 
1641+  FCFE 00 00 00 00 
1641+  FD02 00 00 00 00 
1641+  FD06 00 00 00 00 
1641+  FD0A 00 00 00 00 
1641+  FD0E 00 00 00 00 
1641+  FD12 00 00 00 00 
1641+  FD16 00 00 00 00 
1641+  FD1A 00 00 00 00 
1641+  FD1E 00 00 00 00 
1641+  FD22 00 00 00 00 
1641+  FD26 00 00 00 00 
1641+  FD2A 00 00 00 00 
1641+  FD2E 00 00 00 00 
1641+  FD32 00 00 00 00 
1641+  FD36 00 00 00 00 
1641+  FD3A 00 00 00 00 
1641+  FD3E 00 00 00 00 
1641+  FD42 00 00 00 00 
1641+  FD46 00 00 00 00 
1641+  FD4A 00 00 00 00 
1641+  FD4E 00 00 00 00 
1641+  FD52 00 00 00 00 
1641+  FD56 00 00 00 00 
1641+  FD5A 00 00 00 00 
1641+  FD5E 00 00 00 00 
1641+  FD62 00 00 00 00 
1641+  FD66 00 00 00 00 
1641+  FD6A 00 00 00 00 
1641+  FD6E 00 00 00 00 
1641+  FD72 00 00 00 00 
1641+  FD76 00 00 00 00 
1641+  FD7A 00 00 00 00 
1641+  FD7E 00 00 00 00 
1641+  FD82 00 00 00 00 
1641+  FD86 00 00 00 00 
1641+  FD8A 00 00 00 00 
1641+  FD8E 00 00 00 00 
1641+  FD92 00 00 00 00 
1641+  FD96 00 00 00 00 
1641+  FD9A 00 00 00 00 
1641+  FD9E 00 00 00 00 
1641+  FDA2 00 00 00 00 
1641+  FDA6 00 00 00 00 
1641+  FDAA 00 00 00 00 
1641+  FDAE 00 00 00 00 
1641+  FDB2 00 00 00 00 
1641+  FDB6 00 00 00 00 
1641+  FDBA 00 00 00 00 
1641+  FDBE 00 00 00 00 
1641+  FDC2 00 00 
1642+  FDC4             
1643+  FDC4 C3 78 F6                        JP          i2c_ack             ; 19 (0FDC4h) - Send an i2c ACK.
1644+  FDC7 C3 DE FA                        JP          set_usr_interrupt   ; 18 (0FDC7h) - Set the User interrupt vector. HL = 0 to clear, or address of user routine. HL= 0FFFFh to query.
1645+  FDCA C3 D5 FA                        JP          bios_flash_write    ; 17 (0FDCAh) - Erase and write flash data. Data is written to 4K sectors, which are erased before writing.
1646+  FDCD C3 C3 FA                        JP          get_disk_page       ; 16 (0FDCDh) - Get the page in RAM/ROM being used as the base for the drive selected by A, or zero if error.
1647+  FDD0 C3 A3 F9                        JP          rtc_get_time_hl     ; 15 (0FDD0h) - Get the time to the 7 bytes pointed to by HL. Returns carry set if sucessful
1648+  FDD3 C3 8F F7                        JP          disp_char_bright    ; 14 (0FDD3h) - Set LED Digit A to brightness C
1649+  FDD6 C3 EE F7                        JP          disp_bitmask        ; 13 (0FDD6h) - Directly write bitmask in HL to display column A
1650+  FDD9 C3 30 F0                        JP          m_print_inline      ; 12 (0FDD9h) - Print the characters following the call instruction
1651+  FDDC C3 A2 FA                        JP          get_page_mapping    ; 11 (0FDDCh) - Return the logical (cpu) page C (0-2) in A
1652+  FDDF C3 AB FA                        JP          set_page_mapping    ; 10 (0FDDFh) - Set the logical (cpu) page in A (0-2) to the physical (RAM/ROM) page in E
1653+  FDE2 C3 BF F5                        JP          i2c_start           ; 9  (0FDE2h) - Sends I2C start sequence
1654+  FDE5 C3 CE F5                        JP          i2c_stop            ; 8  (0FDE5h) - Sends I2C stop sequence
1655+  FDE8 C3 1A F6                        JP          i2c_write           ; 7  (0FDE8h) - Write A as a byte to i2c bus. Carry SET if success. i2c_stop is not called.
1656+  FDEB C3 65 F6                        JP          i2c_read            ; 6  (0FDEBh) - Read byte from i2C into A, without ACK
1657+  FDEE C3 06 F6                        JP          i2c_write_to        ; 5  (0FDEEh) - Prepare to write to Device address H, Register L. Carry SET if success. i2c_stop is not called.
1658+  FDF1 C3 E5 F5                        JP          i2c_read_from       ; 4  (0FDF1h) - Read a byte int A from Device address H, Register L. Carry SET if success. i2c_stop is not called.
1659+  FDF4 C3 5A F4                        JP          wait_for_key        ; 3  (0FDF4h) - Waits for until a key is pressed and released
1660+  FDF7 C3 EF F3                        JP          play_note           ; 2  (0FDF7h) - Plays the note defined by DE (octave, note) and C (duration, tenths)
1661+  FDFA C3 D2 FA                        JP          get_version         ; 1  (0FDFAh) - Returns the Bios version in A
1662+  FDFD             
1663+  FDFD             
1664+  FDFD~            .IF $ > BIOS_TOP
1665+  FDFD~                .ECHO "End of BIOS is too high ("
1666+  FDFD~                .ECHO $
1667+  FDFD~                .ECHO " > "
1668+  FDFD~                .ECHO BIOS_TOP
1669+  FDFD~                .ECHO ") \n\n"
1670+  FDFD~                .STOP
1671+  FDFD             .ENDIF
1672+  FDFD             
1673+  FDFD             .ECHO "Bios Size is "
1674+  FDFD             .ECHO BIOS_TOP-BIOS_START-BIOS_SPARE
1675+  FDFD             .ECHO ". Limit is "
1676+  FDFD             .ECHO BIOS_TOP-BIOS_START
1677+  FDFD             .ECHO ". Spare "
1678+  FDFD             .ECHO BIOS_SPARE
1679+  FDFD             .ECHO "\n\n"
1680+  FDFD             
1681+  FDFD                                 .INCLUDE shared_data.asm
0001++ FDFD             ;
0002++ FDFD             ; Shared data - common state data for routines
0003++ FDFD             ;
0004++ FDFD             ; [] show default/initial values stored at the location
0005++ FDFD             ;
0006++ FDFD             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0007++ FDFD             ;
0008++ FDFD             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0009++ FDFD             ;
0010++ FDFD             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0011++ FDFD             ; of this software and associated documentation files (the "Software"), to deal
0012++ FDFD             ; in the Software without restriction, including without limitation the rights
0013++ FDFD             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0014++ FDFD             ; copies of the Software, and to permit persons to whom the Software is
0015++ FDFD             ; furnished to do so, subject to the following conditions:
0016++ FDFD             ; 
0017++ FDFD             ; The above copyright notice and this permission notice shall be included in all
0018++ FDFD             ; copies or substantial portions of the Software.
0019++ FDFD             ; 
0020++ FDFD             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0021++ FDFD             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0022++ FDFD             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0023++ FDFD             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0024++ FDFD             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0025++ FDFD             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0026++ FDFD             ; SOFTWARE.
0027++ FDFD             ;
0028++ FDFD             
0029++ FF00                                 .ORG    0FF00h
0030++ FF00             
0031++ FF00             ; I2C/Port B routines
0032++ FF00             port_b_mode         .BLOCK  1
0033++ FF01             port_b_dir          .BLOCK  1
0034++ FF02             port_b_data         .BLOCK  1
0035++ FF03             
0036++ FF03             boot_mode           .BLOCK  1              ; Set during boot. 
0037++ FF04             
0038++ FF04             ;
0039++ FF04             ; Stuff
0040++ FF04             timer               .BLOCK  4              ; 2 Words - counts up by 1 every 64th of a second. Rollover ~2 years.
0041++ FF08                                     
0042++ FF08             ; General I/O
0043++ FF08             ;
0044++ FF08             ; This MUST start with keyboard_state, and will all be reset to zero when io_init is called
0045++ FF08             ;
0046++ FF08             _key_state_size     .EQU    8               ; 8 key rollover
0047++ FF08             
0048++ FF08             keyboard_state      .BLOCK  _key_state_size ; state buffer - 8 bytes containing raw key codes for keys currently pressed
0049++ FF10             keyboard_pos        .BLOCK  2               ; Internal state
0050++ FF12             key_shift_state     .BLOCK  1               ; Holds state of shift and control keys in bits 0 and 1 respectively
0051++ FF13             control_key_pressed .BLOCK  1               ; If special control keys are pressed, they are stored here..
0052++ FF14             last_keycode        .BLOCK  1               ; The last keycode that was pressed, for repeats..
0053++ FF15             key_repeat_time     .BLOCK  1               ; How many poll events since the key state last changed
0054++ FF16             
0055++ FF16             _input_buffer_size  .EQU    16
0056++ FF16             input_buffer        .BLOCK _input_buffer_size          ; 16 byte input buffer. Note wraparound is handled by bitmasks, so don't change this length
0057++ FF26             input_pos           .BLOCK  1               ; Next read position in input buffer
0058++ FF27             input_free          .BLOCK  1               ; Next write position in input buffer
0059++ FF28             input_size          .BLOCK  1               ; Bytes occupied in the input buffer
0060++ FF29             
0061++ FF29             io_data_end         .EQU  input_size        ; Byte after IO data block, used to reset values to zero
0062++ FF29             
0063++ FF29             ;------------------------------- Console output and screen data ------------------------------------------------
0064++ FF29             screen_page         .BLOCK  1               ; [30?]  1 Byte, screen buffer page address
0065++ FF2A             screen_offset       .BLOCK  1               ; [0]    1 Byte, row offset (0-63) of virtual screen in screen buffer (high byte of screen address).
0066++ FF2B             
0067++ FF2B             ; *** ROW AND COL MUST BE IN THIS ORDER - READ BY bios_conout ***
0068++ FF2B             display_row         .BLOCK  1               ; [0]    1 Byte, current row being shown by the LED display
0069++ FF2C             display_col         .BLOCK  1               ; [0]    1 Byte, current column being shown by the LED display - Note, 0 based
0070++ FF2D             
0071++ FF2D             ; *** ROW AND COL MUST BE IN THIS ORDER - READ BY bios_conout ***
0072++ FF2D             cursor_row          .BLOCK  1               ; [1]    1 Byte, cursor row on virtual console. Top of page is row 1.   
0073++ FF2E             cursor_col          .BLOCK  1               ; [1]    1 Byte, cursor column on virtual console. Left of page is column 1.
0074++ FF2F             
0075++ FF2F             console_height      .BLOCK  1               ; [24]   1 Byte, virtual console height (rows)
0076++ FF30             console_width       .BLOCK  1               ; [40]   1 byte, virtual console width (columns)
0077++ FF31             
0078++ FF31             console_colour      .BLOCK  1               ; [0x0F] 1 Byte, current colour. Top 4 bits [7:4] are background, bottom 4 [3:0] are foreground
0079++ FF32             console_flags       .BLOCK  1               ;        1 Byte, bit flags for console
0080++ FF33             
0081++ FF33             console_timer       .BLOCK  1               ;        1 Byte, used to blink cursor, clear movement indicator etc.
0082++ FF34             console_escape      .BLOCK  1               ;        1 Byte, escape value (0 if not received yet)
0083++ FF35             console_param1      .BLOCK  1               ;        1 Byte, first character after escape (0 if not recieved yet)
0084++ FF36             
0085++ FF36             console_identify    .BLOCK  1               ; [0]    1 Byte, indicates console identifier sequence to be returned..
0086++ FF37             
0087++ FF37             CFLAGS_SHOW_CURSOR  .EQU    1               ; Awaiting input - show (blink) the cursor
0088++ FF37             CFLAGS_TRACK_CURSOR .EQU    2               ; LED display is tracking cursor position
0089++ FF37             CFLAGS_SHOW_MOVED   .EQU    4               ; Show display as being moved by user
0090++ FF37             CFLAGS_ESCAPE       .EQU    8               ; Escape sequence started
0091++ FF37             CFLAGS_CURSOR_ON    .EQU    16              ; Cursor is currently displayed
0092++ FF37             CFLAGS_LED_OFF      .EQU    32              ; If set, don't echo to the LED display
0093++ FF37             
0094++ FF37             SHOW_MOVE_DELAY     .EQU    60              ; How long to show the display has been moved
0095++ FF37             
0096++ FF37             ;------------------------------- BIOS customisation  ------------------------------------------------
0097++ FF37             
0098++ FF37             drive_a_mem_page    .BLOCK  1               ; First page in RAM/ROM for the Drive A image  - NOTE: These values must be in order of drive number
0099++ FF38             drive_b_mem_page    .BLOCK  1               ; First page in RAM/ROM for the Drive B image
0100++ FF39             
0101++ FF39             page_0_mapping      .BLOCK  1               ; Stores the user mapping for these pages, so they can be correctly restored after interrupts
0102++ FF3A             page_1_mapping      .BLOCK  1
0103++ FF3B             page_2_mapping      .BLOCK  1
0104++ FF3C             page_3_mapping      .BLOCK  1
0105++ FF3D             
0106++ FF3D             ;------------------------------- BDOS variables ------------------------------------------------
0107++ FF3D             ; *** TRACK AND SECTOR MUST BE IN THIS ORDER - READ BY _get_memdisc_addr ***
0108++ FF3D             sys_track           .BLOCK  1               ; 1 Byte, Current disk track 
0109++ FF3E             sys_sector          .BLOCK  2               ; Word, current disk sector
0110++ FF40             sys_dmaaddr         .BLOCK  2               ; Word, DMA address - Disc will read data to this address, or write from this address
0111++ FF42             sys_disk_dph        .BLOCK  2               ; Word, points to current disk parameter header (DPH) 
0112++ FF44             sys_seldsk          .BLOCK  1               ; Byte, current selected disk drive (A=0, B=1..)
0113++ FF45             
0114++ FF45             sys_alv0            .BLOCK  32              ; 32 bytes, allocation vector 0 (max 255 blocks)
0115++ FF65             sys_alv1            .BLOCK  32              ; 32 bytes, allocation vector 1 (max 255 blocks)
0116++ FF85             
0117++ FF85             display_buffer      .BLOCK  24*2            ; 48 byte scratch area used for composing display output (eg. rtc time display etc.)
0118++ FFB5             
0119++ FFB5             intr_stackarea      .BLOCK  24              ; Interrupt handler stack
0120++ FFCD             intr_stack          .BLOCK  2
0121++ FFCF             
0122++ FFCF             user_interrupt      .BLOCK  2               ; Address of user interrupt routine, or zero
0123++ FFD1             
0124++ FFD1             ; Display functions
0125++ FFD1             display_address     .BLOCK  1              ; byte - I/O address of the display driver (right or left) being written to
0126++ FFD2             
0127++ FFD2             ; Panic codes
0128++ FFD2             ;
0129++ FFD2             PANIC_0001          .EQU    0F001h
0130++ FFD2             PANIC_0002          .EQU    0F002h
0131++ FFD2             PANIC_0003          .EQU    0F003h
0132++ FFD2             PANIC_0004          .EQU    0F004h
0133++ FFD2             
0134++ FFD2             ; Boot options
0135++ FFD2             BOOT_TO_CPM         .EQU    001h
0136++ FFD2             BOOT_NO_LED         .EQU    002h
0137++ FFD2             BOOT_RESTORE_B      .EQU    004h
0138++ FFD2             BOOT_TTY_INPUT      .EQU    008h1682+  FFD2                                 .END1199   FFD2                                 .END
tasm: Number of errors = 0
