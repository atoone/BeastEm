0001   0000             ;
0002   0000             ; Monitor using CP/M BIOS
0003   0000             ;
0004   0000             ;
0005   0000             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006   0000             ;
0007   0000             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008   0000             ;
0009   0000             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010   0000             ; of this software and associated documentation files (the "Software"), to deal
0011   0000             ; in the Software without restriction, including without limitation the rights
0012   0000             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013   0000             ; copies of the Software, and to permit persons to whom the Software is
0014   0000             ; furnished to do so, subject to the following conditions:
0015   0000             ; 
0016   0000             ; The above copyright notice and this permission notice shall be included in all
0017   0000             ; copies or substantial portions of the Software.
0018   0000             ; 
0019   0000             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020   0000             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021   0000             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022   0000             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023   0000             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024   0000             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025   0000             ; SOFTWARE.
0026   0000             ;
0027   0000                                 .MODULE  main
0028   0000             
0029   0000             MONITOR_START       .EQU   0DB00h
0030   0000             
0031   DB00                                 .ORG   MONITOR_START
0032   DB00 CD 1C F0                        CALL   configure_hardware
0033   DB03             
0034   DB03 3E 01                           LD      A, 1
0035   DB05 32 03 00                        LD      (iobyte), A
0036   DB08             
0037   DB08 3E 25                           LD      A, DRIVE_B_PAGE
0038   DB0A 32 38 FF                        LD      (drive_b_mem_page), A
0039   DB0D             
0040   DB0D 21 37 E5    _clock_check        LD      HL, timer_int
0041   DB10 22 FE FD                        LD      (0FDFEh), HL
0042   DB13             
0043   DB13 3E 01                           LD      A, 1
0044   DB15 32 04 FF                        LD      (timer), A
0045   DB18 3E 03                           LD      A, 3
0046   DB1A CD 28 E5                        CALL    detect_int
0047   DB1D             
0048   DB1D 79                              LD      A, C
0049   DB1E B0                              OR      B
0050   DB1F 20 0A                           JR      NZ, _clock_detected
0051   DB21             
0052   DB21 CD 04 F0    _no_clock           CALL    m_print_inline
0053   DB24 2E 00                           .DB     ".", 0
0054   DB26             
0055   DB26 CD A1 F1                        CALL    _do_reti
0056   DB29 18 E2                           JR      _clock_check
0057   DB2B             
0058   DB2B 3E 07       _clock_detected     LD      A, 7
0059   DB2D CD 28 E5                        CALL    detect_int
0060   DB30 79                              LD      A, C
0061   DB31 B0                              OR      B 
0062   DB32 28 ED                           JR      Z, _no_clock
0063   DB34             
0064   DB34                                 ; At this point BC ~= 13 * (clock * 100)
0065   DB34                                 ; Divide by 13, round lowest digit up/down
0066   DB34             
0067   DB34 C5                              PUSH    BC
0068   DB35 E1                              POP     HL
0069   DB36 0E 0D                           LD      C, 13
0070   DB38 CD 44 E5                        CALL    divide_hl_c
0071   DB3B             
0072   DB3B E5                              PUSH    HL
0073   DB3C D1                              POP     DE
0074   DB3D CD 51 E5                        CALL    de_to_bcd
0075   DB40             
0076   DB40 3A 89 E5                        LD      A, (bcd_scratch)         ; Units
0077   DB43 FE 06                           CP      6
0078   DB45 38 11                           JR      C, _display_speed
0079   DB47             
0080   DB47 2A 8A E5                        LD      HL, (bcd_scratch+1)
0081   DB4A 06 04                           LD      B,  4
0082   DB4C             
0083   DB4C 7E          _increment_bcd      LD      A, (HL)
0084   DB4D 3C                              INC     A
0085   DB4E 77                              LD      (HL), A
0086   DB4F FE 0A                           CP      10
0087   DB51 38 05                           JR      C, _display_speed        ; No carry here
0088   DB53 AF                              XOR     A
0089   DB54 77                              LD      (HL), A
0090   DB55 23                              INC     HL
0091   DB56 10 F4                           DJNZ    _increment_bcd
0092   DB58             
0093   DB58 3A 8C E5    _display_speed      LD      A, (bcd_scratch+3)
0094   DB5B A7                              AND     A
0095   DB5C 28 05                           JR      Z, _skip_leading
0096   DB5E C6 30                           ADD     A, '0'
0097   DB60 32 8A DB                        LD      (_speed_value),A
0098   DB63 3A 8B E5    _skip_leading       LD       A, (bcd_scratch+2)
0099   DB66 C6 30                           ADD     A, '0'
0100   DB68 32 8B DB                        LD      (_speed_value+1), A
0101   DB6B 3A 8A E5                        LD      A, (bcd_scratch+1)
0102   DB6E C6 30                           ADD     A, '0'
0103   DB70 32 8D DB                        LD      (_speed_value+3), A
0104   DB73             
0105   DB73 01 60 00                        LD      BC, 60h
0106   DB76 CD 11 E5                        CALL    pause_for_ticks
0107   DB79             
0108   DB79 CD 04 F0                        CALL    m_print_inline
0109   DB7C 0A 0D 43 6C                     .DB     NEWLINE, CARRIAGE_RETURN, "Clock speed "
0109   DB80 6F 63 6B 20 
0109   DB84 73 70 65 65 
0109   DB88 64 20 
0110   DB8A 20 30 2C 30 _speed_value        .DB     " 0,0Mhz", 0
0110   DB8E 4D 68 7A 00 
0111   DB92             
0112   DB92 21 42 F1                        LD      HL, interrupt_handler
0113   DB95 22 FE FD                        LD      (0FDFEh), HL
0114   DB98             
0115   DB98 01 60 00                        LD      BC, 60h
0116   DB9B CD 11 E5                        CALL    pause_for_ticks
0117   DB9E             
0118   DB9E CD 04 F0                        CALL    m_print_inline
0119   DBA1 0A 0D 4D 69                     .DB     NEWLINE, CARRIAGE_RETURN, "MicroBeast Monitor 1.6", 0
0119   DBA5 63 72 6F 42 
0119   DBA9 65 61 73 74 
0119   DBAD 20 4D 6F 6E 
0119   DBB1 69 74 6F 72 
0119   DBB5 20 31 2E 36 
0119   DBB9 00 
0120   DBBA             
0121   DBBA 01 60 00                        LD      BC, 60h
0122   DBBD CD 11 E5                        CALL    pause_for_ticks
0123   DBC0             
0124   DBC0 0E 0A                           LD      C, NEWLINE
0125   DBC2 CD 00 EC                        CALL    bios_conout
0126   DBC5             
0127   DBC5 CD 8E E5    _monitor_menu       CALL    rtc_display_time
0128   DBC8             
0129   DBC8 01 40 00                        LD      BC, 040h
0130   DBCB CD 11 E5                        CALL    pause_for_ticks
0131   DBCE             
0132   DBCE CD 71 EB    _monitor_read       CALL    bios_conist
0133   DBD1 A7                              AND     A
0134   DBD2 28 F1                           JR      Z, _monitor_menu
0135   DBD4             
0136   DBD4 CD 9A EB                        CALL    bios_conin
0137   DBD7             
0138   DBD7 21 FE DB                        LD      HL, main_menu
0139   DBDA CD 42 E4                        CALL    start_menu
0140   DBDD 18 E6                           JR      _monitor_menu
0141   DBDF             
0142   DBDF             
0143   DBDF CD 04 F0    boot_cpm            CALL    m_print_inline
0144   DBE2 0A 0D 46 6F                     .DB     NEWLINE, CARRIAGE_RETURN, "Format RAM disk", 0
0144   DBE6 72 6D 61 74 
0144   DBEA 20 52 41 4D 
0144   DBEE 20 64 69 73 
0144   DBF2 6B 00 
0145   DBF4             
0146   DBF4 CD 73 E3                        CALL    format_memdisk
0147   DBF7             
0148   DBF7 21 F1 EA    boot_without_format LD      HL, bios_boot
0149   DBFA E5                              PUSH    HL
0150   DBFB C3 31 EB                        JP      load_ccp
0151   DBFE             
0152   DBFE             
0153   DBFE 53 65 6C 65 main_menu           .DB     "Select action", 0
0153   DC02 63 74 20 61 
0153   DC06 63 74 69 6F 
0153   DC0A 6E 00 
0154   DC0C             
0155   DC0C DF DB                           .DW     boot_cpm
0156   DC0E 4C 61 75 6E                     .DB     "Launch CP/M", 0
0156   DC12 63 68 20 43 
0156   DC16 50 2F 4D 00 
0157   DC1A             
0158   DC1A 78 E1                           .DW     memory_view
0159   DC1C 4D 65 6D 6F                     .DB     "Memory Editor", 0
0159   DC20 72 79 20 45 
0159   DC24 64 69 74 6F 
0159   DC28 72 00 
0160   DC2A             
0161   DC2A B2 DD                           .DW     ymodem_loader
0162   DC2C 59 2D 4D 6F                     .DB     "Y-Modem Transfer", 0
0162   DC30 64 65 6D 20 
0162   DC34 54 72 61 6E 
0162   DC38 73 66 65 72 
0162   DC3C 00 
0163   DC3D             
0164   DC3D 55 DC                           .DW     set_date
0165   DC3F 53 65 74 20                     .DB     "Set Date", 0
0165   DC43 44 61 74 65 
0165   DC47 00 
0166   DC48             
0167   DC48 1C DD                           .DW     set_time
0168   DC4A 53 65 74 20                     .DB     "Set Time", 0
0168   DC4E 54 69 6D 65 
0168   DC52 00 
0169   DC53 00 00                           .DW     0
0170   DC55             
0171   DC55             
0172   DC55                                 .INCLUDE monitor_dates.asm
0001+  DC55             ;
0002+  DC55             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0003+  DC55             ;
0004+  DC55             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0005+  DC55             ;
0006+  DC55             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0007+  DC55             ; of this software and associated documentation files (the "Software"), to deal
0008+  DC55             ; in the Software without restriction, including without limitation the rights
0009+  DC55             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0010+  DC55             ; copies of the Software, and to permit persons to whom the Software is
0011+  DC55             ; furnished to do so, subject to the following conditions:
0012+  DC55             ; 
0013+  DC55             ; The above copyright notice and this permission notice shall be included in all
0014+  DC55             ; copies or substantial portions of the Software.
0015+  DC55             ; 
0016+  DC55             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0017+  DC55             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0018+  DC55             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0019+  DC55             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0020+  DC55             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0021+  DC55             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0022+  DC55             ; SOFTWARE.
0023+  DC55             ;
0024+  DC55             
0025+  DC55 3A 2D FF    set_date            LD      A, (cursor_row)
0026+  DC58 C6 1F                           ADD     A, 31
0027+  DC5A 32 75 DC                        LD      (_set_date_row), A
0028+  DC5D 32 88 DC                        LD      (_set_week_row), A
0029+  DC60 CD 04 F0                        CALL    m_print_inline
0030+  DC63 0D 44 61 74                     .DB     CARRIAGE_RETURN, "Date YY/MM/DD", ESCAPE_CHAR, "K", ESCAPE_CHAR, "Y",
0030+  DC67 65 20 59 59 
0030+  DC6B 2F 4D 4D 2F 
0030+  DC6F 44 44 1B 4B 
0030+  DC73 1B 59 
0031+  DC75 00          _set_date_row       .DB     0
0032+  DC76 25 00                           .DB     31+6, 0
0033+  DC78 21 63 DD                        LD      HL, date_limits
0034+  DC7B CD 71 DD                        CALL    get_date_time
0035+  DC7E             
0036+  DC7E 3E 01                           LD      A, 1
0037+  DC80 32 69 DD    _select_loop        LD      (day_of_week), A
0038+  DC83             
0039+  DC83 CD 04 F0                        CALL    m_print_inline
0040+  DC86 1B 59                           .DB     ESCAPE_CHAR, "Y", 
0041+  DC88 00          _set_week_row       .DB     0
0042+  DC89 2F 00                           .DB     31+16, 0
0043+  DC8B             
0044+  DC8B 3A 69 DD                        LD      A, (day_of_week)
0045+  DC8E 47                              LD      B, A
0046+  DC8F 21 18 E6                        LD      HL, weekdays
0047+  DC92 10 0A       _week_loop          DJNZ    _next_week
0048+  DC94             
0049+  DC94 7E          _print_week         LD      A, (HL)
0050+  DC95 23                              INC     HL
0051+  DC96 A7                              AND     A
0052+  DC97 28 0C                           JR      Z, _select_week
0053+  DC99 CD 11 F0                        CALL    m_print_a_safe
0054+  DC9C 18 F6                           JR      _print_week
0055+  DC9E             
0056+  DC9E 7E          _next_week          LD      A, (HL)
0057+  DC9F 23                              INC     HL
0058+  DCA0 A7                              AND     A
0059+  DCA1 20 FB                           JR      NZ, _next_week
0060+  DCA3 18 ED                           JR      _week_loop
0061+  DCA5             
0062+  DCA5 CD 71 EB    _select_week        CALL    bios_conist
0063+  DCA8 A7                              AND     A
0064+  DCA9 28 FA                           JR      Z, _select_week
0065+  DCAB CD 9A EB                        CALL    bios_conin
0066+  DCAE FE 80                           CP      KEY_UP
0067+  DCB0 20 0A                           JR      NZ, _test_down
0068+  DCB2 3A 69 DD                        LD      A, (day_of_week)
0069+  DCB5 FE 07                           CP      7
0070+  DCB7 28 EC                           JR      Z, _select_week
0071+  DCB9 3C                              INC     A
0072+  DCBA 18 C4                           JR      _select_loop
0073+  DCBC FE 81       _test_down          CP      KEY_DOWN
0074+  DCBE 20 0A                           JR      NZ, _test_enter 
0075+  DCC0 3A 69 DD                        LD      A, (day_of_week)
0076+  DCC3 FE 01                           CP      1
0077+  DCC5 28 DE                           JR      Z, _select_week
0078+  DCC7 3D                              DEC     A
0079+  DCC8 18 B6                           JR      _select_loop
0080+  DCCA FE 0D       _test_enter         CP      KEY_ENTER
0081+  DCCC 20 D7                           JR      NZ, _select_week
0082+  DCCE             
0083+  DCCE F3                              DI
0084+  DCCF 26 6F                           LD      H, RTC_ADDRESS      
0085+  DCD1 2E 03                           LD      L, RTC_REG_WKDAY
0086+  DCD3 CD DB F5                        CALL    i2c_write_to
0087+  DCD6 D2 05 DD                        JP      NC, _clock_error
0088+  DCD9             
0089+  DCD9 21 69 DD                        LD      HL, day_of_week
0090+  DCDC 7E                              LD      A, (HL)
0091+  DCDD 23                              INC     HL
0092+  DCDE             
0093+  DCDE F6 08                           OR      RTC_WEEKDAY_RUNNING
0094+  DCE0 CD EF F5                        CALL    i2c_write
0095+  DCE3 D2 05 DD                        JP      NC, _clock_error
0096+  DCE6             
0097+  DCE6 46          _write_date_loop    LD      B, (HL)
0098+  DCE7 23                              INC     HL
0099+  DCE8             
0100+  DCE8 7E                              LD      A, (HL)
0101+  DCE9 23                              INC     HL
0102+  DCEA CB 27                           SLA     A
0103+  DCEC CB 27                           SLA     A
0104+  DCEE CB 27                           SLA     A
0105+  DCF0 CB 27                           SLA     A
0106+  DCF2             
0107+  DCF2 B0                              OR      B
0108+  DCF3 FE FF                           CP      0ffh
0109+  DCF5 CA 00 DD                        JP      Z, _start_clock
0110+  DCF8 CD EF F5                        CALL    i2c_write
0111+  DCFB D2 05 DD                        JP      NC, _clock_error
0112+  DCFE 18 E6                           JR      _write_date_loop
0113+  DD00             
0114+  DD00 CD A3 F5    _start_clock        CALL    i2c_stop
0115+  DD03 FB                              EI
0116+  DD04 C9                              RET
0117+  DD05             
0118+  DD05 CD A3 F5    _clock_error        CALL    i2c_stop
0119+  DD08 FB                              EI
0120+  DD09 CD 04 F0                        CALL    m_print_inline
0121+  DD0C 0D 52 54 43                     .DB     CARRIAGE_RETURN, "RTC Error", ESCAPE_CHAR, "K", 0
0121+  DD10 20 45 72 72 
0121+  DD14 6F 72 1B 4B 
0121+  DD18 00 
0122+  DD19 C3 9A EB                        JP      bios_conin
0123+  DD1C             
0124+  DD1C 3A 2D FF    set_time            LD      A, (cursor_row)
0125+  DD1F C6 1F                           ADD     A, 31
0126+  DD21 32 39 DD                        LD      (_set_time_row), A
0127+  DD24 CD 04 F0                        CALL    m_print_inline
0128+  DD27 0D 54 69 6D                     .DB     CARRIAGE_RETURN, "Time HH/mm/ss", ESCAPE_CHAR, "K", ESCAPE_CHAR, "Y",
0128+  DD2B 65 20 48 48 
0128+  DD2F 2F 6D 6D 2F 
0128+  DD33 73 73 1B 4B 
0128+  DD37 1B 59 
0129+  DD39 00          _set_time_row       .DB     0
0130+  DD3A 25 00                           .DB     31+6, 0
0131+  DD3C 21 5D DD                        LD      HL, time_limits
0132+  DD3F CD 71 DD                        CALL    get_date_time
0133+  DD42             
0134+  DD42 3A 6B DD                        LD      A, (digit_values+1)
0135+  DD45 F6 08                           OR      08h
0136+  DD47 32 6B DD                        LD      (digit_values+1), A
0137+  DD4A CD 9A EB                        CALL    bios_conin
0138+  DD4D             
0139+  DD4D F3                              DI
0140+  DD4E 26 6F                           LD      H, RTC_ADDRESS      
0141+  DD50 2E 00                           LD      L, RTC_REG_SEC
0142+  DD52 CD DB F5                        CALL    i2c_write_to
0143+  DD55 D2 05 DD                        JP      NC, _clock_error
0144+  DD58             
0145+  DD58 21 6A DD                        LD      HL, digit_values
0146+  DD5B 18 89                           JR      _write_date_loop
0147+  DD5D                                 
0148+  DD5D 09 05 09 05 time_limits         .DB     9,5,9,5,3,2
0148+  DD61 03 02 
0149+  DD63             
0150+  DD63 01 03 02 01 date_limits         .DB     1,3,2,1,9,9
0150+  DD67 09 09 
0151+  DD69             
0152+  DD69 01          day_of_week         .DB     1
0153+  DD6A 00 00 00 00 digit_values        .DB     0,0,0,0,0,0
0153+  DD6E 00 00 
0154+  DD70 FF                              .DB     0FFh
0155+  DD71             
0156+  DD71 11 6A DD    get_date_time       LD      DE, digit_values
0157+  DD74 01 06 00                        LD      BC, 6
0158+  DD77 ED B0                           LDIR
0159+  DD79 2B                              DEC     HL
0160+  DD7A 1B                              DEC     DE
0161+  DD7B 06 06                           LD      B, 6
0162+  DD7D             
0163+  DD7D E5          _get_digit          PUSH    HL
0164+  DD7E D5                              PUSH    DE
0165+  DD7F C5                              PUSH    BC
0166+  DD80 CD 9A EB                        CALL    bios_conin
0167+  DD83 C1                              POP     BC
0168+  DD84 D1                              POP     DE
0169+  DD85 E1                              POP     HL
0170+  DD86 D6 30                           SUB     '0'
0171+  DD88 38 F3                           JR      C, _get_digit
0172+  DD8A 4F                              LD      C, A
0173+  DD8B 1A                              LD      A, (DE)
0174+  DD8C 32 A1 DD                        LD      (_digit_compare+1),A
0175+  DD8F B9                              CP      C
0176+  DD90 38 EB                           JR      C, _get_digit
0177+  DD92             
0178+  DD92 79                              LD      A, C
0179+  DD93 12                              LD      (DE), A
0180+  DD94 C6 30                           ADD     A,'0'
0181+  DD96 CD 11 F0                        CALL    m_print_a_safe
0182+  DD99             
0183+  DD99 1A                              LD      A,(DE)
0184+  DD9A 2B                              DEC     HL
0185+  DD9B 1B                              DEC     DE
0186+  DD9C CB 40                           BIT     0, B
0187+  DD9E 20 0A                           JR      NZ, _next_tuple
0188+  DDA0 FE 00       _digit_compare      CP      0
0189+  DDA2 28 03                           JR      Z, _next_digit
0190+  DDA4 3E 09                           LD      A, 9
0191+  DDA6 12                              LD      (DE), A
0192+  DDA7 10 D4       _next_digit         DJNZ    _get_digit
0193+  DDA9 C9                              RET
0194+  DDAA CD 04 F0    _next_tuple         CALL    m_print_inline
0195+  DDAD 1B 43 00                        .DB     ESCAPE_CHAR, 'C', 0
0196+  DDB0 18 F5                           JR      _next_digit0173   DDB2             
0174   DDB2             
0175   DDB2 AF          ymodem_loader       XOR     A
0176   DDB3 32 04 E0                        LD      (_ymodem_set), A
0177   DDB6 21 7D E0                        LD      HL, ymodem_menu
0178   DDB9 CD 42 E4                        CALL    start_menu
0179   DDBC                                 
0180   DDBC 3A 04 E0                        LD      A, (_ymodem_set)
0181   DDBF A7                              AND     A
0182   DDC0 C8                              RET     Z
0183   DDC1             
0184   DDC1 ED 5B 01 E0                     LD      DE, (_ymodem_address)
0185   DDC5 3A 03 E0                        LD      A, (_ymodem_page)
0186   DDC8 21 6F DA                        LD      HL, MONITOR_START-YMODEM_BUFFER
0187   DDCB F3                              DI
0188   DDCC CD 81 E6                        CALL    ymodem
0189   DDCF FB                              EI
0190   DDD0 A7                              AND     A
0191   DDD1 CA 83 DE                        JP      Z, _ymodem_success
0192   DDD4             
0193   DDD4 3D                              DEC     A
0194   DDD5 5F                              LD      E, A
0195   DDD6 16 00                           LD      D, 0
0196   DDD8 21 03 DE                        LD      HL, _ymodem_errors
0197   DDDB 19                              ADD     HL, DE
0198   DDDC 19                              ADD     HL, DE
0199   DDDD             
0200   DDDD 7E                              LD      A, (HL)
0201   DDDE 23                              INC     HL
0202   DDDF 66                              LD      H, (HL)
0203   DDE0 6F                              LD      L, A
0204   DDE1             
0205   DDE1 79                              LD      A, C
0206   DDE2 C6 30                           ADD     A, '0'
0207   DDE4 32 3F DE                        LD      (_packet_err_code), A
0208   DDE7             
0209   DDE7 E5                              PUSH    HL
0210   DDE8 CD 04 F0                        CALL    m_print_inline
0211   DDEB 0D 45 52 52                     .DB     CARRIAGE_RETURN, "ERROR: ", 0
0211   DDEF 4F 52 3A 20 
0211   DDF3 00 
0212   DDF4             
0213   DDF4 E1                              POP     HL
0214   DDF5             
0215   DDF5 7E          _ymodem_err_loop    LD      A, (HL)
0216   DDF6 23                              INC     HL
0217   DDF7 A7                              AND     A
0218   DDF8 CA 9A EB                        JP      Z, bios_conin                   ; Wait for a key then go to main menu..
0219   DDFB 4F                              LD      C, A
0220   DDFC E5                              PUSH    HL
0221   DDFD CD 00 EC                        CALL    bios_conout
0222   DE00 E1                              POP     HL
0223   DE01 18 F2                           JR      _ymodem_err_loop
0224   DE03             
0225   DE03 13 DE       _ymodem_errors      .DW     _y_msg_timeout
0226   DE05 1D DE                           .DW     _y_msg_unknown
0227   DE07 2E DE                           .DW     _y_msg_cancel     
0228   DE09 37 DE                           .DW     _y_msg_packet
0229   DE0B 44 DE                           .DW     _y_msg_length
0230   DE0D 52 DE                           .DW     _y_msg_no_dest
0231   DE0F 63 DE                           .DW     _y_msg_send
0232   DE11 72 DE                           .DW     _y_msg_files
0233   DE13             
0234   DE13 54 69 6D 65 _y_msg_timeout      .DB     "Timeout", ESCAPE_CHAR, "K", 0
0234   DE17 6F 75 74 1B 
0234   DE1B 4B 00 
0235   DE1D 55 6E 6B 6E _y_msg_unknown      .DB     "Unknown packet", ESCAPE_CHAR, "K", 0
0235   DE21 6F 77 6E 20 
0235   DE25 70 61 63 6B 
0235   DE29 65 74 1B 4B 
0235   DE2D 00 
0236   DE2E 43 61 6E 63 _y_msg_cancel       .DB     "Cancel", ESCAPE_CHAR, "K", 0
0236   DE32 65 6C 1B 4B 
0236   DE36 00 
0237   DE37 50 61 63 6B _y_msg_packet       .DB     "Packet (", 
0237   DE3B 65 74 20 28 
0238   DE3F             
0239   DE3F 30 29 1B 4B _packet_err_code    .DB     "0)", ESCAPE_CHAR, "K", 0
0239   DE43 00 
0240   DE44             
0241   DE44 46 69 6C 65 _y_msg_length       .DB     "File length", ESCAPE_CHAR, "K", 0
0241   DE48 20 6C 65 6E 
0241   DE4C 67 74 68 1B 
0241   DE50 4B 00 
0242   DE52 4E 6F 20 64 _y_msg_no_dest      .DB     "No destination", ESCAPE_CHAR, "K", 0
0242   DE56 65 73 74 69 
0242   DE5A 6E 61 74 69 
0242   DE5E 6F 6E 1B 4B 
0242   DE62 00 
0243   DE63 53 65 6E 64 _y_msg_send         .DB     "Send Timeout", ESCAPE_CHAR, "K", 0
0243   DE67 20 54 69 6D 
0243   DE6B 65 6F 75 74 
0243   DE6F 1B 4B 00 
0244   DE72 4D 75 6C 74 _y_msg_files        .DB     "Multiple files", ESCAPE_CHAR, "K", 0
0244   DE76 69 70 6C 65 
0244   DE7A 20 66 69 6C 
0244   DE7E 65 73 1B 4B 
0244   DE82 00 
0245   DE83             
0246   DE83 CD 04 F0    _ymodem_success     CALL    m_print_inline           
0247   DE86 0D 4F 4B 20                     .DB     CARRIAGE_RETURN, "OK ",0
0247   DE8A 00 
0248   DE8B 3A 73 DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_high)
0249   DE8E FE FF                           CP      0FFh
0250   DE90 28 06                           JR      Z, _ymodem_no_high
0251   DE92 C6 30                           ADD     A, '0'
0252   DE94 4F                              LD      C, A
0253   DE95 CD 00 EC                        CALL    bios_conout
0254   DE98 3A 72 DA    _ymodem_no_high     LD      A, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0255   DE9B CD D0 E4                        CALL    hex_out
0256   DE9E 3A 71 DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_low)
0257   DEA1 CD D0 E4                        CALL    hex_out
0258   DEA4 CD 04 F0                        CALL    m_print_inline
0259   DEA7 20 42 59 54                     .DB     " BYTES @ ", 0
0259   DEAB 45 53 20 40 
0259   DEAF 20 00 
0260   DEB1 3A 6F DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)
0261   DEB4 17                              RLA
0262   DEB5 38 10                           JR      C, _ymodem_show_addr
0263   DEB7 1F                              RRA
0264   DEB8 CD D0 E4                        CALL    hex_out
0265   DEBB 0E 2F                           LD      C, '/'
0266   DEBD CD 00 EC                        CALL    bios_conout
0267   DEC0 3A 79 DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_high)
0268   DEC3 D6 40                           SUB     40h
0269   DEC5 18 03                           JR      _ymodem_addr
0270   DEC7             
0271   DEC7 3A 79 DA    _ymodem_show_addr   LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_high)
0272   DECA CD D0 E4    _ymodem_addr        CALL    hex_out
0273   DECD 3A 78 DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0274   DED0 CD D0 E4                        CALL    hex_out
0275   DED3 CD 04 F0                        CALL    m_print_inline
0276   DED6 1B 4B 00                        .DB     ESCAPE_CHAR, "K", 0
0277   DED9 CD 71 EB    _ymodem_waitkey     CALL    bios_conist                  
0278   DEDC A7                              AND     A
0279   DEDD 28 FA                           JR      Z, _ymodem_waitkey
0280   DEDF             
0281   DEDF CD 9A EB                        CALL    bios_conin
0282   DEE2             
0283   DEE2             
0284   DEE2 3A 6F DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)      ; Do something with the file.
0285   DEE5 17                              RLA
0286   DEE6 30 06                           JR      NC, _ymodem_handle_page
0287   DEE8             
0288   DEE8 21 05 E0                        LD      HL, ymodem_mem_menu
0289   DEEB C3 42 E4                        JP      start_menu
0290   DEEE             
0291   DEEE             
0292   DEEE 21 32 E0    _ymodem_handle_page LD      HL, ymodem_page_menu
0293   DEF1 C3 42 E4                        JP      start_menu
0294   DEF4             
0295   DEF4 2A 78 DA    _ymodem_view        LD      HL, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0296   DEF7 22 72 E1                        LD      (monitor_address), HL
0297   DEFA C3 51 E2                        JP      edit_memory
0298   DEFD             
0299   DEFD 2A 78 DA    _ymodem_exec        LD      HL, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0300   DF00 E5                              PUSH    HL
0301   DF01 C9          _ymodem_exit        RET
0302   DF02             
0303   DF02 CD 04 F0    _ymodem_flash       CALL    m_print_inline
0304   DF05 0D 0A 50 61                     .DB     CARRIAGE_RETURN, NEWLINE, "Page 00-1f >", ESCAPE_CHAR, "K", 0
0304   DF09 67 65 20 30 
0304   DF0D 30 2D 31 66 
0304   DF11 20 3E 1B 4B 
0304   DF15 00 
0305   DF16             
0306   DF16 06 02                           LD      B, 2
0307   DF18 CD BC E3                        CALL    hex_input
0308   DF1B CD 2E E4                        CALL    delete_or_enter
0309   DF1E 3A 2C E4                        LD      A, (hex_input_result)
0310   DF21 FE 1F                           CP      1fh
0311   DF23 30 DD                           JR      NC, _ymodem_flash
0312   DF25             
0313   DF25 CD 04 F0                        CALL    m_print_inline
0314   DF28 20 59 2F 4E                     .DB     " Y/N?", 0
0314   DF2C 3F 00 
0315   DF2E CD 9A EB                        CALL    bios_conin
0316   DF31 FE 79                           CP      'y'
0317   DF33 20 B9                           JR      NZ, _ymodem_handle_page
0318   DF35             
0319   DF35 CD 04 F0                        CALL    m_print_inline
0320   DF38 0D 0A 57 72                     .DB     CARRIAGE_RETURN, NEWLINE, "Writing", ESCAPE_CHAR, "K", 0
0320   DF3C 69 74 69 6E 
0320   DF40 67 1B 4B 00 
0321   DF44             
0322   DF44 3A 2C E4                        LD      A, (hex_input_result)
0323   DF47 17                              RLA
0324   DF48 17                              RLA
0325   DF49 57                              LD      D, A
0326   DF4A             
0327   DF4A 3A 6F DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)         ; Page loaded
0328   DF4D 32 03 E0    _next_page          LD      (_ymodem_page), A
0329   DF50 D3 71                           OUT     (IO_MEM_1), A
0330   DF52             
0331   DF52 2A 72 DA                        LD      HL, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0332   DF55 7D                              LD      A, L
0333   DF56 E6 C0                           AND     0c0h
0334   DF58 B4                              OR      H
0335   DF59 20 22                           JR      NZ, _full_page
0336   DF5B             
0337   DF5B ED 4B 71 DA                     LD      BC, (MONITOR_START-YMODEM_INFO+ym_length_low)
0338   DF5F 78                              LD      A, B
0339   DF60 B1                              OR      C
0340   DF61 28 06                           JR      Z, _flash_done
0341   DF63 21 00 40                        LD      HL, 4000h
0342   DF66 CD 4C FA                        CALL    flash_write
0343   DF69             
0344   DF69 3E 20       _flash_done         LD      A, RAM_PAGE_0
0345   DF6B D3 70                           OUT     (IO_MEM_0), A
0346   DF6D             
0347   DF6D CD 04 F0                        CALL    m_print_inline
0348   DF70 0D 0A 44 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Done ", ESCAPE_CHAR, "K", 0           
0348   DF74 6E 65 20 1B 
0348   DF78 4B 00 
0349   DF7A C3 9A EB                        JP      bios_conin
0350   DF7D             
0351   DF7D 01 40 00    _full_page          LD      BC, 0040h
0352   DF80 AF                              XOR     A
0353   DF81 ED 42                           SBC     HL, BC
0354   DF83 22 72 DA                        LD      (MONITOR_START-YMODEM_INFO+ym_length_mid), HL
0355   DF86 21 00 40                        LD      HL, 4000h
0356   DF89 44                              LD      B, H
0357   DF8A 4D                              LD      C, L
0358   DF8B CD 4C FA                        CALL    flash_write
0359   DF8E 14                              INC     D
0360   DF8F 3A 03 E0                        LD      A,(_ymodem_page)
0361   DF92 3C                              INC     A
0362   DF93 18 B8                           JR      _next_page
0363   DF95             
0364   DF95 3A 73 DA    _ymodem_firmware    LD      A, (MONITOR_START-YMODEM_INFO+ym_length_high)
0365   DF98 A7                              AND     A
0366   DF99 20 52                           JR      NZ, _not_firmware
0367   DF9B 3A 72 DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0368   DF9E FE 40                           CP      040h
0369   DFA0 30 4B                           JR      NC, _not_firmware
0370   DFA2             
0371   DFA2 CD 04 F0                        CALL    m_print_inline
0372   DFA5 0D 57 72 69                     .DB     CARRIAGE_RETURN, "Write firmware, Y/N?", ESCAPE_CHAR, "K", 0
0372   DFA9 74 65 20 66 
0372   DFAD 69 72 6D 77 
0372   DFB1 61 72 65 2C 
0372   DFB5 20 59 2F 4E 
0372   DFB9 3F 1B 4B 00 
0373   DFBD CD 9A EB                        CALL    bios_conin
0374   DFC0 FE 79                           CP      'y'
0375   DFC2 C2 EE DE                        JP      NZ, _ymodem_handle_page
0376   DFC5             
0377   DFC5 ED 4B 71 DA                     LD      BC, (MONITOR_START-YMODEM_INFO+ym_length_low)
0378   DFC9 3A 6F DA                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)         ; Page loaded
0379   DFCC D3 71                           OUT     (IO_MEM_1), A
0380   DFCE                                 
0381   DFCE 21 00 40                        LD      HL, 4000h
0382   DFD1 16 00                           LD      D, 0
0383   DFD3 CD 4C FA                        CALL    flash_write
0384   DFD6             
0385   DFD6 CD 04 F0                        CALL    m_print_inline
0386   DFD9 0D 0A 44 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Done ", ESCAPE_CHAR, "K", 0
0386   DFDD 6E 65 20 1B 
0386   DFE1 4B 00 
0387   DFE3 ED 5B 71 DA                     LD      DE, (MONITOR_START-YMODEM_INFO+ym_length_low)
0388   DFE7 CD C9 E4                        CALL    hex_word
0389   DFEA C3 9A EB                        JP      bios_conin
0390   DFED             
0391   DFED CD 04 F0    _not_firmware       CALL    m_print_inline
0392   DFF0 0D 0A 54 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Too large", ESCAPE_CHAR, "K", 0
0392   DFF4 6F 20 6C 61 
0392   DFF8 72 67 65 1B 
0392   DFFC 4B 00 
0393   DFFE C3 9A EB                        JP      bios_conin
0394   E001             
0395   E001             
0396   E001 00 00       _ymodem_address     .DW     0
0397   E003 00          _ymodem_page        .DB     0
0398   E004 00          _ymodem_set         .DB     0
0399   E005             
0400   E005 46 69 6C 65 ymodem_mem_menu     .DB     "File actions", 0
0400   E009 20 61 63 74 
0400   E00D 69 6F 6E 73 
0400   E011 00 
0401   E012 F4 DE                           .DW     _ymodem_view
0402   E014 56 69 65 77                     .DB     "View file", 0
0402   E018 20 66 69 6C 
0402   E01C 65 00 
0403   E01E FD DE                           .DW     _ymodem_exec
0404   E020 52 75 6E 00                     .DB     "Run", 0
0405   E024 01 DF                           .DW     _ymodem_exit
0406   E026 4D 61 69 6E                     .DB     "Main menu", 0
0406   E02A 20 6D 65 6E 
0406   E02E 75 00 
0407   E030 00 00                           .DW     0
0408   E032             
0409   E032 46 69 6C 65 ymodem_page_menu    .DB     "File actions", 0
0409   E036 20 61 63 74 
0409   E03A 69 6F 6E 73 
0409   E03E 00 
0410   E03F 02 DF                           .DW     _ymodem_flash
0411   E041 43 6F 70 79                     .DB     "Copy to flash", 0
0411   E045 20 74 6F 20 
0411   E049 66 6C 61 73 
0411   E04D 68 00 
0412   E04F F7 DB                           .DW     boot_without_format
0413   E051 43 50 4D 20                     .DB     "CPM Drive B", 0
0413   E055 44 72 69 76 
0413   E059 65 20 42 00 
0414   E05D 95 DF                           .DW     _ymodem_firmware
0415   E05F 55 70 64 61                     .DB     "Update firmware", 0
0415   E063 74 65 20 66 
0415   E067 69 72 6D 77 
0415   E06B 61 72 65 00 
0416   E06F 01 DF                           .DW     _ymodem_exit
0417   E071 4D 61 69 6E                     .DB     "Main menu", 0
0417   E075 20 6D 65 6E 
0417   E079 75 00 
0418   E07B 00 00                           .DW     0
0419   E07D             
0420   E07D 44 6F 77 6E ymodem_menu         .DB     "Download options", 0
0420   E081 6C 6F 61 64 
0420   E085 20 6F 70 74 
0420   E089 69 6F 6E 73 
0420   E08D 00 
0421   E08E CF E0                           .DW     _ymodem_from_file
0422   E090 41 64 64 72                     .DB     "Address from file", 0
0422   E094 65 73 73 20 
0422   E098 66 72 6F 6D 
0422   E09C 20 66 69 6C 
0422   E0A0 65 00 
0423   E0A2 F0 E0                           .DW     _ymodem_logical
0424   E0A4 43 50 55 20                     .DB     "CPU (Logical) address",0
0424   E0A8 28 4C 6F 67 
0424   E0AC 69 63 61 6C 
0424   E0B0 29 20 61 64 
0424   E0B4 64 72 65 73 
0424   E0B8 73 00 
0425   E0BA 26 E1                           .DW     _ymodem_physical
0426   E0BC 50 68 79 73                     .DB     "Physical address", 0
0426   E0C0 69 63 61 6C 
0426   E0C4 20 61 64 64 
0426   E0C8 72 65 73 73 
0426   E0CC 00 
0427   E0CD 00 00                           .DW     0
0428   E0CF             
0429   E0CF 11 FF FF    _ymodem_from_file   LD      DE, 0FFFFh
0430   E0D2 ED 53 01 E0                     LD      (_ymodem_address), DE
0431   E0D6 ED 53 03 E0                     LD      (_ymodem_page), DE
0432   E0DA CD 04 F0    _ymodem_transfer    CALL    m_print_inline
0433   E0DD 0D 53 74 61                     .DB     CARRIAGE_RETURN, "Start transfer", ESCAPE_CHAR, "K", 0
0433   E0E1 72 74 20 74 
0433   E0E5 72 61 6E 73 
0433   E0E9 66 65 72 1B 
0433   E0ED 4B 00 
0434   E0EF C9                              RET
0435   E0F0             
0436   E0F0 CD 04 F0    _ymodem_logical     CALL    m_print_inline
0437   E0F3 0D 41 64 64                     .DB     CARRIAGE_RETURN, "Address 0000-FFFF >", ESCAPE_CHAR, "K", 0
0437   E0F7 72 65 73 73 
0437   E0FB 20 30 30 30 
0437   E0FF 30 2D 46 46 
0437   E103 46 46 20 3E 
0437   E107 1B 4B 00 
0438   E10A 06 04                           LD      B, 4
0439   E10C CD BC E3                        CALL    hex_input
0440   E10F CD 2E E4                        CALL    delete_or_enter
0441   E112 3E FF                           LD      A, 0FFh
0442   E114 32 03 E0                        LD      (_ymodem_page), A
0443   E117             
0444   E117 ED 5B 2C E4 _ymodem_set_and_go  LD      DE, (hex_input_result)
0445   E11B ED 53 01 E0                     LD      (_ymodem_address), DE
0446   E11F 3E FF                           LD      A, 0FFh
0447   E121 32 04 E0                        LD      (_ymodem_set), A
0448   E124 18 B4                           JR      _ymodem_transfer
0449   E126             
0450   E126 CD 04 F0    _ymodem_physical    CALL    m_print_inline
0451   E129 0D 50 61 67                     .DB     CARRIAGE_RETURN, "Page 20-3F >", ESCAPE_CHAR, "K", 0
0451   E12D 65 20 32 30 
0451   E131 2D 33 46 20 
0451   E135 3E 1B 4B 00 
0452   E139 06 02                           LD      B, 2
0453   E13B CD BC E3                        CALL    hex_input
0454   E13E CD 2E E4                        CALL    delete_or_enter
0455   E141 3A 2C E4                        LD      A, (hex_input_result)
0456   E144 32 03 E0                        LD      (_ymodem_page), A
0457   E147 CD 04 F0                        CALL    m_print_inline
0458   E14A 0D 4F 66 66                     .DB     CARRIAGE_RETURN, "Offset 0000-3FFF >", ESCAPE_CHAR, "K", 0
0458   E14E 73 65 74 20 
0458   E152 30 30 30 30 
0458   E156 2D 33 46 46 
0458   E15A 46 20 3E 1B 
0458   E15E 4B 00 
0459   E160 06 04                           LD      B, 4
0460   E162 CD BC E3                        CALL    hex_input
0461   E165 CD 2E E4                        CALL    delete_or_enter
0462   E168 3A 2D E4                        LD      A, (hex_input_result+1)         ; YModem loads to page 1, so allow for offset..
0463   E16B F6 40                           OR      040h
0464   E16D 32 2D E4                        LD      (hex_input_result+1), A
0465   E170 18 A5                           JR      _ymodem_set_and_go
0466   E172             
0467   E172             ;------------------------------ Memory Editor --------------------------------------------
0468   E172             
0469   E172 00 80       monitor_address     .DW     08000h              ; Default address is 0x8000
0470   E174 00          monitor_mode        .DB     0                   ; 0 = show address + 3 characters, ~0 = hide address + 8 characters
0471   E175 00          edit_col            .DB     0                   ; Column currently being edited..
0472   E176 00 00       edit_digit          .DW     0
0473   E178             
0474   E178 CD 0E E3    memory_view         CALL    display_mem_row
0475   E17B             
0476   E17B CD 71 EB    _wait_key           CALL    bios_conist
0477   E17E A7                              AND     A
0478   E17F 28 FA                           JR      Z, _wait_key
0479   E181 CD 9A EB                        CALL    bios_conin
0480   E184             
0481   E184 FE 80                           CP      KEY_UP
0482   E186 20 0D                           JR      NZ, _not_up
0483   E188 2A 72 E1    memory_up           LD      HL, (monitor_address)
0484   E18B 11 08 00                        LD      DE, 8
0485   E18E ED 52                           SBC     HL, DE
0486   E190 22 72 E1                        LD      (monitor_address), HL
0487   E193 18 E3                           JR      memory_view
0488   E195             
0489   E195 FE 81       _not_up             CP      KEY_DOWN
0490   E197 20 0C                           JR      NZ, _not_down
0491   E199 2A 72 E1    memory_down         LD      HL, (monitor_address)
0492   E19C 11 08 00                        LD      DE, 8
0493   E19F 19                              ADD     HL, DE
0494   E1A0 22 72 E1                        LD      (monitor_address), HL
0495   E1A3 18 D3                           JR      memory_view
0496   E1A5             
0497   E1A5 FE 20       _not_down           CP      ' '
0498   E1A7 20 09                           JR      NZ, _not_space
0499   E1A9 3A 74 E1                        LD      A, (monitor_mode)
0500   E1AC 2F                              CPL
0501   E1AD 32 74 E1                        LD      (monitor_mode), A
0502   E1B0 18 C6                           JR      memory_view
0503   E1B2             
0504   E1B2 FE 0D       _not_space          CP      CARRIAGE_RETURN
0505   E1B4 28 0E                           JR      Z, _input_address
0506   E1B6             
0507   E1B6 FE 83                           CP      KEY_RIGHT
0508   E1B8 CA 51 E2                        JP      Z, edit_memory
0509   E1BB FE 08                           CP      KEY_BACKSPACE
0510   E1BD C8                              RET     Z
0511   E1BE             
0512   E1BE FE 78                           CP      'x'
0513   E1C0 28 1C                           JR      Z, execute
0514   E1C2 18 B7                           JR      _wait_key
0515   E1C4             
0516   E1C4 AF          _input_address      XOR     A
0517   E1C5 32 74 E1                        LD      (monitor_mode), A
0518   E1C8 CD 0E E3                        CALL    display_mem_row
0519   E1CB 0E 0D                           LD      C, CARRIAGE_RETURN
0520   E1CD CD 00 EC                        CALL    bios_conout
0521   E1D0             
0522   E1D0 06 04                           LD      B, 4
0523   E1D2 CD BC E3                        CALL    hex_input
0524   E1D5 2A 2C E4                        LD      HL, (hex_input_result)
0525   E1D8 22 72 E1                        LD      (monitor_address), HL
0526   E1DB C3 78 E1                        JP      memory_view
0527   E1DE             
0528   E1DE AF          execute             XOR     A
0529   E1DF 32 75 E1                        LD      (edit_col), A
0530   E1E2 CD 04 F0    execute_col         CALL    m_print_inline
0531   E1E5 0D 1B 62 2E                     .DB     CARRIAGE_RETURN, ESCAPE_CHAR, 'b', CPM_NUM+15, "Execute from ", 0
0531   E1E9 45 78 65 63 
0531   E1ED 75 74 65 20 
0531   E1F1 66 72 6F 6D 
0531   E1F5 20 00 
0532   E1F7 21 35 E2                        LD      HL, _exec_done
0533   E1FA E5                              PUSH    HL
0534   E1FB 2A 72 E1                        LD      HL, (monitor_address)
0535   E1FE 3A 75 E1                        LD      A, (edit_col)
0536   E201 5F                              LD      E, A
0537   E202 16 00                           LD      D, 0
0538   E204 19                              ADD     HL, DE
0539   E205                                 
0540   E205 E5                              PUSH    HL
0541   E206 EB                              EX      DE, HL
0542   E207 CD C9 E4                        CALL    hex_word
0543   E20A CD 04 F0                        CALL    m_print_inline
0544   E20D 20 59 2F 4E                     .DB     " Y/N?", ESCAPE_CHAR, "K", 0
0544   E211 3F 1B 4B 00 
0545   E215             
0546   E215 CD 9A EB    _exec_loop          CALL    bios_conin
0547   E218 FE 79                           CP      'y'
0548   E21A 28 09                           JR      Z, _exec_go
0549   E21C FE 6E                           CP      'n'
0550   E21E 20 F5                           JR      NZ, _exec_loop
0551   E220 E1                              POP     HL
0552   E221 E1                              POP     HL
0553   E222 C3 78 E1                        JP      memory_view
0554   E225             
0555   E225 CD 04 F0    _exec_go            CALL    m_print_inline
0556   E228 0A 0D 52 75                     .DB     NEWLINE, CARRIAGE_RETURN, "Running", ESCAPE_CHAR, "K", 0
0556   E22C 6E 6E 69 6E 
0556   E230 67 1B 4B 00 
0557   E234 C9                              RET
0558   E235             
0559   E235 F5          _exec_done          PUSH    AF
0560   E236 CD 04 F0                        CALL    m_print_inline
0561   E239 0A 0D 44 6F                     .DB     NEWLINE, CARRIAGE_RETURN, "Done. A=",0
0561   E23D 6E 65 2E 20 
0561   E241 41 3D 00 
0562   E244 F1                              POP     AF
0563   E245 CD D0 E4                        CALL    hex_out
0564   E248 CD 04 F0                        CALL    m_print_inline
0565   E24B 1B 4B 00                        .DB     ESCAPE_CHAR, "K", 0
0566   E24E CD 9A EB                        CALL    bios_conin ;pause for a key, then return to memory edit at the execution location
0567   E251             
0568   E251             
0569   E251 AF          edit_memory         XOR     A
0570   E252 32 75 E1    _set_col_and_edit   LD      (edit_col), A
0571   E255 CD 0E E3    _edit_loop          CALL    display_mem_row
0572   E258 3A 75 E1                        LD      A, (edit_col)
0573   E25B 87                              ADD     A, A
0574   E25C 4F                              LD      C, A
0575   E25D 3A 74 E1                        LD      A, (monitor_mode)
0576   E260 A7                              AND     A
0577   E261 20 04                           JR      NZ, _address_hidden
0578   E263 3E 05                           LD      A, 5
0579   E265 81                              ADD     A, C
0580   E266 4F                              LD      C, A
0581   E267 3A 2D FF    _address_hidden     LD      A, (cursor_row)
0582   E26A C6 1F                           ADD     A, 31
0583   E26C 32 7D E2                        LD      (_edit_set_row), A
0584   E26F 79                              LD      A, C
0585   E270 C6 20                           ADD     A, 32
0586   E272 32 7E E2                        LD      (_edit_set_col), A
0587   E275             
0588   E275 CD 04 F0                        CALL    m_print_inline
0589   E278 1B 62 27                        .DB     ESCAPE_CHAR, 'b', CPM_NUM+8         ; Set the correct brightness
0590   E27B 1B 59                           .DB     ESCAPE_CHAR, 'Y'                    ; And position the cursor
0591   E27D 00          _edit_set_row       .DB     0
0592   E27E 00          _edit_set_col       .DB     0
0593   E27F 00                              .DB     0
0594   E280             
0595   E280 11 00 02                        LD      DE, 0200h
0596   E283 ED 53 76 E1 _edit_next_digit    LD      (edit_digit), DE
0597   E287             
0598   E287 CD 9A EB    _edit_input         CALL    bios_conin
0599   E28A FE 78                           CP      'x'
0600   E28C CA E2 E1                        JP      Z, execute_col
0601   E28F             
0602   E28F FE 83                           CP      KEY_RIGHT
0603   E291 20 1B                           JR      NZ, _not_right
0604   E293 3A 75 E1    _edit_right         LD      A, (edit_col)
0605   E296 FE 07                           CP      7
0606   E298 28 03                           JR      Z, _edit_wrap_down
0607   E29A 3C                              INC     A
0608   E29B 18 B5                           JR      _set_col_and_edit
0609   E29D             
0610   E29D AF          _edit_wrap_down     XOR     A
0611   E29E 32 75 E1                        LD      (edit_col),A
0612   E2A1 11 08 00    _edit_down          LD      DE, 08h
0613   E2A4 2A 72 E1    _edit_move          LD      HL, (monitor_address)
0614   E2A7 19                              ADD     HL, DE
0615   E2A8 22 72 E1                        LD      (monitor_address), HL
0616   E2AB C3 55 E2                        JP      _edit_loop
0617   E2AE             
0618   E2AE FE 82       _not_right          CP      KEY_LEFT
0619   E2B0 20 13                           JR      NZ, _not_left
0620   E2B2 3A 75 E1                        LD      A, (edit_col)
0621   E2B5 A7                              AND     A
0622   E2B6 28 03                           JR      Z, _edit_wrap_up
0623   E2B8 3D                              DEC     A
0624   E2B9 18 97                           JR      _set_col_and_edit
0625   E2BB             
0626   E2BB 3E 07       _edit_wrap_up       LD      A, 7
0627   E2BD 32 75 E1                        LD      (edit_col),A
0628   E2C0 11 F8 FF    _edit_up            LD      DE, 0FFF8h
0629   E2C3 18 DF                           JR      _edit_move
0630   E2C5             
0631   E2C5 FE 80       _not_left           CP      KEY_UP
0632   E2C7 CA C0 E2                        JP      Z, _edit_up
0633   E2CA FE 81                           CP      KEY_DOWN
0634   E2CC CA A1 E2                        JP      Z, _edit_down
0635   E2CF FE 08                           CP      KEY_BACKSPACE
0636   E2D1 C2 DF E2                        JP      NZ, _not_delete
0637   E2D4             
0638   E2D4 3A 77 E1                        LD      A, (edit_digit+1)
0639   E2D7 FE 02                           CP      2
0640   E2D9 CA 78 E1                        JP      Z, memory_view
0641   E2DC C3 55 E2                        JP      _edit_loop
0642   E2DF             
0643   E2DF CD F7 E4    _not_delete         CALL    valid_hex_char
0644   E2E2 38 A3                           JR      C, _edit_input
0645   E2E4             
0646   E2E4 4F                              LD      C, A
0647   E2E5 CD 07 E5                        CALL    hex_char_to_num
0648   E2E8 F5                              PUSH    AF
0649   E2E9 CD 00 EC                        CALL    bios_conout
0650   E2EC F1                              POP     AF
0651   E2ED                                 
0652   E2ED ED 5B 76 E1                     LD      DE, (edit_digit)
0653   E2F1 CB 23                           SLA     E
0654   E2F3 CB 23                           SLA     E
0655   E2F5 CB 23                           SLA     E
0656   E2F7 CB 23                           SLA     E
0657   E2F9 B3                              OR      E
0658   E2FA 5F                              LD      E, A
0659   E2FB 15                              DEC     D
0660   E2FC 20 85                           JR      NZ, _edit_next_digit
0661   E2FE             
0662   E2FE 3A 75 E1                        LD      A, (edit_col)
0663   E301 4F                              LD      C, A
0664   E302 06 00                           LD      B, 0
0665   E304 2A 72 E1                        LD      HL, (monitor_address)
0666   E307 09                              ADD     HL, BC
0667   E308 73                              LD      (HL), E
0668   E309 CD 0E E3                        CALL    display_mem_row
0669   E30C 18 85                           JR      _edit_right
0670   E30E             
0671   E30E 0E 0D       display_mem_row     LD      C, CARRIAGE_RETURN
0672   E310 CD 00 EC                        CALL    bios_conout
0673   E313 3A 74 E1                        LD      A, (monitor_mode)
0674   E316 A7                              AND     A
0675   E317 20 14                           JR      NZ, _hex_values
0676   E319             
0677   E319 CD 04 F0                        CALL    m_print_inline
0678   E31C 0D 1B 62 2E                     .DB     CARRIAGE_RETURN, ESCAPE_CHAR, 'b', CPM_NUM+15, 0
0678   E320 00 
0679   E321             
0680   E321 ED 5B 72 E1                     LD      DE, (monitor_address)
0681   E325 CD C9 E4                        CALL    hex_word
0682   E328             
0683   E328 0E 20                           LD      C, ' '
0684   E32A CD 00 EC                        CALL    bios_conout
0685   E32D             
0686   E32D CD 04 F0    _hex_values         CALL    m_print_inline
0687   E330 1B 62 27 00                     .DB     ESCAPE_CHAR, 'b', CPM_NUM+8, 0
0688   E334             
0689   E334 2A 72 E1                        LD      HL, (monitor_address)
0690   E337 06 08                           LD      B, 8
0691   E339 7E          _mem_hex            LD      A, (HL)
0692   E33A E5                              PUSH    HL
0693   E33B C5                              PUSH    BC
0694   E33C CD D0 E4                        CALL    hex_out
0695   E33F C1                              POP     BC
0696   E340 E1                              POP     HL
0697   E341 23                              INC     HL
0698   E342 10 F5                           DJNZ    _mem_hex
0699   E344             
0700   E344 CD 04 F0                        CALL    m_print_inline
0701   E347 1B 62 2E 00                     .DB     ESCAPE_CHAR, 'b', CPM_NUM+15, 0
0702   E34B             
0703   E34B 2A 72 E1                        LD      HL, (monitor_address)
0704   E34E 06 03                           LD      B, 3
0705   E350 3A 74 E1                        LD      A, (monitor_mode)
0706   E353 A7                              AND     A
0707   E354 28 02                           JR      Z, _mem_char
0708   E356 06 08                           LD      B, 8
0709   E358             
0710   E358 7E          _mem_char           LD      A, (HL)
0711   E359 FE 20                           CP      ' '
0712   E35B D2 60 E3                        JP      NC, _not_control_char
0713   E35E 3E 2E                           LD      A, '.'
0714   E360 FE 80       _not_control_char   CP      128
0715   E362 DA 67 E3                        JP      C, _not_extended_char
0716   E365 3E 2E                           LD      A, '.'
0717   E367 E5          _not_extended_char  PUSH    HL
0718   E368 C5                              PUSH    BC
0719   E369 4F                              LD      C, A
0720   E36A CD 00 EC                        CALL    bios_conout
0721   E36D C1                              POP     BC
0722   E36E E1                              POP     HL
0723   E36F 23                              INC     HL
0724   E370 10 E6                           DJNZ    _mem_char
0725   E372 C9                              RET
0726   E373             
0727   E373             ; Format memory disk
0728   E373             ;
0729   E373 3E 01       format_memdisk      LD      A, 1
0730   E375 4F                              LD      C, A
0731   E376 CD 2F EF                        CALL    bios_seldsk
0732   E379             
0733   E379 21 80 00                        LD      HL, BIOS_SECTOR_ADDRESS     ; Sector buffer
0734   E37C 22 BA E3                        LD      (_fmt_address),HL
0735   E37F             
0736   E37F 54                              LD      D, H                        ; Fill sector buffer with 0E5h (blank byte)
0737   E380 5D                              LD      E, L
0738   E381 13                              INC     DE
0739   E382 3E E5                           LD      A, 0E5h
0740   E384 77                              LD      (HL),A
0741   E385 01 7F 00                        LD      BC, 07fh
0742   E388 ED B0                           LDIR
0743   E38A             
0744   E38A 3E 02                           LD      A,BIOS_BOOT_TRACKS          ; First track (Offset = 2)
0745   E38C 32 B8 E3    _fmt_track_loop     LD      (_fmt_track),A
0746   E38F 4F                              LD      C,A                         ; Set track
0747   E390 CD 4A EF                        CALL    bios_settrk
0748   E393             
0749   E393 AF                              XOR     A                           ; Initial sector
0750   E394 32 B9 E3    _fmt_sector_loop    LD      (_fmt_sector),A
0751   E397             
0752   E397 FE 1A                           CP      MEMDISK_SECTORS
0753   E399 28 14                           JR      Z,_fmt_next_track
0754   E39B 4F                              LD      C,A                         ; Set sector
0755   E39C CD 4F EF                        CALL    bios_setsec
0756   E39F ED 4B BA E3                     LD      BC,(_fmt_address)           ; Address to write from
0757   E3A3 CD 54 EF                        CALL    bios_setdma
0758   E3A6 CD 92 EF                        CALL    bios_write
0759   E3A9 3A B9 E3                        LD      A,(_fmt_sector)
0760   E3AC             
0761   E3AC 3C                              INC     A
0762   E3AD 18 E5                           JR      _fmt_sector_loop
0763   E3AF             
0764   E3AF 3A B8 E3    _fmt_next_track     LD      A,(_fmt_track)
0765   E3B2 FE 4F                           CP      MEMDISK_TRACKS
0766   E3B4 C8                              RET     Z
0767   E3B5 3C                              INC     A
0768   E3B6 18 D4                           JR      _fmt_track_loop
0769   E3B8             
0770   E3B8 00          _fmt_track          .DB     0
0771   E3B9 00          _fmt_sector         .DB     0
0772   E3BA 00 00       _fmt_address        .DW     0
0773   E3BC             
0774   E3BC             ;------------------------------------------------------
0775   E3BC             ; Read hex input into the (input_hex) address
0776   E3BC             ; Params - B = number of characters to input
0777   E3BC             ;
0778   E3BC 78          hex_input           LD      A, B
0779   E3BD 32 01 E4                        LD      (_hi_size), A
0780   E3C0 21 00 00                        LD      HL, 0
0781   E3C3 22 2C E4                        LD      (hex_input_result), HL
0782   E3C6             
0783   E3C6 C5          _hi_loop            PUSH    BC
0784   E3C7 CD EB E4    _hi_loop_join       CALL    hex_char_in
0785   E3CA FE 08                           CP      KEY_BACKSPACE
0786   E3CC 28 34                           JR      Z, _hi_delete
0787   E3CE 4F                              LD      C, A
0788   E3CF F5                              PUSH    AF
0789   E3D0 CD 00 EC                        CALL    bios_conout
0790   E3D3 F1                              POP     AF
0791   E3D4 CD 07 E5                        CALL    hex_char_to_num
0792   E3D7 2A 2C E4                        LD      HL, (hex_input_result)
0793   E3DA CB 27                           SLA     A
0794   E3DC CB 27                           SLA     A
0795   E3DE CB 27                           SLA     A
0796   E3E0 CB 27                           SLA     A
0797   E3E2             
0798   E3E2 CB 27                           SLA     A
0799   E3E4 CB 15                           RL      L
0800   E3E6 CB 14                           RL      H
0801   E3E8 CB 27                           SLA     A
0802   E3EA CB 15                           RL      L
0803   E3EC CB 14                           RL      H
0804   E3EE CB 27                           SLA     A
0805   E3F0 CB 15                           RL      L
0806   E3F2 CB 14                           RL      H
0807   E3F4 CB 27                           SLA     A
0808   E3F6 CB 15                           RL      L
0809   E3F8 CB 14                           RL      H
0810   E3FA 22 2C E4                        LD      (hex_input_result), HL
0811   E3FD C1                              POP     BC
0812   E3FE 10 C6                           DJNZ    _hi_loop
0813   E400 C9                              RET
0814   E401             
0815   E401 00          _hi_size            .DB     0
0816   E402             
0817   E402 C1          _hi_delete          POP     BC
0818   E403 3A 01 E4    _hi_delete_join     LD      A, (_hi_size)
0819   E406 B8                              CP      B
0820   E407 28 BD                           JR      Z, _hi_loop
0821   E409 04                              INC     B
0822   E40A C5                              PUSH    BC
0823   E40B             
0824   E40B 2A 2C E4                        LD      HL, (hex_input_result)
0825   E40E CB 3C                           SRL     H
0826   E410 CB 1D                           RR      L
0827   E412 CB 3C                           SRL     H
0828   E414 CB 1D                           RR      L
0829   E416 CB 3C                           SRL     H
0830   E418 CB 1D                           RR      L
0831   E41A CB 3C                           SRL     H
0832   E41C CB 1D                           RR      L
0833   E41E 22 2C E4                        LD      (hex_input_result), HL
0834   E421             
0835   E421 CD 04 F0                        CALL    m_print_inline
0836   E424 1B 44 20 1B                     .DB     ESCAPE_CHAR, "D ", ESCAPE_CHAR, "D", 0
0836   E428 44 00 
0837   E42A 18 9B                           JR      _hi_loop_join
0838   E42C             
0839   E42C 00 00       hex_input_result    .DW     0
0840   E42E             
0841   E42E             delete_or_enter     ; Wait for Delete or enter keys and handle..
0842   E42E CD 9A EB                        CALL    bios_conin
0843   E431 FE 0D                           CP      CARRIAGE_RETURN
0844   E433 C8                              RET     Z
0845   E434 06 00                           LD      B, 0
0846   E436 FE 08                           CP      KEY_BACKSPACE
0847   E438 CC 03 E4                        CALL    Z, _hi_delete_join
0848   E43B 18 F1                           JR      delete_or_enter
0849   E43D             
0850   E43D             
0851   E43D             ;------------------------------------------------------
0852   E43D             ; Menu system
0853   E43D 00          menu_index          .DB     0
0854   E43E 00 00       menu_address        .DW     0
0855   E440 00 00       menu_current        .DW     0
0856   E442             
0857   E442 AF          start_menu          XOR    A
0858   E443 32 3D E4                        LD     (menu_index), A
0859   E446 22 3E E4                        LD     (menu_address), HL
0860   E449             
0861   E449 CD 89 E4    _menu_loop          CALL   _display_menu
0862   E44C 01 58 02                        LD     BC, 600
0863   E44F CD 11 E5                        CALL   pause_for_ticks
0864   E452 CD 71 EB                        CALL   bios_conist
0865   E455 A7                              AND    A
0866   E456 C8                              RET    Z
0867   E457             
0868   E457 CD 9A EB    _menu_key           CALL   bios_conin
0869   E45A FE 81                           CP     KEY_DOWN
0870   E45C 20 09                           JR     NZ, _menu_up
0871   E45E             
0872   E45E 3A 3D E4                        LD      A, (menu_index)
0873   E461 3C                              INC     A
0874   E462 32 3D E4    _menu_set_index     LD      (menu_index),A
0875   E465 18 E2                           JR      _menu_loop
0876   E467             
0877   E467 FE 80       _menu_up            CP      KEY_UP
0878   E469 20 08                           JR      NZ, _menu_delete
0879   E46B 3A 3D E4                        LD      A, (menu_index)
0880   E46E 3D                              DEC     A
0881   E46F 28 D8                           JR      Z, _menu_loop
0882   E471 18 EF                           JR      _menu_set_index
0883   E473             
0884   E473 FE 08       _menu_delete        CP      KEY_BACKSPACE
0885   E475 C8                              RET     Z
0886   E476             
0887   E476 FE 0D       _menu_enter         CP      KEY_ENTER
0888   E478 20 CF                           JR      NZ, _menu_loop
0889   E47A 3A 3D E4                        LD      A, (menu_index)
0890   E47D A7                              AND     A
0891   E47E 28 C9                           JR      Z, _menu_loop
0892   E480 2A 40 E4                        LD      HL, (menu_current)
0893   E483 7E                              LD      A, (HL)
0894   E484 23                              INC     HL
0895   E485 66                              LD      H, (HL)
0896   E486 6F                              LD      L, A
0897   E487 E5                              PUSH    HL
0898   E488 C9                              RET
0899   E489             
0900   E489             
0901   E489             
0902   E489 0E 0D       _display_menu       LD      C, CARRIAGE_RETURN
0903   E48B CD 00 EC                        CALL    bios_conout
0904   E48E             
0905   E48E 3A 3D E4                        LD      A, (menu_index)
0906   E491 2A 3E E4                        LD      HL, (menu_address)
0907   E494 A7          _entry_loop         AND     A
0908   E495 28 12                           JR      Z, _display_entry
0909   E497 47                              LD      B, A
0910   E498 7E          _next_menu          LD      A, (HL)
0911   E499 23                              INC     HL
0912   E49A A7                              AND     A
0913   E49B 20 FB                           JR      NZ, _next_menu
0914   E49D             
0915   E49D 22 40 E4                        LD      (menu_current), HL
0916   E4A0 7E                              LD      A, (HL)
0917   E4A1 23                              INC     HL
0918   E4A2 5E                              LD      E, (HL)
0919   E4A3 23                              INC     HL
0920   E4A4 B3                              OR      E
0921   E4A5 28 19                           JR      Z, _menu_end
0922   E4A7 10 EF                           DJNZ    _next_menu
0923   E4A9                                 
0924   E4A9 7E          _display_entry      LD      A, (HL)
0925   E4AA A7                              AND     A
0926   E4AB 28 09                           JR      Z, _entry_end
0927   E4AD 4F                              LD      C, A
0928   E4AE E5                              PUSH    HL
0929   E4AF CD 00 EC                        CALL    bios_conout
0930   E4B2 E1                              POP     HL
0931   E4B3 23                              INC     HL
0932   E4B4 18 F3                           JR      _display_entry
0933   E4B6 0E 1B       _entry_end          LD      C, ESCAPE_CHAR
0934   E4B8 CD 00 EC                        CALL    bios_conout
0935   E4BB 0E 4B                           LD      C, 'K'
0936   E4BD C3 00 EC                        JP      bios_conout
0937   E4C0             
0938   E4C0 3A 3D E4    _menu_end           LD      A, (menu_index)
0939   E4C3 3D                              DEC     A
0940   E4C4 32 3D E4                        LD      (menu_index), A
0941   E4C7 18 C0                           JR      _display_menu
0942   E4C9             
0943   E4C9             
0944   E4C9             ;------------------------------------------------------
0945   E4C9             ; Write the Hex value of DE as four characters to conout
0946   E4C9             ;
0947   E4C9 D5          hex_word            PUSH    DE
0948   E4CA 7A                              LD      A, D
0949   E4CB CD D0 E4                        CALL    hex_out
0950   E4CE D1                              POP     DE
0951   E4CF 7B                              LD      A, E                ; Fall into hex_out..
0952   E4D0             
0953   E4D0             ;------------------------------------------------------
0954   E4D0             ; Write the Hex value of A as two characters to conout
0955   E4D0             ;
0956   E4D0 4F          hex_out             LD      C, A
0957   E4D1 CB 3F                           SRL     A
0958   E4D3 CB 3F                           SRL     A
0959   E4D5 CB 3F                           SRL     A
0960   E4D7 CB 3F                           SRL     A
0961   E4D9 C5                              PUSH    BC
0962   E4DA CD DF E4                        CALL    _nibble
0963   E4DD C1                              POP     BC
0964   E4DE 79                              LD      A, C
0965   E4DF             
0966   E4DF E6 0F       _nibble             AND     $0F      ;LOW NIBBLE ONLY
0967   E4E1 C6 90                           ADD     A,$90
0968   E4E3 27                              DAA 
0969   E4E4 CE 40                           ADC     A,$40
0970   E4E6 27                              DAA 
0971   E4E7 4F                              LD      C,A
0972   E4E8 C3 00 EC                        JP      bios_conout
0973   E4EB             
0974   E4EB             
0975   E4EB             ;------------------------------------------------------
0976   E4EB             ; Only accept hex characters (0-9, a-f), or DELETE from the input
0977   E4EB             ; Returns with character in A, a-f are capitalised
0978   E4EB             ;
0979   E4EB CD 9A EB    hex_char_in         CALL    bios_conin
0980   E4EE FE 08                           CP      KEY_BACKSPACE
0981   E4F0 C8                              RET     Z
0982   E4F1 CD F7 E4                        CALL    valid_hex_char
0983   E4F4 38 F5                           JR      C, hex_char_in
0984   E4F6 C9                              RET
0985   E4F7             ;
0986   E4F7             ; Return with carry CLEAR if the character is a valid hex digit
0987   E4F7             ; Enter with A = character to test
0988   E4F7             ; Returns with A capitalised
0989   E4F7 FE 30       valid_hex_char      CP      '0'
0990   E4F9 D8                              RET     C
0991   E4FA FE 3A                           CP      ':'
0992   E4FC 3F                              CCF
0993   E4FD D0                              RET     NC
0994   E4FE FE 61                           CP      'a'
0995   E500 D8                              RET     C
0996   E501 FE 67                           CP      'g'
0997   E503 CB AF                           RES     5, a                ; Capitalise it..
0998   E505 3F                              CCF
0999   E506 C9                              RET
1000   E507             
1001   E507 FE 41       hex_char_to_num     CP      'A'
1002   E509 30 03                           JR      NC, _alpha_char
1003   E50B D6 30                           SUB     '0'
1004   E50D C9                              RET
1005   E50E D6 37       _alpha_char         SUB     'A'-10
1006   E510 C9                              RET
1007   E511             
1008   E511             ;
1009   E511             ; Pause for BC ticks
1010   E511             ; Uses HL, DE
1011   E511             ;
1012   E511 ED 5B 04 FF pause_for_ticks     LD      DE, (timer)
1013   E515 C5          _pause_loop         PUSH    BC
1014   E516 D5                              PUSH    DE
1015   E517 CD 71 EB                        CALL    bios_conist
1016   E51A D1                              POP     DE
1017   E51B C1                              POP     BC
1018   E51C A7                              AND     A
1019   E51D C0                              RET     NZ
1020   E51E 2A 04 FF                        LD      HL, (timer)
1021   E521 ED 52                           SBC     HL, DE
1022   E523 ED 42                           SBC     HL, BC
1023   E525 38 EE                           JR      C, _pause_loop
1024   E527 C9                              RET
1025   E528             ;
1026   E528             ; Detect (and time) interrupt
1027   E528             ; Enter with A containing the mask for which bits of the timer byte we check for zero
1028   E528             ; Return when the timer is zero, with BC containing 72 + 48*t-states taken
1029   E528             ;
1030   E528 01 00 00    detect_int          LD      BC, 0
1031   E52B 57                              LD      D, A
1032   E52C 3A 04 FF    _wait_for_tick      LD      A, (timer)               ; 13            ; Loop = 13+4+5+6+4+4+12 (=48) * BC + (13 + 4 + 11 + 13 + 4 + 17 + 10 (CALL)) = 72
1033   E52F A2                              AND     D                        ; 4
1034   E530 C8                              RET     Z                        ; 5 / 11
1035   E531 03                              INC     BC                       ; 6
1036   E532 79                              LD      A, C                     ; 4
1037   E533 B0                              OR      B                        ; 4
1038   E534 20 F6                           JR      NZ, _wait_for_tick       ; 7 / 12
1039   E536 C9                              RET
1040   E537             ;
1041   E537             ; Fast int routine to allow us to time CPU speed
1042   E537             ;
1043   E537 F3          timer_int           DI
1044   E538 E5                              PUSH    HL
1045   E539 2A 04 FF                        LD      HL, (timer)
1046   E53C 23                              INC     HL
1047   E53D 22 04 FF                        LD      (timer), HL
1048   E540 E1                              POP     HL
1049   E541 FB                              EI
1050   E542 ED 4D                           RETI
1051   E544             
1052   E544             ; Divide HL by C (unsigned)
1053   E544             ;Inputs:
1054   E544             ;     HL is the numerator
1055   E544             ;     C is the denominator
1056   E544             ;Outputs:
1057   E544             ;     A is the remainder
1058   E544             ;     B is 0
1059   E544             ;     C is not changed
1060   E544             ;     DE is not changed
1061   E544             ;     HL is the quotient
1062   E544             ;
1063   E544             divide_hl_c
1064   E544 06 10                           LD      B, 16
1065   E546 AF                              XOR     A
1066   E547 29          _div0               ADD     HL, HL
1067   E548 17                              RLA
1068   E549 B9                              CP      C
1069   E54A 38 02                           JR      C,_div1
1070   E54C 2C                              INC     L
1071   E54D 91                              SUB     C
1072   E54E 10 F7       _div1               DJNZ    _div0
1073   E550 C9                              RET
1074   E551             
1075   E551             ;
1076   E551             ; Convert DE to a five digit BCD value stored in bcd_scratch
1077   E551             ; 
1078   E551 AF          de_to_bcd           XOR     A
1079   E552 21 89 E5                        LD      HL, bcd_scratch
1080   E555 06 05                           LD      B, 5
1081   E557 77          _clear_scratch      LD      (HL), A
1082   E558 23                              INC     HL
1083   E559 10 FC                           DJNZ    _clear_scratch
1084   E55B                 
1085   E55B 06 10                           LD      B, 16           ; Convert 16 bits
1086   E55D 0E 05       _bcd_loop           LD      C, 5
1087   E55F 21 89 E5                        LD      HL, bcd_scratch
1088   E562 7E          _correct_digits     LD      A, (HL)
1089   E563 FE 05                           CP      5
1090   E565 38 03                           JR      C, _digit_ok
1091   E567 C6 03                           ADD     A, 3
1092   E569 77                              LD      (HL), A
1093   E56A 23          _digit_ok           INC     HL
1094   E56B 0D                              DEC     C
1095   E56C 20 F4                           JR      NZ, _correct_digits                   
1096   E56E             
1097   E56E 21 89 E5                        LD      HL, bcd_scratch
1098   E571 0E 05                           LD      C, 5
1099   E573 CB 23                           SLA     E
1100   E575 CB 12                           RL      D
1101   E577             
1102   E577 7E          _shift_digits       LD      A, (HL)
1103   E578 CB 17                           RL      A
1104   E57A CB 67                           BIT     4, A
1105   E57C 28 03                           JR      Z, _skip_carry
1106   E57E E6 0F                           AND     0Fh
1107   E580 37                              SCF
1108   E581 77          _skip_carry         LD      (HL), A
1109   E582 23                              INC     HL
1110   E583 0D                              DEC     C
1111   E584 20 F1                           JR      NZ, _shift_digits
1112   E586 10 D5                           DJNZ    _bcd_loop
1113   E588 C9                              RET
1114   E589             
1115   E589 00 00 00 00 bcd_scratch         .DB      0,0,0,0,0      ; Five bytes - 0 to 99,999. Smallest digit (units) first
1115   E58D 00 
1116   E58E             
1117   E58E                                 .INCLUDE  "monitor_rtc.asm"
0001+  E58E             ;
0002+  E58E             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0003+  E58E             ;
0004+  E58E             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0005+  E58E             ;
0006+  E58E             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0007+  E58E             ; of this software and associated documentation files (the "Software"), to deal
0008+  E58E             ; in the Software without restriction, including without limitation the rights
0009+  E58E             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0010+  E58E             ; copies of the Software, and to permit persons to whom the Software is
0011+  E58E             ; furnished to do so, subject to the following conditions:
0012+  E58E             ; 
0013+  E58E             ; The above copyright notice and this permission notice shall be included in all
0014+  E58E             ; copies or substantial portions of the Software.
0015+  E58E             ; 
0016+  E58E             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0017+  E58E             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0018+  E58E             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0019+  E58E             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0020+  E58E             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0021+  E58E             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0022+  E58E             ; SOFTWARE.
0023+  E58E             ;
0024+  E58E                                     .MODULE monitor_rtc
0025+  E58E             
0026+  E58E             _offset_sec             .EQU    0
0027+  E58E             _offset_min             .EQU    1
0028+  E58E             _offset_hour            .EQU    2
0029+  E58E             _offset_wkday           .EQU    3
0030+  E58E             _offset_date            .EQU    4
0031+  E58E             _offset_month           .EQU    5
0032+  E58E             _offset_year            .EQU    6
0033+  E58E             
0034+  E58E             
0035+  E58E 21 A5 F9    rtc_display_time        LD      HL, time_scratch
0036+  E591 CD 79 F9                            CALL    rtc_get_time_hl
0037+  E594 D2 64 E6                            JP      NC, _get_error
0038+  E597             
0039+  E597 0E 0D                               LD      C, CARRIAGE_RETURN
0040+  E599 CD 00 EC                            CALL    bios_conout
0041+  E59C                                     
0042+  E59C 3A A8 F9                            LD      A, (time_scratch+_offset_wkday)
0043+  E59F 21 18 E6                            LD      HL, weekdays
0044+  E5A2 4F                                  LD      C, A
0045+  E5A3             
0046+  E5A3 CD 02 E6                            CALL    _search_word
0047+  E5A6                                     
0048+  E5A6 CD E3 E5    _get_date               CALL    _space
0049+  E5A9 3A A9 F9                            LD      A, (time_scratch+_offset_date)
0050+  E5AC CD E0 E5                            CALL    _two_chars_space
0051+  E5AF             
0052+  E5AF 3A AA F9                            LD      A, (time_scratch+_offset_month)
0053+  E5B2 21 34 E6                            LD      HL, _months
0054+  E5B5 CB 67                               BIT     4, A
0055+  E5B7 28 02                               JR      Z, _month_ok
0056+  E5B9 D6 06                               SUB     6
0057+  E5BB 4F          _month_ok               LD      C,A
0058+  E5BC             
0059+  E5BC CD 02 E6                            CALL    _search_word
0060+  E5BF CD E3 E5                            CALL    _space
0061+  E5C2 3E 20                               LD      A, 20h
0062+  E5C4 CD E8 E5                            CALL    _two_chars
0063+  E5C7             
0064+  E5C7 3A AB F9                            LD      A, (time_scratch+_offset_year)
0065+  E5CA CD E0 E5                            CALL    _two_chars_space
0066+  E5CD             
0067+  E5CD 3A A7 F9                            LD      A, (time_scratch+_offset_hour)
0068+  E5D0 CD E0 E5                            CALL    _two_chars_space
0069+  E5D3             
0070+  E5D3 3A A6 F9                            LD      A, (time_scratch+_offset_min)
0071+  E5D6 CD E0 E5                            CALL    _two_chars_space
0072+  E5D9             
0073+  E5D9 3A A5 F9                            LD      A, (time_scratch+_offset_sec)
0074+  E5DC CD E8 E5                            CALL    _two_chars
0075+  E5DF C9                                  RET
0076+  E5E0             
0077+  E5E0 CD E8 E5    _two_chars_space       CALL    _two_chars
0078+  E5E3 0E 20       _space                  LD      C, ' '
0079+  E5E5 C3 00 EC                            JP      bios_conout
0080+  E5E8             
0081+  E5E8 4F          _two_chars              LD      C,A
0082+  E5E9 CB 3F                               SRL     A
0083+  E5EB CB 3F                               SRL     A
0084+  E5ED CB 3F                               SRL     A
0085+  E5EF CB 3F                               SRL     A
0086+  E5F1 C6 30                               ADD     A, '0'
0087+  E5F3 C5                                  PUSH    BC
0088+  E5F4 4F                                  LD      C, A
0089+  E5F5 CD 00 EC                            CALL    bios_conout
0090+  E5F8 C1                                  POP     BC
0091+  E5F9 79                                  LD      A,C
0092+  E5FA E6 0F                               AND     0fh
0093+  E5FC C6 30                               ADD     A, '0'
0094+  E5FE 4F                                  LD      C, A
0095+  E5FF C3 00 EC                            JP      bios_conout
0096+  E602             ;
0097+  E602             ; Search table pointed to by HL for the C'th word (1-based)
0098+  E602             ; Prints the chosen word to conout
0099+  E602             ;
0100+  E602 0D          _search_word            DEC     C
0101+  E603 20 0C                               JR      NZ, _next_char
0102+  E605                                     
0103+  E605 7E          _print_word             LD      A, (HL)
0104+  E606 23                                  INC     HL
0105+  E607 A7                                  AND     A
0106+  E608 C8                                  RET     Z
0107+  E609 4F                                  LD      C, A
0108+  E60A E5                                  PUSH    HL
0109+  E60B CD 00 EC                            CALL    bios_conout
0110+  E60E E1                                  POP     HL
0111+  E60F 18 F4                               JR      _print_word
0112+  E611             
0113+  E611 7E          _next_char              LD      A, (HL)
0114+  E612 23                                  INC     HL
0115+  E613 A7                                  AND     A
0116+  E614 20 FB                               JR      NZ, _next_char
0117+  E616 18 EA                               JR      _search_word
0118+  E618             
0119+  E618             
0120+  E618 4D 6F 6E 00 weekdays                .DB "Mon",0
0121+  E61C 54 75 65 00                         .DB "Tue",0
0122+  E620 57 65 64 00                         .DB "Wed",0
0123+  E624 54 68 75 00                         .DB "Thu",0
0124+  E628 46 72 69 00                         .DB "Fri",0
0125+  E62C 53 61 74 00                         .DB "Sat",0
0126+  E630 53 75 6E 00                         .DB "Sun",0
0127+  E634             
0128+  E634 4A 61 6E 00 _months                 .DB "Jan",0
0129+  E638 46 65 62 00                         .DB "Feb",0
0130+  E63C 4D 61 72 00                         .DB "Mar",0
0131+  E640 41 70 72 00                         .DB "Apr",0
0132+  E644 4D 61 79 00                         .DB "May",0
0133+  E648 4A 75 6E 00                         .DB "Jun",0
0134+  E64C 4A 75 6C 00                         .DB "Jul",0
0135+  E650 41 75 67 00                         .DB "Aug",0
0136+  E654 53 65 70 00                         .DB "Sep",0
0137+  E658 4F 63 74 00                         .DB "Oct",0
0138+  E65C 4E 6F 76 00                         .DB "Nov",0
0139+  E660 44 65 63 00                         .DB "Dec",0
0140+  E664             
0141+  E664             
0142+  E664 CD A3 F5    _get_error              CALL    i2c_stop
0143+  E667 CD 04 F0                            CALL    m_print_inline 
0144+  E66A 45 72 72 6F                         .DB     "Error getting time\r\n", 0
0144+  E66E 72 20 67 65 
0144+  E672 74 74 69 6E 
0144+  E676 67 20 74 69 
0144+  E67A 6D 65 0D 0A 
0144+  E67E 00 
0145+  E67F AF                                  XOR     A
0146+  E680 C9                                  RET
0147+  E681             
0148+  E681                                     .MODULE main1118   E681                                 .INCLUDE "ymodem.asm"
0001+  E681             ;
0002+  E681             ; YModem implementation.
0003+  E681             ; File format: The filename MAY indicate the load address in memory for the file. If so, the format is:
0004+  E681             ;       filename_mHHHH.suffix
0005+  E681             ;    or filename_pHH.suffix
0006+  E681             ;
0007+  E681             ; Where:  _mHHHH indicates a preferred destination address of HHHH (in memory) - four digits hexadecimal value (uppercase).
0008+  E681             ;   or    _pHH   indicates the page in memory that the file is intended for (assumes start at offset 0 in page..)
0009+  E681             ;
0010+  E681             ; When _p is used, the file is always written to bank 1 - address 4000h. It is expected that the calling program will
0011+  E681             ; then copy the data to the target page, which can be retrieved from the ym_file_mode return value.
0012+  E681             ; 
0013+  E681             ;
0014+  E681             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0015+  E681             ;
0016+  E681             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0017+  E681             ;
0018+  E681             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0019+  E681             ; of this software and associated documentation files (the "Software"), to deal
0020+  E681             ; in the Software without restriction, including without limitation the rights
0021+  E681             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0022+  E681             ; copies of the Software, and to permit persons to whom the Software is
0023+  E681             ; furnished to do so, subject to the following conditions:
0024+  E681             ; 
0025+  E681             ; The above copyright notice and this permission notice shall be included in all
0026+  E681             ; copies or substantial portions of the Software.
0027+  E681             ; 
0028+  E681             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0029+  E681             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0030+  E681             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0031+  E681             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0032+  E681             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0033+  E681             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0034+  E681             ; SOFTWARE.
0035+  E681             ;
0036+  E681             
0037+  E681                                 .MODULE ymodem
0038+  E681             
0039+  E681             _PAGE_PREFIX        .EQU    'p'
0040+  E681             _DEST_PREFIX        .EQU    'm'
0041+  E681             
0042+  E681             ; Return values
0043+  E681             YMODEM_SUCCESS      .EQU    000h
0044+  E681             YMODEM_TIMEOUT      .EQU    001h
0045+  E681             YMODEM_UNKNOWN      .EQU    002h            ; Unknown packet type (Packet byte in C)
0046+  E681             YMODEM_CANCEL       .EQU    003h            ; Cancelled by sender
0047+  E681             YMODEM_PACKET_ERROR .EQU    004h            ; Packet data error (Error code in C)
0048+  E681             YMODEM_LENGTH_ERROR .EQU    005h            ; Length data in zeroth packet is invalid
0049+  E681             YMODEM_NO_DEST      .EQU    006h            ; No destination provided
0050+  E681             YMODEM_SEND_TIMEOUT .EQU    007h
0051+  E681             YMODEM_MULTI_FILES  .EQU    008h            ; Cannot receive more than one file 
0052+  E681             
0053+  E681             _SOH                .EQU    001h            ; 128 byte data packet header
0054+  E681             _STX                .EQU    002h            ; 1024 byte data packet header
0055+  E681             _EOT                .EQU    004h            ; End transfer
0056+  E681             _ACK                .EQU    006h            ; Respond
0057+  E681             _NAK                .EQU    015h            ; No response
0058+  E681             _CAN                .EQU    018h            ; Transmission aborted
0059+  E681             _C                  .EQU    043h            ; Request packet
0060+  E681             
0061+  E681             _SOH_PACKET_SIZE    .EQU    128
0062+  E681             _STX_PACKET_SIZE    .EQU    1024
0063+  E681             _FRAME_OVERHEAD     .EQU    5               ; Three byte header + two byte CRC (high byte first)
0064+  E681             
0065+  E681             _TIMEOUT_COUNT      .EQU    50000
0066+  E681             
0067+  E681             _ERR_PACKET_COUNT   .EQU    1               ; Wrong packet index
0068+  E681             _ERR_CHECK_HIGH     .EQU    2               ; High byte of CRC failed
0069+  E681             _ERR_CHECK_LOW      .EQU    3               ; Low byte of CRC failed
0070+  E681             _ERR_CANCEL         .EQU    4               ; Got a cancel request without second cancel
0071+  E681             _ERR_ZERO_PACKET    .EQU    5               ; Zeroth packet must be SOH
0072+  E681             
0073+  E681             YM_DEST_FROM_FILE   .EQU    0FEh            ; File destination set from filename
0074+  E681             
0075+  E681             ymodem_data_length  .EQU    17              ; Size of data block before buffer
0076+  E681             
0077+  E681             ym_file_mode        .EQU    -17             ; FFh : Normal transfer,  FEh : Destination set by file, 0-7Fh : Page write 
0078+  E681             ym_file_count       .EQU    -16
0079+  E681             ym_length_low       .EQU    -15             ; Length specified in header packet
0080+  E681             ym_length_mid       .EQU    -14
0081+  E681             ym_length_high      .EQU    -13
0082+  E681             ym_loaded_high      .EQU    -12             ; Tracks high byte of length during load.
0083+  E681             ym_soh_saved_len    .EQU    -11             ; We have to copy part of a final SOH packet from the buffer - track actual length needed
0084+  E681             ym_soh_saved_len_h  .EQU    -10 
0085+  E681             ym_current_page     .EQU    -9              ; FFh if no paging, otherwise page to send data to
0086+  E681             ym_dest_low         .EQU    -8              ; If specified in file header - the destination address of the file
0087+  E681             ym_dest_high        .EQU    -7
0088+  E681             ym_current_packet   .EQU    -6              ; Expected packet number
0089+  E681             ym_packet_type      .EQU    -5              ; Packet type - SOH/STX
0090+  E681             ym_packet_num       .EQU    -4              ; Packet number we're currently receiving
0091+  E681             ym_packet_num_cpl   .EQU    -3              ; Complement..
0092+  E681             ym_crc_low          .EQU    -2              ; CRC Low byte
0093+  E681             ym_crc_high         .EQU    -1              ; CRC High byte
0094+  E681             
0095+  E681             YMODEM_BUFFER       .EQU    _SOH_PACKET_SIZE + ymodem_data_length
0096+  E681             YMODEM_INFO         .EQU    _SOH_PACKET_SIZE
0097+  E681             
0098+  E681             ;
0099+  E681             ; ymodem - Main entry point. Call with:
0100+  E681             ;     HL = Address of YMODEM_BUFFER (=128 + ymodem_data_length) byte buffer for receiving data
0101+  E681             ;     DE = (Optional) address to write data. 0xFFFF to accept destination from filename otherwise
0102+  E681             ;      A = Page to write data. 0xFF to disable paging/accept page from filename otherwise
0103+  E681             ;
0104+  E681             ; If using A to set a Page destination, DE should be an offset within Bank 1 (ie 4000h - 7FFFh)
0105+  E681             ; If the file specifies a page destination, DE is initialised to 4000h - the start of the page
0106+  E681             ;
0107+  E681             ; Returns status code in A:
0108+  E681             ;     YMODEM_SUCCESS : (=0) If the file was successfully received
0109+  E681             ;     YMODEM_xxxx    : (Non zero) If the receiver timed out waiting for a byte
0110+  E681             ;
0111+  E681             ; Note Bank 1 may have been set to a new page destination if one was specified.
0112+  E681             
0113+  E681 01 11 00    ymodem              LD      BC, ymodem_data_length      ; Skip data block at start of buffer
0114+  E684 09                              ADD     HL, BC
0115+  E685 E5                              PUSH    HL
0116+  E686 DD E1                           POP     IX
0117+  E688 DD 77 F7                        LD      (IX+ym_current_page), A
0118+  E68B DD 77 EF                        LD      (IX+ym_file_mode), A           ; Default normal transfer, 0FFh, else page 
0119+  E68E AF                              XOR     A                           
0120+  E68F DD 77 F0                        LD      (IX+ym_file_count), A
0121+  E692 3D                              DEC     A
0122+  E693 DD 73 F8                        LD      (IX+ym_dest_low), E
0123+  E696 DD 72 F9                        LD      (IX+ym_dest_high), D
0124+  E699             
0125+  E699 AF          _ymodem_start       XOR     A                           ; Set initial packet number
0126+  E69A DD 77 FA                        LD      (IX+ym_current_packet), A
0127+  E69D FD 21 FF FF                     LD      IY, 0FFFFh                  ; IY - bytes to load. Default - load all bytes
0128+  E6A1             
0129+  E6A1                                 ; Now we can load.
0130+  E6A1                                 ; DE = destination
0131+  E6A1                                 ; IY = low 16 bits of length
0132+  E6A1                                 ; IX = load buffer
0133+  E6A1             
0134+  E6A1 CD 2E E9    _packet_loop        CALL    _recieve_safe
0135+  E6A4 20 07                           JR      NZ, _packet_byte
0136+  E6A6 3E 43       _send_crc_and_loop  LD      A, _C
0137+  E6A8 CD 59 E9                        CALL    _send_byte
0138+  E6AB 18 F4                           JR      _packet_loop
0139+  E6AD             
0140+  E6AD FE 01       _packet_byte        CP      _SOH
0141+  E6AF C2 BA E6                        JP      NZ, _check_stx
0142+  E6B2             
0143+  E6B2 DD E5                           PUSH    IX                          ; SOH - May be zero'th or last packet
0144+  E6B4 E1                              POP     HL
0145+  E6B5 01 80 00                        LD      BC, _SOH_PACKET_SIZE
0146+  E6B8 18 40                           JR      _receive_packet
0147+  E6BA             
0148+  E6BA FE 02       _check_stx          CP      _STX
0149+  E6BC 20 07                           JR      NZ, _check_eot
0150+  E6BE                                                                     
0151+  E6BE 62                              LD      H, D                        ; STX packets go straight to DE
0152+  E6BF 6B                              LD      L, E
0153+  E6C0 01 00 04                        LD      BC, _STX_PACKET_SIZE    
0154+  E6C3 18 35                           JR      _receive_packet
0155+  E6C5             
0156+  E6C5 FE 04       _check_eot          CP      _EOT
0157+  E6C7 20 0A                           JR      NZ, _check_can
0158+  E6C9                                                                     ; End of transmission
0159+  E6C9 3E 06                           LD      A, _ACK 
0160+  E6CB CD 59 E9                        CALL    _send_byte
0161+  E6CE             
0162+  E6CE DD 34 F0                        INC     (IX+ym_file_count)      
0163+  E6D1 18 C6                           JR      _ymodem_start  
0164+  E6D3             
0165+  E6D3 FE 18       _check_can          CP      _CAN
0166+  E6D5 20 1E                           JR      NZ, _unknown_packet
0167+  E6D7                                                                     ; Single cancel request. Check for another
0168+  E6D7 CD 39 E9                        CALL    _receive_byte
0169+  E6DA FE 18                           CP      _CAN
0170+  E6DC 3E 04                           LD      A, _ERR_CANCEL
0171+  E6DE 20 10                           JR      NZ, _packet_error
0172+  E6E0             
0173+  E6E0 3E 06                           LD      A, _ACK 
0174+  E6E2 CD 59 E9                        CALL    _send_byte
0175+  E6E5 CD 2E E9    _purge              CALL    _recieve_safe               ; Purge remains of any cancel request
0176+  E6E8 20 FB                           JR      NZ, _purge
0177+  E6EA             
0178+  E6EA 3E 03                           LD      A, YMODEM_CANCEL
0179+  E6EC A7                              AND     A
0180+  E6ED C9                              RET
0181+  E6EE             
0182+  E6EE 3E 05       _zero_error         LD      A, _ERR_ZERO_PACKET
0183+  E6F0 4F          _packet_error       LD      C, A                        ; Packet data error - return error code in C
0184+  E6F1 3E 04                           LD      A, YMODEM_PACKET_ERROR
0185+  E6F3 A7                              AND     A
0186+  E6F4 C9                              RET
0187+  E6F5             
0188+  E6F5 4F          _unknown_packet     LD      C, A                        ; Unknown packet type - return header byte in C
0189+  E6F6 3E 02                           LD      A, YMODEM_UNKNOWN
0190+  E6F8 A7                              AND     A
0191+  E6F9 C9                              RET     
0192+  E6FA             
0193+  E6FA             ; Receive data for both SOH and STX packets..
0194+  E6FA             ; At this point HL is destination (either DE or IX-buffer), and BC is a byte count
0195+  E6FA             ;
0196+  E6FA DD 77 FB    _receive_packet     LD      (IX+ym_packet_type), A   
0197+  E6FD             
0198+  E6FD DD 7E F7                        LD      A, (IX+ym_current_page)
0199+  E700 FE FF                           CP      0FFh
0200+  E702 28 02                           JR      Z, _no_page_specified
0201+  E704 D3 71                           OUT     (IO_MEM_1), A
0202+  E706             
0203+  E706 AF          _no_page_specified  XOR     A
0204+  E707 DD 77 F5                        LD      (IX+ym_soh_saved_len), A     ; Reset how many bytes of an SOH packet we actually loaded..
0205+  E70A DD 77 F6                        LD      (IX+ym_soh_saved_len_h), A
0206+  E70D             
0207+  E70D DD BE FA                        CP      (IX+ym_current_packet)         ; If this is the zeroth packet, it must be SOH
0208+  E710 20 07                           JR      NZ, _not_zeroth_packet
0209+  E712 3E 01                           LD      A, _SOH
0210+  E714 DD 96 FB                        SUB     (IX+ym_packet_type)            ; Leave A as zero if this is OK
0211+  E717 20 D5                           JR      NZ, _zero_error
0212+  E719             
0213+  E719 DD 77 FF    _not_zeroth_packet  LD      (IX+ym_crc_high), A
0214+  E71C DD 77 FE                        LD      (IX+ym_crc_low), A
0215+  E71F             
0216+  E71F CD 39 E9                        CALL    _receive_byte   
0217+  E722 DD 77 FC                        LD      (IX+ym_packet_num), A
0218+  E725 CD 39 E9                        CALL    _receive_byte   
0219+  E728 DD 77 FD                        LD      (IX+ym_packet_num_cpl), A
0220+  E72B             
0221+  E72B 7D          _data_loop          LD      A, L                        ; Handle paging if we're loading into paged memory..
0222+  E72C A7                              AND     A
0223+  E72D 20 12                           JR      NZ, _data_receive
0224+  E72F 7C                              LD      A, H
0225+  E730 FE 80                           CP      80h
0226+  E732 20 0D                           JR      NZ, _data_receive
0227+  E734 DD 7E F7                        LD      A, (IX+ym_current_page)
0228+  E737 3C                              INC     A
0229+  E738 28 07                           JR      Z, _data_receive           ; Paging disabled
0230+  E73A             
0231+  E73A DD 77 F7                        LD      (IX+ym_current_page), A        ; Move to next page
0232+  E73D D3 71                           OUT     (IO_MEM_1), A
0233+  E73F 26 40                           LD      H, 40h
0234+  E741                                 
0235+  E741 CD 39 E9    _data_receive       CALL    _receive_byte
0236+  E744             
0237+  E744 77                              LD      (HL), A
0238+  E745             
0239+  E745 CD FB E8                        CALL    _calc_checksum  
0240+  E748             
0241+  E748 C5                              PUSH    BC                          ; Count down the bytes remaining, and once we get to zero, send bytes to _dev_null
0242+  E749 01 FF FF                        LD      BC, -1
0243+  E74C FD 09                           ADD     IY, BC                      ; Carry set if IY not zero
0244+  E74E C1                              POP     BC
0245+  E74F 38 10                           JR      C, _in_range
0246+  E751             
0247+  E751 DD 35 F4                        DEC     (IX+ym_loaded_high)
0248+  E754 F2 61 E7                        JP      P, _in_range
0249+  E757                  
0250+  E757 DD 34 F4                        INC     (IX+ym_loaded_high)      ; Keep resetting counter...
0251+  E75A FD 23                           INC     IY
0252+  E75C 21 2D E9                        LD      HL, _dev_null
0253+  E75F 18 09                           JR      _do_next
0254+  E761             
0255+  E761 DD 34 F5    _in_range           INC     (IX+ym_soh_saved_len)
0256+  E764 20 03                           JR      NZ, _packet_part_ok
0257+  E766 DD 34 F6                        INC     (IX+ym_soh_saved_len_h)
0258+  E769 23          _packet_part_ok     INC     HL
0259+  E76A             
0260+  E76A 0B          _do_next            DEC     BC
0261+  E76B             
0262+  E76B 78                              LD      A, B
0263+  E76C B1                              OR      C
0264+  E76D 20 BC                           JR      NZ, _data_loop
0265+  E76F             
0266+  E76F AF                              XOR     A
0267+  E770 CD FB E8                        CALL    _calc_checksum  
0268+  E773 AF                              XOR     A
0269+  E774 CD FB E8                        CALL    _calc_checksum  
0270+  E777             
0271+  E777 CD 39 E9                        CALL    _receive_byte
0272+  E77A 47                              LD      B, A
0273+  E77B CD 39 E9                        CALL    _receive_byte   
0274+  E77E 4F                              LD      C, A
0275+  E77F             ;
0276+  E77F             ; Now do checks...
0277+  E77F             
0278+  E77F DD 7E FC                        LD      A, (IX+ym_packet_num)
0279+  E782 2F                              CPL
0280+  E783 DD BE FD                        CP      (IX+ym_packet_num_cpl)
0281+  E786 3E 01                           LD      A, _ERR_PACKET_COUNT
0282+  E788 C2 F0 E6                        JP      NZ, _packet_error
0283+  E78B DD 7E FF                        LD      A, (IX+ym_crc_high)
0284+  E78E B8                              CP      B
0285+  E78F 3E 02                           LD      A, _ERR_CHECK_HIGH
0286+  E791 C2 F0 E6                        JP      NZ, _packet_error
0287+  E794 DD 7E FE                        LD      A, (IX+ym_crc_low)
0288+  E797 B9                              CP      C
0289+  E798 3E 03                           LD      A, _ERR_CHECK_LOW
0290+  E79A C2 F0 E6                        JP      NZ, _packet_error
0291+  E79D             
0292+  E79D             ; CRC and packet number check out... 
0293+  E79D DD 7E FC                        LD      A, (IX+ym_packet_num)
0294+  E7A0 DD BE FA                        CP      (IX+ym_current_packet)
0295+  E7A3 20 23                           JR      NZ, _retry_packet               ; We need to restore IY (length) if we wish to survive.. DE is not updated until later, so OK
0296+  E7A5 DD 34 FA                        INC     (IX+ym_current_packet)
0297+  E7A8 A7                              AND     A
0298+  E7A9 28 4A                           JR      Z, _header_packet
0299+  E7AB             
0300+  E7AB DD 7E FB                        LD      A, (IX+ym_packet_type)
0301+  E7AE FE 01                           CP      _SOH
0302+  E7B0 20 0C                           JR      NZ, _not_soh
0303+  E7B2             
0304+  E7B2             ; SOH packets must be copied to DE -> 
0305+  E7B2 DD 4E F5                        LD      C, (IX+ym_soh_saved_len)
0306+  E7B5 06 00                           LD      B, 0
0307+  E7B7 DD E5                           PUSH    IX
0308+  E7B9 E1                              POP     HL
0309+  E7BA ED B0                           LDIR
0310+  E7BC 18 02                           JR      _send_ack
0311+  E7BE             
0312+  E7BE 54          _not_soh            LD      D, H
0313+  E7BF 5D                              LD      E, L
0314+  E7C0 3E 06       _send_ack           LD      A, _ACK 
0315+  E7C2 CD 59 E9    _send_and_loop      CALL    _send_byte
0316+  E7C5 C3 A6 E6                        JP      _send_crc_and_loop      
0317+  E7C8             
0318+  E7C8 AF          _retry_packet       XOR     A                           ; Clear carry
0319+  E7C9 ED 52                           SBC     HL, DE
0320+  E7CB 30 0D                           JR      NC, _retry_page_ok          
0321+  E7CD             
0322+  E7CD DD 7E F7                        LD      A,(IX+ym_current_page)         ; If HL (latest write dest) is less than DE (write dest at start of packet) assume we've changed pages..
0323+  E7D0 FE FF                           CP      0FFH
0324+  E7D2 28 06                           JR      Z, _retry_page_ok           ; We're not paging anyway...
0325+  E7D4 3D                              DEC     A 
0326+  E7D5 DD 77 F7                        LD      (IX+ym_current_page), A
0327+  E7D8 D3 71                           OUT     (IO_MEM_1),A
0328+  E7DA             
0329+  E7DA DD 4E F5    _retry_page_ok      LD      C, (IX+ym_soh_saved_len)     ; Restore IY (length)
0330+  E7DD DD 46 F6                        LD      B, (IX+ym_soh_saved_len_h)
0331+  E7E0 FD E5                           PUSH    IY
0332+  E7E2 E1                              POP     HL
0333+  E7E3 09                              ADD     HL, BC
0334+  E7E4 30 03                           JR      NC, _retry_iy_ok
0335+  E7E6 DD 34 F4                        INC     (IX+ym_loaded_high)
0336+  E7E9 E5          _retry_iy_ok        PUSH    HL
0337+  E7EA FD E1                           POP     IY
0338+  E7EC                                                                     ; TODO: If we've changed the page, that needs to be restored as well
0339+  E7EC             
0340+  E7EC             
0341+  E7EC CD 2E E9    _retry_drain        CALL   _recieve_safe                ; Drain the incoming stream before sending nak
0342+  E7EF 20 FB                           JR      NZ, _retry_drain
0343+  E7F1             
0344+  E7F1 3E 15                           LD      A, _NAK
0345+  E7F3 18 CD                           JR      _send_and_loop
0346+  E7F5             
0347+  E7F5             
0348+  E7F5 DD E5       _header_packet      PUSH    IX
0349+  E7F7 E1                              POP     HL
0350+  E7F8 7E                              LD      A, (HL)                     ; Empty zeroth packet means end of batch send
0351+  E7F9 A7                              AND     A
0352+  E7FA 20 09                           JR      NZ, _check_filecount
0353+  E7FC             
0354+  E7FC 3E 06                           LD      A, _ACK 
0355+  E7FE CD 59 E9                        CALL    _send_byte
0356+  E801 3E 00                           LD      A, YMODEM_SUCCESS   
0357+  E803 A7                              AND     A
0358+  E804 C9                              RET
0359+  E805             
0360+  E805 DD 7E F0    _check_filecount    LD      A, (IX+ym_file_count)
0361+  E808 A7                              AND     A
0362+  E809 28 04                           JR      Z, _next_filechar
0363+  E80B             
0364+  E80B 3E 08                           LD      A, YMODEM_MULTI_FILES
0365+  E80D A7                              AND     A
0366+  E80E C9                              RET
0367+  E80F             
0368+  E80F 7E          _next_filechar      LD      A, (HL)
0369+  E810 23                              INC     HL
0370+  E811 A7          _check_char         AND     A
0371+  E812 28 71                           JR      Z, _read_length
0372+  E814 FE 5F                           CP      '_'                     ; Check for special transfer modes
0373+  E816 20 F7                           JR      NZ, _next_filechar
0374+  E818 7E                              LD      A, (HL)
0375+  E819 4F                              LD      C, A                    ; Remember the prefix char in C
0376+  E81A 23                              INC     HL
0377+  E81B FE 6D                           CP      _DEST_PREFIX
0378+  E81D 20 07                           JR      NZ, _check_flash
0379+  E81F 06 04                           LD      B, 4
0380+  E821 11 00 00                        LD      DE, 0
0381+  E824 18 09                           JR      _parse_dest
0382+  E826             
0383+  E826 FE 70       _check_flash        CP      _PAGE_PREFIX
0384+  E828 20 E7                           JR      NZ, _check_char
0385+  E82A 06 02                           LD      B, 2
0386+  E82C 11 00 00                        LD      DE, 0
0387+  E82F             
0388+  E82F 7E          _parse_dest         LD      A, (HL)
0389+  E830 23                              INC     HL
0390+  E831 D6 30                           SUB     '0'
0391+  E833 38 48                           JR      C, _invalid_dest
0392+  E835 FE 0A                           CP      10
0393+  E837 38 08                           JR      C, _digit_checked
0394+  E839 D6 07                           SUB     7
0395+  E83B 38 40                           JR      C, _invalid_dest
0396+  E83D FE 10                           CP      16
0397+  E83F 30 3C                           JR      NC, _invalid_dest
0398+  E841             
0399+  E841 E5          _digit_checked      PUSH    HL                          ; Shift existing dest left 4 bits and merge new hex digit
0400+  E842 62                              LD      H, D
0401+  E843 6B                              LD      L, E
0402+  E844 29                              ADD     HL, HL
0403+  E845 29                              ADD     HL, HL
0404+  E846 29                              ADD     HL, HL
0405+  E847 29                              ADD     HL, HL
0406+  E848 B5                              OR      L
0407+  E849 54                              LD      D, H
0408+  E84A 5F                              LD      E, A
0409+  E84B E1                              POP     HL
0410+  E84C 10 E1                           DJNZ    _parse_dest
0411+  E84E             
0412+  E84E 79                              LD      A, C                        ; Which char did we start with?
0413+  E84F FE 70                           CP      _PAGE_PREFIX
0414+  E851 20 12                           JR      NZ, _memory_dest
0415+  E853             
0416+  E853 DD 7E F7                        LD      A, (IX+ym_current_page)        ; Page prefix. Use original value if set when ymodem was called
0417+  E856 FE FF                           CP      0FFh
0418+  E858 20 B5                           JR      NZ, _next_filechar
0419+  E85A             
0420+  E85A DD 73 EF                        LD      (IX+ym_file_mode), E           ; Otherwise use the file specified value and load from 4000h
0421+  E85D DD 73 F7                        LD      (IX+ym_current_page), E
0422+  E860 11 00 40                        LD      DE,04000h    
0423+  E863 18 10                           JR      _store_dest
0424+  E865             
0425+  E865 3E FF       _memory_dest        LD      A, 0FFh                     ; Only set the dest from the filename if 
0426+  E867 DD BE F8                        CP      (IX+ym_dest_low)               ; the routine was called with a destination of 0FFFFh
0427+  E86A 20 A3                           JR      NZ, _next_filechar
0428+  E86C DD BE F9                        CP      (IX+ym_dest_high)
0429+  E86F 20 9E                           JR      NZ, _next_filechar
0430+  E871             
0431+  E871 DD 36 EF FE                     LD      (IX+ym_file_mode), YM_DEST_FROM_FILE
0432+  E875             
0433+  E875 DD 73 F8    _store_dest         LD      (IX+ym_dest_low), E
0434+  E878 DD 72 F9                        LD      (IX+ym_dest_high), D
0435+  E87B             
0436+  E87B 18 92                           JR      _next_filechar
0437+  E87D             
0438+  E87D DD 5E F8    _invalid_dest       LD      E, (IX+ym_dest_low)            ; We silently skip invalid destination values
0439+  E880 DD 56 F9                        LD      D, (IX+ym_dest_high)
0440+  E883 18 8A                           JR      _next_filechar
0441+  E885             
0442+  E885 3E FF       _read_length        LD      A, 0FFh                     ; At this point we should have a valid destination
0443+  E887 DD BE F8                        CP      (IX+ym_dest_low)               
0444+  E88A 20 09                           JR      NZ, _dest_ok
0445+  E88C DD BE F9                        CP      (IX+ym_dest_high)
0446+  E88F 20 04                           JR      NZ, _dest_ok
0447+  E891             
0448+  E891 3E 06                           LD      A, YMODEM_NO_DEST
0449+  E893 A7                              AND     A
0450+  E894 C9                              RET
0451+  E895             
0452+  E895 3E FF       _dest_ok            LD      A, 0FFh
0453+  E897 DD 77 F1                        LD      (IX+ym_length_low), A       ; Reset the length counter///
0454+  E89A DD 77 F2                        LD      (IX+ym_length_mid), A
0455+  E89D DD 77 F3                        LD      (IX+ym_length_high), A         
0456+  E8A0 DD 77 F4                        LD      (IX+ym_loaded_high), A
0457+  E8A3 FD 21 FF FF                     LD      IY, 0FFFFh 
0458+  E8A7 44                              LD      B, H
0459+  E8A8 4D                              LD      C, L               
0460+  E8A9 21 00 00                        LD      HL, 0
0461+  E8AC 0A                              LD      A, (BC)                     ; Length is optional
0462+  E8AD A7                              AND     A
0463+  E8AE CA C0 E7                        JP      Z, _send_ack
0464+  E8B1             
0465+  E8B1 0A          _parse_length       LD      A, (BC)
0466+  E8B2 03                              INC     BC
0467+  E8B3 A7                              AND     A
0468+  E8B4 28 2F                           JR      Z, _length_end
0469+  E8B6 FE 20                           CP      ' '
0470+  E8B8 28 2B                           JR      Z, _length_end
0471+  E8BA D6 30                           SUB     '0'
0472+  E8BC 38 39                           JR      C, _invalid_length
0473+  E8BE FE 0A                           CP      10
0474+  E8C0 30 35                           JR      NC, _invalid_length
0475+  E8C2             
0476+  E8C2 C5                              PUSH    BC
0477+  E8C3 D5                              PUSH    DE
0478+  E8C4 F5                              PUSH    AF
0479+  E8C5             
0480+  E8C5 EB                              EX      DE, HL              ; HL into DE 
0481+  E8C6 3E 0A                           LD      A, 10
0482+  E8C8             
0483+  E8C8                                 ; DE x A  -> AHL  (from http://z80-heaven.wikidot.com/advanced-math#toc12)
0484+  E8C8                                 ; preserves DE
0485+  E8C8 01 00 08                        LD      BC, 0800h
0486+  E8CB 61                              LD      H, C
0487+  E8CC 69                              LD      L, C
0488+  E8CD 29          _pl_loop            ADD     HL, HL
0489+  E8CE 17                              RLA
0490+  E8CF 30 02                           JR      NC, _pl_skip
0491+  E8D1 19                              ADD     HL, DE
0492+  E8D2 89                              ADC     A, C
0493+  E8D3 10 F8       _pl_skip            DJNZ    _pl_loop
0494+  E8D5             
0495+  E8D5 DD 77 F3                        LD      (IX+ym_length_high), A     ; Note we only handle overflow for one digit.. max value 655,359?
0496+  E8D8 F1                              POP     AF
0497+  E8D9 5F                              LD      E, A
0498+  E8DA 51                              LD      D, C
0499+  E8DB 19                              ADD     HL, DE
0500+  E8DC 30 03                           JR      NC, _pl_length_ok
0501+  E8DE DD 34 F3                        INC     (IX+ym_length_high)
0502+  E8E1             
0503+  E8E1 D1          _pl_length_ok       POP     DE
0504+  E8E2 C1                              POP     BC
0505+  E8E3 18 CC                           JR      _parse_length
0506+  E8E5             
0507+  E8E5 E5          _length_end         PUSH    HL
0508+  E8E6 FD E1                           POP     IY
0509+  E8E8 DD 75 F1                        LD      (IX+ym_length_low), L
0510+  E8EB DD 74 F2                        LD      (IX+ym_length_mid), H
0511+  E8EE DD 7E F3                        LD      A, (IX+ym_length_high)
0512+  E8F1 DD 77 F4                        LD      (IX+ym_loaded_high), A
0513+  E8F4 C3 C0 E7                        JP      _send_ack
0514+  E8F7             
0515+  E8F7 3E 05       _invalid_length     LD      A, YMODEM_LENGTH_ERROR      ; Hard fail on invalid length data
0516+  E8F9 A7                              AND     A
0517+  E8FA C9                              RET
0518+  E8FB             
0519+  E8FB             ;-----
0520+  E8FB             ; Calculate the checksum from A
0521+  E8FB E5          _calc_checksum      PUSH    HL
0522+  E8FC C5                              PUSH    BC
0523+  E8FD             
0524+  E8FD 06 01                           LD      B, 1
0525+  E8FF 4F                              LD      C, A
0526+  E900 DD 66 FF                        LD      H, (IX+ym_crc_high)
0527+  E903 DD 6E FE                        LD      L, (IX+ym_crc_low)
0528+  E906             
0529+  E906 29          _crc_loop           ADD     HL, HL
0530+  E907 F5                              PUSH    AF
0531+  E908             
0532+  E908 CB 21                           SLA     C
0533+  E90A CB 10                           RL      B
0534+  E90C 30 02                           JR      NC, _no_in_overflow
0535+  E90E CB C1                           SET     0, C
0536+  E910             _no_in_overflow
0537+  E910 CB 40                           BIT     0, B
0538+  E912 28 01                           JR      Z, _no_in_bit
0539+  E914 23                              INC     HL
0540+  E915             _no_in_bit                    
0541+  E915 F1                              POP     AF
0542+  E916 30 08                           JR      NC, _no_crc_overflow
0543+  E918 3E 21                           LD      A, 021h
0544+  E91A AD                              XOR     L 
0545+  E91B 6F                              LD      L,A
0546+  E91C 3E 10                           LD      A, 010h
0547+  E91E AC                              XOR     H 
0548+  E91F 67                              LD      H, A
0549+  E920             _no_crc_overflow
0550+  E920 CB 41                           BIT     0, C
0551+  E922 28 E2                           JR      Z, _crc_loop    
0552+  E924             
0553+  E924 DD 74 FF                        LD      (IX+ym_crc_high), H
0554+  E927 DD 75 FE                        LD      (IX+ym_crc_low), L
0555+  E92A C1                              POP     BC
0556+  E92B E1                              POP     HL
0557+  E92C C9                              RET
0558+  E92D             
0559+  E92D 00          _dev_null           .DB     0
0560+  E92E             
0561+  E92E             ;
0562+  E92E             ; Recieve a byte with timeout, without exiting ymodem
0563+  E92E             ; If success, A contains byte, non-zero flag set
0564+  E92E             ; Otherwise A is zero, Zero flag is set
0565+  E92E             ;
0566+  E92E 21 37 E9    _recieve_safe       LD      HL, _back_safe
0567+  E931 E5                              PUSH    HL
0568+  E932 CD 39 E9                        CALL    _receive_byte
0569+  E935 E1                              POP     HL
0570+  E936 C9                              RET
0571+  E937 AF          _back_safe          XOR     A
0572+  E938 C9                              RET     
0573+  E939             
0574+  E939             ;
0575+  E939             ; Receive a byte with timeout
0576+  E939             ; If success: A contains byte, non-zero flag set
0577+  E939             ; Otherwise : Pops the return address off the stack and returns to the original caller with A containing YMODEM_TIMEOUT
0578+  E939             ;
0579+  E939 C5          _receive_byte       PUSH    BC
0580+  E93A 01 50 C3                        LD      BC, _TIMEOUT_COUNT
0581+  E93D DB 25       _receive_loop       IN      A, (UART_LINE_STATUS)
0582+  E93F CB 47                           BIT     0, A
0583+  E941 20 12                           JR      NZ, _receive_ready
0584+  E943 78                              LD      A, B
0585+  E944 06 0A                           LD      B, 10
0586+  E946 A7          _rx_delay           AND     A
0587+  E947 10 FD                           DJNZ    _rx_delay
0588+  E949 47                              LD      B, A
0589+  E94A 0B                              DEC     BC
0590+  E94B 78                              LD      A, B
0591+  E94C B1                              OR      C
0592+  E94D 20 EE                           JR      NZ, _receive_loop
0593+  E94F C1                              POP     BC
0594+  E950 C1                              POP     BC
0595+  E951 3E 01                           LD      A, YMODEM_TIMEOUT
0596+  E953 A7                              AND     A
0597+  E954 C9                              RET
0598+  E955             
0599+  E955 DB 20       _receive_ready      IN      A, (UART_TX_RX)
0600+  E957 C1                              POP     BC
0601+  E958 C9                              RET
0602+  E959             
0603+  E959             ;
0604+  E959             ; Send a byte with timeout
0605+  E959             ; If success: returns normally, no registers affected
0606+  E959             ; Otherwise : Pops the return address off the stack and returns to the original caller with A containing YMODEM_SEND_TIMEOUT
0607+  E959             ;
0608+  E959 C5          _send_byte          PUSH    BC
0609+  E95A F5                              PUSH    AF
0610+  E95B 01 50 C3                        LD      BC, _TIMEOUT_COUNT
0611+  E95E DB 25       _send_loop          IN      A, (UART_LINE_STATUS)
0612+  E960 CB 6F                           BIT     5, A
0613+  E962 C2 72 E9                        JP      NZ, _send_ready             ; Bit 5 is set when the UART is ready
0614+  E965 0B                              DEC     BC
0615+  E966 78                              LD      A, B
0616+  E967 B1                              OR      C
0617+  E968 C2 5E E9                        JP      NZ, _send_loop
0618+  E96B             
0619+  E96B F1                              POP     AF
0620+  E96C C1                              POP     BC
0621+  E96D C1                              POP     BC
0622+  E96E             
0623+  E96E 3E 07                           LD      A, YMODEM_SEND_TIMEOUT
0624+  E970 A7                              AND     A
0625+  E971 C9                              RET
0626+  E972             
0627+  E972 F1          _send_ready         POP     AF
0628+  E973 C1                              POP     BC
0629+  E974 D3 20                           OUT     (UART_TX_RX), A
0630+  E976 C9                              RET
0631+  E977             
0632+  E977                                 .MODULE main1119   E977             
1120   E977~            .IF $ >= BIOS_START
1121   E977~                .ECHO "End of Monitor is too high ("
1122   E977~                .ECHO $
1123   E977~                .ECHO " > "
1124   E977~                .ECHO BIOS_START
1125   E977~                .ECHO ") \n\n"
1126   E977~                .STOP
1127   E977             .ENDIF
1128   E977             
1129   E977             .ECHO "Spare after monitor "
1130   E977             .ECHO BIOS_START-$
1131   E977             .ECHO "\n\n"
1132   E977             
1133   E977 FF FF FF FF                     .FILL  BIOS_START-$
1133   E97B FF FF FF FF 
1133   E97F FF FF FF FF 
1133   E983 FF FF FF FF 
1133   E987 FF FF FF FF 
1133   E98B FF FF FF FF 
1133   E98F FF FF FF FF 
1133   E993 FF FF FF FF 
1133   E997 FF FF FF FF 
1133   E99B FF FF FF FF 
1133   E99F FF FF FF FF 
1133   E9A3 FF FF FF FF 
1133   E9A7 FF FF FF FF 
1133   E9AB FF FF FF FF 
1133   E9AF FF FF FF FF 
1133   E9B3 FF FF FF FF 
1133   E9B7 FF FF FF FF 
1133   E9BB FF FF FF FF 
1133   E9BF FF FF FF FF 
1133   E9C3 FF FF FF FF 
1133   E9C7 FF FF FF FF 
1133   E9CB FF FF FF FF 
1133   E9CF FF FF FF FF 
1133   E9D3 FF FF FF FF 
1133   E9D7 FF FF FF FF 
1133   E9DB FF FF FF FF 
1133   E9DF FF FF FF FF 
1133   E9E3 FF FF FF FF 
1133   E9E7 FF FF FF FF 
1133   E9EB FF FF FF FF 
1133   E9EF FF FF FF FF 
1133   E9F3 FF FF FF FF 
1133   E9F7 FF FF FF FF 
1133   E9FB FF FF FF FF 
1133   E9FF FF 
1134   EA00             
1135   EA00                                 .INCLUDE "bios.asm"
0001+  EA00             ;
0002+  EA00             ; Simple-ish CP/M compatible BIOS
0003+  EA00             ;
0004+  EA00             ; References - http://www.gaby.de/cpm/manuals/archive/cpm22htm/axb.htm - CPM Manual 'Simple skeletal BIOS'
0005+  EA00             ;
0006+  EA00             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0007+  EA00             ;
0008+  EA00             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0009+  EA00             ;
0010+  EA00             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0011+  EA00             ; of this software and associated documentation files (the "Software"), to deal
0012+  EA00             ; in the Software without restriction, including without limitation the rights
0013+  EA00             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0014+  EA00             ; copies of the Software, and to permit persons to whom the Software is
0015+  EA00             ; furnished to do so, subject to the following conditions:
0016+  EA00             ; 
0017+  EA00             ; The above copyright notice and this permission notice shall be included in all
0018+  EA00             ; copies or substantial portions of the Software.
0019+  EA00             ; 
0020+  EA00             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0021+  EA00             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0022+  EA00             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0023+  EA00             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0024+  EA00             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0025+  EA00             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0026+  EA00             ; SOFTWARE.
0027+  EA00             ;
0028+  EA00                                 .MODULE  main
0029+  EA00             
0030+  EA00             BIOS_START          .EQU    0EA00h   ; If this is changed, CP/M must be rebuilt and the disk image updated
0031+  EA00             BIOS_TOP            .EQU    0FDFDh
0032+  EA00             
0033+  EA00             CCP                 .EQU    BIOS_START - 01600h
0034+  EA00             BDOS                .EQU    CCP + 0806h
0035+  EA00             
0036+  EA00             CCP_SECTOR_COUNT    .EQU    (BIOS_START-CCP)/128
0037+  EA00             
0038+  EA00~            .IF (CCP_SECTOR_COUNT * 128) < (BIOS_START-CCP)
0039+  EA00~                .ECHO "CCP isn't an exact multiple of 128 byte sectors\n"
0040+  EA00~                .ECHO "  Got "
0041+  EA00~                .ECHO (BIOS_START-CCP)
0042+  EA00~                .ECHO "\n"
0043+  EA00~                .STOP
0044+  EA00             .ENDIF
0045+  EA00             
0046+  EA00             iobyte              .EQU    03h     ; Location of Intel standard I/O definition byte
0047+  EA00             usrdrv              .EQU    04h     ; Location of Current user number and drive
0048+  EA00             tpabuf              .EQU    0080h   ; Default I/O buffer and command line storage
0049+  EA00             
0050+  EA00             IO_BAT              .EQU    02h     ; CONsole IO defined by RDR for input, LST for output
0051+  EA00             
0052+  EA00             bios_start          .ORG    BIOS_START
0053+  EA00             
0054+  EA00 C3 F1 EA                        JP      bios_boot     ;  0 Initialize
0055+  EA03 C3 08 EB    wboote              JP      bios_wboot    ;  1 Warm boot
0056+  EA06 C3 71 EB                        JP      bios_conist   ;  2 Console status - Return A = 0FFH if character ready, 00H if not
0057+  EA09 C3 9A EB                        JP      bios_conin    ;  3 Console input  - Wait for input, returning character in A
0058+  EA0C C3 00 EC                        JP      bios_conout   ;  4 Console OUTput - Write character in C to console
0059+  EA0F C3 2A EF                        JP      bios_list     ;  5 List OUTput
0060+  EA12 C3 2C EF                        JP      bios_punch    ;  6 punch OUTput
0061+  EA15 C3 2E EF                        JP      bios_reader   ;  7 Reader input
0062+  EA18 C3 48 EF                        JP      bios_home     ;  8 Home disk
0063+  EA1B C3 2F EF                        JP      bios_seldsk   ;  9 Select disk
0064+  EA1E C3 4A EF                        JP      bios_settrk   ; 10 Select track
0065+  EA21 C3 4F EF                        JP      bios_setsec   ; 11 Select sector
0066+  EA24 C3 54 EF                        JP      bios_setdma   ; 12 Set DMA ADDress
0067+  EA27 C3 59 EF                        JP      bios_read     ; 13 Read 128 bytes
0068+  EA2A C3 92 EF                        JP      bios_write    ; 14 Write 128 bytes
0069+  EA2D C3 FF EF                        JP      bios_listst   ; 15 List status
0070+  EA30 C3 01 F0                        JP      bios_sectrn   ; 16 Sector translate
0071+  EA33             
0072+  EA33             MEMDISK_SECTORS     .EQU    26
0073+  EA33             MEMDISK_TRACKS      .EQU    79
0074+  EA33             
0075+  EA33             BIOS_BOOT_TRACKS    .EQU    2
0076+  EA33             BIOS_SECTOR_ADDRESS .EQU    tpabuf
0077+  EA33             
0078+  EA33             DRIVE_A_PAGE        .EQU    04h     ; Page 4 of ROM - offset 010000h
0079+  EA33             DRIVE_B_PAGE        .EQU    25h     ; Page 5 of RAM
0080+  EA33             
0081+  EA33             CONSOLE_PAGE        .EQU    24h     ; Page 4 of RAM - Console emulation for non-VideoBeast systems
0082+  EA33             
0083+  EA33             ; Disk Parameter Headers -------------------------------------------------------
0084+  EA33             ; These are 256K discs, equivalent to this disc format (for cpmtools)
0085+  EA33             ; 
0086+  EA33             ; References : https://www.idealine.info/sharpmz/dpb.htm - Explanation of values
0087+  EA33             ;              https://jeelabs.org/article/1715b/        - Bootstrapping CP/M
0088+  EA33             ;
0089+  EA33             ; diskdef memotech-type50
0090+  EA33             ;  seclen 128
0091+  EA33             ;  tracks 79
0092+  EA33             ;  sectrk 26
0093+  EA33             ;  blocksize 1024
0094+  EA33             ;  maxdir 64
0095+  EA33             ;  skew 1
0096+  EA33             ;  boottrk 2
0097+  EA33             ;  os 2.2
0098+  EA33             ; end
0099+  EA33             ;
0100+  EA33             MAX_DRIVES          .EQU    2
0101+  EA33             
0102+  EA33 00 00 00 00 dpbase              .DW     0,0,0,0,dirbuf,dpb0,0,sys_alv0      ; Disk 0 is Flash
0102+  EA37 00 00 00 00 
0102+  EA3B 71 EA 53 EA 
0102+  EA3F 00 00 45 FF 
0103+  EA43 00 00 00 00                     .DW     0,0,0,0,dirbuf,dpb1,0,sys_alv1      ; Disk 1 is RAM
0103+  EA47 00 00 00 00 
0103+  EA4B 71 EA 62 EA 
0103+  EA4F 00 00 65 FF 
0104+  EA53             
0105+  EA53 1A 00       dpb0                .DW     MEMDISK_SECTORS     ; SPT - sectors per track
0106+  EA55 03                              .DB     3                   ; BSH - block shift factor  BSH+BLM together mean 1024 byte blocksize
0107+  EA56 07                              .DB     7                   ; BLM - block mask
0108+  EA57 00                              .DB     0                   ; EXM - Extent mask
0109+  EA58 F7 00                           .DW     247                 ; DSM - Storage size (blocks - 1)
0110+  EA5A 3F 00                           .DW     63                  ; DRM - Number of directory entries - 1
0111+  EA5C C0                              .DB     192                 ; AL0 - 1 bit set per directory block
0112+  EA5D 00                              .DB     0                   ; AL1 - ... 8 more bits
0113+  EA5E 00 00                           .DW     0                   ; CKS - DIR check vector size (DRM+1)/4 (0=fixed disk)
0114+  EA60 02 00                           .DW     BIOS_BOOT_TRACKS    ; OFF - Reserved tracks
0115+  EA62             
0116+  EA62 1A 00       dpb1                .DW     MEMDISK_SECTORS     ; SPT - sectors per track
0117+  EA64 03                              .DB     3                   ; BSH - block shift factor  BSH+BLM together mean 1024 byte blocksize
0118+  EA65 07                              .DB     7                   ; BLM - block mask
0119+  EA66 00                              .DB     0                   ; EXM - Extent mask
0120+  EA67 F7 00                           .DW     247                 ; DSM - Storage size (blocks - 1)
0121+  EA69 3F 00                           .DW     63                  ; DRM - Number of directory entries - 1
0122+  EA6B C0                              .DB     192                 ; AL0 - 1 bit set per directory block
0123+  EA6C 00                              .DB     0                   ; AL1 - ... 8 more bits
0124+  EA6D 00 00                           .DW     0                   ; CKS - DIR check vector size (DRM+1)/4 (0=fixed disk)
0125+  EA6F 02 00                           .DW     BIOS_BOOT_TRACKS    ; OFF - Reserved tracks
0126+  EA71             
0127+  EA71 00 00 00 00 dirbuf              .FILL   128, 0 ; disk directory scratch area
0127+  EA75 00 00 00 00 
0127+  EA79 00 00 00 00 
0127+  EA7D 00 00 00 00 
0127+  EA81 00 00 00 00 
0127+  EA85 00 00 00 00 
0127+  EA89 00 00 00 00 
0127+  EA8D 00 00 00 00 
0127+  EA91 00 00 00 00 
0127+  EA95 00 00 00 00 
0127+  EA99 00 00 00 00 
0127+  EA9D 00 00 00 00 
0127+  EAA1 00 00 00 00 
0127+  EAA5 00 00 00 00 
0127+  EAA9 00 00 00 00 
0127+  EAAD 00 00 00 00 
0127+  EAB1 00 00 00 00 
0127+  EAB5 00 00 00 00 
0127+  EAB9 00 00 00 00 
0127+  EABD 00 00 00 00 
0127+  EAC1 00 00 00 00 
0127+  EAC5 00 00 00 00 
0127+  EAC9 00 00 00 00 
0127+  EACD 00 00 00 00 
0127+  EAD1 00 00 00 00 
0127+  EAD5 00 00 00 00 
0127+  EAD9 00 00 00 00 
0127+  EADD 00 00 00 00 
0127+  EAE1 00 00 00 00 
0127+  EAE5 00 00 00 00 
0127+  EAE9 00 00 00 00 
0127+  EAED 00 00 00 00 
0128+  EAF1             
0129+  EAF1             ; BIOS Entry points ---------------------------------------------------------------
0130+  EAF1             
0131+  EAF1             bios_boot     ;  0 Initialize - This is called on first boot when CCP and BIOS have all been read into memory. Initialise hardware and start CCP
0132+  EAF1 F3                              DI
0133+  EAF2 31 00 00                        LD      SP,000h
0134+  EAF5 21 00 EA                        LD      HL,BIOS_START        ; Why are we doing this?
0135+  EAF8 22 FE FF                        LD      (0FFFEh),HL
0136+  EAFB CD 1C F0                        CALL    configure_hardware
0137+  EAFE AF                              XOR     A
0138+  EAFF 32 04 00                        LD      (usrdrv),A
0139+  EB02 3C                              INC     A
0140+  EB03 32 03 00                        LD      (iobyte),A           ; Input on keyboard, output on display
0141+  EB06 18 07                           JR      start_cpm
0142+  EB08             
0143+  EB08             ;------------------------------------------------------                    
0144+  EB08             bios_wboot    ;  1 Warm boot - Hardware is intialised, but CCP should be reloaded before being run
0145+  EB08 F3                              DI
0146+  EB09 31 00 00                        LD      SP,000h
0147+  EB0C                                 ;CALL    setup_screen
0148+  EB0C CD 31 EB                        CALL    load_ccp
0149+  EB0F             
0150+  EB0F FB          start_cpm           EI                           ; Make sure interrupts are enabled
0151+  EB10 21 80 00                        LD      HL,tpabuf            ; Address of BIOS DMA buffer
0152+  EB13 22 40 FF                        LD      (sys_dmaaddr),hl
0153+  EB16 3E C3                           LD      A, 0C3h              ; Opcode for 'JP'
0154+  EB18 32 00 00                        LD      (00h),A              ; Load at start of RAM
0155+  EB1B 21 03 EA                        LD      HL,wboote            ; Address of jump for a warm boot
0156+  EB1E 22 01 00                        LD      (01h),HL
0157+  EB21 32 05 00                        LD      (05h),a              ; Opcode for 'JP'
0158+  EB24 21 06 DC                        LD      HL,BDOS              ; Address of jump for the BDOS
0159+  EB27 22 06 00                        LD      (06h),HL
0160+  EB2A 3A 04 00                        LD      A,(usrdrv)           ; Save new drive number (0)  ; TODO: Ugh? Where is this set, what does it mean???
0161+  EB2D 4F                              LD      C, A                 ; Pass drive number in C
0162+  EB2E C3 00 D4                        JP      CCP                  ; Start CP/M by jumping to the CCP
0163+  EB31             
0164+  EB31                                 ; Load CCP - Note we're doing this through BIOS calls, so if we move the OS to a different
0165+  EB31                                 ;       drive, the code should still function...
0166+  EB31 0E 00       load_ccp            LD      C, 0
0167+  EB33 CD 2F EF                        CALL    bios_seldsk
0168+  EB36 CD 48 EF                        CALL    bios_home            ; Go to track 0
0169+  EB39             
0170+  EB39 06 2C                           LD      B, CCP_SECTOR_COUNT
0171+  EB3B 0E 00                           LD      C, 0                 ; Track number
0172+  EB3D 16 00                           LD      D, 0                 ; Sector to read - start with sector 0 (TODO: Check sectors are 0 based)
0173+  EB3F 21 00 D4                        LD      HL, CCP
0174+  EB42 C5          _read_ccp           PUSH    BC
0175+  EB43 D5                              PUSH    DE
0176+  EB44 E5                              PUSH    HL
0177+  EB45 4A                              LD      C, D                 ; Set the sector to read
0178+  EB46 CD 4F EF                        CALL    bios_setsec
0179+  EB49 C1                              POP     BC
0180+  EB4A C5                              PUSH    BC
0181+  EB4B CD 54 EF                        CALL    bios_setdma
0182+  EB4E CD 59 EF                        CALL    bios_read
0183+  EB51 A7                              AND     A                    ; Reboot if error 
0184+  EB52 20 B4                           JR      NZ, bios_wboot
0185+  EB54             
0186+  EB54 E1                              POP     HL                   ; Calculate next address to read
0187+  EB55 11 80 00                        LD      DE, 128
0188+  EB58 19                              ADD     HL, DE
0189+  EB59 D1                              POP     DE                   ; Count down the sectors
0190+  EB5A C1                              POP     BC
0191+  EB5B 05                              DEC     B
0192+  EB5C C8                              RET     Z                    ; And return if we've read 'em all
0193+  EB5D             
0194+  EB5D 14                              INC     D                    ; Otherwise, increment sector   
0195+  EB5E 7A                              LD      A, D
0196+  EB5F FE 1B                           CP      27
0197+  EB61 38 DF                           JR      C, _read_ccp
0198+  EB63             
0199+  EB63 16 01                           LD      D, 1                 ; Or, set sector back to 1 and increment track 
0200+  EB65 0C                              INC     C
0201+  EB66             
0202+  EB66 C5                              PUSH    BC
0203+  EB67 D5                              PUSH    DE
0204+  EB68 E5                              PUSH    HL
0205+  EB69 CD 4A EF                        CALL    bios_settrk
0206+  EB6C E1                              POP     HL
0207+  EB6D D1                              POP     DE
0208+  EB6E C1                              POP     BC
0209+  EB6F 18 D1                           JR      _read_ccp
0210+  EB71             
0211+  EB71             
0212+  EB71                                 
0213+  EB71             ;------------------------------------------------------  
0214+  EB71             bios_conist   ; CONSOLE STATUS, - Return A = 0FFH if character ready, 00H if not
0215+  EB71 3A 03 00                        LD      A, (iobyte)                ; Check input on CON
0216+  EB74 E6 03                           AND     03h
0217+  EB76 28 12                           JR      Z, _coninst_tty
0218+  EB78 FE 02                           CP      IO_BAT
0219+  EB7A 28 15                           JR      Z, _coninst_rdr
0220+  EB7C             
0221+  EB7C 3A 36 FF    _coninst_kbd        LD      A, (console_identify)
0222+  EB7F A7                              AND     A
0223+  EB80 20 05                           JR      NZ, _coninst_has_char
0224+  EB82             
0225+  EB82 3A 28 FF                        LD      A, (input_size)
0226+  EB85 A7                              AND     A
0227+  EB86 C8                              RET     Z
0228+  EB87 3E FF       _coninst_has_char   LD      A, 0FFh
0229+  EB89 C9                              RET
0230+  EB8A              
0231+  EB8A AF          _coninst_tty        XOR     A
0232+  EB8B CD 52 F5                        CALL    uart_ready
0233+  EB8E D0                              RET     NC
0234+  EB8F 3D                              DEC     A
0235+  EB90 C9                              RET     
0236+  EB91 3A 03 00    _coninst_rdr        LD      A, (iobyte)                 ; Input is determined by RDR
0237+  EB94 E6 0C                           AND     0Ch
0238+  EB96 28 F2                           JR      Z, _coninst_tty
0239+  EB98 18 E2                           JR      _coninst_kbd
0240+  EB9A             
0241+  EB9A             ;------------------------------------------------------  
0242+  EB9A             bios_conin    ;  3 Console input - Wait for input, returning character in A
0243+  EB9A 3A 03 00                        LD      A, (iobyte)
0244+  EB9D E6 03                           AND     03h
0245+  EB9F 28 17                           JR      Z, _conin_tty
0246+  EBA1 FE 02                           CP      02h
0247+  EBA3 28 19                           JR      Z, _conin_rdr
0248+  EBA5                                 
0249+  EBA5 3A 36 FF    _conin_kbd          LD      A, (console_identify)           ; If the terminal has been sent an identity request escape sequence, return the response
0250+  EBA8 3D                              DEC     A
0251+  EBA9 FA C7 EB                        JP      M, _conin_read_char
0252+  EBAC 32 36 FF                        LD      (console_identify), A
0253+  EBAF 21 FD EB                        LD      HL, _indentity_sequence
0254+  EBB2 4F                              LD      C, A
0255+  EBB3 06 00                           LD      B, 0
0256+  EBB5 09                              ADD     HL, BC
0257+  EBB6 7E                              LD      A, (HL) 
0258+  EBB7 C9                              RET        
0259+  EBB8             
0260+  EBB8 CD 61 F5    _conin_tty          CALL    uart_receive
0261+  EBBB D8                              RET     C
0262+  EBBC 18 FA                           JR      _conin_tty
0263+  EBBE                  
0264+  EBBE 3A 03 00    _conin_rdr          LD      A, (iobyte)
0265+  EBC1 E6 0C                           AND     0ch
0266+  EBC3 28 F3                           JR      Z, _conin_tty
0267+  EBC5 18 DE                           JR      _conin_kbd
0268+  EBC7             
0269+  EBC7 3A 28 FF    _conin_read_char    LD      A, (input_size)                 ; Don't blink cursor if there is a character already waiting..
0270+  EBCA A7                              AND     A
0271+  EBCB 28 03                           JR      Z, _conin_wait
0272+  EBCD C3 25 F4                        JP      get_key
0273+  EBD0             
0274+  EBD0 3A 32 FF    _conin_wait         LD      A, (console_flags)              ; Turn the cursor on..
0275+  EBD3 F6 01                           OR      CFLAGS_SHOW_CURSOR
0276+  EBD5 32 32 FF                        LD      (console_flags), A
0277+  EBD8 F3                              DI
0278+  EBD9 ED 5B 2D FF                     LD      DE, (cursor_row)
0279+  EBDD 7A                              LD      A, D                            ; Force cursor update...
0280+  EBDE 3D                              DEC     A
0281+  EBDF 32 2E FF                        LD      (cursor_col),A
0282+  EBE2 CD 20 ED                        CALL    _conout_csr_update
0283+  EBE5 FB                              EI
0284+  EBE6 CD 25 F4                        CALL    get_key
0285+  EBE9 47                              LD      B, A
0286+  EBEA 3A 32 FF                        LD      A, (console_flags)
0287+  EBED E6 FE                           AND     ~CFLAGS_SHOW_CURSOR
0288+  EBEF 32 32 FF                        LD      (console_flags), A
0289+  EBF2                                 ;
0290+  EBF2 C5                              PUSH    BC
0291+  EBF3 1E 00                           LD      E, 0
0292+  EBF5 F3                              DI
0293+  EBF6 CD 3F F2                        CALL    update_cursor
0294+  EBF9 FB                              EI
0295+  EBFA C1                              POP     BC
0296+  EBFB 78                              LD      A, B
0297+  EBFC C9                              RET
0298+  EBFD                  
0299+  EBFD 4B 2F 1B    _indentity_sequence .DB     'K', '/', ESCAPE_CHAR           ; RETURNED BY VT-52 emulation - note sequence is reversed
0300+  EC00             IDENTITY_LENGTH     .EQU    3
0301+  EC00             
0302+  EC00             ;------------------------------------------------------  
0303+  EC00             bios_conout   ;  4 Console OUTput  - Write character in C to console
0304+  EC00 3A 03 00                        LD      A, (iobyte)
0305+  EC03 E6 03                           AND     03h
0306+  EC05 FE 02                           CP      IO_BAT
0307+  EC07 20 0B                           JR      NZ, _conout_disp_tty
0308+  EC09             
0309+  EC09 3A 03 00                        LD      A, (iobyte)
0310+  EC0C E6 C0                           AND     0C0h
0311+  EC0E 20 08                           JR      NZ, _conout_disp 
0312+  EC10 79                              LD      A, C
0313+  EC11 C3 35 F5                        JP      uart_send
0314+  EC14             
0315+  EC14 79          _conout_disp_tty    LD      A, C
0316+  EC15 CD 35 F5                        CALL    uart_send
0317+  EC18             
0318+  EC18 3A 34 FF    _conout_disp        LD      A, (console_escape)             ; Test to see if handling an escape sequence and expect more parameters
0319+  EC1B B7                              OR      A
0320+  EC1C C2 D1 EC                        JP      NZ, _conout_escape_seq
0321+  EC1F             
0322+  EC1F 3A 32 FF                        LD      A, (console_flags)              ; Test to see if we're expecting an escape character
0323+  EC22 E6 08                           AND     CFLAGS_ESCAPE
0324+  EC24 CA BE EC                        JP      Z, _conout_check_esc
0325+  EC27             
0326+  EC27                                                                         ; If so, this is the first character after we got an escape...
0327+  EC27 ED 5B 2D FF                     LD      DE, (cursor_row)                ; Get cursor position in DE
0328+  EC2B 3A 32 FF                        LD      A,(console_flags)               ; Reset the escape flag
0329+  EC2E E6 F7                           AND     ~CFLAGS_ESCAPE
0330+  EC30 32 32 FF                        LD      (console_flags),A
0331+  EC33             
0332+  EC33 79                              LD      A, C
0333+  EC34             
0334+  EC34 FE 41                           CP      'A'
0335+  EC36 20 04                           JR      NZ, _conout_not_up
0336+  EC38 1D                              DEC     E
0337+  EC39 C3 20 ED                        JP      _conout_csr_update
0338+  EC3C             
0339+  EC3C FE 42       _conout_not_up      CP      'B'
0340+  EC3E 20 04                           JR      NZ, _conout_not_down
0341+  EC40 1C                              INC     E
0342+  EC41 C3 20 ED                        JP      _conout_csr_update
0343+  EC44             
0344+  EC44 FE 43       _conout_not_down    CP      'C'
0345+  EC46 20 09                           JR      NZ, _conout_not_right
0346+  EC48 3A 30 FF                        LD      A, (console_width)
0347+  EC4B BA                              CP      D
0348+  EC4C C8                              RET     Z                           
0349+  EC4D 14                              INC     D
0350+  EC4E C3 20 ED                        JP      _conout_csr_update
0351+  EC51             
0352+  EC51 FE 44       _conout_not_right   CP      'D'
0353+  EC53 20 05                           JR      NZ, _conout_not_left
0354+  EC55 15                              DEC     D
0355+  EC56 C8                              RET     Z
0356+  EC57 C3 20 ED                        JP      _conout_csr_update
0357+  EC5A             
0358+  EC5A FE 46       _conout_not_left    CP      'F'                         ; Enter graphics mode.. not supported
0359+  EC5C C8                              RET     Z
0360+  EC5D             
0361+  EC5D FE 47                           CP      'G'                         ; Exit graphics mode
0362+  EC5F C8                              RET     Z
0363+  EC60             
0364+  EC60 FE 48                           CP      'H'
0365+  EC62 20 06                           JR      NZ, _conout_not_home
0366+  EC64 11 01 01                        LD      DE, 0101h
0367+  EC67 C3 20 ED                        JP      _conout_csr_update
0368+  EC6A             
0369+  EC6A FE 49       _conout_not_home    CP      'I'                         ; Reverse line feed. Insert line above and move cursor up. Not supported
0370+  EC6C C8                              RET     Z                    
0371+  EC6D             
0372+  EC6D FE 4A                           CP      'J'
0373+  EC6F 20 19                           JR      NZ, _conout_not_clr_sc
0374+  EC71             
0375+  EC71 CD 94 EC                        CALL    _conout_clr_ln
0376+  EC74 ED 4B 2D FF                     LD      BC, (cursor_row)
0377+  EC78 0E 00                           LD      C, 0
0378+  EC7A 04          _conout_clr_scrn    INC     B
0379+  EC7B 3A 2F FF                        LD      A, (console_height)
0380+  EC7E B8                              CP      B
0381+  EC7F CA D5 ED                        JP      Z, _redraw_buffer
0382+  EC82 C5                              PUSH    BC
0383+  EC83 78                              LD      A, B
0384+  EC84 CD 03 EF                        CALL    clear_screen_row
0385+  EC87 C1                              POP     BC
0386+  EC88 18 F0                           JR      _conout_clr_scrn
0387+  EC8A             
0388+  EC8A FE 4B       _conout_not_clr_sc  CP      'K'
0389+  EC8C 20 11                           JR      NZ, _conout_not_clr_ln
0390+  EC8E             
0391+  EC8E CD 94 EC                        CALL   _conout_clr_ln
0392+  EC91 C3 D5 ED                        JP     _redraw_buffer
0393+  EC94             
0394+  EC94 ED 4B 2D FF _conout_clr_ln      LD      BC, (cursor_row)
0395+  EC98 05                              DEC     B
0396+  EC99 79                              LD      A, C
0397+  EC9A 3D                              DEC     A
0398+  EC9B 48                              LD      C, B
0399+  EC9C C3 03 EF                        JP      clear_screen_row
0400+  EC9F             
0401+  EC9F FE 59       _conout_not_clr_ln  CP      'Y'
0402+  ECA1 20 08                           JR      NZ, _conout_not_pos
0403+  ECA3             
0404+  ECA3 32 34 FF    _conout_start_esc   LD      (console_escape), A         ; Start an escape sequence
0405+  ECA6 AF                              XOR     A
0406+  ECA7 32 35 FF                        LD      (console_param1), A
0407+  ECAA C9                              RET
0408+  ECAB             
0409+  ECAB FE 5A       _conout_not_pos     CP      'Z'
0410+  ECAD 20 06                           JR      NZ, _conout_not_ident
0411+  ECAF 3E 03                           LD      A, IDENTITY_LENGTH
0412+  ECB1 32 36 FF                        LD      (console_identify), A
0413+  ECB4 C9                              RET
0414+  ECB5             
0415+  ECB5 FE 62       _conout_not_ident   CP      'b'
0416+  ECB7 28 EA                           JR      Z, _conout_start_esc
0417+  ECB9 FE 63                           CP      'c'
0418+  ECBB 28 E6                           JR      Z, _conout_start_esc
0419+  ECBD             
0420+  ECBD                                 ; TODO: Any addtional escape sequences here...
0421+  ECBD C9                              RET
0422+  ECBE             
0423+  ECBE 79          _conout_check_esc   LD      A, C                    
0424+  ECBF FE 1B                           CP      ESCAPE_CHAR
0425+  ECC1 C2 AC EE                        JP      NZ, _conout_character
0426+  ECC4             
0427+  ECC4 3A 32 FF                        LD      A, (console_flags)
0428+  ECC7 F6 08                           OR      CFLAGS_ESCAPE
0429+  ECC9 32 32 FF                        LD      (console_flags), A
0430+  ECCC AF                              XOR     A
0431+  ECCD 32 34 FF                        LD      (console_escape),A
0432+  ECD0 C9                              RET
0433+  ECD1             
0434+  ECD1 3A 34 FF    _conout_escape_seq  LD      A,(console_escape)
0435+  ECD4 FE 59                           CP      'Y'
0436+  ECD6 28 0D                           JR      Z, _conout_esc_pos
0437+  ECD8 FE 62                           CP      'b'
0438+  ECDA 28 31                           JR      Z, _conout_esc_foreg
0439+  ECDC FE 63                           CP      'c'
0440+  ECDE 28 1C                           JR      Z, _conout_esc_backg
0441+  ECE0             
0442+  ECE0                                 ; All unknown sequences reset the escape sequence
0443+  ECE0 AF          _conout_reset_seq   XOR     A
0444+  ECE1 32 34 FF                        LD      (console_escape),A
0445+  ECE4 C9                              RET
0446+  ECE5             
0447+  ECE5 3A 35 FF    _conout_esc_pos     LD      A, (console_param1)
0448+  ECE8 A7                              AND     A
0449+  ECE9 20 05                           JR      NZ, _conout_pos_param
0450+  ECEB 79                              LD      A, C
0451+  ECEC 32 35 FF                        LD      (console_param1),A
0452+  ECEF C9                              RET
0453+  ECF0             
0454+  ECF0 D6 1F       _conout_pos_param   SUB     31
0455+  ECF2 5F                              LD      E, A
0456+  ECF3 79                              LD      A, C
0457+  ECF4 D6 1F                           SUB     31
0458+  ECF6 57                              LD      D, A
0459+  ECF7 CD E0 EC                        CALL    _conout_reset_seq
0460+  ECFA 18 24                           JR      _conout_csr_update
0461+  ECFC             
0462+  ECFC 3A 31 FF    _conout_esc_backg   LD      A, (console_colour)
0463+  ECFF E6 F0                           AND     0F0h
0464+  ED01 47                              LD      B, A
0465+  ED02 79                              LD      A, C
0466+  ED03 D6 1F                           SUB     31
0467+  ED05 E6 0F                           AND     0Fh
0468+  ED07 B0          _conout_set_colour  OR      B
0469+  ED08 32 31 FF                        LD      (console_colour), A
0470+  ED0B 18 D3                           JR      _conout_reset_seq
0471+  ED0D             
0472+  ED0D 3A 31 FF    _conout_esc_foreg   LD      A, (console_colour)
0473+  ED10 E6 0F                           AND     0Fh
0474+  ED12 47                              LD      B, A
0475+  ED13 79                              LD      A, C
0476+  ED14 D6 1F                           SUB     31
0477+  ED16 CB 27                           SLA     A
0478+  ED18 CB 27                           SLA     A
0479+  ED1A CB 27                           SLA     A
0480+  ED1C CB 27                           SLA     A
0481+  ED1E 18 E7                           JR      _conout_set_colour
0482+  ED20             
0483+  ED20             ; Cursor position has changed, check if we need to update the whole display.
0484+  ED20             ; This is entered with DE as D = new cursor column, E = new cursor row
0485+  ED20             ;         Writes new cursor poition to (cursor_row, cursor_column)
0486+  ED20             ;         Returns HL = updated display column, row to track the cursor position..
0487+  ED20             ; Assume column is always within range, row may be before start/after end of visible screen
0488+  ED20             ;
0489+  ED20 2A 2B FF    _conout_csr_update  LD      HL, (display_row)           ; HL = current display column, row..
0490+  ED23 ED 4B 2D FF                     LD      BC, (cursor_row)            ; BC = old values of cursor column, row
0491+  ED27 7B                              LD      A, E                        
0492+  ED28 B9                              CP      C
0493+  ED29 32 2D FF                        LD      (cursor_row), A
0494+  ED2C 20 0A                           JR      NZ, _conout_check_row       ; If cursor row has changed, we must update display_row and optionally screen_offset
0495+  ED2E             
0496+  ED2E 7A          _conout_track_col   LD      A, D
0497+  ED2F B8                              CP      B
0498+  ED30 32 2E FF                        LD      (cursor_col), A
0499+  ED33 20 1A                           JR      NZ, _conout_check_col       ; If only column has changed, we may update display_col..
0500+  ED35 C3 D5 ED                        JP      _redraw_buffer              ; Otherwise, nothing has changed. Make sure display is up to date
0501+  ED38             
0502+  ED38 A7          _conout_check_row   AND     A                           
0503+  ED39 20 05                           JR      NZ, _conout_chk_bottom         
0504+  ED3B 3C                              INC     A                           ; We're above the screen, fix the cursor_row but set L (display row) to -1 
0505+  ED3C 32 2D FF                        LD      (cursor_row), A
0506+  ED3F             
0507+  ED3F AF                              XOR     A
0508+  ED40             
0509+  ED40 3D          _conout_chk_bottom  DEC     A
0510+  ED41 6F                              LD      L, A                        ; Update the display row in HL which will force refresh
0511+  ED42 3A 2F FF                        LD      A, (console_height)
0512+  ED45 BD                              CP      L
0513+  ED46 20 03                           JR      NZ, _conout_not_bottom
0514+  ED48             
0515+  ED48 32 2D FF                        LD      (cursor_row), A
0516+  ED4B             
0517+  ED4B 7A          _conout_not_bottom  LD      A, D                        ; Write col here since it wasn't previously set...
0518+  ED4C 32 2E FF                        LD      (cursor_col), A
0519+  ED4F             
0520+  ED4F 7C          _conout_check_col   LD      A, H                        ; Current display col
0521+  ED50 3C                              INC     A
0522+  ED51 92                              SUB     D                           ; Subtract new cursor col
0523+  ED52 30 18                           JR      NC, _conout_scroll_l        ; Cursor col is before beginning of screen
0524+  ED54             
0525+  ED54 3A 32 FF                        LD      A, (console_flags)
0526+  ED57 E6 01                           AND     CFLAGS_SHOW_CURSOR
0527+  ED59 3E 01                           LD      A, 1
0528+  ED5B 28 01                           JR      Z, _conout_keep_left
0529+  ED5D 3D                              DEC     A
0530+  ED5E C6 18       _conout_keep_left   ADD     A, DISPLAY_WIDTH          
0531+  ED60 47                              LD      B, A
0532+  ED61 84                              ADD     A, H                        ; Right hand edge of display...
0533+  ED62 BA                              CP      D
0534+  ED63 30 0A                           JR      NC, _conout_refresh
0535+  ED65             
0536+  ED65 7A                              LD      A, D                        ; Cursor col is after end of screen
0537+  ED66 90                              SUB     B
0538+  ED67 30 05                           JR      NC, _conout_scroll_done
0539+  ED69 AF                              XOR     A
0540+  ED6A 18 02                           JR      _conout_scroll_done
0541+  ED6C             
0542+  ED6C 7A          _conout_scroll_l    LD      A, D
0543+  ED6D 3D                              DEC     A
0544+  ED6E 67          _conout_scroll_done LD      H, A
0545+  ED6F             
0546+  ED6F             
0547+  ED6F             ; We enter with HL = new display column, row
0548+  ED6F             ; At this point one or both of display row or column may changed, so update the whole display...   
0549+  ED6F             ; If row is -1, we're before the beginning of the screen - need to scroll up
0550+  ED6F             ; And if row > console_height, we need to scroll down.. Display row stays constant, but screen_offset changes..
0551+  ED6F             
0552+  ED6F             ; Do scroll first, then only change display row/col if console_flags is set to track cursor..
0553+  ED6F             ; If display row/col have changed, compare screen buffer with display buffer and update whichever characters/brightnesses have changed..
0554+  ED6F             ;
0555+  ED6F             ; 
0556+  ED6F             _conout_refresh     
0557+  ED6F 7D                              LD      A, L
0558+  ED70 B7                              OR      A
0559+  ED71 F2 88 ED                        JP      P, _conout_row_postv
0560+  ED74             
0561+  ED74                                 ; Display row negative
0562+  ED74 AF                              XOR     A
0563+  ED75 6F                              LD      L, A                        ; Reset display row to zero
0564+  ED76 3A 2A FF                        LD      A, (screen_offset)
0565+  ED79 3D                              DEC     A
0566+  ED7A E6 3F                           AND     03Fh
0567+  ED7C 32 2A FF                        LD      (screen_offset), A
0568+  ED7F E5                              PUSH    HL
0569+  ED80 0E 00                           LD      C, 0
0570+  ED82 CD 03 EF                        CALL    clear_screen_row
0571+  ED85 E1                              POP     HL
0572+  ED86 18 43                           JR      _conout_update_display
0573+  ED88             
0574+  ED88 3A 2F FF    _conout_row_postv   LD      A, (console_height)
0575+  ED8B 4F                              LD      C, A                        ; Remember for later on
0576+  ED8C BD                              CP      L
0577+  ED8D 20 3C                           JR      NZ, _conout_update_display
0578+  ED8F             
0579+  ED8F                                 ; display row below screen
0580+  ED8F E5                              PUSH    HL
0581+  ED90 3A 2A FF                        LD      A, (screen_offset)
0582+  ED93 3C                              INC     A
0583+  ED94 E6 3F                           AND     03Fh
0584+  ED96 32 2A FF                        LD      (screen_offset), A
0585+  ED99                                 ; SUB     C
0586+  ED99 E6 3F                           AND     03Fh
0587+  ED9B 6F                              LD      L, A
0588+  ED9C             
0589+  ED9C 3A 29 FF                        LD      A, (screen_page)
0590+  ED9F FE 40                           CP      VIDEOBEAST_PAGE
0591+  EDA1 20 20                           JR      NZ, _not_videobeast
0592+  EDA3             
0593+  EDA3 F3                              DI
0594+  EDA4 D3 71                           OUT     (IO_MEM_1), A
0595+  EDA6 3E F3                           LD      A, VB_UNLOCK
0596+  EDA8 32 FE 7F                        LD      (VB_REGISTERS_LOCKED), A
0597+  EDAB 7D                              LD      A, L
0598+  EDAC 87                              ADD     A, A
0599+  EDAD 87                              ADD     A, A
0600+  EDAE 87                              ADD     A, A
0601+  EDAF 32 C7 7F                        LD      (VB_LAYER_4+LAYER_SCROLL_Y), A
0602+  EDB2 3E 10                           LD      A, 010h
0603+  EDB4 38 01                           JR      C, _conout_scroll_xy
0604+  EDB6 AF                              XOR     A
0605+  EDB7 32 C6 7F    _conout_scroll_xy   LD      (VB_LAYER_4+LAYER_SCROLL_XY), A
0606+  EDBA 32 FE 7F                        LD      (VB_REGISTERS_LOCKED), A    ; Either value will re-lock registers..
0607+  EDBD             
0608+  EDBD 3A 3A FF                        LD      A, (page_1_mapping)
0609+  EDC0 D3 71                           OUT     (IO_MEM_1), A
0610+  EDC2 FB                              EI 
0611+  EDC3             
0612+  EDC3 79          _not_videobeast     LD      A, C
0613+  EDC4                                 
0614+  EDC4 0E 00                           LD      C, 0
0615+  EDC6 CD 03 EF                        CALL    clear_screen_row
0616+  EDC9 E1                              POP     HL 
0617+  EDCA 2D                              DEC     L
0618+  EDCB             
0619+  EDCB             _conout_update_display
0620+  EDCB                                 ; We've scrolled if necessary, update the display row if required..
0621+  EDCB 3A 32 FF                        LD      A, (console_flags)
0622+  EDCE E6 02                           AND     CFLAGS_TRACK_CURSOR         
0623+  EDD0 28 03                           JR      Z, _redraw_buffer
0624+  EDD2 22 2B FF                        LD      (display_row), HL           ; Only move display row if we're tracking the cursor
0625+  EDD5             
0626+  EDD5 F3          _redraw_buffer      DI
0627+  EDD6 CD DB ED                        CALL    unsafe_redraw
0628+  EDD9 FB                              EI
0629+  EDDA C9                              RET
0630+  EDDB             
0631+  EDDB             ;----------------------------------------------------------------------------------------------------
0632+  EDDB             ; Note that this uses Mem Page 1
0633+  EDDB             ;
0634+  EDDB 3A 32 FF    unsafe_redraw       LD      A, (console_flags)
0635+  EDDE E6 20                           AND     CFLAGS_LED_OFF
0636+  EDE0 C0                              RET     NZ
0637+  EDE1             
0638+  EDE1 2A 2B FF    unsafe_led_redraw   LD      HL, (display_row)       ; Calculate our screen source in DE
0639+  EDE4 3A 2A FF                        LD      A, (screen_offset)      
0640+  EDE7 85                              ADD     A, L
0641+  EDE8             
0642+  EDE8 E6 3F                           AND     03Fh
0643+  EDEA F6 40                           OR      040h                    ; We're going to use page 1 for the screen buffer
0644+  EDEC 57                              LD      D, A
0645+  EDED 7C                              LD      A, H
0646+  EDEE CB 27                           SLA     A
0647+  EDF0 5F                              LD      E, A
0648+  EDF1             
0649+  EDF1 21 85 FF                        LD      HL, display_buffer
0650+  EDF4 06 18                           LD      B, DISPLAY_WIDTH
0651+  EDF6 0E 00                           LD      C, 0
0652+  EDF8             
0653+  EDF8 3A 32 FF                        LD      A, (console_flags)      ; Don't draw last character if we've moved
0654+  EDFB E6 24                           AND     CFLAGS_SHOW_MOVED | CFLAGS_LED_OFF
0655+  EDFD 28 01                           JR      Z, _full_redraw
0656+  EDFF 05                              DEC     B
0657+  EE00             
0658+  EE00 3A 29 FF    _full_redraw        LD      A, (screen_page)
0659+  EE03 D3 71                           OUT     (IO_MEM_1), A
0660+  EE05             
0661+  EE05 1A          _redraw_loop        LD      A, (DE)
0662+  EE06 BE                              CP      (HL)
0663+  EE07 28 0A                           JR      Z, _redraw_skip_char
0664+  EE09 77                              LD      (HL), A
0665+  EE0A C5                              PUSH    BC
0666+  EE0B E5                              PUSH    HL
0667+  EE0C D5                              PUSH    DE
0668+  EE0D CD A3 F7                        CALL    disp_character
0669+  EE10 D1                              POP     DE
0670+  EE11 E1                              POP     HL
0671+  EE12 C1                              POP     BC
0672+  EE13             
0673+  EE13 23          _redraw_skip_char   INC     HL
0674+  EE14 13                              INC     DE
0675+  EE15             
0676+  EE15 3A 32 FF                        LD      A, (console_flags)
0677+  EE18 E6 24                           AND     CFLAGS_SHOW_MOVED | CFLAGS_LED_OFF
0678+  EE1A 1A                              LD      A, (DE)  
0679+  EE1B 28 05                           JR      Z, _redraw_normal
0680+  EE1D             
0681+  EE1D CB 3F                           SRL     A
0682+  EE1F CB 3F                           SRL     A
0683+  EE21 3C                              INC     A
0684+  EE22             
0685+  EE22 BE          _redraw_normal      CP      (HL)
0686+  EE23 28 12                           JR      Z, _redraw_skip_bri
0687+  EE25 77                              LD      (HL), A
0688+  EE26 C5                              PUSH    BC
0689+  EE27 E5                              PUSH    HL
0690+  EE28 D5                              PUSH    DE
0691+  EE29 79                              LD      A, C                    ; Ugh... disp_char_bright has parameters in other order..
0692+  EE2A 4E                              LD      C, (HL)
0693+  EE2B CB 21                           SLA     C
0694+  EE2D CB 21                           SLA     C
0695+  EE2F CB 21                           SLA     C
0696+  EE31 CD 65 F7                        CALL    disp_char_bright    ; Column A, brightness C
0697+  EE34 D1                              POP     DE
0698+  EE35 E1                              POP     HL
0699+  EE36 C1                              POP     BC
0700+  EE37             
0701+  EE37 23          _redraw_skip_bri    INC     HL
0702+  EE38 13                              INC     DE
0703+  EE39 0C                              INC     C
0704+  EE3A 10 C9                           DJNZ    _redraw_loop
0705+  EE3C             
0706+  EE3C 3A 32 FF                        LD      A, (console_flags)
0707+  EE3F 4F                              LD      C, A
0708+  EE40 E6 24                           AND     CFLAGS_SHOW_MOVED | CFLAGS_LED_OFF
0709+  EE42 28 5D                           JR      Z, _redraw_done
0710+  EE44             
0711+  EE44                                 ; We've moved the cursor, so draw the last character as our location bitmap..
0712+  EE44 36 00       _redraw_moved       LD      (HL), 0
0713+  EE46 23                              INC     HL
0714+  EE47 36 80                           LD      (HL), DISP_DEFAULT_BRIGHTNESS
0715+  EE49 79                              LD      A, C
0716+  EE4A E6 20                           AND     CFLAGS_LED_OFF
0717+  EE4C 79                              LD      A, C
0718+  EE4D 28 05                           JR      Z, _led_normal
0719+  EE4F             
0720+  EE4F 21 07 09                        LD      HL, LED_OFF_BITMAP
0721+  EE52 18 41                           JR      _redraw_map2
0722+  EE54             
0723+  EE54 E6 02       _led_normal         AND     CFLAGS_TRACK_CURSOR
0724+  EE56 20 4F                           JR      NZ, _redraw_tracking
0725+  EE58             
0726+  EE58 21 00 00                        LD      HL, 0
0727+  EE5B ED 4B 2D FF                     LD      BC, (cursor_row)
0728+  EE5F 0D                              DEC     C
0729+  EE60                                 
0730+  EE60 ED 5B 2B FF                     LD      DE, (display_row)
0731+  EE64 7B                              LD      A, E
0732+  EE65 A7                              AND     A
0733+  EE66 20 05                           JR      NZ, _redraw_not_top
0734+  EE68 21 01 00                        LD      HL, MOVE_TOP_BITMAP
0735+  EE6B 18 0A                           JR      _redraw_not_bottom
0736+  EE6D             
0737+  EE6D 3A 2F FF    _redraw_not_top     LD      A, (console_height)
0738+  EE70 3D                              DEC     A
0739+  EE71 BB                              CP      E
0740+  EE72 20 03                           JR      NZ, _redraw_not_bottom
0741+  EE74 21 08 00                        LD      HL, MOVE_BOTTOM_BITMAP
0742+  EE77             
0743+  EE77 7B          _redraw_not_bottom  LD      A, E
0744+  EE78 B9                              CP      C
0745+  EE79 01 00 00                        LD      BC, 0
0746+  EE7C 20 04                           JR      NZ, _redraw_not_row
0747+  EE7E 0E C0                           LD      C, MOVE_ROW_BITMAP_L
0748+  EE80 18 08                           JR      _redraw_map
0749+  EE82             
0750+  EE82 06 28       _redraw_not_row     LD      B, MOVE_BELOW_BITMAP_H
0751+  EE84 38 02                           JR      C, _redraw_not_above
0752+  EE86 18 02                           JR      _redraw_map
0753+  EE88             
0754+  EE88 06 05       _redraw_not_above   LD      B, MOVE_ABOVE_BITMAP_H
0755+  EE8A             
0756+  EE8A 09          _redraw_map         ADD     HL, BC
0757+  EE8B 3A 2C FF                        LD      A, (display_col)
0758+  EE8E A7                              AND     A
0759+  EE8F 20 04                           JR      NZ, _redraw_map2
0760+  EE91 3E 30                           LD      A, MOVE_AT_LEFT_BITMAP
0761+  EE93 B5                              OR      L
0762+  EE94 6F                              LD      L, A
0763+  EE95 3E 17       _redraw_map2        LD      A, DISPLAY_WIDTH-1
0764+  EE97 CD C4 F7                        CALL    disp_bitmask
0765+  EE9A             
0766+  EE9A 3E 17                           LD      A, DISPLAY_WIDTH-1
0767+  EE9C 0E 80                           LD      C, DISP_DEFAULT_BRIGHTNESS
0768+  EE9E CD 65 F7                        CALL    disp_char_bright
0769+  EEA1             
0770+  EEA1 3A 3A FF    _redraw_done        LD      A, (page_1_mapping)
0771+  EEA4 D3 71                           OUT     (IO_MEM_1), A
0772+  EEA6 C9                              RET
0773+  EEA7             
0774+  EEA7 21 3F 2D    _redraw_tracking    LD      HL, 2d3fh          ; Tracking symbol
0775+  EEAA 18 E9                           JR      _redraw_map2
0776+  EEAC             
0777+  EEAC             MOVE_TOP_BITMAP     .EQU    0001h
0778+  EEAC             MOVE_BOTTOM_BITMAP  .EQU    0008h
0779+  EEAC             MOVE_ROW_BITMAP_L   .EQU    0c0h
0780+  EEAC             MOVE_ABOVE_BITMAP_H .EQU    05h
0781+  EEAC             MOVE_BELOW_BITMAP_H .EQU    28h
0782+  EEAC             MOVE_AT_LEFT_BITMAP .EQU    030h
0783+  EEAC             LED_OFF_BITMAP      .EQU    0907h
0784+  EEAC             
0785+  EEAC             ;---------------------------------------- Simple character output.. 
0786+  EEAC ED 5B 2D FF _conout_character   LD      DE, (cursor_row)
0787+  EEB0 FE 0D                           CP      CARRIAGE_RETURN
0788+  EEB2 20 05                           JR      NZ, _conout_not_cr
0789+  EEB4                
0790+  EEB4 16 01                           LD      D, 1
0791+  EEB6 C3 20 ED                        JP      _conout_csr_update
0792+  EEB9             
0793+  EEB9 FE 0A       _conout_not_cr      CP      NEWLINE
0794+  EEBB 20 04                           JR      NZ, _conout_not_lf
0795+  EEBD             
0796+  EEBD 1C                              INC     E
0797+  EEBE C3 20 ED                        JP      _conout_csr_update
0798+  EEC1             
0799+  EEC1 FE 08       _conout_not_lf      CP      BACKSPACE_CHAR
0800+  EEC3 20 05                           JR      NZ, _conout_visible
0801+  EEC5             
0802+  EEC5 15                              DEC     D
0803+  EEC6 C2 20 ED                        JP      NZ, _conout_csr_update
0804+  EEC9 C9                              RET
0805+  EECA             
0806+  EECA                                 ; Now, C is character to write,
0807+  EECA ED 5B 2D FF _conout_visible     LD      DE, (cursor_row)
0808+  EECE 15                              DEC     D                       ; 1 based col
0809+  EECF 1D                              DEC     E                       ; 1 based row
0810+  EED0             
0811+  EED0 3A 2A FF                        LD      A, (screen_offset)      ; Write the character and colour into our screen buffer
0812+  EED3 83                              ADD     A, E
0813+  EED4             
0814+  EED4 E6 3F                           AND     03Fh
0815+  EED6 F6 40                           OR      040h                    ; We're going to use page 1 for the screen buffer
0816+  EED8 67                              LD      H, A
0817+  EED9 7A                              LD      A, D
0818+  EEDA CB 27                           SLA     A
0819+  EEDC 6F                              LD      L, A
0820+  EEDD 3A 29 FF                        LD      A, (screen_page)
0821+  EEE0 D3 71                           OUT     (IO_MEM_1), A
0822+  EEE2 71                              LD      (HL), C
0823+  EEE3 3A 31 FF                        LD      A, (console_colour)
0824+  EEE6 23                              INC     HL
0825+  EEE7 77                              LD      (HL), A
0826+  EEE8 3A 3A FF                        LD      A, (page_1_mapping)
0827+  EEEB D3 71                           OUT     (IO_MEM_1), A
0828+  EEED             
0829+  EEED ED 5B 2D FF                     LD      DE, (cursor_row)
0830+  EEF1 3A 30 FF                        LD      A, (console_width)
0831+  EEF4 6F                              LD      L, A
0832+  EEF5 7A                              LD      A, D
0833+  EEF6 BD                              CP      L
0834+  EEF7 28 04                           JR      Z, _conout_wrap
0835+  EEF9 14                              INC     D
0836+  EEFA C3 20 ED                        JP      _conout_csr_update
0837+  EEFD             
0838+  EEFD 16 01       _conout_wrap        LD      D, 1
0839+  EEFF 1C                              INC     E
0840+  EF00 C3 20 ED                        JP      _conout_csr_update          ; If we've wrapped, use the new wrap position..
0841+  EF03             ;
0842+  EF03             ;
0843+  EF03             ; Fill the row of the screen buffer with space chars..
0844+  EF03             ; Enter with A -> row of screen buffer, C -> start column
0845+  EF03             ;          Uses HL, C
0846+  EF03             ;
0847+  EF03 67          clear_screen_row    LD      H, A
0848+  EF04 3A 2A FF                        LD      A, (screen_offset)
0849+  EF07 84                              ADD     A, H
0850+  EF08             
0851+  EF08 E6 3F                           AND    03Fh
0852+  EF0A F6 40                           OR     040h
0853+  EF0C 67                              LD     H, A
0854+  EF0D 79                              LD     A, C
0855+  EF0E 81                              ADD    A, C
0856+  EF0F 6F                              LD     L, A
0857+  EF10             
0858+  EF10 3A 31 FF                        LD      A, (console_colour)
0859+  EF13 4F                              LD      C, A
0860+  EF14             
0861+  EF14 3A 29 FF                        LD      A, (screen_page)
0862+  EF17 D3 71                           OUT     (IO_MEM_1), A
0863+  EF19             
0864+  EF19 3E 20       _clear_loop         LD      A, ' '
0865+  EF1B 77                              LD      (HL), A
0866+  EF1C 2C                              INC     L
0867+  EF1D 71                              LD      (HL), C
0868+  EF1E 2C                              INC     L
0869+  EF1F 3E FE                           LD      A, 0FEh
0870+  EF21 BD                              CP      L
0871+  EF22 20 F5                           JR      NZ, _clear_loop
0872+  EF24             
0873+  EF24 3A 3A FF                        LD      A, (page_1_mapping)
0874+  EF27 D3 71                           OUT     (IO_MEM_1), A
0875+  EF29 C9                              RET
0876+  EF2A             ;------------------------------------------------------  
0877+  EF2A             bios_list     ;  5 List OUTput
0878+  EF2A AF                              XOR     A
0879+  EF2B C9                              RET
0880+  EF2C                                 
0881+  EF2C             ;------------------------------------------------------  
0882+  EF2C             bios_punch    ;  6 punch OUTput
0883+  EF2C AF                              XOR     A
0884+  EF2D C9                              RET
0885+  EF2E                                 
0886+  EF2E             ;------------------------------------------------------  
0887+  EF2E             bios_reader   ;  7 Reader input
0888+  EF2E C9                              RET
0889+  EF2F                                 
0890+  EF2F             
0891+  EF2F                                 
0892+  EF2F             ;------------------------------------------------------  
0893+  EF2F             bios_seldsk   ;  9 Select disk - Select disc in C, returns HL =  address of DPH, or 0 if error
0894+  EF2F                                 ; Store C in A, Check drive is in range
0895+  EF2F 79                              LD      A, C
0896+  EF30 21 00 00                        LD      HL, 0
0897+  EF33 FE 02                           CP      MAX_DRIVES
0898+  EF35 D0                              RET     NC
0899+  EF36             
0900+  EF36 06 00                           LD      B, 0
0901+  EF38 CB 21                           SLA     C
0902+  EF3A CB 21                           SLA     C
0903+  EF3C CB 21                           SLA     C
0904+  EF3E CB 21                           SLA     C
0905+  EF40 21 33 EA                        LD      HL, dpbase
0906+  EF43 09                              ADD     HL, BC
0907+  EF44 32 44 FF                        LD      (sys_seldsk), A
0908+  EF47 C9                              RET
0909+  EF48             
0910+  EF48             ;------------------------------------------------------  
0911+  EF48             bios_home     ;  8 Home disk
0912+  EF48 0E 00                           LD      C, 0            
0913+  EF4A             ;------------------------------------------------------  
0914+  EF4A             bios_settrk   ; 10 Select track - Move drive to track stored in C - 0 based (0-76)
0915+  EF4A 79                              LD      A, C
0916+  EF4B 32 3D FF                        LD      (sys_track), A
0917+  EF4E C9                              RET
0918+  EF4F                                 
0919+  EF4F             ;------------------------------------------------------  
0920+  EF4F             bios_setsec   ; 11 Select sector - Move drive to sector stored in BC - 1 based (1-26) - TODO: Confirm this, not sure if true..
0921+  EF4F ED 43 3E FF                     LD      (sys_sector), BC
0922+  EF53 C9                              RET
0923+  EF54                                 
0924+  EF54             ;------------------------------------------------------  
0925+  EF54             bios_setdma   ; 12 Set DMA ADDress - Set the DMA address to BC - source or destination for disk read/write
0926+  EF54                           ; Note: CP/M 2.2 appears to only set this to the DIRBUF address defined in the DPF, or the USER DMA address (0x80h)
0927+  EF54 ED 43 40 FF                     LD      (sys_dmaaddr), BC
0928+  EF58 C9                              RET
0929+  EF59                                 
0930+  EF59             ;------------------------------------------------------  
0931+  EF59             ;
0932+  EF59             ; Uses Mem Page 1, 2
0933+  EF59             ;
0934+  EF59             bios_read     ; 13 Read 128 bytes
0935+  EF59 CD C5 EF                        CALL    _get_memdisc_addr
0936+  EF5C F3                              DI
0937+  EF5D D3 71                           OUT     (IO_MEM_1), A
0938+  EF5F CB F0                           SET     6, B            ; Point B into page 1
0939+  EF61 C5                              PUSH    BC
0940+  EF62 E1                              POP     HL
0941+  EF63 0E 80                           LD      C, 128
0942+  EF65             
0943+  EF65 ED 5B 40 FF                     LD      DE, (sys_dmaaddr)
0944+  EF69 7A                              LD      A, D
0945+  EF6A 07                              RLCA
0946+  EF6B 07                              RLCA
0947+  EF6C E6 03                           AND     03h             ; Bottom two bits
0948+  EF6E F6 20                           OR      RAM_PAGE_0
0949+  EF70 47                              LD      B, A            ; B is destination page
0950+  EF71 D3 72       _read_page          OUT     (IO_MEM_2), A
0951+  EF73             
0952+  EF73 CB FA                           SET     7, D            ; Point D to second page
0953+  EF75 CB B2                           RES     6, D
0954+  EF77             
0955+  EF77 ED A0       _read_next          LDI
0956+  EF79 79                              LD      A, C
0957+  EF7A B7                              OR      A
0958+  EF7B 28 08                           JR      Z, _read_write_done
0959+  EF7D             
0960+  EF7D CB 72                           BIT     6, D
0961+  EF7F 28 F6                           JR      Z, _read_next
0962+  EF81             
0963+  EF81 04                              INC     B
0964+  EF82 78                              LD      A, B
0965+  EF83 18 EC                           JR      _read_page
0966+  EF85             
0967+  EF85 3A 3A FF    _read_write_done    LD      A, (page_1_mapping)   ; Return page map to normal
0968+  EF88 D3 71                           OUT     (IO_MEM_1), A
0969+  EF8A 3A 3B FF                        LD      A, (page_2_mapping)
0970+  EF8D D3 72                           OUT     (IO_MEM_2), A
0971+  EF8F FB                              EI
0972+  EF90 AF                              XOR     A               ; No errors
0973+  EF91 C9                              RET
0974+  EF92                                 
0975+  EF92             ;------------------------------------------------------  
0976+  EF92             ;
0977+  EF92             ; Uses Mem Page 1, 2
0978+  EF92             ;
0979+  EF92             bios_write    ; 14 Write 128 bytes
0980+  EF92 3A 44 FF                        LD      A, (sys_seldsk)
0981+  EF95 B7                              OR      A
0982+  EF96 20 02                           JR      NZ, _write_ok
0983+  EF98 3C                              INC     A
0984+  EF99 C9                              RET
0985+  EF9A             
0986+  EF9A CD C5 EF    _write_ok           CALL    _get_memdisc_addr
0987+  EF9D F3                              DI
0988+  EF9E D3 71                           OUT     (IO_MEM_1), A
0989+  EFA0 CB F0                           SET     6, B
0990+  EFA2 C5                              PUSH    BC
0991+  EFA3 D1                              POP     DE
0992+  EFA4 0E 80                           LD      C, 128
0993+  EFA6             
0994+  EFA6 2A 40 FF                        LD      HL, (sys_dmaaddr)
0995+  EFA9 7C                              LD      A, H
0996+  EFAA 07                              RLCA
0997+  EFAB 07                              RLCA
0998+  EFAC E6 03                           AND     03h              ; Bottom two bits
0999+  EFAE F6 20                           OR      RAM_PAGE_0
1000+  EFB0 47                              LD      B, A             ; B is source page
1001+  EFB1 D3 72       _write_page         OUT     (IO_MEM_2), A
1002+  EFB3             
1003+  EFB3 CB FC                           SET     7, H
1004+  EFB5 CB B4                           RES     6, H
1005+  EFB7             
1006+  EFB7 ED A0       _write_next         LDI
1007+  EFB9 79                              LD      A, C
1008+  EFBA B7                              OR      A
1009+  EFBB 28 C8                           JR      Z, _read_write_done
1010+  EFBD             
1011+  EFBD CB 74                           BIT     6, H
1012+  EFBF 28 F6                           JR      Z, _write_next
1013+  EFC1             
1014+  EFC1 04                              INC     B
1015+  EFC2 78                              LD      A, B
1016+  EFC3 18 EC                           JR      _write_page
1017+  EFC5                                 
1018+  EFC5             ; IN THIS CASE, WE HAVE SAVED THE DISK NUMBER IN 'DISKNO' (0, 1)
1019+  EFC5             ;           THE TRACK NUMBER IN 'TRACK' (0-76)
1020+  EFC5             ;           THE SECTOR NUMBER IN 'SECTOR' (1-26)
1021+  EFC5             ;           THE DMA ADDRESS IN 'DMAAD' (0-65535)
1022+  EFC5             ;
1023+  EFC5             ; Returns BC = address in page for sector
1024+  EFC5             ;          A = page number (ROM/RAM)
1025+  EFC5             ;
1026+  EFC5             ; Note: BC is always aligned to page boundaries, so a sector will never overlap the end of a page.
1027+  EFC5             ;
1028+  EFC5 21 00 00    _get_memdisc_addr   LD      HL, 0
1029+  EFC8 ED 4B 3D FF                     LD      BC, (sys_track)     ; C is track, B is sector (up to 256!)
1030+  EFCC 68                              LD      L, B
1031+  EFCD 44                              LD      B, H 
1032+  EFCE CB 21                           SLA     C                   ; x 2
1033+  EFD0 CB 10                           RL      B
1034+  EFD2 09                              ADD     HL, BC
1035+  EFD3 CB 21                           SLA     C                   ; x 4
1036+  EFD5 CB 10                           RL      B
1037+  EFD7 CB 21                           SLA     C                   ; x 8
1038+  EFD9 CB 10                           RL      B
1039+  EFDB 09                              ADD     HL, BC
1040+  EFDC CB 21                           SLA     C                   ; x 16
1041+  EFDE CB 10                           RL      B
1042+  EFE0 09                              ADD     HL, BC              ; HL = Sector + BC * (2 + 8 + 16) = sector + track * 26
1043+  EFE1             
1044+  EFE1 7D                              LD      A, L
1045+  EFE2 E6 7F                           AND     07Fh
1046+  EFE4 47                              LD      B, A
1047+  EFE5 0E 00                           LD      C, 0
1048+  EFE7 CB 38                           SRL     B
1049+  EFE9 CB 19                           RR      C                   ; BC = Address in page of sector
1050+  EFEB             
1051+  EFEB CB 25                           SLA     L
1052+  EFED CB 14                           RL      H                   ; H is now page number 
1053+  EFEF             
1054+  EFEF 3A 44 FF                        LD      A, (sys_seldsk)
1055+  EFF2 B7                              OR      A
1056+  EFF3 28 05                           JR      Z, _get_memdisk_a
1057+  EFF5 3A 38 FF                        LD      A, (drive_b_mem_page)
1058+  EFF8 84                              ADD     A, H
1059+  EFF9 C9                              RET
1060+  EFFA 3A 37 FF    _get_memdisk_a      LD      A, (drive_a_mem_page)
1061+  EFFD 84                              ADD     A, H
1062+  EFFE C9                              RET
1063+  EFFF             
1064+  EFFF             
1065+  EFFF             ;------------------------------------------------------  
1066+  EFFF             bios_listst   ; 15 List status
1067+  EFFF AF                              XOR     A
1068+  F000 C9                              RET
1069+  F001                                 
1070+  F001             ;------------------------------------------------------  
1071+  F001             bios_sectrn   ; 16 Sector translate - BC = logical sector number (zero based), DE = address of translation table. Return HL as physical sector number
1072+  F001 69                              LD      L, C                ; No skewing needed, just return BC in HL
1073+  F002 60                              LD      H, B
1074+  F003 C9                              RET
1075+  F004                                 
1076+  F004             ;------------------------------------------------------
1077+  F004             ; Inline print. Preserves HL, DE, BC
1078+  F004             ;
1079+  F004 E3          m_print_inline      EX      (SP), HL
1080+  F005 7E          _inline_loop        LD      A, (HL)
1081+  F006 23                              INC     HL
1082+  F007 A7                              AND     A
1083+  F008 28 05                           JR      Z, _inline_done
1084+  F00A CD 11 F0                        CALL    m_print_a_safe
1085+  F00D 18 F6                           JR      _inline_loop
1086+  F00F             
1087+  F00F E3          _inline_done        EX      (SP), HL
1088+  F010 C9                              RET
1089+  F011             
1090+  F011             ;------------------------------------------------------
1091+  F011             ; Print character in A. Preserves HL, DE, BC
1092+  F011             ;
1093+  F011 E5          m_print_a_safe      PUSH    HL
1094+  F012 D5                              PUSH    DE
1095+  F013 C5                              PUSH    BC
1096+  F014 4F                              LD      C, A
1097+  F015 CD 00 EC                        CALL    bios_conout
1098+  F018 C1                              POP     BC
1099+  F019 D1                              POP     DE
1100+  F01A E1                              POP     HL
1101+  F01B C9                              RET
1102+  F01C             
1103+  F01C             ;------------------------------------------------------  
1104+  F01C             
1105+  F01C F3          configure_hardware  DI     
1106+  F01D 3E 20                           LD      A, RAM_PAGE_0
1107+  F01F D3 70                           OUT     (IO_MEM_0), A       ; Page 0 is RAM 0 
1108+  F021 32 39 FF                        LD      (page_0_mapping), A
1109+  F024 3C                              INC     A
1110+  F025 D3 71                           OUT     (IO_MEM_1), A       ; Page 1 is RAM 1
1111+  F027 32 3A FF                        LD      (page_1_mapping), A
1112+  F02A 3C                              INC      A
1113+  F02B D3 72                           OUT     (IO_MEM_2), A       ; Page 2 is RAM 2 
1114+  F02D 32 3B FF                        LD      (page_2_mapping), A
1115+  F030 3C                              INC     A                   ; Assume we're in RAM 3
1116+  F031 32 3C FF                        LD      (page_3_mapping), A
1117+  F034             
1118+  F034 21 00 FE                        LD      HL, 0FE00h          ; Set up the IM 2 table
1119+  F037 06 00                           LD      B, 0
1120+  F039 36 FD       _fill_vector        LD      (HL), 0FDh
1121+  F03B 23                              INC     HL
1122+  F03C 10 FB                           DJNZ    _fill_vector
1123+  F03E             
1124+  F03E CD A5 F2                        CALL    keyboard_init       ; Set up the keyboard status tables
1125+  F041             
1126+  F041 3E C3                           LD      A, 0C3h             ; JP reset   instruction
1127+  F043 32 FD FD                        LD      (0FDFDh), A
1128+  F046 21 42 F1                        LD      HL, interrupt_handler
1129+  F049 22 FE FD                        LD      (0FDFEh), HL
1130+  F04C             
1131+  F04C 21 00 00                        LD      HL, 0
1132+  F04F 22 CF FF                        LD      (user_interrupt), HL
1133+  F052             
1134+  F052 3E 02                           LD      A, 2
1135+  F054 D3 13                           OUT     (PIO_B_CTRL),A      ; Zero interrupt vector
1136+  F056             
1137+  F056 3E B7                           LD      A, 0B7h             ; Enable interrupts on any of the following bits
1138+  F058 D3 13                           OUT     (PIO_B_CTRL),A
1139+  F05A 00                              NOP
1140+  F05B 3E CF                           LD      A, 0CFh             ; Just B5 (RTC interrupt) 
1141+  F05D D3 13                           OUT     (PIO_B_CTRL),A
1142+  F05F             
1143+  F05F 3E FE                           LD      A, 0FEh
1144+  F061 ED 47                           LD      I, A
1145+  F063 ED 5E                           IM      2
1146+  F065             
1147+  F065 CD BF F0                        CALL    setup_screen
1148+  F068             
1149+  F068 3E 04                           LD      A, DRIVE_A_PAGE
1150+  F06A 32 37 FF                        LD      (drive_a_mem_page), A
1151+  F06D             
1152+  F06D FB                              EI
1153+  F06E             
1154+  F06E 3E 00                           LD      A, 0
1155+  F070 CD 09 F5                        CALL    uart_init           ; Reinitialise the UART to make sure we've not missed anything
1156+  F073             
1157+  F073 CD D4 F8                        CALL    rtc_init            ; Make sure clock is running and reset time if necesary
1158+  F076             
1159+  F076 06 04       _set_ctrl           LD      B, 4                ; Set RTC Coarse mode and Output Pin to Square wave - gives 64 Hz pulse
1160+  F078 C5          _set_ctrl_loop      PUSH    BC
1161+  F079 26 6F                           LD      H, RTC_ADDRESS      
1162+  F07B 2E 07                           LD      L, RTC_REG_CTRL
1163+  F07D CD DB F5                        CALL    i2c_write_to
1164+  F080 30 0B                           JR      NC, _rtc_ack_error
1165+  F082 3E 44                           LD      A, RTC_64HZ_ENABLED
1166+  F084 CD EF F5                        CALL    i2c_write
1167+  F087 30 04                           JR      NC, _rtc_ack_error
1168+  F089 AF                              XOR     A
1169+  F08A CD EF F5                        CALL    i2c_write
1170+  F08D CD A3 F5    _rtc_ack_error      CALL    i2c_stop
1171+  F090             
1172+  F090 CD 9B F0                        CALL    _pause
1173+  F093             
1174+  F093 CD A0 F0                        CALL    _check_ctrl
1175+  F096 C1                              POP     BC
1176+  F097 C8                              RET     Z
1177+  F098 10 DE                           DJNZ    _set_ctrl_loop
1178+  F09A C9                              RET
1179+  F09B             
1180+  F09B 06 00       _pause              LD      B, 0
1181+  F09D 10 FE                           DJNZ    $
1182+  F09F C9                              RET
1183+  F0A0             
1184+  F0A0             ; Check that the control is set to coarse trim and 0 offset
1185+  F0A0             ; Returns with Zero flag set if settings are good.
1186+  F0A0             ;
1187+  F0A0 26 6F       _check_ctrl         LD      H, RTC_ADDRESS      
1188+  F0A2 2E 07                           LD      L, RTC_REG_CTRL
1189+  F0A4 CD BA F5                        CALL    i2c_read_from
1190+  F0A7 16 02                           LD      D, 2
1191+  F0A9 30 11                           JR      NC, _ctrl_error
1192+  F0AB 5F                              LD      E, A
1193+  F0AC CD 4D F6                        CALL    i2c_ack
1194+  F0AF CD 3A F6                        CALL    i2c_read
1195+  F0B2 57                              LD      D, A
1196+  F0B3 CD A3 F5                        CALL    i2c_stop
1197+  F0B6 7B                              LD      A, E
1198+  F0B7 06 04                           LD      B, 4
1199+  F0B9 FE 44                           CP      RTC_64HZ_ENABLED
1200+  F0BB C0                              RET     NZ
1201+  F0BC 7A          _ctrl_error         LD      A, D
1202+  F0BD A7                              AND     A
1203+  F0BE C9                              RET 
1204+  F0BF             
1205+  F0BF             ; SHOULD NOT BE CALLED WITH INTERRUPTS ENABLED!
1206+  F0BF             ;
1207+  F0BF 3E 40       setup_screen        LD      A, VIDEOBEAST_PAGE
1208+  F0C1 D3 71                           OUT     (IO_MEM_1), A
1209+  F0C3 21 00 40                        LD      HL, PAGE_1_START
1210+  F0C6 AF                              XOR     A
1211+  F0C7 47                              LD      B, A
1212+  F0C8 77          _videobeast_check   LD      (HL), A
1213+  F0C9 BE                              CP      (HL)
1214+  F0CA 20 2E                           JR      NZ, _no_videobeast
1215+  F0CC C6 0D                           ADD     A, 13
1216+  F0CE 10 F8                           DJNZ    _videobeast_check
1217+  F0D0             
1218+  F0D0 3E 40                           LD      A, VIDEOBEAST_PAGE
1219+  F0D2 32 28 F1                        LD      (_screen_defaults), A
1220+  F0D5 21 1E 50                        LD      HL, 0501Eh          ; 80 x 30 screen
1221+  F0D8 22 2E F1                        LD      (_screen_size), HL
1222+  F0DB             
1223+  F0DB 3E F3                           LD      A, VB_UNLOCK
1224+  F0DD 32 FE 7F                        LD      (VB_REGISTERS_LOCKED), A
1225+  F0E0 3E 01                           LD      A, MODE_848 | MODE_MAP_16K
1226+  F0E2 32 FF 7F                        LD      (VB_MODE), A
1227+  F0E5 AF                              XOR     A
1228+  F0E6 32 F9 7F                        LD      (VB_PAGE_0), A
1229+  F0E9 32 D0 7F                        LD      (VB_LAYER_5), A             ; Clear page 'above' our console
1230+  F0EC             
1231+  F0EC 21 36 F1                        LD      HL, _videobeast
1232+  F0EF 11 C0 7F                        LD      DE, VB_LAYER_4
1233+  F0F2 01 0C 00                        LD      BC, _videobeast_length
1234+  F0F5 ED B0                           LDIR
1235+  F0F7 32 FE 7F                        LD      (VB_REGISTERS_LOCKED), A  ; Lock registers
1236+  F0FA             
1237+  F0FA 11 29 FF    _no_videobeast      LD      DE, screen_page     ; Copy the startup defaults to the shared_data area
1238+  F0FD 21 28 F1                        LD      HL, _screen_defaults
1239+  F100 01 0E 00                        LD      BC, _defaults_length
1240+  F103 ED B0                           LDIR
1241+  F105 3A 29 FF                        LD      A, (screen_page)    ; Clear the screen buffer
1242+  F108 D3 71                           OUT     (IO_MEM_1), A       ; Screen buffer is in PAGE_1
1243+  F10A 21 00 40                        LD      HL, PAGE_1_START
1244+  F10D 11 02 40                        LD      DE, PAGE_1_START+2
1245+  F110 0E 20                           LD      C, ' '
1246+  F112 3A 31 FF                        LD      A, (console_colour)
1247+  F115 47                              LD      B, A
1248+  F116 ED 43 00 40                     LD      (PAGE_1_START), BC
1249+  F11A 01 FA 3F                        LD      BC, 16378           ; Don't over write last couple of bytes (VideoBeast)
1250+  F11D ED B0                           LDIR
1251+  F11F             
1252+  F11F CD 06 F8                        CALL    disp_clear          ; Clear the LED screen
1253+  F122             
1254+  F122 3A 3A FF    restore_page_return LD      A, (page_1_mapping)       ; Return Page 1 to normal RAM
1255+  F125 D3 71                           OUT     (IO_MEM_1), A
1256+  F127 C9                              RET
1257+  F128             
1258+  F128 24          _screen_defaults    .DB     CONSOLE_PAGE        ; Screen buffer page
1259+  F129 00                              .DB     0                   ; Row offset in buffer
1260+  F12A 00 00                           .DB     0,0                 ; Row, column being shown on LED Display
1261+  F12C 01 01                           .DB     1,1                 ; Row, column of cursor
1262+  F12E 18 40       _screen_size        .DB     24,64               ; Console height (rows), width (columns)
1263+  F130 F0                              .DB     0F0h                ; Current colour [7:4] = background, [3:0] = foreground
1264+  F131 02                              .DB     CFLAGS_TRACK_CURSOR ; Flags
1265+  F132 00                              .DB     0                   ; Timer
1266+  F133 00 00                           .DB     0, 0                ; Escape char and first parameter
1267+  F135 00                              .DB     0                   ; Disable identifier sequence
1268+  F136             _defaults_length    .EQU    $-_screen_defaults
1269+  F136             
1270+  F136 01 01 1E 02 _videobeast         .DB     TYPE_TEXT, 1, 30, 2, 81         ; Text, top, bottom, left, right
1270+  F13A 51 
1271+  F13B 00 00 00                        .DB     0, 0, 0                         ; No scroll
1272+  F13E 00 10                           .DB     0, 010h                         ; Char map in page 0, font 16x2K -> 32K
1273+  F140 07 00                           .DB     7, 0                            ; Palette 0, no hi-res
1274+  F142             _videobeast_length  .EQU    $-_videobeast
1275+  F142             
1276+  F142 F3          interrupt_handler   DI
1277+  F143 ED 73 CD FF                     LD      (intr_stack), SP
1278+  F147 31 CD FF                        LD      SP, intr_stack
1279+  F14A F5                              PUSH    AF
1280+  F14B D9                              EXX
1281+  F14C CD BB F2                        CALL    keyboard_poll
1282+  F14F             
1283+  F14F 3A 13 FF                        LD      A,(control_key_pressed)
1284+  F152 A7                              AND     A
1285+  F153 C4 A4 F1                        CALL    NZ, handle_screen_shift
1286+  F156             
1287+  F156 3A 33 FF                        LD      A, (console_timer)
1288+  F159 3D                              DEC     A
1289+  F15A FA 6D F1                        JP      M, _not_moved
1290+  F15D 32 33 FF                        LD      (console_timer), A
1291+  F160 20 0B                           JR      NZ, _not_moved
1292+  F162             
1293+  F162 3A 32 FF                        LD      A, (console_flags)
1294+  F165 E6 FB                           AND     ~CFLAGS_SHOW_MOVED
1295+  F167 32 32 FF                        LD      (console_flags), A
1296+  F16A CD DB ED                        CALL    unsafe_redraw
1297+  F16D             
1298+  F16D 2A 04 FF    _not_moved          LD      HL, (timer)
1299+  F170 5D                              LD      E, L                ; E is old low byte of timer - used to blink cursor
1300+  F171 23                              INC     HL
1301+  F172 22 04 FF                        LD      (timer), HL
1302+  F175 7C                              LD      A, H
1303+  F176 B5                              OR      L
1304+  F177 20 07                           JR      NZ, _timer_done
1305+  F179 2A 06 FF                        LD      HL, (timer+2)
1306+  F17C 23                              INC     HL
1307+  F17D 22 06 FF                        LD      (timer+2),HL   
1308+  F180             
1309+  F180 3A 32 FF    _timer_done         LD      A, (console_flags)
1310+  F183 E6 01                           AND     CFLAGS_SHOW_CURSOR
1311+  F185 28 0B                           JR      Z, _int_done
1312+  F187             
1313+  F187 3A 04 FF                        LD      A, (timer)          ; Blink when timer bit changes
1314+  F18A AB                              XOR     E
1315+  F18B E6 20                           AND     020h
1316+  F18D 28 03                           JR      Z, _int_done
1317+  F18F CD 3F F2                        CALL    update_cursor
1318+  F192             
1319+  F192 2A CF FF    _int_done           LD      HL, (user_interrupt)
1320+  F195 7C                              LD      A, H
1321+  F196 B5                              OR      L
1322+  F197 C4 A3 F1                        CALL    NZ, _do_usr_interrupt
1323+  F19A             
1324+  F19A D9                              EXX
1325+  F19B F1                              POP     AF
1326+  F19C ED 7B CD FF                     LD      SP, (intr_stack)
1327+  F1A0 FB                              EI
1328+  F1A1 ED 4D       _do_reti            RETI
1329+  F1A3             
1330+  F1A3 E9          _do_usr_interrupt   JP      (HL)
1331+  F1A4             
1332+  F1A4             ; Enter with A containing a special control character
1333+  F1A4             ;
1334+  F1A4             ;
1335+  F1A4 FE 90       handle_screen_shift CP      KEY_CTRL_UP
1336+  F1A6 20 25                           JR      NZ, _not_ctrl_up
1337+  F1A8             
1338+  F1A8 3A 2B FF                        LD      A, (display_row)
1339+  F1AB 3D                              DEC     A
1340+  F1AC FA 3A F2                        JP      M, _shift_done
1341+  F1AF F5          _shift_row          PUSH    AF
1342+  F1B0 1E 00                           LD      E, 0
1343+  F1B2 CD 3F F2                        CALL    update_cursor
1344+  F1B5 F1                              POP     AF
1345+  F1B6 32 2B FF                        LD      (display_row), A
1346+  F1B9             
1347+  F1B9 3A 32 FF    _shift_complete     LD      A, (console_flags)
1348+  F1BC E6 FD                           AND     ~CFLAGS_TRACK_CURSOR
1349+  F1BE F6 04       _flags_and_redraw   OR      CFLAGS_SHOW_MOVED
1350+  F1C0 32 32 FF                        LD      (console_flags), A
1351+  F1C3 3E 3C                           LD      A, SHOW_MOVE_DELAY
1352+  F1C5 32 33 FF                        LD      (console_timer),A
1353+  F1C8 CD E1 ED                        CALL    unsafe_led_redraw       ; Always redraw regardless of LED status
1354+  F1CB 18 6D                           JR      _shift_done
1355+  F1CD             
1356+  F1CD FE 91       _not_ctrl_up        CP      KEY_CTRL_DOWN
1357+  F1CF 20 0D                           JR      NZ, _not_ctrl_down
1358+  F1D1             
1359+  F1D1 3A 2F FF    _shift_down         LD      A, (console_height)
1360+  F1D4 4F                              LD      C, A
1361+  F1D5 3A 2B FF                        LD      A, (display_row)
1362+  F1D8 3C                              INC     A
1363+  F1D9 B9                              CP      C
1364+  F1DA 28 5E                           JR      Z, _shift_done
1365+  F1DC 18 D1                           JR      _shift_row
1366+  F1DE             
1367+  F1DE FE 93       _not_ctrl_down      CP      KEY_CTRL_RIGHT
1368+  F1E0 20 0F                           JR      NZ, _not_ctrl_right
1369+  F1E2             
1370+  F1E2 3A 30 FF                        LD      A, (console_width)
1371+  F1E5 D6 17                           SUB     DISPLAY_WIDTH-1
1372+  F1E7 4F                              LD      C, A
1373+  F1E8 3A 2C FF                        LD      A, (display_col)
1374+  F1EB 3C                              INC     A
1375+  F1EC B9                              CP      C
1376+  F1ED 28 4B                           JR      Z, _shift_done
1377+  F1EF 18 0B                           JR      _shift_col
1378+  F1F1             
1379+  F1F1 FE 92       _not_ctrl_right     CP      KEY_CTRL_LEFT
1380+  F1F3 20 13                           JR      NZ, _not_ctrl_left
1381+  F1F5             
1382+  F1F5 3A 2C FF                        LD      A, (display_col)
1383+  F1F8 3D                              DEC     A
1384+  F1F9 FA 3A F2                        JP      M, _shift_done
1385+  F1FC F5          _shift_col          PUSH    AF
1386+  F1FD 1E 00                           LD      E, 0
1387+  F1FF CD 3F F2                        CALL    update_cursor
1388+  F202 F1                              POP     AF
1389+  F203 32 2C FF                        LD      (display_col), A
1390+  F206 18 B1                           JR      _shift_complete
1391+  F208             
1392+  F208 FE 94       _not_ctrl_left      CP      KEY_CTRL_ENTER
1393+  F20A 20 19                           JR      NZ, _not_ctrl_enter
1394+  F20C 3A 2D FF                        LD      A, (cursor_row)
1395+  F20F 3D                              DEC     A
1396+  F210 32 2B FF                        LD      (display_row), A
1397+  F213 3A 2E FF                        LD      A, (cursor_col)
1398+  F216 D6 16                           SUB     DISPLAY_WIDTH-2
1399+  F218 30 01                           JR      NC, _col_ok
1400+  F21A AF                              XOR     A
1401+  F21B             
1402+  F21B 32 2C FF    _col_ok             LD      (display_col), A
1403+  F21E 3A 32 FF                        LD      A, (console_flags)
1404+  F221 F6 02                           OR      CFLAGS_TRACK_CURSOR
1405+  F223 18 99                           JR      _flags_and_redraw
1406+  F225             
1407+  F225 FE 95       _not_ctrl_enter     CP      KEY_CTRL_SPACE
1408+  F227 20 06                           JR      NZ, _not_ctrl_space
1409+  F229             
1410+  F229 AF                              XOR     A
1411+  F22A 32 2C FF                        LD      (display_col), A
1412+  F22D 18 A2                           JR      _shift_down
1413+  F22F             
1414+  F22F FE 96       _not_ctrl_space     CP      KEY_CTRL_D
1415+  F231 20 07                           JR      NZ, _shift_done
1416+  F233             
1417+  F233 3A 32 FF                        LD      A, (console_flags)
1418+  F236 EE 20                           XOR     CFLAGS_LED_OFF
1419+  F238 18 84                           JR      _flags_and_redraw
1420+  F23A             
1421+  F23A AF          _shift_done         XOR     A
1422+  F23B 32 13 FF                        LD      (control_key_pressed),A
1423+  F23E C9                              RET
1424+  F23F             
1425+  F23F             ;
1426+  F23F             ; Blinks the cursor 
1427+  F23F             ;  Enter with E = timer low byte. 
1428+  F23F             ;  If CURSOR_BIT is 1, show the cursor at the line, otherwise restore the existing character
1429+  F23F             ;
1430+  F23F 3A 2B FF    update_cursor       LD      A, (display_row)    ; Are we on the same row as the cursor?
1431+  F242 47                              LD      B, A
1432+  F243 3A 2D FF                        LD      A, (cursor_row)
1433+  F246 3D                              DEC     A
1434+  F247 B8                              CP      B
1435+  F248 C0                              RET     NZ
1436+  F249             
1437+  F249 3A 2C FF                        LD      A, (display_col)    ; Check the cursor column is within the display window
1438+  F24C 47                              LD      B, A
1439+  F24D 3A 2E FF                        LD      A, (cursor_col)
1440+  F250 3D                              DEC     A
1441+  F251 90                              SUB     B
1442+  F252 F8                              RET     M
1443+  F253             
1444+  F253 06 00                           LD      B, 0
1445+  F255 4F                              LD      C, A
1446+  F256             
1447+  F256 3A 29 FF                        LD      A, (screen_page)
1448+  F259 FE 40                           CP      VIDEOBEAST_PAGE
1449+  F25B 20 2E                           JR      NZ, _skip_videobeast
1450+  F25D             
1451+  F25D D3 71                           OUT     (IO_MEM_1), A
1452+  F25F             
1453+  F25F 3A 2A FF                        LD      A, (screen_offset)
1454+  F262 67                              LD      H, A
1455+  F263 3A 2D FF                        LD      A, (cursor_row)         ; 1 based
1456+  F266 3D                              DEC     A
1457+  F267 84                              ADD     A, H
1458+  F268 E6 3F                           AND     03Fh
1459+  F26A F6 40                           OR      040h                    ; Page 1 for videobeast
1460+  F26C 67                              LD      H, A
1461+  F26D 3A 2E FF                        LD      A, (cursor_col)
1462+  F270 3D                              DEC     A
1463+  F271 87                              ADD     A, A
1464+  F272 6F                              LD      L, A
1465+  F273 2C                              INC     L
1466+  F274             
1467+  F274 7B                              LD      A, E
1468+  F275 E6 20                           AND     20h
1469+  F277 3A 31 FF                        LD      A, (console_colour)
1470+  F27A 28 08                           JR      Z, _normal
1471+  F27C CB 0F                           RRC     A 
1472+  F27E CB 0F                           RRC     A
1473+  F280 CB 0F                           RRC     A
1474+  F282 CB 0F                           RRC     A
1475+  F284 77          _normal             LD      (HL), A
1476+  F285             
1477+  F285 2B                              DEC     HL
1478+  F286 3A 3A FF                        LD      A, (page_1_mapping)
1479+  F289 D3 71                           OUT     (IO_MEM_1), A
1480+  F28B             
1481+  F28B 79          _skip_videobeast    LD      A, C
1482+  F28C FE 18                           CP      DISPLAY_WIDTH
1483+  F28E D0                              RET     NC
1484+  F28F             
1485+  F28F 3A 32 FF                        LD      A, (console_flags)
1486+  F292 E6 20                           AND     CFLAGS_LED_OFF
1487+  F294 C0                              RET     NZ
1488+  F295             
1489+  F295                                 ; At this point, BC holds the current display column for the cursor..
1490+  F295 21 85 FF                        LD      HL, display_buffer
1491+  F298 09                              ADD     HL, BC
1492+  F299 09                              ADD     HL, BC
1493+  F29A             
1494+  F29A 7B                              LD      A, E
1495+  F29B E6 20                           AND     20h
1496+  F29D 7E                              LD      A, (HL)
1497+  F29E 28 02                           JR      Z, _unblink
1498+  F2A0 3E 5F                           LD      A, '_'
1499+  F2A2 C3 A3 F7    _unblink            JP    disp_character
1500+  F2A5             
1501+  F2A5                                 .INCLUDE "../ports.asm"
0001++ F2A5             ;
0002++ F2A5             ; Port definintions
0003++ F2A5             ;
0004++ F2A5             ;
0005++ F2A5             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006++ F2A5             ;
0007++ F2A5             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008++ F2A5             ;
0009++ F2A5             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010++ F2A5             ; of this software and associated documentation files (the "Software"), to deal
0011++ F2A5             ; in the Software without restriction, including without limitation the rights
0012++ F2A5             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013++ F2A5             ; copies of the Software, and to permit persons to whom the Software is
0014++ F2A5             ; furnished to do so, subject to the following conditions:
0015++ F2A5             ; 
0016++ F2A5             ; The above copyright notice and this permission notice shall be included in all
0017++ F2A5             ; copies or substantial portions of the Software.
0018++ F2A5             ; 
0019++ F2A5             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020++ F2A5             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021++ F2A5             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022++ F2A5             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023++ F2A5             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024++ F2A5             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025++ F2A5             ; SOFTWARE.
0026++ F2A5             ;
0027++ F2A5             
0028++ F2A5             BACKSPACE_CHAR      .EQU  08h
0029++ F2A5             CARRIAGE_RETURN     .EQU  0Dh
0030++ F2A5             NEWLINE             .EQU  0Ah
0031++ F2A5             ESCAPE_CHAR         .EQU  1Bh
0032++ F2A5             CPM_NUM             .EQU  1Fh
0033++ F2A5             
0034++ F2A5             ;=================================== UART ============================================
0035++ F2A5             UART_TX_RX          .EQU    020h    ; Read: receiver buffer, Write: transmitter buffer
0036++ F2A5             UART_INT_ENABLE     .EQU    021h    ; Interrupt enable register
0037++ F2A5             UART_INT_ID         .EQU    022h    ; Read: Interrupt identification register
0038++ F2A5             UART_FIFO_CTRL      .EQU    022h    ; Write: FIFO Control register
0039++ F2A5             UART_LINE_CTRL      .EQU    023h    ; Line control register
0040++ F2A5             UART_MODEM_CTRL     .EQU    024h    ; Modem control
0041++ F2A5             UART_LINE_STATUS    .EQU    025h    ; Line status
0042++ F2A5             UART_MODEM_STATUS   .EQU    026h    ; Modem status
0043++ F2A5             UART_SCRATCH        .EQU    027h    ; Scratch register
0044++ F2A5             
0045++ F2A5             ;==================================== PIO ============================================
0046++ F2A5             PIO_A_DATA          .EQU  010h
0047++ F2A5             PIO_A_CTRL          .EQU  012h
0048++ F2A5             
0049++ F2A5             PIO_B_DATA          .EQU  011h
0050++ F2A5             PIO_B_CTRL          .EQU  013h
0051++ F2A5             
0052++ F2A5             PIO_MODE_0          .EQU  00Fh      ; Mode 0: All outputs
0053++ F2A5             PIO_MODE_1          .EQU  04fh      ; Mode 1: All inputs
0054++ F2A5             PIO_MODE_2          .EQU  080h      ; Mode 2 (Port A only): Bi-directional
0055++ F2A5             PIO_MODE_3          .EQU  0CFh      ; Mode 3: Per-pin I/O on the given port - write an additional word with bits set (1) for input, reset (0) for output on the matching pin.
0056++ F2A5             
0057++ F2A5             PIO_SET_INTERRUPT   .EQU  007h      ; Set interrupt control world. By itself, this wil disable interrupts on the given port. OR with the following constants to change this
0058++ F2A5             PIO_ENABLE_INT      .EQU  080h      ; Enable interrupts on the given port, when OR'd with the PIO_SET_INTERRUPT control word.
0059++ F2A5             PIO_INT_MASK        .EQU  010h      ; When OR'd with the PIO_SET_INTERRUPT control word, the following word will enable interrupts for pins where the matching bit is zero
0060++ F2A5             
0061++ F2A5             ;================================== AUDIO ============================================
0062++ F2A5             ; Constants for Audio output
0063++ F2A5             AUDIO_PIO           .EQU  1         ; Audio on PIO (rev. 0.1 boards)
0064++ F2A5             AUDIO_UART          .EQU  2         ; Audio on UART (rev. 0.2 boards)
0065++ F2A5             
0066++ F2A5             AUDIO_VERSION       .EQU  AUDIO_UART
0067++ F2A5             
0068++ F2A5~            #IF AUDIO_VERSION = AUDIO_PIO
0069++ F2A5~            PORT_B_IOMASK       .EQU  0EFh      ; All inputs, apart from bit 4 (audio out)
0070++ F2A5~            AUDIO_MASK          .EQU  010h      ; Bitmask for audio output on Port B. The bit is set for the output pin.
0071++ F2A5~            AUDIO_PORT          .EQU  PIO_B_DATA
0072++ F2A5~            
0073++ F2A5             #ELSE
0074++ F2A5             PORT_B_IOMASK       .EQU  0FFh      ; All inputs
0075++ F2A5             AUDIO_MASK          .EQU  008h      ; Bitmask for audio output on UART Out 2. The bit is set for the output pin
0076++ F2A5             AUDIO_PORT          .EQU  UART_MODEM_CTRL
0077++ F2A5             
0078++ F2A5             #ENDIF
0079++ F2A5             
0080++ F2A5             
0081++ F2A5             ;=================================== MEMORY PAGING ===================================
0082++ F2A5             IO_MEM_0            .EQU    070h      ; Page 0: 0000h - 3fffh
0083++ F2A5             IO_MEM_1            .EQU    071h      ; Page 1: 4000h - 7fffh
0084++ F2A5             IO_MEM_2            .EQU    072h      ; Page 2: 8000h - bfffh
0085++ F2A5             IO_MEM_3            .EQU    073h      ; Page 3: c000h - ffffh
0086++ F2A5             
0087++ F2A5             IO_MEM_CTRL         .EQU    074h      ; Paging enable register
0088++ F2A5             IO_MEM_ENABLE       .EQU    1
0089++ F2A5             IO_MEM_DISABLE      .EQU    0 
0090++ F2A5             
0091++ F2A5             RAM_PAGE_0          .EQU    020h
0092++ F2A5             RAM_PAGE_1          .EQU    021h
0093++ F2A5             RAM_PAGE_2          .EQU    022h
0094++ F2A5             RAM_PAGE_3          .EQU    023h
0095++ F2A5             
0096++ F2A5             RAM_PAGE_16         .EQU    030h
0097++ F2A5             RAM_PAGE_31         .EQU    03Fh
0098++ F2A5             
0099++ F2A5             ROM_PAGE_0          .EQU    000h
0100++ F2A5             ROM_PAGE_16         .EQU    010h
0101++ F2A5             
0102++ F2A5             PAGE_1_START        .EQU    4000h
0103++ F2A5             
0104++ F2A5             ;====================================== I2C DEVICES ===================================
0105++ F2A5             I2C_DATA_BIT            .equ    7
0106++ F2A5             I2C_CLK_BIT             .equ    6
0107++ F2A5             
0108++ F2A5             I2C_DATA_MASK           .equ    1 << I2C_DATA_BIT
0109++ F2A5             I2C_CLK_MASK            .equ    1 << I2C_CLK_BIT
0110++ F2A5             
0111++ F2A5             ; Display
0112++ F2A5             ;==========
0113++ F2A5             DL_ADDRESS              .EQU    050h     ; Left  Matrix controller I2C address
0114++ F2A5             DR_ADDRESS              .EQU    053h     ; Right Matrix controller I2C address
0115++ F2A5             
0116++ F2A5             DISP_REG_CRWL           .EQU    0FEh     ; Command Register write lock
0117++ F2A5             DISP_UNLOCK             .EQU    0C5h     ; Unlock command
0118++ F2A5             
0119++ F2A5             DISP_DEFAULT_BRIGHTNESS .EQU    080h     ; Default brightness
0120++ F2A5             DISP_DIMMED             .EQU    018h     ; Dimmed
0121++ F2A5             
0122++ F2A5             DISPLAY_WIDTH           .EQU    24       ; 24 characters
0123++ F2A5             
0124++ F2A5             ; RTC
0125++ F2A5             ;==========
0126++ F2A5             RTC_ADDRESS             .EQU    06fh
0127++ F2A5             
0128++ F2A5             RTC_REG_SEC             .EQU    000h    ; Also has oscillator enable bit in B7, 1 = run
0129++ F2A5             RTC_REG_MIN             .EQU    001h
0130++ F2A5             RTC_REG_HOUR            .EQU    002h    ; B6: 1 = 12hr/ 0 = 24hr clock (r/w) 
0131++ F2A5                                                     ;        If 12 hr clock, B5: 1 = PM/ 0 = AM. B4: hour tens. Otherwise B5-4: hour tens, B3-0: hour units
0132++ F2A5             RTC_REG_WKDAY           .EQU    003h    ; Oscillator status bit in B5, 1 = enabled and running. 
0133++ F2A5                                                     ;   B4: 1 = power was lost, write 0 to clear (timestamp registers are set)
0134++ F2A5                                                     ;   B3: 1 = enable external battery supply (VBAT)
0135++ F2A5                                                     ;   B2-0: Weekday, from 1 to 7 
0136++ F2A5             RTC_REG_DATE            .EQU    004h    ; BCD Date (1 to 31)
0137++ F2A5             RTC_REG_MTH             .EQU    005h    ; B5: 1 = Leap year (read only). B4: month tens, B3-0: month units  (Month is 1 to 12)
0138++ F2A5             RTC_REG_YEAR            .EQU    006h    ; BCD Year
0139++ F2A5             
0140++ F2A5             RTC_REG_CTRL            .EQU    007h    ; B7: If Square wave and Alarm 0 and Alarm 1 are disabled, sets Output Pin level
0141++ F2A5                                                     ;   B6: SQWEN, 1 = Enable square wave on Output Pin, Alarms disabled
0142++ F2A5                                                     ;   B5, B4: Alarm 1, 0 Enable. 1 = Alarm is enabled
0143++ F2A5                                                     ;   B3: 1 = Use external oscillator
0144++ F2A5                                                     ;   B2: CRSTRIM, 1 = Coarse trim mode, Output pin is 64Hz
0145++ F2A5                                                     ;   B1-0: If SQWEN = 1 & CRSTRIM = 0, sets Output pin freq. 00 -> 1Hz, 01 -> 4.096kHz, 10 -> 8.192kHz, 11 -> 32.768kHz
0146++ F2A5             RTC_REG_TRIM            .EQU    008h    ; Trim, initially 0. B7: Sign, 1=Add, 0=Subtract clock cycles.  
0147++ F2A5                                                     ;   B6-0: Trim amount/2. Applied 1 every minute in fine trim, 128 times a second in coarse trim mode. 0 = disable trim
0148++ F2A5             
0149++ F2A5             RTC_64HZ_ENABLED        .EQU    044h    ; Value for RTC_REG_CTRL to enable 64Hz interrupt output
0150++ F2A5             
0151++ F2A5             RTC_WEEKDAY_RUNNING     .EQU    008h    ; Value for RTC_REG_WKDAY for normall running of clock1502+  F2A5             
1503+  F2A5                                 .INCLUDE "../io.asm"
0001++ F2A5             ;
0002++ F2A5             ; I/O routines.. specifically keyboard and serial
0003++ F2A5             ;
0004++ F2A5             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ F2A5             ;
0006++ F2A5             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ F2A5             ;
0008++ F2A5             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ F2A5             ; of this software and associated documentation files (the "Software"), to deal
0010++ F2A5             ; in the Software without restriction, including without limitation the rights
0011++ F2A5             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ F2A5             ; copies of the Software, and to permit persons to whom the Software is
0013++ F2A5             ; furnished to do so, subject to the following conditions:
0014++ F2A5             ; 
0015++ F2A5             ; The above copyright notice and this permission notice shall be included in all
0016++ F2A5             ; copies or substantial portions of the Software.
0017++ F2A5             ; 
0018++ F2A5             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ F2A5             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ F2A5             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ F2A5             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ F2A5             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ F2A5             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ F2A5             ; SOFTWARE.
0025++ F2A5             ;
0026++ F2A5             
0027++ F2A5             
0028++ F2A5 21 08 FF    keyboard_init       LD      HL, keyboard_state
0029++ F2A8 06 20                           LD      B, io_data_end - keyboard_state
0030++ F2AA AF                              XOR     A
0031++ F2AB 77          _init_loop          LD      (HL),A
0032++ F2AC 23                              INC     HL
0033++ F2AD 05                              DEC     B
0034++ F2AE 20 FB                           JR      NZ, _init_loop
0035++ F2B0 AF                              XOR     A
0036++ F2B1 32 28 FF                        LD      (input_size),A
0037++ F2B4 32 27 FF                        LD      (input_free),A
0038++ F2B7 32 26 FF                        LD      (input_pos),A
0039++ F2BA C9                              RET
0040++ F2BB             
0041++ F2BB             ; Poll the keyboard, adding raw codes to the keyboard_state buffer, and decoded characters to the input_buffer
0042++ F2BB             ;
0043++ F2BB 01 00 FD    keyboard_poll       LD      BC, 0FD00h          ; Check shift key
0044++ F2BE 3A 12 FF                        LD      A, (key_shift_state)
0045++ F2C1 E6 FC                           AND     ~(KEY_SHIFT_BIT | KEY_CTRL_BIT)
0046++ F2C3 57                              LD      D, A
0047++ F2C4             
0048++ F2C4 ED 78                           IN      A, (C)
0049++ F2C6 E6 20                           AND     020h
0050++ F2C8 20 04                           JR      NZ, _check_ctrl_key
0051++ F2CA 3E 01                           LD      A, KEY_SHIFT_BIT
0052++ F2CC B2                              OR      D
0053++ F2CD 57                              LD      D, A
0054++ F2CE             
0055++ F2CE 01 00 FE    _check_ctrl_key     LD      BC, 0FE00h          ; Keyboard row 0
0056++ F2D1 ED 78                           IN      A, (C)
0057++ F2D3 E6 10                           AND     010h
0058++ F2D5 20 04                           JR      NZ, _store_modifiers
0059++ F2D7 3E 02                           LD      A, KEY_CTRL_BIT
0060++ F2D9 B2                              OR      D
0061++ F2DA 57                              LD      D, A
0062++ F2DB             
0063++ F2DB 7A          _store_modifiers    LD      A, D
0064++ F2DC 32 12 FF                        LD      (key_shift_state), A
0065++ F2DF             
0066++ F2DF             
0067++ F2DF 21 49 F4                        LD      HL, keyboard
0068++ F2E2 ED 78       _poll_loop          IN      A, (C)              ; BC -> Keyboard row port..
0069++ F2E4 16 01                           LD      D, 1                ; D -> Current Bit
0070++ F2E6 5F                              LD      E, A                ; E -> Key row bit set
0071++ F2E7 22 10 FF    _next_key           LD      (keyboard_pos), HL
0072++ F2EA A2                              AND     D
0073++ F2EB 20 3F                           JR      NZ, _released
0074++ F2ED                                                             ; Key is pressed... add it to state buffer
0075++ F2ED C5                              PUSH    BC
0076++ F2EE 7E                              LD      A, (HL)             ; Raw key code in A
0077++ F2EF             
0078++ F2EF 21 08 FF                        LD      HL, keyboard_state
0079++ F2F2 06 08                           LD      B, _key_state_size
0080++ F2F4 BE          _check_pressed      CP      (HL)
0081++ F2F5 CA 45 F3                        JP      Z, _do_nothing      ; Key already in state table - nothing to do..
0082++ F2F8 23                              INC     HL
0083++ F2F9 05                              DEC     B
0084++ F2FA 20 F8                           JR      NZ, _check_pressed
0085++ F2FC                                                             ; Key wasn't pressed, so add it to the first free slot
0086++ F2FC 21 08 FF                        LD      HL, keyboard_state
0087++ F2FF 06 08                           LD      B, _key_state_size
0088++ F301 4F                              LD      C, A
0089++ F302 AF                              XOR     A
0090++ F303 BE          _find_free          CP      (HL)
0091++ F304 28 07                           JR      Z, _key_pressed
0092++ F306 23                              INC     HL
0093++ F307 05                              DEC     B
0094++ F308 20 F9                           JR      NZ, _find_free
0095++ F30A C3 45 F3                        JP      _do_nothing         ; No free slots, so ignore the key
0096++ F30D             
0097++ F30D 71          _key_pressed        LD      (HL), C             ; Found free slot, store the raw key code
0098++ F30E             
0099++ F30E                                 ; Reset repeat counter       
0100++ F30E             
0101++ F30E 2A 10 FF                        LD      HL, (keyboard_pos)  ; Get the current keyboard character location
0102++ F311 01 30 00                        LD      BC, _keyboard_size
0103++ F314 3A 12 FF                        LD      A, (key_shift_state)
0104++ F317 A7                              AND     A
0105++ F318 28 04                           JR      Z, _got_keycode
0106++ F31A 09          _modifier_offset    ADD     HL, BC
0107++ F31B 3D                              DEC     A
0108++ F31C 20 FC                           JR      NZ, _modifier_offset
0109++ F31E             
0110++ F31E 7E          _got_keycode        LD      A, (HL) 
0111++ F31F 32 14 FF                        LD      (last_keycode), A
0112++ F322 CD 75 F3                        CALL    _store_key
0113++ F325 AF                              XOR     A
0114++ F326 32 15 FF                        LD      (key_repeat_time), A
0115++ F329             
0116++ F329 C1                              POP     BC
0117++ F32A 18 1A                           JR      _poll_next
0118++ F32C             
0119++ F32C                                                             ; Key is not pressed... remove it from the state buffer if it was pressed (key up event)
0120++ F32C                                                             ; TODO: This is rather inefficient...
0121++ F32C C5          _released           PUSH    BC
0122++ F32D 7E                              LD      A, (HL)             ; Raw key code in A
0123++ F32E A7                              AND     A
0124++ F32F 28 14                           JR      Z, _do_nothing      ; Ignore character zero
0125++ F331             
0126++ F331 21 08 FF                        LD      HL, keyboard_state
0127++ F334 06 08                           LD      B, _key_state_size
0128++ F336 BE          _check_released     CP      (HL)
0129++ F337 28 06                           JR      Z, _handle_release
0130++ F339 23                              INC     HL
0131++ F33A 05                              DEC     B
0132++ F33B 20 F9                           JR      NZ, _check_released
0133++ F33D 18 06                           JR      _do_nothing         ; Code not in state buffer, not released
0134++ F33F             
0135++ F33F 4F          _handle_release     LD      C, A
0136++ F340 AF                              XOR     A
0137++ F341 77                              LD      (HL), A             ; Remove it from the buffer 
0138++ F342 32 14 FF                        LD      (last_keycode), A
0139++ F345                                                             ; TODO: We should probably tell someone about this...
0140++ F345 C1          _do_nothing         POP     BC
0141++ F346             
0142++ F346 2A 10 FF    _poll_next          LD      HL, (keyboard_pos)
0143++ F349 7B                              LD      A, E                ; Get the bitmask back
0144++ F34A 23                              INC     HL
0145++ F34B CB 22                           SLA     D
0146++ F34D CB 72                           BIT     6, D
0147++ F34F CA E7 F2                        JP      Z, _next_key
0148++ F352             
0149++ F352 CB 00                           RLC     B                   ; Move to the next key row
0150++ F354 3E FE                           LD      A, 0FEh
0151++ F356 B8                              CP      B
0152++ F357 C2 E2 F2                        JP      NZ, _poll_loop
0153++ F35A             
0154++ F35A 3A 14 FF                        LD      A, (last_keycode)
0155++ F35D A7                              AND     A
0156++ F35E C8                              RET     Z
0157++ F35F 3A 15 FF                        LD      A, (key_repeat_time)
0158++ F362 3C                              INC     A
0159++ F363 32 15 FF                        LD      (key_repeat_time), A
0160++ F366 FE 28                           CP      KEY_REPEAT_DELAY
0161++ F368 28 08                           JR      Z, _do_repeat
0162++ F36A FE 2F                           CP      KEY_REPEAT_AFTER
0163++ F36C C0                              RET     NZ
0164++ F36D 3E 28                           LD      A, KEY_REPEAT_DELAY
0165++ F36F 32 15 FF                        LD      (key_repeat_time),A
0166++ F372 3A 14 FF    _do_repeat          LD      A, (last_keycode)
0167++ F375             
0168++ F375             
0169++ F375             ; Store the decoded keycode in A to the relevant buffer...
0170++ F375 4F          _store_key          LD      C, A
0171++ F376 E6 F8                           AND     CTRL_KEY_MASK       ; Check for special control characters 
0172++ F378 FE 90                           CP      CTRL_KEY_CHECK
0173++ F37A 20 05                           JR      NZ, _get_key
0174++ F37C             
0175++ F37C 79                              LD      A, C                ; Store them in a separate location
0176++ F37D 32 13 FF                        LD      (control_key_pressed), A
0177++ F380 C9                              RET
0178++ F381                                                             ; Write the character to the input buffer
0179++ F381 79          _get_key            LD      A, C                ; Get the actual character...
0180++ F382 A7                              AND     A                   ; Skip blank character codes
0181++ F383 C8                              RET     Z
0182++ F384             
0183++ F384 6F                              LD      L, A                ; Store it in L
0184++ F385             
0185++ F385 3A 28 FF                        LD      A, (input_size)     ; Now check we have space
0186++ F388 FE 10                           CP      _input_buffer_size
0187++ F38A C8                              RET     Z
0188++ F38B             
0189++ F38B 3C                              INC     A
0190++ F38C 32 28 FF                        LD      (input_size), A
0191++ F38F             
0192++ F38F 06 00                           LD      B, 0
0193++ F391 3A 27 FF                        LD      A, (input_free)
0194++ F394 4F                              LD      C, A
0195++ F395 7D                              LD      A, L                ; Get the character from L
0196++ F396 21 16 FF                        LD      HL, input_buffer
0197++ F399 09                              ADD     HL, BC
0198++ F39A 77                              LD      (HL), A             ; Store the character
0199++ F39B             
0200++ F39B 0C                              INC     C                   ; Point to next byte in input
0201++ F39C 3E 0F                           LD      A, 0Fh
0202++ F39E A1                              AND     C
0203++ F39F 32 27 FF                        LD      (input_free), A
0204++ F3A2 C9                              RET
0205++ F3A3             
0206++ F3A3             ;
0207++ F3A3             ; Reads the next available character in A, returning that or 0 if none are available
0208++ F3A3             ; Z flag is set if no character
0209++ F3A3             ; Uses HL, BC, A
0210++ F3A3 3A 28 FF    read_character      LD      A, (input_size)
0211++ F3A6 A7                              AND     A
0212++ F3A7 C8                              RET     Z
0213++ F3A8             
0214++ F3A8 F3                              DI                          ; Make sure we don't get into a race condition..
0215++ F3A9 3A 28 FF                        LD      A, (input_size)
0216++ F3AC 3D                              DEC     A
0217++ F3AD 32 28 FF                        LD      (input_size),A
0218++ F3B0 3A 26 FF                        LD      A, (input_pos)
0219++ F3B3 4F                              LD      C, A
0220++ F3B4 3C                              INC     A
0221++ F3B5 E6 0F                           AND     0Fh
0222++ F3B7 32 26 FF                        LD      (input_pos),A
0223++ F3BA 06 00                           LD      B, 0
0224++ F3BC 21 16 FF                        LD      HL, input_buffer
0225++ F3BF 09                              ADD     HL, BC
0226++ F3C0 7E                              LD      A, (HL)
0227++ F3C1 B7                              OR      A
0228++ F3C2 FB                              EI
0229++ F3C3 C9                              RET
0230++ F3C4                                 
0231++ F3C4             ;;
0232++ F3C4             ; D = Octave 2-6
0233++ F3C4             ; E = Note 0-11
0234++ F3C4             ; C = 1-15 duration, ~tenths of a second
0235++ F3C4             ;
0236++ F3C4 3E 07       play_note           LD      A, 7
0237++ F3C6 92                              SUB     D
0238++ F3C7 16 00                           LD      D, 0
0239++ F3C9 21 0B F4                        LD      HL, _note_table
0240++ F3CC 19                              ADD     HL, DE
0241++ F3CD 19                              ADD     HL, DE
0242++ F3CE             
0243++ F3CE 5E                              LD      E, (HL)
0244++ F3CF 23                              INC     HL
0245++ F3D0 56                              LD      D, (HL)
0246++ F3D1             
0247++ F3D1 A7          _note_octave        AND     A
0248++ F3D2 28 07                           JR      Z, _note_shifted
0249++ F3D4             
0250++ F3D4 CB 3A                           SRL     D
0251++ F3D6 CB 1B                           RR      E
0252++ F3D8 3D                              DEC     A
0253++ F3D9 18 F6                           JR      _note_octave
0254++ F3DB             
0255++ F3DB 41          _note_shifted       LD      B, C
0256++ F3DC 4F                              LD      C, A        ; A is zero from previous octave calc
0257++ F3DD CB 20                           SLA     B    
0258++ F3DF CB 20                           SLA     B    
0259++ F3E1 CB 20                           SLA     B    
0260++ F3E3 CB 20                           SLA     B           ; Now BC = 4096 * C
0261++ F3E5             
0262++ F3E5 DB 24                           IN      A, (AUDIO_PORT)
0263++ F3E7 32 F8 F3                        LD      (_tone_val+1), A
0264++ F3EA F3                              DI
0265++ F3EB             
0266++ F3EB             _tone_loop          ; 186 T-states          
0267++ F3EB 19                              ADD     HL, DE              ; 11
0268++ F3EC 1F                              RRA                         ; 4   Carry into bit 7
0269++ F3ED CB 2F                           SRA     A                   ; 8   Copy to bit 6
0270++ F3EF CB 2F                           SRA     A                   ; 8   ..5
0271++ F3F1 CB 2F                           SRA     A                   ; 8   ..4
0272++ F3F3 CB 2F                           SRA     A                   ; 8   ..3
0273++ F3F5             
0274++ F3F5 E6 08                           AND     AUDIO_MASK          ; 7
0275++ F3F7 EE 00       _tone_val           XOR     0                   ; 7
0276++ F3F9 32 F8 F3                        LD      (_tone_val+1), A    ; 13
0277++ F3FC             
0278++ F3FC D3 24                           OUT     (AUDIO_PORT),A      ; 12
0279++ F3FE             
0280++ F3FE 78                              LD      A, B                ; 4
0281++ F3FF 06 05                           LD      B, 5                ; 7
0282++ F401 10 FE                           DJNZ    $                   ; 4 * 13 + 7 = 59
0283++ F403 47                              LD      B, A                ; 4
0284++ F404             
0285++ F404 0B                              DEC     BC                  ; 6
0286++ F405 78                              LD      A, B                ; 4
0287++ F406 B1                              OR      C                   ; 4
0288++ F407 20 E2                           JR      NZ, _tone_loop      ; 12
0289++ F409             
0290++ F409 FB                              EI
0291++ F40A C9                              RET
0292++ F40B             
0293++ F40B EB 18       _note_table         .DW 6379
0294++ F40D 65 1A                           .DW 6757
0295++ F40F F6 1B                           .DW 7158
0296++ F411 A1 1D                           .DW 7585
0297++ F413 63 1F                           .DW 8035
0298++ F415 40 21                           .DW 8512
0299++ F417 3F 23                           .DW 9023
0300++ F419 51 25                           .DW 9553
0301++ F41B 8C 27                           .DW 10124
0302++ F41D EA 29                           .DW 10730
0303++ F41F 60 2C                           .DW 11360
0304++ F421 0D 2F                           .DW 12045
0305++ F423 00 00                           .DW 0
0306++ F425             
0307++ F425             ;
0308++ F425             ; Get the next key press
0309++ F425             ;
0310++ F425 CD A3 F3    get_key             CALL    read_character
0311++ F428 06 00                           LD      B, 0
0312++ F42A 10 FE                           DJNZ    $
0313++ F42C 28 F7                           JR      Z, get_key
0314++ F42E C9                              RET
0315++ F42F             ;
0316++ F42F             ; Wait for a key to be pressed and released
0317++ F42F             ;
0318++ F42F             ;
0319++ F42F CD A3 F3    wait_for_key        CALL    read_character
0320++ F432 06 00                           LD      B, 0
0321++ F434 10 FE                           DJNZ    $
0322++ F436 28 F7                           JR      Z, wait_for_key
0323++ F438             
0324++ F438             ;
0325++ F438             ; wait until there are no keys being pressed
0326++ F438             ;
0327++ F438             ;
0328++ F438 CD A3 F3    wait_no_keys        CALL    read_character
0329++ F43B 20 FB                           JR      NZ, wait_no_keys
0330++ F43D 01 00 00                        LD      BC, 0h              ; Make sure key is released
0331++ F440 ED 78                           IN      A, (C)
0332++ F442 E6 3F                           AND     03Fh
0333++ F444 FE 3F                           CP      03Fh
0334++ F446 20 F0                           JR      NZ, wait_no_keys
0335++ F448 C9                              RET
0336++ F449             
0337++ F449             ; Non-printing key codes
0338++ F449             ;
0339++ F449             KEY_ENTER       .EQU    13
0340++ F449             KEY_DELETE      .EQU    127
0341++ F449             KEY_CTRL_C      .EQU    03h
0342++ F449             KEY_CTRL_E      .EQU    05h
0343++ F449             
0344++ F449             KEY_CTRL_P      .EQU    10h
0345++ F449             KEY_CTRL_R      .EQU    12h
0346++ F449             KEY_CTRL_S      .EQU    13h
0347++ F449             KEY_CTRL_U      .EQU    15h
0348++ F449             KEY_CTRL_X      .EQU    18h
0349++ F449             KEY_CTRL_Z      .EQU    1Ah
0350++ F449             KEY_ESCAPE      .EQU    1Bh
0351++ F449             
0352++ F449             KEY_BACKSPACE   .EQU    08h
0353++ F449             
0354++ F449             ; Modifier and special keys have key codes with the top bit set..
0355++ F449             ;
0356++ F449             KEY_UP          .EQU    128
0357++ F449             KEY_DOWN        .EQU    129
0358++ F449             KEY_LEFT        .EQU    130
0359++ F449             KEY_RIGHT       .EQU    131
0360++ F449             KEY_SHIFT       .EQU    132
0361++ F449             KEY_CTRL        .EQU    134
0362++ F449             
0363++ F449             ; 144 = 90h
0364++ F449             ;
0365++ F449             CTRL_KEY_MASK   .EQU    0F8h
0366++ F449             CTRL_KEY_CHECK  .EQU    090h
0367++ F449             
0368++ F449             KEY_CTRL_UP     .EQU    144             ; These characters start on an exact multiple of 8 so they 
0369++ F449             KEY_CTRL_DOWN   .EQU    145             ; Can easily be detected
0370++ F449             KEY_CTRL_LEFT   .EQU    146
0371++ F449             KEY_CTRL_RIGHT  .EQU    147
0372++ F449             KEY_CTRL_ENTER  .EQU    148
0373++ F449             KEY_CTRL_SPACE  .EQU    149 
0374++ F449             KEY_CTRL_D      .EQU    150
0375++ F449             
0376++ F449             _keyboard_size  .EQU    48
0377++ F449             
0378++ F449             KEY_SHIFT_BIT   .EQU    1
0379++ F449             KEY_CTRL_BIT    .EQU    2
0380++ F449             
0381++ F449             KEY_REPEAT_DELAY .EQU   40
0382++ F449             KEY_REPEAT_AFTER .EQU   KEY_REPEAT_DELAY+7
0383++ F449             
0384++ F449 76 63 78 7A keyboard        .DB    "vcxz", 0, 0
0384++ F44D 00 00 
0385++ F44F 67 66 64 73                 .DB    "gfdsa", 0
0385++ F453 61 00 
0386++ F455 74 72 65 77                 .DB    "trewq", KEY_DOWN
0386++ F459 71 81 
0387++ F45B 35 34 33 32                 .DB    "54321", KEY_UP  
0387++ F45F 31 80 
0388++ F461 36 37 38 39                 .DB    "67890", KEY_BACKSPACE
0388++ F465 30 08 
0389++ F467 79 75 69 6F                 .DB    "yuiop:"
0389++ F46B 70 3A 
0390++ F46D 68 6A 6B 6C                 .DB    "hjkl.", KEY_ENTER
0390++ F471 2E 0D 
0391++ F473 62 6E 6D 20                 .DB    "bnm ", KEY_LEFT, KEY_RIGHT
0391++ F477 82 83 
0392++ F479             
0393++ F479 56 43 58 5A _shifted        .DB     "VCXZ", 0, 0
0393++ F47D 00 00 
0394++ F47F 47 46 44 53                 .DB     "GFDSA", 0
0394++ F483 41 00 
0395++ F485 54 52 45 57                 .DB     "TREWQ", 0              ; Shift + down?
0395++ F489 51 00 
0396++ F48B 25 24 23 22                 .DB     "%$", 35, 34, "!", 0    ; Shift + up
0396++ F48F 21 00 
0397++ F491 5E 26 2A 28                 .DB     "^&*()", KEY_DELETE     ; Shift + delete
0397++ F495 29 7F 
0398++ F497 59 55 49 4F                 .DB     "YUIOP;"
0398++ F49B 50 3B 
0399++ F49D 48 4A 4B 4C                 .DB     "HJKL,", 0              ; Shift + enter
0399++ F4A1 2C 00 
0400++ F4A3 42 4E 4D 00                 .DB     "BNM", 0,0,0            ; Shift left + right
0400++ F4A7 00 00 
0401++ F4A9             
0402++ F4A9 00 03 18 1A _ctrl           .DB    0,KEY_CTRL_C,KEY_CTRL_X,KEY_CTRL_Z,0,0
0402++ F4AD 00 00 
0403++ F4AF 00 00 96 13                 .DB    0,0,KEY_CTRL_D,KEY_CTRL_S,0,0
0403++ F4B3 00 00 
0404++ F4B5 00 12 05 00                 .DB    0,KEY_CTRL_R,KEY_CTRL_E,0,0,KEY_CTRL_DOWN
0404++ F4B9 00 91 
0405++ F4BB 00 00 00 27                 .DB    0,0,0,27h,7Ch,KEY_CTRL_UP ; Vertical bar, single quote
0405++ F4BF 7C 90 
0406++ F4C1 7B 7D 60 5B                 .DB    "{}`[]", KEY_ESCAPE
0406++ F4C5 5D 1B 
0407++ F4C7 00 15 2B 3D                 .DB    0,KEY_CTRL_U, "+=-", 0
0407++ F4CB 2D 00 
0408++ F4CD 00 3C 40 3E                 .DB    0, "<@>_", KEY_CTRL_ENTER
0408++ F4D1 5F 94 
0409++ F4D3 5C 3F 2F 95                 .DB    "\\?/", KEY_CTRL_SPACE,KEY_CTRL_LEFT,KEY_CTRL_RIGHT
0409++ F4D7 92 93 
0410++ F4D9             
0411++ F4D9 00 00 00 00 _shift_ctrl     .DB    0,0,0,0,0,0
0411++ F4DD 00 00 
0412++ F4DF 00 00 00 00                 .DB    0,0,0,0,0,0
0412++ F4E3 00 00 
0413++ F4E5 00 00 00 00                 .DB    0,0,0,0,0,0
0413++ F4E9 00 00 
0414++ F4EB 00 00 00 00                 .DB    0,0,0,0,0,0
0414++ F4EF 00 00 
0415++ F4F1 00 00 00 00                 .DB    0,0,0,0,0,0
0415++ F4F5 00 00 
0416++ F4F7 00 00 00 00                 .DB    0,0,0,0,KEY_CTRL_P,0
0416++ F4FB 10 00 
0417++ F4FD 00 00 00 00                 .DB    0,0,0,0,0,0
0417++ F501 00 00 
0418++ F503 00 00 00 00                 .DB    0,0,0,0,0,0
0418++ F507 00 00 
1504+  F509                                 .INCLUDE "../uart.asm"
0001++ F509             ;
0002++ F509             ; UART routines..
0003++ F509             ;
0004++ F509             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ F509             ;
0006++ F509             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ F509             ;
0008++ F509             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ F509             ; of this software and associated documentation files (the "Software"), to deal
0010++ F509             ; in the Software without restriction, including without limitation the rights
0011++ F509             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ F509             ; copies of the Software, and to permit persons to whom the Software is
0013++ F509             ; furnished to do so, subject to the following conditions:
0014++ F509             ; 
0015++ F509             ; The above copyright notice and this permission notice shall be included in all
0016++ F509             ; copies or substantial portions of the Software.
0017++ F509             ; 
0018++ F509             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ F509             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ F509             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ F509             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ F509             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ F509             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ F509             ; SOFTWARE.
0025++ F509             ;
0026++ F509                                 .MODULE     uart
0027++ F509             
0028++ F509             ;
0029++ F509             ; Baud rates, assuming 1.8432Mhz crystal
0030++ F509             ;
0031++ F509             UART_9600           .EQU    12
0032++ F509             UART_19200          .EQU    6
0033++ F509             UART_38400          .EQU    3
0034++ F509             
0035++ F509             UART_MODE_AUTO      .EQU    022h   ; Auto flow mode
0036++ F509             UART_MODE_NO_FLOW   .EQU    000h   ; Auto RTS and CTS disabled
0037++ F509             UART_MODE_DIAG      .EQU    030h   ; Loopback mode
0038++ F509             
0039++ F509             ;
0040++ F509             ; Various constants
0041++ F509             ;
0042++ F509             UART_8N1            .EQU    003h
0043++ F509             UART_TIMEOUT        .EQU    50000
0044++ F509             
0045++ F509             _CTS_STATUS_MASK    .EQU    010h
0046++ F509             
0047++ F509             ;
0048++ F509             ; Set up the UART. Assume it has had time to settle after reset...
0049++ F509             ;
0050++ F509             ;
0051++ F509 01 06 00    uart_init           LD      BC, UART_19200              ; B is flow control, 0 -> No auto flow control
0052++ F50C             
0053++ F50C DB 26                           IN      A,(UART_MODEM_STATUS)       ; If CTS is enabled, assume we can use flow control
0054++ F50E E6 10                           AND     _CTS_STATUS_MASK
0055++ F510 28 02                           JR      Z, _no_listener
0056++ F512             
0057++ F512 06 22                           LD      B, UART_MODE_AUTO
0058++ F514                                     
0059++ F514 3E 80       _no_listener        LD      A, 80h                      ; Divisor Latch Setting Mode
0060++ F516 D3 23                           OUT     (UART_LINE_CTRL), A         ;  - entered by writing 1 to bit 7 of LCR
0061++ F518 00                              NOP
0062++ F519 00                              NOP
0063++ F51A 79                              LD      A, C
0064++ F51B D3 20                           OUT     (UART_TX_RX), A
0065++ F51D 00                              NOP
0066++ F51E 00                              NOP
0067++ F51F AF                              XOR     A
0068++ F520 D3 21                           OUT     (UART_INT_ENABLE), A
0069++ F522 00                              NOP
0070++ F523 00                              NOP
0071++ F524             
0072++ F524 3E 03                           LD      A, UART_8N1                 ; Set 8N1 and exit divisor latch setting mode
0073++ F526 D3 23                           OUT     (UART_LINE_CTRL), A
0074++ F528             
0075++ F528 3E 07                           LD      A, 07h                      ; Enable and clear FIFO registers
0076++ F52A D3 22                           OUT     (UART_FIFO_CTRL), A
0077++ F52C             
0078++ F52C 78                              LD      A, B
0079++ F52D A7                              AND     A
0080++ F52E 28 02                           JR      Z, _no_flowcontrol
0081++ F530             
0082++ F530 D3 24                           OUT     (UART_MODEM_CTRL), A
0083++ F532             
0084++ F532 00          _no_flowcontrol     NOP
0085++ F533 00                              NOP
0086++ F534 C9                              RET
0087++ F535             
0088++ F535             ;
0089++ F535             ; Send character in A to UART
0090++ F535             ; Preserves all registers
0091++ F535             ;
0092++ F535             ; Carry flag is set on return if the UART send succeeded, clear if it timed out
0093++ F535             ;
0094++ F535 C5          uart_send           PUSH    BC
0095++ F536 F5                              PUSH    AF
0096++ F537 01 50 C3                        LD      BC, UART_TIMEOUT
0097++ F53A DB 25       _check_ready        IN      A, (UART_LINE_STATUS)
0098++ F53C CB 6F                           BIT     5, A
0099++ F53E C2 4C F5                        JP      NZ, _uart_ready             ; Bit 5 is set when the UART is ready
0100++ F541 0B                              DEC     BC
0101++ F542 78                              LD      A, B
0102++ F543 B1                              OR      C
0103++ F544 C2 3A F5                        JP      NZ, _check_ready
0104++ F547             
0105++ F547 F1                              POP     AF
0106++ F548 C1                              POP     BC
0107++ F549 37                              SCF
0108++ F54A 3F                              CCF
0109++ F54B C9                              RET
0110++ F54C             
0111++ F54C F1          _uart_ready         POP     AF
0112++ F54D C1                              POP     BC
0113++ F54E D3 20                           OUT     (UART_TX_RX), A
0114++ F550 37                              SCF
0115++ F551 C9                              RET
0116++ F552             
0117++ F552             ;
0118++ F552             ; Check to see if there are any characters to receive
0119++ F552             ; Preserves all registers
0120++ F552             ;
0121++ F552             ; Returns with carry set if there are characters ready, clear if not
0122++ F552             ;
0123++ F552 F5          uart_ready          PUSH    AF
0124++ F553 DB 25                           IN      A, (UART_LINE_STATUS)
0125++ F555 CB 47                           BIT     0, A
0126++ F557 CA 5D F5                        JP      Z, _not_ready
0127++ F55A F1                              POP     AF
0128++ F55B 37                              SCF
0129++ F55C C9                              RET
0130++ F55D             
0131++ F55D F1          _not_ready          POP     AF
0132++ F55E 37                              SCF
0133++ F55F 3F                              CCF
0134++ F560 C9                              RET
0135++ F561             
0136++ F561             ;
0137++ F561             ; Receive a character from the UART in A
0138++ F561             ; 
0139++ F561             ; Returns with a character in A and the carry flag set. If no characters
0140++ F561             ; are available, returns with the carry flag clear.
0141++ F561             ;
0142++ F561 DB 25       uart_receive        IN      A, (UART_LINE_STATUS)
0143++ F563 CB 47                           BIT     0, A
0144++ F565 CA 6C F5                        JP      Z, _no_character
0145++ F568 DB 20                           IN      A, (UART_TX_RX)
0146++ F56A 37                              SCF
0147++ F56B C9                              RET
0148++ F56C             
0149++ F56C 37          _no_character       SCF
0150++ F56D 3F                              CCF
0151++ F56E C9                              RET
0152++ F56F             
0153++ F56F                                 .MODULE main1505+  F56F                                 .INCLUDE "../i2c.asm"
0001++ F56F             ; ============================================ I2C Routines =================================================
0002++ F56F             ; Software driven I2C for Z80 PIO
0003++ F56F             ;
0004++ F56F             ; Assume I2C clock is on Port B bit 6
0005++ F56F             ;            data is on Port B bit 7
0006++ F56F             ;
0007++ F56F             ;
0008++ F56F             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0009++ F56F             ;
0010++ F56F             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0011++ F56F             ;
0012++ F56F             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0013++ F56F             ; of this software and associated documentation files (the "Software"), to deal
0014++ F56F             ; in the Software without restriction, including without limitation the rights
0015++ F56F             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0016++ F56F             ; copies of the Software, and to permit persons to whom the Software is
0017++ F56F             ; furnished to do so, subject to the following conditions:
0018++ F56F             ; 
0019++ F56F             ; The above copyright notice and this permission notice shall be included in all
0020++ F56F             ; copies or substantial portions of the Software.
0021++ F56F             ; 
0022++ F56F             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0023++ F56F             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0024++ F56F             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0025++ F56F             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0026++ F56F             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0027++ F56F             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0028++ F56F             ; SOFTWARE.
0029++ F56F             ;
0030++ F56F                                 .MODULE i2c
0031++ F56F             
0032++ F56F 3E CF       init_portb          LD      A, PIO_MODE_3           ; Port B mode 3
0033++ F571 32 00 FF                        LD      (port_b_mode), A
0034++ F574 D3 13                           OUT     (PIO_B_CTRL), A
0035++ F576             
0036++ F576 3E FF                           LD      A, PORT_B_IOMASK        ;
0037++ F578 32 01 FF                        LD      (port_b_dir), A
0038++ F57B D3 13                           OUT     (PIO_B_CTRL), A
0039++ F57D             
0040++ F57D 3E 3F                           LD      A, 03Fh                 ; All bits high apart from D7, D6
0041++ F57F 32 02 FF                        LD      (port_b_data),A
0042++ F582 D3 11                           OUT     (PIO_B_DATA), A         ; Changing D7 or D6 to an output will drive the lines low
0043++ F584 C9                              RET
0044++ F585             
0045++ F585             ; Reset the bus
0046++ F585             ;
0047++ F585             ; Uses A, B, D
0048++ F585 06 0A       i2c_bus_reset       LD      B, 0ah          ; ten cycles
0049++ F587 CD 96 F6    _loop_b             CALL    i2c_scl_cycle
0050++ F58A 10 FB                           DJNZ    _loop_b
0051++ F58C CD 86 F6                        CALL    i2c_scl_high
0052++ F58F 06 F0                           LD      B, 0F0h
0053++ F591 10 FE                           DJNZ    $
0054++ F593 C9                              RET
0055++ F594             
0056++ F594             ;
0057++ F594             ; Uses A
0058++ F594 CD 66 F6    i2c_start           CALL    i2c_sda_high
0059++ F597 CD 86 F6                        CALL    i2c_scl_high
0060++ F59A CD 76 F6                        CALL    i2c_sda_low     ; Drive data low
0061++ F59D C3 56 F6                        JP      i2c_scl_low     ; Drive clock low
0062++ F5A0             
0063++ F5A0             
0064++ F5A0             ;
0065++ F5A0             ; Read a byte from Device address H, Register L into A
0066++ F5A0             ; Calls i2c_start, sets address, reads byte and then calls i2c_stop
0067++ F5A0             ; Returns With Carry SET and A containing the register value, or Carry CLEAR if no acknowledge
0068++ F5A0             ; Uses A, B, C, D, H, L
0069++ F5A0             ; Preserves H, L
0070++ F5A0 CD BA F5    i2c_read_byte       CALL    i2c_read_from
0071++ F5A3                                 ; Fall through into stop
0072++ F5A3                             
0073++ F5A3             ;
0074++ F5A3             ; Uses A
0075++ F5A3 CD 76 F6    i2c_stop            CALL    i2c_sda_low     ; Drive data low
0076++ F5A6 CD 86 F6                        CALL    i2c_scl_high
0077++ F5A9 C3 66 F6                        JP      i2c_sda_high
0078++ F5AC             
0079++ F5AC             ; Write a byte in C to Device address H, register L
0080++ F5AC             ; Returns with Carry SET if OK, CLEAR if no acknowledgement
0081++ F5AC             ; Calls i2c_stop when done..
0082++ F5AC             ;
0083++ F5AC             ; Preserves H, L
0084++ F5AC C5          i2c_write_byte      PUSH    BC
0085++ F5AD CD DB F5                        CALL    i2c_write_to
0086++ F5B0 C1                              POP     BC
0087++ F5B1 D2 A3 F5                        JP      NC, i2c_stop
0088++ F5B4 79                              LD      A, C
0089++ F5B5 CD EF F5                        CALL    i2c_write
0090++ F5B8 18 E9                           JR      i2c_stop
0091++ F5BA                                 
0092++ F5BA             ;
0093++ F5BA             ; Read a byte from Device address H, Register L
0094++ F5BA             ; Calls i2c_start, but does NOT call i2c_stop
0095++ F5BA             ; Returns With Carry SET and A containing the register value, or Carry CLEAR if no acknowledge
0096++ F5BA             ; Uses A, B, C, D, H, L
0097++ F5BA             ; Preserves H, L
0098++ F5BA CD 94 F5    i2c_read_from       CALL    i2c_start
0099++ F5BD 7C                              LD      A, H
0100++ F5BE CD ED F5                        CALL    i2c_address_w
0101++ F5C1 30 17                           JR      NC, _read_end
0102++ F5C3 7D                              LD      A, L
0103++ F5C4 CD EF F5                        CALL    i2c_write
0104++ F5C7 30 11                           JR      NC, _read_end
0105++ F5C9 06 32                           LD      B, 50
0106++ F5CB 10 FE       _read_pause         DJNZ    _read_pause
0107++ F5CD CD 94 F5                        CALL    i2c_start
0108++ F5D0 7C                              LD      A, H
0109++ F5D1 CD E7 F5                        CALL    i2c_address_r
0110++ F5D4 30 04                           JR      NC, _read_end
0111++ F5D6 CD 3A F6                        CALL    i2c_read
0112++ F5D9 37                              SCF
0113++ F5DA C9          _read_end           RET
0114++ F5DB             
0115++ F5DB             
0116++ F5DB             ;
0117++ F5DB             ; Prepare to write to Device address H, Register L
0118++ F5DB             ; Calls i2c_start, but does NOT call i2c_stop
0119++ F5DB             ; Returns with Carry SET if OK, CLEAR if no acknowledgement
0120++ F5DB             ;
0121++ F5DB             ; Preserves H, L
0122++ F5DB CD 94 F5    i2c_write_to        CALL    i2c_start
0123++ F5DE 7C                              LD      A, H
0124++ F5DF CD ED F5                        CALL    i2c_address_w
0125++ F5E2 D0                              RET     NC
0126++ F5E3 7D                              LD      A, L
0127++ F5E4 C3 EF F5                        JP      i2c_write
0128++ F5E7             
0129++ F5E7             ; Start reading from device address held in A
0130++ F5E7             ;
0131++ F5E7             ; Uses A, B, C, D
0132++ F5E7 CB 27       i2c_address_r       SLA     A
0133++ F5E9 F6 01                           OR      1
0134++ F5EB 18 02                           JR      i2c_write
0135++ F5ED             
0136++ F5ED             ; Start writing to device address held in A
0137++ F5ED             ;
0138++ F5ED             ; Uses A, B, C, D
0139++ F5ED CB 27       i2c_address_w       SLA     A
0140++ F5EF             
0141++ F5EF             ; Write A as a byte to i2c bus
0142++ F5EF             ; Returns Carry CLEAR if no acknowledge
0143++ F5EF             ;
0144++ F5EF             ; Uses A, B, C, D
0145++ F5EF E5          i2c_write           PUSH    HL
0146++ F5F0 2A 00 FF                        LD      HL, (port_b_mode)           ; L = port_b_mode, H = port_b_dir
0147++ F5F3 57                              LD      D, A
0148++ F5F4                                 
0149++ F5F4 3E 3F                           LD      A, ~(I2C_DATA_MASK|I2C_CLK_MASK)           ; Set SDA and SCL (port_b_dir bit) LOW
0150++ F5F6 A4                              AND     H
0151++ F5F7 CB 27                           SLA     A
0152++ F5F9 67                              LD      H, A
0153++ F5FA             
0154++ F5FA 0E 13                           LD      C, PIO_B_CTRL
0155++ F5FC 06 08                           LD      B, 8
0156++ F5FE             
0157++ F5FE 7C          _fast_loop          LD      A, H
0158++ F5FF CB 22                           SLA     D
0159++ F601 CB 1F                           RR      A
0160++ F603 ED 69                           OUT     (C),L
0161++ F605 D3 13                           OUT     (PIO_B_CTRL), A
0162++ F607             
0163++ F607 F6 40                           OR      I2C_CLK_MASK
0164++ F609 ED 69                           OUT     (C), L
0165++ F60B D3 13                           OUT     (PIO_B_CTRL), A                 ; Clock high
0166++ F60D             
0167++ F60D EE 40                           XOR     I2C_CLK_MASK
0168++ F60F ED 69                           OUT     (C), L
0169++ F611 D3 13                           OUT     (PIO_B_CTRL),A                  ; Clock low
0170++ F613 10 E9                           DJNZ    _fast_loop
0171++ F615             
0172++ F615 7C                              LD      A, H
0173++ F616 37                              SCF
0174++ F617 CB 1F                           RR      A
0175++ F619 ED 69                           OUT     (C),L                           ; Release SDA
0176++ F61B D3 13                           OUT     (PIO_B_CTRL), A
0177++ F61D             
0178++ F61D F6 40                           OR      I2C_CLK_MASK
0179++ F61F ED 69                           OUT     (C), L
0180++ F621 D3 13                           OUT     (PIO_B_CTRL), A                 ; Clock high
0181++ F623             
0182++ F623 ED 69                           OUT     (C), L
0183++ F625 EE 40                           XOR     I2C_CLK_MASK
0184++ F627 6F                              LD      L, A
0185++ F628 32 01 FF                        LD      (port_b_dir), A
0186++ F62B             
0187++ F62B DB 11                           IN      A, (PIO_B_DATA)                 ; Read ACK
0188++ F62D ED 69                           OUT     (C),L                           ; Clock low
0189++ F62F             
0190++ F62F E1                              POP     HL
0191++ F630             
0192++ F630 CB 7A                           BIT     I2C_DATA_BIT, D     ; D contains acknowledge bit
0193++ F632 37                              SCF
0194++ F633 C8                              RET     Z               ; Return with carry set if acknowledge bit is low
0195++ F634             
0196++ F634 CD A3 F5                        CALL    i2c_stop        ; Stop bus if error
0197++ F637 37                              SCF
0198++ F638 3F                              CCF
0199++ F639 C9                              RET                     ; Clear carry if acknowledge is high
0200++ F63A             
0201++ F63A             ; Read byte from i2C into A, without ACK
0202++ F63A             ;
0203++ F63A             ; Uses A, B, C, D
0204++ F63A 06 08       i2c_read            LD      B, 8h
0205++ F63C DB 11       _loop_r             IN      A, (PIO_B_DATA)
0206++ F63E 37                              SCF
0207++ F63F CB 7F                           BIT     I2C_DATA_BIT, A
0208++ F641 20 01                           JR      NZ, _data_high
0209++ F643 3F                              CCF
0210++ F644 CB 11       _data_high          RL      C
0211++ F646 CD 96 F6                        CALL    i2c_scl_cycle
0212++ F649 10 F1                           DJNZ    _loop_r
0213++ F64B                                 ; CALL    i2c_scl_cycle
0214++ F64B             
0215++ F64B 79                              LD      A, C
0216++ F64C C9                              RET
0217++ F64D             
0218++ F64D             ;
0219++ F64D             ; Send an ACK..
0220++ F64D             ;
0221++ F64D CD 76 F6    i2c_ack             CALL    i2c_sda_low
0222++ F650 CD 96 F6                        CALL    i2c_scl_cycle
0223++ F653 18 11                           JR      i2c_sda_high
0224++ F655             
0225++ F655             ;
0226++ F655             ; Send a byte in A, returning the ACK state in D
0227++ F655             ; Uses A, B, C,
0228++ F655             ;
0229++ F655             i2c_send_bytez      
0230++ F655 C9                              RET
0231++ F656             
0232++ F656             ; SCL/SDA toggle routines
0233++ F656             ;
0234++ F656             ; All use A
0235++ F656 3A 00 FF    i2c_scl_low         LD      A, (port_b_mode)
0236++ F659 D3 13                           OUT     (PIO_B_CTRL), A
0237++ F65B             
0238++ F65B 3A 01 FF                        LD      A, (port_b_dir)
0239++ F65E CB B7                           RES     I2C_CLK_BIT, A
0240++ F660 D3 13                           OUT     (PIO_B_CTRL), A
0241++ F662 32 01 FF                        LD      (port_b_dir), A
0242++ F665 C9                              RET
0243++ F666             
0244++ F666 3A 00 FF    i2c_sda_high        LD      A, (port_b_mode)
0245++ F669 D3 13                           OUT     (PIO_B_CTRL), A
0246++ F66B             
0247++ F66B 3A 01 FF                        LD      A, (port_b_dir)
0248++ F66E CB FF                           SET     I2C_DATA_BIT, A
0249++ F670 D3 13                           OUT     (PIO_B_CTRL), A
0250++ F672 32 01 FF                        LD      (port_b_dir), A
0251++ F675 C9                              RET
0252++ F676             
0253++ F676 3A 00 FF    i2c_sda_low         LD      A, (port_b_mode)
0254++ F679 D3 13                           OUT     (PIO_B_CTRL), A
0255++ F67B             
0256++ F67B 3A 01 FF                        LD      A, (port_b_dir)
0257++ F67E CB BF                           RES     I2C_DATA_BIT, A
0258++ F680 D3 13                           OUT     (PIO_B_CTRL), A
0259++ F682 32 01 FF                        LD      (port_b_dir), A
0260++ F685 C9                              RET
0261++ F686             
0262++ F686 3A 00 FF    i2c_scl_high        LD      A, (port_b_mode)
0263++ F689 D3 13                           OUT     (PIO_B_CTRL), A
0264++ F68B             
0265++ F68B 3A 01 FF                        LD      A, (port_b_dir)
0266++ F68E CB F7                           SET     I2C_CLK_BIT, A
0267++ F690 D3 13                           OUT     (PIO_B_CTRL), A
0268++ F692 32 01 FF                        LD      (port_b_dir), A
0269++ F695 C9                              RET
0270++ F696             
0271++ F696 C5          i2c_scl_cycle       PUSH   BC
0272++ F697 01 13 00                        LD     BC, PIO_B_CTRL
0273++ F69A 3A 00 FF                        LD     A, (port_b_mode)
0274++ F69D 57                              LD     D, A
0275++ F69E 3A 01 FF                        LD     A, (port_b_dir)
0276++ F6A1             
0277++ F6A1 CB B7                           RES    I2C_CLK_BIT, A
0278++ F6A3 32 01 FF                        LD     (port_b_dir), A
0279++ F6A6 ED 51                           OUT    (C), D
0280++ F6A8 D3 13                           OUT    (PIO_B_CTRL), A
0281++ F6AA                                 
0282++ F6AA CB F7                           SET    I2C_CLK_BIT, A
0283++ F6AC ED 51                           OUT    (C), D
0284++ F6AE D3 13                           OUT    (PIO_B_CTRL), A
0285++ F6B0                                 
0286++ F6B0 DB 11                           IN     A, (PIO_B_DATA)
0287++ F6B2 ED 51                           OUT    (C), D
0288++ F6B4 57                              LD     D, A
0289++ F6B5 3A 01 FF                        LD     A, (port_b_dir)
0290++ F6B8 D3 13                           OUT    (PIO_B_CTRL), A
0291++ F6BA C1                              POP    BC
0292++ F6BB C9                              RET
0293++ F6BC             
0294++ F6BC                                 .MODULE main
1506+  F6BC             
1507+  F6BC                                 .INCLUDE "../disp.asm"
0001++ F6BC             ; ========================================== Display Routines ===============================================
0002++ F6BC             ;
0003++ F6BC             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0004++ F6BC             ;
0005++ F6BC             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0006++ F6BC             ;
0007++ F6BC             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0008++ F6BC             ; of this software and associated documentation files (the "Software"), to deal
0009++ F6BC             ; in the Software without restriction, including without limitation the rights
0010++ F6BC             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0011++ F6BC             ; copies of the Software, and to permit persons to whom the Software is
0012++ F6BC             ; furnished to do so, subject to the following conditions:
0013++ F6BC             ; 
0014++ F6BC             ; The above copyright notice and this permission notice shall be included in all
0015++ F6BC             ; copies or substantial portions of the Software.
0016++ F6BC             ; 
0017++ F6BC             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0018++ F6BC             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0019++ F6BC             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0020++ F6BC             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0021++ F6BC             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0022++ F6BC             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0023++ F6BC             ; SOFTWARE.
0024++ F6BC             ;
0025++ F6BC                                 .MODULE disp
0026++ F6BC             
0027++ F6BC             CONFIG_PAGE         .EQU    3
0028++ F6BC             BRIGHT_PAGE         .EQU    1
0029++ F6BC             LED_PAGE            .EQU    0 
0030++ F6BC             
0031++ F6BC CD 06 F8    display_init        CALL    disp_clear
0032++ F6BF 1E 80                           LD      E, DISP_DEFAULT_BRIGHTNESS
0033++ F6C1 CD FC F6                        CALL    disp_brightness
0034++ F6C4             
0035++ F6C4 CD D0 F6                        CALL    disp_select_l
0036++ F6C7 CD DC F6                        CALL    disp_config
0037++ F6CA             
0038++ F6CA CD D6 F6                        CALL    disp_select_r
0039++ F6CD CD DC F6                        CALL    disp_config
0040++ F6D0             
0041++ F6D0 3E 50       disp_select_l       LD      A, DL_ADDRESS
0042++ F6D2 32 03 FF                        LD      (display_address), A
0043++ F6D5 C9                              RET
0044++ F6D6             
0045++ F6D6 3E 53       disp_select_r       LD      A, DR_ADDRESS
0046++ F6D8 32 03 FF                        LD      (display_address), A
0047++ F6DB C9                              RET
0048++ F6DC             
0049++ F6DC 2E 03       disp_config         LD      L, CONFIG_PAGE
0050++ F6DE CD 37 F7                        CALL    disp_page
0051++ F6E1 CD 94 F5                        CALL    i2c_start
0052++ F6E4 3A 03 FF                        LD      A, (display_address)
0053++ F6E7 CD ED F5                        CALL    i2c_address_w
0054++ F6EA 3E 00                           LD      A, 000h
0055++ F6EC CD EF F5                        CALL    i2c_write
0056++ F6EF 3E 01                           LD      A, 001h         ; Turn display on
0057++ F6F1 CD EF F5                        CALL    i2c_write
0058++ F6F4 3E 78                           LD      A, 078h         ; 0.020mA
0059++ F6F6 CD EF F5                        CALL    i2c_write
0060++ F6F9 C3 A3 F5                        JP      i2c_stop
0061++ F6FC             
0062++ F6FC             ;
0063++ F6FC             ; Sets the brightness for the display
0064++ F6FC             ; Enter with E set to the desired brightness for all segments
0065++ F6FC             ;
0066++ F6FC CD D0 F6    disp_brightness     CALL    disp_select_l
0067++ F6FF CD 05 F7                        CALL    _set_bright
0068++ F702 CD D6 F6                        CALL    disp_select_r
0069++ F705 2E 01       _set_bright         LD      L, BRIGHT_PAGE
0070++ F707 CD 37 F7                        CALL    disp_page
0071++ F70A 2E 0C                           LD      L, 12
0072++ F70C CD 94 F5    _bright_loop        CALL    i2c_start
0073++ F70F 3A 03 FF                        LD      A, (display_address)
0074++ F712 CD ED F5                        CALL    i2c_address_w
0075++ F715 7D                              LD      A, L
0076++ F716 3D                              DEC     A
0077++ F717 CB 27                           SLA     A
0078++ F719 CB 27                           SLA     A
0079++ F71B CB 27                           SLA     A
0080++ F71D CB 27                           SLA     A
0081++ F71F CD EF F5                        CALL    i2c_write
0082++ F722 26 10                           LD      H, 010h
0083++ F724 7B          _bright_byte        LD      A, E
0084++ F725 CD EF F5                        CALL    i2c_write
0085++ F728 25                              DEC     H
0086++ F729 20 F9                           JR      NZ, _bright_byte
0087++ F72B CD A3 F5                        CALL    i2c_stop
0088++ F72E 2D                              DEC     L
0089++ F72F 20 DB                           JR      NZ, _bright_loop
0090++ F731 2E 00                           LD      L, LED_PAGE
0091++ F733 CD 37 F7                        CALL    disp_page
0092++ F736 C9                              RET
0093++ F737             
0094++ F737             ; Set the Page number
0095++ F737             ; Call with page number in L
0096++ F737             ;
0097++ F737             ; Uses A, B, C, D
0098++ F737 CD 4F F7    disp_page           CALL    disp_unlock
0099++ F73A CD 94 F5                        CALL    i2c_start
0100++ F73D 3A 03 FF                        LD      A, (display_address)
0101++ F740 CD ED F5                        CALL    i2c_address_w
0102++ F743 3E FD                           LD      A, 0FDh
0103++ F745 CD EF F5                        CALL    i2c_write
0104++ F748 7D                              LD      A, L
0105++ F749 CD EF F5                        CALL    i2c_write
0106++ F74C C3 A3 F5                        JP      i2c_stop
0107++ F74F             
0108++ F74F CD 94 F5    disp_unlock         CALL    i2c_start           ; Must be called before switching pages
0109++ F752 3A 03 FF                        LD      A, (display_address)
0110++ F755 CD ED F5                        CALL    i2c_address_w
0111++ F758 3E FE                           LD      A, DISP_REG_CRWL
0112++ F75A CD EF F5                        CALL    i2c_write
0113++ F75D 3E C5                           LD      A, DISP_UNLOCK
0114++ F75F CD EF F5                        CALL    i2c_write
0115++ F762 C3 A3 F5                        JP      i2c_stop
0116++ F765             
0117++ F765             ; Set the character at column A to brightness C
0118++ F765             ;
0119++ F765             ;
0120++ F765 C5          disp_char_bright    PUSH    BC
0121++ F766 06 50                           LD      B, DL_ADDRESS
0122++ F768 FE 0C                           CP      12
0123++ F76A DA 71 F7                        JP      C, _bright_left
0124++ F76D 06 53                           LD      B, DR_ADDRESS
0125++ F76F D6 0C                           SUB     12
0126++ F771 5F          _bright_left        LD      E, A
0127++ F772 78                              LD      A, B
0128++ F773 32 03 FF                        LD      (display_address), A
0129++ F776 2E 01                           LD      L, BRIGHT_PAGE
0130++ F778 CD 37 F7                        CALL    disp_page
0131++ F77B             
0132++ F77B CD 94 F5                        CALL    i2c_start
0133++ F77E 3A 03 FF                        LD      A, (display_address)
0134++ F781 CD ED F5                        CALL    i2c_address_w
0135++ F784 7B                              LD      A, E
0136++ F785 CB 27                           SLA     A
0137++ F787 CB 27                           SLA     A
0138++ F789 CB 27                           SLA     A
0139++ F78B CB 27                           SLA     A
0140++ F78D CD EF F5                        CALL    i2c_write
0141++ F790 E1                              POP     HL
0142++ F791 26 10                           LD      H, 010h
0143++ F793 7D          _bright_char_loop   LD      A, L
0144++ F794 CD EF F5                        CALL    i2c_write
0145++ F797 25                              DEC     H
0146++ F798 20 F9                           JR      NZ, _bright_char_loop
0147++ F79A CD A3 F5                        CALL    i2c_stop
0148++ F79D             
0149++ F79D 2E 00                           LD      L, LED_PAGE
0150++ F79F CD 37 F7                        CALL    disp_page
0151++ F7A2 C9                              RET
0152++ F7A3                                 
0153++ F7A3             ; Display a single character A at column C
0154++ F7A3             ;
0155++ F7A3             ; Returns with A pointing to next column
0156++ F7A3             ;
0157++ F7A3 FE 20       disp_character      CP      32
0158++ F7A5 F2 AF F7                        JP      P, _not_control
0159++ F7A8             
0160++ F7A8 21 61 48    _invalid_char       LD      HL, INVALID_CHAR_BITMASK
0161++ F7AB 79                              LD      A, C
0162++ F7AC C3 C4 F7                        JP      disp_bitmask
0163++ F7AF             
0164++ F7AF CB 7F       _not_control        BIT     7, A
0165++ F7B1 C2 A8 F7                        JP      NZ, _invalid_char
0166++ F7B4 D6 20                           SUB     32
0167++ F7B6             
0168++ F7B6 16 00                           LD      D, 0
0169++ F7B8 5F                              LD      E, A
0170++ F7B9 CB 23                           SLA     E                   ; Don't need to shift into D, since bit 7 is zero
0171++ F7BB 21 14 F8                        LD      HL, font  
0172++ F7BE 19                              ADD     HL, DE
0173++ F7BF 56                              LD      D, (HL)
0174++ F7C0 23                              INC     HL
0175++ F7C1 66                              LD      H, (HL)
0176++ F7C2 6A                              LD      L, D
0177++ F7C3 79                              LD      A, C
0178++ F7C4                                 ; Fall into disp_bitmask
0179++ F7C4             
0180++ F7C4             ; Display a bitmask in HL at column A (0 - 23)
0181++ F7C4             ;
0182++ F7C4             ; Returns with A pointing to next column
0183++ F7C4             ;
0184++ F7C4             ; Uses A, B, C, D, E
0185++ F7C4 F5          disp_bitmask        PUSH    AF
0186++ F7C5 06 50                           LD      B, DL_ADDRESS
0187++ F7C7 FE 0C                           CP      12
0188++ F7C9 DA D0 F7                        JP      C, _disp_left
0189++ F7CC 06 53                           LD      B, DR_ADDRESS
0190++ F7CE D6 0C                           SUB     12
0191++ F7D0 5F          _disp_left          LD      E, A
0192++ F7D1 CD 94 F5                        CALL    i2c_start
0193++ F7D4 78                              LD      A, B
0194++ F7D5 CD ED F5                        CALL    i2c_address_w
0195++ F7D8 7B                              LD      A, E
0196++ F7D9 CB 27                           SLA     A
0197++ F7DB CD EF F5                        CALL    i2c_write
0198++ F7DE 7D                              LD      A, L
0199++ F7DF CD EF F5                        CALL    i2c_write
0200++ F7E2 7C                              LD      A, H
0201++ F7E3 CD EF F5                        CALL    i2c_write
0202++ F7E6 CD A3 F5                        CALL    i2c_stop
0203++ F7E9 F1                              POP     AF
0204++ F7EA 3C                              INC     A
0205++ F7EB C9                              RET
0206++ F7EC             
0207++ F7EC             ;
0208++ F7EC             ; Clear the display and show an inline string from column 0
0209++ F7EC             ;
0210++ F7EC CD 06 F8    disp_clear_inline   CALL    disp_clear
0211++ F7EF AF                              XOR     A
0212++ F7F0             ;
0213++ F7F0             ; Display an inline string to column A->
0214++ F7F0             ;
0215++ F7F0 E3          disp_inline         EX      (SP), HL
0216++ F7F1 CD F7 F7                        CALL    disp_string
0217++ F7F4 23                              INC     HL
0218++ F7F5 E3                              EX      (SP), HL
0219++ F7F6 C9                              RET
0220++ F7F7             
0221++ F7F7             ; Display a string pointed to by HL to column A->
0222++ F7F7             ; Note string should be zero terminated...
0223++ F7F7             ; Returns with HL pointing to the 0 terminator
0224++ F7F7             ;
0225++ F7F7 4F          disp_string         LD      C, A
0226++ F7F8 7E                              LD      A, (HL)
0227++ F7F9 B7                              OR      A
0228++ F7FA C2 FE F7                        JP      NZ, _char_ok
0229++ F7FD C9                              RET
0230++ F7FE             
0231++ F7FE E5          _char_ok            PUSH    HL
0232++ F7FF CD A3 F7                        CALL    disp_character
0233++ F802 E1                              POP     HL
0234++ F803 23                              INC     HL
0235++ F804 18 F1                           JR      disp_string
0236++ F806             
0237++ F806             ; Clear the display
0238++ F806             ;
0239++ F806 3E 00       disp_clear          LD      A, 0
0240++ F808 21 00 00                        LD      HL, 0
0241++ F80B CD C4 F7    _clear_loop         CALL    disp_bitmask
0242++ F80E FE 18                           CP      24
0243++ F810 C2 0B F8                        JP      NZ, _clear_loop
0244++ F813 C9                              RET
0245++ F814             
0246++ F814                                 .MODULE main1508+  F814                                 .INCLUDE "../font.asm"
0001++ F814             ;
0002++ F814             ; Font definition
0003++ F814             ;
0004++ F814             ;
0005++ F814             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006++ F814             ;
0007++ F814             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008++ F814             ;
0009++ F814             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010++ F814             ; of this software and associated documentation files (the "Software"), to deal
0011++ F814             ; in the Software without restriction, including without limitation the rights
0012++ F814             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013++ F814             ; copies of the Software, and to permit persons to whom the Software is
0014++ F814             ; furnished to do so, subject to the following conditions:
0015++ F814             ; 
0016++ F814             ; The above copyright notice and this permission notice shall be included in all
0017++ F814             ; copies or substantial portions of the Software.
0018++ F814             ; 
0019++ F814             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020++ F814             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021++ F814             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022++ F814             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023++ F814             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024++ F814             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025++ F814             ; SOFTWARE.
0026++ F814             ;
0027++ F814             
0028++ F814             INVALID_CHAR_BITMASK    .EQU 04861h
0029++ F814             
0030++ F814             font
0031++ F814 00 00                           .dw     0000h
0032++ F816 00 49                           .dw     4900h   ; !
0033++ F818 02 02                           .dw     0202h   ; "
0034++ F81A CE 12                           .dw     12ceh   ; #
0035++ F81C ED 12                           .dw     12edh   ; $
0036++ F81E E4 2D                           .dw     2de4h   ; %
0037++ F820 59 0B                           .dw     0b59h   ; &
0038++ F822 00 02                           .dw     0200h   ; '
0039++ F824 00 0C                           .dw     0c00h   ; (
0040++ F826 00 21                           .dw     2100h   ; )
0041++ F828 C0 3F                           .dw     3fc0h   ; *
0042++ F82A C0 12                           .dw     12c0h   ; +
0043++ F82C 00 20                           .dw     2000h   ; ,
0044++ F82E C0 00                           .dw     00c0h   ; -
0045++ F830 00 40                           .dw     4000h   ; .
0046++ F832 00 24                           .dw     2400h   ; /
0047++ F834             
0048++ F834 3F 24                           .dw     243fh   ; 0
0049++ F836 06 04                           .dw     0406h   ; 1
0050++ F838 DB 00                           .dw     00dbh   ; 2
0051++ F83A 8F 00                           .dw     008fh   ; 3
0052++ F83C E6 00                           .dw     00e6h   ; 4
0053++ F83E 69 08                           .dw     0869h   ; 5
0054++ F840 FD 00                           .dw     00fdh   ; 6
0055++ F842 01 14                           .dw     1401h   ; 7
0056++ F844 FF 00                           .dw     00ffh   ; 8
0057++ F846 EF 00                           .dw     00efh   ; 9
0058++ F848 40 00                           .dw     0040h   ; :
0059++ F84A 00 22                           .dw     2200h   ; ;
0060++ F84C 40 0C                           .dw     0c40h   ; <
0061++ F84E C8 00                           .dw     00c8h   ; = 
0062++ F850 80 21                           .dw     2180h   ; >
0063++ F852 83 50                           .dw     5083h   ; ?
0064++ F854             
0065++ F854 BB 02                           .dw     02bbh   ; @
0066++ F856 F7 00                           .dw     00f7h   ; A
0067++ F858 8F 12                           .dw     128fh   ; B
0068++ F85A 39 00                           .dw     0039h   ; C
0069++ F85C 0F 12                           .dw     120fh   ; D
0070++ F85E 79 00                           .dw     0079h   ; E
0071++ F860 71 00                           .dw     0071h   ; F
0072++ F862 BD 00                           .dw     00bdh   ; G
0073++ F864 F6 00                           .dw     00f6h   ; H
0074++ F866 09 12                           .dw     1209h   ; I
0075++ F868 1E 00                           .dw     001eh   ; J
0076++ F86A 70 0C                           .dw     0c70h   ; K
0077++ F86C 38 00                           .dw     0038h   ; L
0078++ F86E 36 05                           .dw     0536h   ; M
0079++ F870 36 09                           .dw     0936h   ; N
0080++ F872 3F 00                           .dw     003fh   ; O
0081++ F874             
0082++ F874 F3 00                           .dw     00f3h   ; P
0083++ F876 3F 08                           .dw     083fh   ; Q
0084++ F878 F3 08                           .dw     08f3h   ; R
0085++ F87A ED 00                           .dw     00edh   ; S
0086++ F87C 01 12                           .dw     1201h   ; T
0087++ F87E 3E 00                           .dw     003eh   ; U
0088++ F880 30 24                           .dw     2430h   ; V
0089++ F882 36 28                           .dw     2836h   ; W
0090++ F884 00 2D                           .dw     2d00h   ; X
0091++ F886 EE 00                           .dw     00eeh   ; Y
0092++ F888 09 24                           .dw     2409h   ; Z
0093++ F88A 39 00                           .dw     0039h   ; [
0094++ F88C 00 09                           .dw     0900h   ; \
0095++ F88E 0F 00                           .dw     000fh   ; ]
0096++ F890 00 28                           .dw     2800h   ; ^
0097++ F892 08 00                           .dw     0008h   ; _
0098++ F894             
0099++ F894 00 01                           .dw     0100h   ; `
0100++ F896 8C 20                           .dw     208ch   ; a
0101++ F898 78 08                           .dw     0878h   ; b
0102++ F89A D8 00                           .dw     00d8h   ; c
0103++ F89C 8E 20                           .dw     208eh   ; d 
0104++ F89E 58 20                           .dw     2058h   ; e 
0105++ F8A0 C0 14                           .dw     14c0h   ; f
0106++ F8A2 8E 04                           .dw     048eh   ; g
0107++ F8A4 70 10                           .dw     1070h   ; h
0108++ F8A6 00 10                           .dw     1000h   ; i
0109++ F8A8 10 22                           .dw     2210h   ; j
0110++ F8AA 00 1E                           .dw     1e00h   ; k
0111++ F8AC 00 12                           .dw     1200h   ; l
0112++ F8AE D4 10                           .dw     10d4h   ; m
0113++ F8B0 50 10                           .dw     1050h   ; n
0114++ F8B2 DC 00                           .dw     00dch   ; o
0115++ F8B4             
0116++ F8B4 70 01                           .dw     0170h   ; p
0117++ F8B6 86 04                           .dw     0486h   ; q
0118++ F8B8 50 00                           .dw     0050h   ; r
0119++ F8BA 88 08                           .dw     0888h   ; s
0120++ F8BC 78 00                           .dw     0078h   ; t
0121++ F8BE 1C 00                           .dw     001ch   ; u
0122++ F8C0 10 20                           .dw     2010h   ; v
0123++ F8C2 14 28                           .dw     2814h   ; w
0124++ F8C4 00 2D                           .dw     2d00h   ; x
0125++ F8C6 8E 02                           .dw     028eh   ; y
0126++ F8C8 48 20                           .dw     2048h   ; z
0127++ F8CA 49 21                           .dw     2149h   ; {
0128++ F8CC 00 12                           .dw     1200h   ; |
0129++ F8CE 89 0C                           .dw     0c89h   ; }
0130++ F8D0 C0 24                           .dw     24c0h   ; ~
0131++ F8D2 00 00                           .dw     0000h   ; 1509+  F8D4                                 .INCLUDE "bios_rtc.asm"
0001++ F8D4             ; RTC Routines
0002++ F8D4             ;
0003++ F8D4             ;
0004++ F8D4             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ F8D4             ;
0006++ F8D4             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ F8D4             ;
0008++ F8D4             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ F8D4             ; of this software and associated documentation files (the "Software"), to deal
0010++ F8D4             ; in the Software without restriction, including without limitation the rights
0011++ F8D4             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ F8D4             ; copies of the Software, and to permit persons to whom the Software is
0013++ F8D4             ; furnished to do so, subject to the following conditions:
0014++ F8D4             ; 
0015++ F8D4             ; The above copyright notice and this permission notice shall be included in all
0016++ F8D4             ; copies or substantial portions of the Software.
0017++ F8D4             ; 
0018++ F8D4             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ F8D4             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ F8D4             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ F8D4             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ F8D4             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ F8D4             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ F8D4             ; SOFTWARE.
0025++ F8D4             ;
0026++ F8D4             ;
0027++ F8D4                                     .MODULE rtc
0028++ F8D4             
0029++ F8D4             ; Set the initial time and start the clock
0030++ F8D4             ;
0031++ F8D4             ;
0032++ F8D4 CD 04 F0    rtc_init                CALL    m_print_inline
0033++ F8D7 0A 0D 43 68                         .DB     "\n\rCheck RTC",0
0033++ F8DB 65 63 6B 20 
0033++ F8DF 52 54 43 00 
0034++ F8E3             
0035++ F8E3 CD 58 F9                            CALL    _read_seconds
0036++ F8E6 CD 53 F9                            CALL    _pause
0037++ F8E9 CB 7B                               BIT     7, E                ; Check to see if the clock is running
0038++ F8EB C0                                  RET     NZ                  ; Return if it is..
0039++ F8EC             
0040++ F8EC CD 04 F0    _do_reset               CALL    m_print_inline
0041++ F8EF 0A 0D 52 65                         .DB     "\n\rReset RTC",0
0041++ F8F3 73 65 74 20 
0041++ F8F7 52 54 43 00 
0042++ F8FB             
0043++ F8FB 26 6F                               LD      H, RTC_ADDRESS      ; Clock isn't running, reset to default time
0044++ F8FD 2E 00                               LD      L, RTC_REG_SEC
0045++ F8FF CD DB F5                            CALL    i2c_write_to
0046++ F902 D2 66 F9                            JP      NC, rtc_ack_error
0047++ F905             
0048++ F905 21 A5 F9                            LD      HL, time_scratch
0049++ F908 7E          _reset_loop             LD      A, (HL)
0050++ F909 23                                  INC     HL
0051++ F90A FE FF                               CP      0ffh
0052++ F90C CA 17 F9                            JP      Z, _start_clock
0053++ F90F CD EF F5                            CALL    i2c_write
0054++ F912 D2 66 F9                            JP      NC, rtc_ack_error
0055++ F915 18 F1                               JR      _reset_loop
0056++ F917             
0057++ F917 CD A3 F5    _start_clock            CALL    i2c_stop            ; Enable VBAT and start the clock
0058++ F91A             
0059++ F91A 26 6F                               LD      H, RTC_ADDRESS      ; Enable VBAT
0060++ F91C 2E 03                               LD      L, RTC_REG_WKDAY
0061++ F91E CD BA F5                            CALL    i2c_read_from
0062++ F921 D2 66 F9                            JP      NC, rtc_ack_error
0063++ F924 5F                                  LD      E, A
0064++ F925 CD A3 F5                            CALL    i2c_stop
0065++ F928 CB DB                               SET     3, E
0066++ F92A CD 53 F9                            CALL    _pause
0067++ F92D             
0068++ F92D CD DB F5                            CALL    i2c_write_to
0069++ F930 D2 66 F9                            JP      NC, rtc_ack_error
0070++ F933 7B                                  LD      A, E
0071++ F934 CD EF F5                            CALL    i2c_write
0072++ F937 D2 66 F9                            JP      NC, rtc_ack_error
0073++ F93A CD A3 F5                            CALL    i2c_stop
0074++ F93D             
0075++ F93D CD 58 F9                            CALL    _read_seconds
0076++ F940 CB FB                               SET     7, E                ; Set bit 7 to enable clock
0077++ F942                                     
0078++ F942 CD DB F5                            CALL    i2c_write_to
0079++ F945 D2 66 F9                            JP      NC, rtc_ack_error
0080++ F948 7B                                  LD      A, E
0081++ F949 CD EF F5                            CALL    i2c_write
0082++ F94C D2 66 F9                            JP      NC, rtc_ack_error
0083++ F94F CD A3 F5                            CALL    i2c_stop
0084++ F952 C9                                  RET
0085++ F953             
0086++ F953 06 00       _pause                  LD      B, 0
0087++ F955 10 FE                               DJNZ    $
0088++ F957 C9                                  RET
0089++ F958             
0090++ F958             ;
0091++ F958             ; Read seconds register in E
0092++ F958             ;
0093++ F958 26 6F       _read_seconds           LD      H, RTC_ADDRESS      
0094++ F95A 2E 00                               LD      L, RTC_REG_SEC      
0095++ F95C CD BA F5                            CALL    i2c_read_from
0096++ F95F D2 66 F9                            JP      NC, rtc_ack_error
0097++ F962 5F                                  LD      E, A
0098++ F963 C3 A3 F5                            JP     i2c_stop
0099++ F966             
0100++ F966 CD A3 F5    rtc_ack_error           CALL    i2c_stop
0101++ F969                                     
0102++ F969 CD 04 F0                            CALL    m_print_inline
0103++ F96C 0A 0D 52 54                         .DB     "\n\rRTC Panic",0
0103++ F970 43 20 50 61 
0103++ F974 6E 69 63 00 
0104++ F978 C9                                  RET
0105++ F979             
0106++ F979             ;
0107++ F979             ; Read the time to the 7 bytes starting at HL
0108++ F979             ; Returns with Carry SET if successful, else Carry CLEAR
0109++ F979             ;
0110++ F979 E5          rtc_get_time_hl         PUSH    HL
0111++ F97A 26 6F                               LD      H, RTC_ADDRESS
0112++ F97C 2E 00                               LD      L, RTC_REG_SEC
0113++ F97E CD BA F5                            CALL    i2c_read_from
0114++ F981 C1                                  POP     BC
0115++ F982 D0                                  RET     NC
0116++ F983 21 9D F9                            LD      HL, _masktable
0117++ F986 18 08                               JR      _store_time
0118++ F988 C5          _get_loop               PUSH    BC 
0119++ F989 CD 4D F6                            CALL    i2c_ack
0120++ F98C CD 3A F6                            CALL    i2c_read
0121++ F98F C1                                  POP     BC
0122++ F990 A6          _store_time             AND     (HL)
0123++ F991 02                                  LD      (BC), A
0124++ F992 23                                  INC     HL
0125++ F993 03                                  INC     BC
0126++ F994 7E                                  LD      A, (HL)
0127++ F995 A7                                  AND     A
0128++ F996 20 F0                               JR      NZ, _get_loop
0129++ F998 CD A3 F5                            CALL    i2c_stop
0130++ F99B 37                                  SCF
0131++ F99C C9                                  RET
0132++ F99D             
0133++ F99D 7F          _masktable              .db     07fh        ; Seconds
0134++ F99E 7F                                  .db     07fh        ; Minutes
0135++ F99F 3F                                  .db     03fh        ; Hours
0136++ F9A0 07                                  .db     007h        ; Weekday
0137++ F9A1 3F                                  .db     03Fh        ; Date
0138++ F9A2 1F                                  .db     01fh        ; Month
0139++ F9A3 FF                                  .db     0ffh        ; Year
0140++ F9A4 00                                  .db     000h        ; End of mask marker
0141++ F9A5             
0142++ F9A5             
0143++ F9A5                                     ;  Initial time on power up..
0144++ F9A5 23          time_scratch            .db  23h            ; Seconds
0145++ F9A6 59                                  .db  59h            ; Minutes
0146++ F9A7 08                                  .db  08h            ; Hours    (24 hr clock)
0147++ F9A8 06                                  .db  06h            ; Weekday  (1-7. Monday=1)
0148++ F9A9 05                                  .db  05h            ; Date
0149++ F9AA 11                                  .db  11h            ; Month
0150++ F9AB 22                                  .db  22h            ; Year 
0151++ F9AC FF                                  .db  0ffh           ; 0ffh end marker
0152++ F9AD             
0153++ F9AD                                     .MODULE main
1510+  F9AD                                 .INCLUDE "../flash.asm"
0001++ F9AD             ;
0002++ F9AD             ; Flash update routines
0003++ F9AD             ;
0004++ F9AD             ; Note that any memory write operations *at all* during flash updates will cancel the current operation.
0005++ F9AD             ; That means no data can be stored to memory, no stack operations (call, push), no interrupts.
0006++ F9AD             ; 
0007++ F9AD             ;
0008++ F9AD             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0009++ F9AD             ;
0010++ F9AD             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0011++ F9AD             ;
0012++ F9AD             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0013++ F9AD             ; of this software and associated documentation files (the "Software"), to deal
0014++ F9AD             ; in the Software without restriction, including without limitation the rights
0015++ F9AD             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0016++ F9AD             ; copies of the Software, and to permit persons to whom the Software is
0017++ F9AD             ; furnished to do so, subject to the following conditions:
0018++ F9AD             ; 
0019++ F9AD             ; The above copyright notice and this permission notice shall be included in all
0020++ F9AD             ; copies or substantial portions of the Software.
0021++ F9AD             ; 
0022++ F9AD             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0023++ F9AD             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0024++ F9AD             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0025++ F9AD             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0026++ F9AD             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0027++ F9AD             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0028++ F9AD             ; SOFTWARE.
0029++ F9AD             ;
0030++ F9AD                                 .MODULE     flash
0031++ F9AD             
0032++ F9AD             _cmd_1_addr         .EQU  05555h
0033++ F9AD             _cmd_2_addr         .EQU  02AAAh
0034++ F9AD             
0035++ F9AD             _bank_mask          .EQU  03FFFh                ; One memory bank is 14 bits -> 16Kb
0036++ F9AD             _sector_mask        .EQU  00FFFh                ; A sector is 12 bits -> 4Kb
0037++ F9AD             
0038++ F9AD             _cmd_1_addr_bank    .EQU  _cmd_1_addr >> 14
0039++ F9AD             _cmd_2_addr_bank    .EQU  _cmd_2_addr >> 14
0040++ F9AD             _cmd_3_addr_bank    .EQU  _cmd_1_addr_bank
0041++ F9AD             _cmd_4_addr_bank    .EQU  _cmd_1_addr_bank
0042++ F9AD             _cmd_5_addr_bank    .EQU  _cmd_2_addr_bank
0043++ F9AD             
0044++ F9AD             _cmd_1_logical_addr .EQU  _cmd_1_addr & _bank_mask
0045++ F9AD             _cmd_2_logical_addr .EQU  _cmd_2_addr & _bank_mask
0046++ F9AD             _cmd_3_logical_addr .EQU  _cmd_1_logical_addr
0047++ F9AD             _cmd_4_logical_addr .EQU  _cmd_1_logical_addr
0048++ F9AD             _cmd_5_logical_addr .EQU  _cmd_2_logical_addr
0049++ F9AD             
0050++ F9AD             _cmd_1_data         .EQU  0AAh
0051++ F9AD             _cmd_2_data         .EQU  055h
0052++ F9AD             _cmd_3_data_write   .EQU  0A0h
0053++ F9AD             _cmd_3_data_erase   .EQU  080h
0054++ F9AD             _cmd_4_data         .EQU  0AAh
0055++ F9AD             _cmd_5_data         .EQU  055h
0056++ F9AD             
0057++ F9AD             _cmd_6_data_erase   .EQU  030h
0058++ F9AD             
0059++ F9AD             ;
0060++ F9AD             ; Enter with A -> 7 bit index of 4K sector to be erased.
0061++ F9AD             ;
0062++ F9AD             ; Preserves BC, DE, HL
0063++ F9AD             ;
0064++ F9AD             ; Note this uses bank 0, and leaves it configured for the page containing the erased sector
0065++ F9AD             ;
0066++ F9AD             ; Typical time to erase sector ~18ms
0067++ F9AD             ;
0068++ F9AD F3          flash_sector_erase  DI                          ; Disable interrupts
0069++ F9AE E5                              PUSH    HL
0070++ F9AF C5                              PUSH    BC
0071++ F9B0 D5                              PUSH    DE
0072++ F9B1             
0073++ F9B1 E6 7F                           AND     07fh
0074++ F9B3 57                              LD      D, A
0075++ F9B4 CB 3A                           SRL     D
0076++ F9B6 CB 3A                           SRL     D                   ; D is now the bank number
0077++ F9B8             
0078++ F9B8 CB 27                           SLA     A
0079++ F9BA CB 27                           SLA     A
0080++ F9BC CB 27                           SLA     A
0081++ F9BE CB 27                           SLA     A
0082++ F9C0 E6 30                           AND     030h
0083++ F9C2 5F                              LD      E, A                ; E is the sector within the bank shifted into bits 13 & 12
0084++ F9C3             
0085++ F9C3 0E 70                           LD      C, IO_MEM_0         ; Use bank 0 to write to
0086++ F9C5 3E 01                           LD      A, _cmd_1_addr_bank
0087++ F9C7 ED 79                           OUT     (C), A
0088++ F9C9 21 55 15                        LD      HL, _cmd_1_logical_addr
0089++ F9CC 36 AA                           LD      (HL), _cmd_1_data
0090++ F9CE             
0091++ F9CE 3E 00                           LD      A, _cmd_2_addr_bank
0092++ F9D0 ED 79                           OUT     (C), A
0093++ F9D2 21 AA 2A                        LD      HL, _cmd_2_logical_addr
0094++ F9D5 36 55                           LD      (HL), _cmd_2_data
0095++ F9D7             
0096++ F9D7 3E 01                           LD      A, _cmd_3_addr_bank
0097++ F9D9 ED 79                           OUT     (C), A
0098++ F9DB 21 55 15                        LD      HL, _cmd_3_logical_addr
0099++ F9DE 36 80                           LD      (HL), _cmd_3_data_erase
0100++ F9E0             
0101++ F9E0 3E 01                           LD      A, _cmd_4_addr_bank
0102++ F9E2 ED 79                           OUT     (C), A
0103++ F9E4 21 55 15                        LD      HL, _cmd_4_logical_addr
0104++ F9E7 36 AA                           LD      (HL), _cmd_4_data
0105++ F9E9             
0106++ F9E9 3E 00                           LD      A, _cmd_5_addr_bank
0107++ F9EB ED 79                           OUT     (C), A
0108++ F9ED 21 AA 2A                        LD      HL, _cmd_5_logical_addr
0109++ F9F0 36 55                           LD      (HL), _cmd_5_data
0110++ F9F2             
0111++ F9F2 ED 51                           OUT     (C), D                  ; Switch to the bank containing our sector
0112++ F9F4 63                              LD      H, E                    ; And write the sector bits as an address (bits 0-11 are ignored)
0113++ F9F5 36 30                           LD      (HL), _cmd_6_data_erase
0114++ F9F7             
0115++ F9F7 7E          _wait_erase         LD      A,(HL)
0116++ F9F8 CB 07                           RLC     A
0117++ F9FA 30 FB                           JR      NC, _wait_erase
0118++ F9FC             
0119++ F9FC D1                              POP     DE
0120++ F9FD C1                              POP     BC
0121++ F9FE E1                              POP     HL
0122++ F9FF FB                              EI
0123++ FA00 C9                              RET
0124++ FA01             
0125++ FA01             ;
0126++ FA01             ; Enter with A -> Byte to write
0127++ FA01             ;            D -> 7 bit index of 4K sector being written
0128++ FA01             ;            HL -> 12 bit address of byte within sector
0129++ FA01             ;
0130++ FA01             ; Preserves D, HL
0131++ FA01             ; Uses A, BC, E
0132++ FA01             ;
0133++ FA01             ; Typical time to erase byte ~14us
0134++ FA01             ;
0135++ FA01 F3          flash_write_byte    DI
0136++ FA02 5F                              LD      E, A                ; Preserve our byte
0137++ FA03                                 
0138++ FA03 7C                              LD      A, H                ; Make sure HL is within our sector
0139++ FA04 E6 0F                           AND     _sector_mask >> 8
0140++ FA06 67                              LD      H, A
0141++ FA07             
0142++ FA07 7A                              LD      A, D                ; Make sure D is a valid sector index
0143++ FA08 E6 7F                           AND     07fh
0144++ FA0A 57                              LD      D, A
0145++ FA0B 47                              LD      B, A
0146++ FA0C             
0147++ FA0C 7A                              LD      A, D                ; Get the bottom 2 bits of our sector index..
0148++ FA0D E6 03                           AND     03h
0149++ FA0F CB 27                           SLA     A
0150++ FA11 CB 27                           SLA     A
0151++ FA13 CB 27                           SLA     A
0152++ FA15 CB 27                           SLA     A
0153++ FA17 B4                              OR      H
0154++ FA18 67                              LD      H, A                ; ..and OR them into H to get a 14 bit address within our bank
0155++ FA19             
0156++ FA19 CB 3A                           SRL     D
0157++ FA1B CB 3A                           SRL     D                   ; D is now our bank number
0158++ FA1D             
0159++ FA1D E5                              PUSH    HL
0160++ FA1E             
0161++ FA1E 0E 70                           LD      C, IO_MEM_0         ; Use bank 0 to write to
0162++ FA20 3E 01                           LD      A, _cmd_1_addr_bank
0163++ FA22 ED 79                           OUT     (C), A
0164++ FA24 21 55 15                        LD      HL, _cmd_1_logical_addr
0165++ FA27 36 AA                           LD      (HL), _cmd_1_data
0166++ FA29             
0167++ FA29 3E 00                           LD      A, _cmd_2_addr_bank
0168++ FA2B ED 79                           OUT     (C), A
0169++ FA2D 21 AA 2A                        LD      HL, _cmd_2_logical_addr
0170++ FA30 36 55                           LD      (HL), _cmd_2_data
0171++ FA32             
0172++ FA32 3E 01                           LD      A, _cmd_3_addr_bank
0173++ FA34 ED 79                           OUT     (C), A
0174++ FA36 21 55 15                        LD      HL, _cmd_3_logical_addr
0175++ FA39 36 A0                           LD      (HL), _cmd_3_data_write
0176++ FA3B             
0177++ FA3B ED 51                           OUT     (C), D
0178++ FA3D E1                              POP     HL
0179++ FA3E 73                              LD      (HL), E
0180++ FA3F             
0181++ FA3F 7E          _wait_byte          LD      A, (HL)
0182++ FA40 AB                              XOR     E
0183++ FA41 CB 07                           RLC     A
0184++ FA43 30 FA                           JR      NC, _wait_byte
0185++ FA45             
0186++ FA45 7C                              LD      A, H                ; Clear bits 13 & 12 to restore HL to sector address..
0187++ FA46 E6 0F                           AND     _sector_mask >> 8
0188++ FA48 67                              LD      H, A
0189++ FA49                            
0190++ FA49 50                              LD      D, B                ; And restore D
0191++ FA4A FB                              EI
0192++ FA4B C9                              RET
0193++ FA4C             
0194++ FA4C             ;
0195++ FA4C             ; Write a flash data block. This uses Page 0 to write the data, so the source must be above 3FFFh
0196++ FA4C             ;
0197++ FA4C             ;       D -> 7 bit index of 4K sector being written
0198++ FA4C             ;       HL -> Address of source data
0199++ FA4C             ;       BC -> bytes to write
0200++ FA4C             ;
0201++ FA4C             ; Returns D pointing to last sector written
0202++ FA4C             ; Note: This means if BC is an exact multiple of sector size, D is returned as the previous sector
0203++ FA4C             
0204++ FA4C DD E5       flash_write         PUSH    IX
0205++ FA4E E5                              PUSH    HL
0206++ FA4F DD E1                           POP     IX
0207++ FA51 21 00 00                        LD      HL, 0           ; Address in sector..
0208++ FA54             
0209++ FA54             _erase_sector       ; Lower 12 bits of HL are zero, erase sector before writing bytes
0210++ FA54 7A                              LD      A, D
0211++ FA55 CD AD F9                        CALL    flash_sector_erase
0212++ FA58 DD 7E 00    _write_loop         LD      A, (IX+0)
0213++ FA5B C5                              PUSH    BC
0214++ FA5C CD 01 FA                        CALL    flash_write_byte
0215++ FA5F C1                              POP     BC
0216++ FA60             
0217++ FA60 DD 23                           INC     IX
0218++ FA62 0B                              DEC     BC
0219++ FA63 78                              LD      A, B
0220++ FA64 B1                              OR      C
0221++ FA65 28 0E                           JR      Z, _success
0222++ FA67             
0223++ FA67 23                              INC     HL
0224++ FA68 7D                              LD      A, L
0225++ FA69 A7                              AND     A
0226++ FA6A 20 EC                           JR      NZ, _write_loop
0227++ FA6C 7C                              LD      A, H
0228++ FA6D E6 0F                           AND     _sector_mask >> 8
0229++ FA6F 67                              LD      H, A
0230++ FA70 20 E6                           JR      NZ, _write_loop
0231++ FA72             
0232++ FA72 14                              INC     D
0233++ FA73 18 DF                           JR      _erase_sector
0234++ FA75             
0235++ FA75 DD E1       _success            POP     IX
0236++ FA77 C9                              RET
0237++ FA78             
0238++ FA78                                 .MODULE main
1511+  FA78                                 .INCLUDE "videobeast.asm"
0001++ FA78             ;
0002++ FA78             ; VideoBeast includes for CP/M BIOS
0003++ FA78             ;
0004++ FA78             ;
0005++ FA78             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006++ FA78             ;
0007++ FA78             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008++ FA78             ;
0009++ FA78             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010++ FA78             ; of this software and associated documentation files (the "Software"), to deal
0011++ FA78             ; in the Software without restriction, including without limitation the rights
0012++ FA78             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013++ FA78             ; copies of the Software, and to permit persons to whom the Software is
0014++ FA78             ; furnished to do so, subject to the following conditions:
0015++ FA78             ; 
0016++ FA78             ; The above copyright notice and this permission notice shall be included in all
0017++ FA78             ; copies or substantial portions of the Software.
0018++ FA78             ; 
0019++ FA78             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020++ FA78             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021++ FA78             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022++ FA78             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023++ FA78             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024++ FA78             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025++ FA78             ; SOFTWARE.
0026++ FA78             ;
0027++ FA78             
0028++ FA78             VBASE               .EQU   04000h
0029++ FA78             
0030++ FA78             VB_MODE             .EQU   VBASE + 03FFFh
0031++ FA78             VB_REGISTERS_LOCKED .EQU   VBASE + 03FFEh
0032++ FA78             
0033++ FA78             VB_PAGE_0           .EQU   VBASE + 03FF9h
0034++ FA78             VB_PAGE_1           .EQU   VBASE + 03FF8h
0035++ FA78             VB_PAGE_2           .EQU   VBASE + 03FF7h
0036++ FA78             VB_PAGE_3           .EQU   VBASE + 03FF6h
0037++ FA78             
0038++ FA78             VB_LOWER_REGS       .EQU   VBASE + 03FF5h
0039++ FA78             
0040++ FA78             
0041++ FA78             VB_LAYER_0          .EQU   VBASE + 03F80h
0042++ FA78             VB_LAYER_1          .EQU   VBASE + 03F90h
0043++ FA78             VB_LAYER_2          .EQU   VBASE + 03FA0h
0044++ FA78             VB_LAYER_3          .EQU   VBASE + 03FB0h
0045++ FA78             VB_LAYER_4          .EQU   VBASE + 03FC0h
0046++ FA78             VB_LAYER_5          .EQU   VBASE + 03FD0h
0047++ FA78             
0048++ FA78             MODE_640            .EQU   0
0049++ FA78             MODE_848            .EQU   1
0050++ FA78             MODE_DOUBLE         .EQU   8
0051++ FA78             MODE_TESTCARD       .EQU   010h
0052++ FA78             
0053++ FA78             MODE_MAP_16K        .EQU   0
0054++ FA78             MODE_MAP_SINCLAIR   .EQU   080h
0055++ FA78             
0056++ FA78             LAYER_TYPE          .EQU   0
0057++ FA78             LAYER_TOP           .EQU   1
0058++ FA78             LAYER_BOTTOM        .EQU   2
0059++ FA78             LAYER_LEFT          .EQU   3
0060++ FA78             LAYER_RIGHT         .EQU   4
0061++ FA78             LAYER_SCROLL_X      .EQU   5
0062++ FA78             LAYER_SCROLL_XY     .EQU   6
0063++ FA78             LAYER_SCROLL_Y      .EQU   7
0064++ FA78             
0065++ FA78             TYPE_NONE           .EQU   0
0066++ FA78             TYPE_TEXT           .EQU   1
0067++ FA78             TYPE_SPRITE         .EQU   2
0068++ FA78             TYPE_TILE           .EQU   3
0069++ FA78             TYPE_BITMAP_8       .EQU   4
0070++ FA78             
0071++ FA78             TEXT_MAP_BASE       .EQU   8       ; 16Kb character map
0072++ FA78             TEXT_FONT_BASE      .EQU   9       ;  2Kb font offset
0073++ FA78             TEXT_PALETTE        .EQU   10      ; Bits 0-3: Palette number   Bit 4: Use Sinclair bit pattern
0074++ FA78             TEXT_BITMAP         .EQU   11      ; 16Kb 1bpp bitmap..
0075++ FA78             
0076++ FA78             VB_UNLOCK           .EQU   0F3h           ; Unlock register write
0077++ FA78             
0078++ FA78             VIDEOBEAST_PAGE     .EQU   40h 1512+  FA78             ;
1513+  FA78             ;
1514+  FA78             ; Page mapping - since the BIOS uses other pages to manage disk and screen, it must also manage the expected page for the user 
1515+  FA78             ; programs, to prevent them from being unexpectedly changed (eg. after interrupts).
1516+  FA78             ;
1517+  FA78             
1518+  FA78             ; Get the User page mapping. Sets A to the physical (RAM/ROM) page selelcted for logical page C (0-2)
1519+  FA78             ; Returns 0FFh for invalid page values
1520+  FA78 79          get_page_mapping    LD      A, C
1521+  FA79 CD 8D FA                        CALL    _mapping_address
1522+  FA7C 3E FF                           LD      A, 0FFH
1523+  FA7E D0                              RET     NC
1524+  FA7F 7E                              LD      A, (HL)
1525+  FA80 C9                              RET
1526+  FA81             
1527+  FA81             ; Set the User page mapping. Sets page A (0-2) to the physical (RAM/ROM) page in E
1528+  FA81             ; Returns with carry SET if successful. The given logical page will now point to the physical page in RAM or ROM
1529+  FA81             ;
1530+  FA81 CD 8D FA    set_page_mapping    CALL    _mapping_address
1531+  FA84 D0                              RET     NC
1532+  FA85 73                              LD      (HL), E 
1533+  FA86             
1534+  FA86 C6 70                           ADD     A, IO_MEM_0             ; NOTE: Order is important here. Interrupts may occur after the page is stored (above)
1535+  FA88 4F                              LD      C, A                    ; This may result in the page being prematurely mapped, but that's OK.
1536+  FA89 ED 59                           OUT     (C), E                  ; If we tried to set the page before storing the new default we'd have to disable interrupts
1537+  FA8B 37                              SCF                             ; To avoid a race condition
1538+  FA8C C9                              RET
1539+  FA8D             
1540+  FA8D FE 04       _mapping_address    CP      4
1541+  FA8F D0                              RET     NC
1542+  FA90 4F                              LD      C, A
1543+  FA91 06 00                           LD      B, 0
1544+  FA93 21 39 FF                        LD      HL, page_0_mapping
1545+  FA96 09                              ADD     HL, BC
1546+  FA97 37                              SCF
1547+  FA98 C9                              RET
1548+  FA99             
1549+  FA99             ; Get the page in memory being used as the base for the drive selected by A
1550+  FA99             ; Returns A = Page in ROM/RAM for the given drive
1551+  FA99             ;    or   A = 0 if the selected drive is not supported.
1552+  FA99             ;
1553+  FA99 FE 02       get_disk_page       CP      MAX_DRIVES
1554+  FA9B 30 09                           JR      NC, _disk_page_err
1555+  FA9D 4F                              LD      C, A
1556+  FA9E 06 00                           LD      B, 0
1557+  FAA0 21 37 FF                        LD      HL, drive_a_mem_page
1558+  FAA3 09                              ADD     HL, BC
1559+  FAA4 7E                              LD      A, (HL)
1560+  FAA5 C9                              RET
1561+  FAA6 AF          _disk_page_err      XOR     A
1562+  FAA7 C9                              RET
1563+  FAA8             
1564+  FAA8 3E 16       get_version         LD      A, 016h
1565+  FAAA C9                              RET
1566+  FAAB             
1567+  FAAB             ;
1568+  FAAB             ; Erase and write flash data. Data is written to 4K sectors, which are erased before writing.
1569+  FAAB             ; This uses Page 0 to write the data, so the source must be above 3FFFh
1570+  FAAB             ;
1571+  FAAB             ;       D -> 7 bit index of 4K sector being written
1572+  FAAB             ;       HL -> Address of source data
1573+  FAAB             ;       BC -> bytes to write
1574+  FAAB             ;
1575+  FAAB             ; Returns D pointing to last sector written
1576+  FAAB             ; Note: This means if BC is an exact multiple of sector size, D is returned as the previous sector
1577+  FAAB             
1578+  FAAB CD 4C FA    bios_flash_write    CALL    flash_write 
1579+  FAAE 3A 39 FF                        LD      A, (page_0_mapping)
1580+  FAB1 D3 70                           OUT     (IO_MEM_0), A
1581+  FAB3 C9                              RET 
1582+  FAB4             
1583+  FAB4             ;
1584+  FAB4             ; Set or query the user interrupt. The specified routine will be called after keyboard polling, every 60th of a 
1585+  FAB4             ; second. The shadow register set is selected before the call (EXX), and AF is preserved. The routine should 
1586+  FAB4             ; RETurn normally. Interrupt routines survive warm reboots, but no special measures are taken to ensure the
1587+  FAB4             ; memory they occupy is preserved.
1588+  FAB4             ;
1589+  FAB4             ;   Parameters: 
1590+  FAB4             ;       HL = Address of user interrupt routine, or zero to disable. Call with 0FFFFh to query the current value
1591+  FAB4             ;   Returns:
1592+  FAB4             ;       The address of the current user interrupt routine, or zero if none is configured.
1593+  FAB4             ;
1594+  FAB4             ;
1595+  FAB4 7C          set_usr_interrupt   LD      A, H
1596+  FAB5 A5                              AND     L
1597+  FAB6 3C                              INC     A
1598+  FAB7 28 03                           JR      Z, _return_usr_int
1599+  FAB9 22 CF FF                        LD      (user_interrupt), HL
1600+  FABC 2A CF FF    _return_usr_int     LD      HL, (user_interrupt)
1601+  FABF C9                              RET
1602+  FAC0             
1603+  FAC0             JUMP_TABLE_SIZE     .EQU    18
1604+  FAC0             
1605+  FAC0~            .IF $ > (BIOS_TOP - (3*JUMP_TABLE_SIZE))
1606+  FAC0~                .ECHO "BIOS No room for Jump Table ("
1607+  FAC0~                .ECHO $
1608+  FAC0~                .ECHO " > "
1609+  FAC0~                .ECHO (BIOS_TOP-(3*JUMP_TABLE_SIZE))
1610+  FAC0~                .ECHO ") \n\n"
1611+  FAC0~                .STOP
1612+  FAC0             .ENDIF
1613+  FAC0             
1614+  FAC0             BIOS_SPARE          .EQU    BIOS_TOP - $ - (3*JUMP_TABLE_SIZE)
1615+  FAC0 00 00 00 00                     .FILL   BIOS_SPARE, 0
1615+  FAC4 00 00 00 00 
1615+  FAC8 00 00 00 00 
1615+  FACC 00 00 00 00 
1615+  FAD0 00 00 00 00 
1615+  FAD4 00 00 00 00 
1615+  FAD8 00 00 00 00 
1615+  FADC 00 00 00 00 
1615+  FAE0 00 00 00 00 
1615+  FAE4 00 00 00 00 
1615+  FAE8 00 00 00 00 
1615+  FAEC 00 00 00 00 
1615+  FAF0 00 00 00 00 
1615+  FAF4 00 00 00 00 
1615+  FAF8 00 00 00 00 
1615+  FAFC 00 00 00 00 
1615+  FB00 00 00 00 00 
1615+  FB04 00 00 00 00 
1615+  FB08 00 00 00 00 
1615+  FB0C 00 00 00 00 
1615+  FB10 00 00 00 00 
1615+  FB14 00 00 00 00 
1615+  FB18 00 00 00 00 
1615+  FB1C 00 00 00 00 
1615+  FB20 00 00 00 00 
1615+  FB24 00 00 00 00 
1615+  FB28 00 00 00 00 
1615+  FB2C 00 00 00 00 
1615+  FB30 00 00 00 00 
1615+  FB34 00 00 00 00 
1615+  FB38 00 00 00 00 
1615+  FB3C 00 00 00 00 
1615+  FB40 00 00 00 00 
1615+  FB44 00 00 00 00 
1615+  FB48 00 00 00 00 
1615+  FB4C 00 00 00 00 
1615+  FB50 00 00 00 00 
1615+  FB54 00 00 00 00 
1615+  FB58 00 00 00 00 
1615+  FB5C 00 00 00 00 
1615+  FB60 00 00 00 00 
1615+  FB64 00 00 00 00 
1615+  FB68 00 00 00 00 
1615+  FB6C 00 00 00 00 
1615+  FB70 00 00 00 00 
1615+  FB74 00 00 00 00 
1615+  FB78 00 00 00 00 
1615+  FB7C 00 00 00 00 
1615+  FB80 00 00 00 00 
1615+  FB84 00 00 00 00 
1615+  FB88 00 00 00 00 
1615+  FB8C 00 00 00 00 
1615+  FB90 00 00 00 00 
1615+  FB94 00 00 00 00 
1615+  FB98 00 00 00 00 
1615+  FB9C 00 00 00 00 
1615+  FBA0 00 00 00 00 
1615+  FBA4 00 00 00 00 
1615+  FBA8 00 00 00 00 
1615+  FBAC 00 00 00 00 
1615+  FBB0 00 00 00 00 
1615+  FBB4 00 00 00 00 
1615+  FBB8 00 00 00 00 
1615+  FBBC 00 00 00 00 
1615+  FBC0 00 00 00 00 
1615+  FBC4 00 00 00 00 
1615+  FBC8 00 00 00 00 
1615+  FBCC 00 00 00 00 
1615+  FBD0 00 00 00 00 
1615+  FBD4 00 00 00 00 
1615+  FBD8 00 00 00 00 
1615+  FBDC 00 00 00 00 
1615+  FBE0 00 00 00 00 
1615+  FBE4 00 00 00 00 
1615+  FBE8 00 00 00 00 
1615+  FBEC 00 00 00 00 
1615+  FBF0 00 00 00 00 
1615+  FBF4 00 00 00 00 
1615+  FBF8 00 00 00 00 
1615+  FBFC 00 00 00 00 
1615+  FC00 00 00 00 00 
1615+  FC04 00 00 00 00 
1615+  FC08 00 00 00 00 
1615+  FC0C 00 00 00 00 
1615+  FC10 00 00 00 00 
1615+  FC14 00 00 00 00 
1615+  FC18 00 00 00 00 
1615+  FC1C 00 00 00 00 
1615+  FC20 00 00 00 00 
1615+  FC24 00 00 00 00 
1615+  FC28 00 00 00 00 
1615+  FC2C 00 00 00 00 
1615+  FC30 00 00 00 00 
1615+  FC34 00 00 00 00 
1615+  FC38 00 00 00 00 
1615+  FC3C 00 00 00 00 
1615+  FC40 00 00 00 00 
1615+  FC44 00 00 00 00 
1615+  FC48 00 00 00 00 
1615+  FC4C 00 00 00 00 
1615+  FC50 00 00 00 00 
1615+  FC54 00 00 00 00 
1615+  FC58 00 00 00 00 
1615+  FC5C 00 00 00 00 
1615+  FC60 00 00 00 00 
1615+  FC64 00 00 00 00 
1615+  FC68 00 00 00 00 
1615+  FC6C 00 00 00 00 
1615+  FC70 00 00 00 00 
1615+  FC74 00 00 00 00 
1615+  FC78 00 00 00 00 
1615+  FC7C 00 00 00 00 
1615+  FC80 00 00 00 00 
1615+  FC84 00 00 00 00 
1615+  FC88 00 00 00 00 
1615+  FC8C 00 00 00 00 
1615+  FC90 00 00 00 00 
1615+  FC94 00 00 00 00 
1615+  FC98 00 00 00 00 
1615+  FC9C 00 00 00 00 
1615+  FCA0 00 00 00 00 
1615+  FCA4 00 00 00 00 
1615+  FCA8 00 00 00 00 
1615+  FCAC 00 00 00 00 
1615+  FCB0 00 00 00 00 
1615+  FCB4 00 00 00 00 
1615+  FCB8 00 00 00 00 
1615+  FCBC 00 00 00 00 
1615+  FCC0 00 00 00 00 
1615+  FCC4 00 00 00 00 
1615+  FCC8 00 00 00 00 
1615+  FCCC 00 00 00 00 
1615+  FCD0 00 00 00 00 
1615+  FCD4 00 00 00 00 
1615+  FCD8 00 00 00 00 
1615+  FCDC 00 00 00 00 
1615+  FCE0 00 00 00 00 
1615+  FCE4 00 00 00 00 
1615+  FCE8 00 00 00 00 
1615+  FCEC 00 00 00 00 
1615+  FCF0 00 00 00 00 
1615+  FCF4 00 00 00 00 
1615+  FCF8 00 00 00 00 
1615+  FCFC 00 00 00 00 
1615+  FD00 00 00 00 00 
1615+  FD04 00 00 00 00 
1615+  FD08 00 00 00 00 
1615+  FD0C 00 00 00 00 
1615+  FD10 00 00 00 00 
1615+  FD14 00 00 00 00 
1615+  FD18 00 00 00 00 
1615+  FD1C 00 00 00 00 
1615+  FD20 00 00 00 00 
1615+  FD24 00 00 00 00 
1615+  FD28 00 00 00 00 
1615+  FD2C 00 00 00 00 
1615+  FD30 00 00 00 00 
1615+  FD34 00 00 00 00 
1615+  FD38 00 00 00 00 
1615+  FD3C 00 00 00 00 
1615+  FD40 00 00 00 00 
1615+  FD44 00 00 00 00 
1615+  FD48 00 00 00 00 
1615+  FD4C 00 00 00 00 
1615+  FD50 00 00 00 00 
1615+  FD54 00 00 00 00 
1615+  FD58 00 00 00 00 
1615+  FD5C 00 00 00 00 
1615+  FD60 00 00 00 00 
1615+  FD64 00 00 00 00 
1615+  FD68 00 00 00 00 
1615+  FD6C 00 00 00 00 
1615+  FD70 00 00 00 00 
1615+  FD74 00 00 00 00 
1615+  FD78 00 00 00 00 
1615+  FD7C 00 00 00 00 
1615+  FD80 00 00 00 00 
1615+  FD84 00 00 00 00 
1615+  FD88 00 00 00 00 
1615+  FD8C 00 00 00 00 
1615+  FD90 00 00 00 00 
1615+  FD94 00 00 00 00 
1615+  FD98 00 00 00 00 
1615+  FD9C 00 00 00 00 
1615+  FDA0 00 00 00 00 
1615+  FDA4 00 00 00 00 
1615+  FDA8 00 00 00 00 
1615+  FDAC 00 00 00 00 
1615+  FDB0 00 00 00 00 
1615+  FDB4 00 00 00 00 
1615+  FDB8 00 00 00 00 
1615+  FDBC 00 00 00 00 
1615+  FDC0 00 00 00 00 
1615+  FDC4 00 00 00 
1616+  FDC7             
1617+  FDC7 C3 B4 FA                        JP          set_usr_interrupt   ; 18 (0FDC7h) - Set the User interrupt vector. HL = 0 to clear, or address of user routine. HL= 0FFFFh to query.
1618+  FDCA C3 AB FA                        JP          bios_flash_write    ; 17 (0FDCAh) - Erase and write flash data. Data is written to 4K sectors, which are erased before writing.
1619+  FDCD C3 99 FA                        JP          get_disk_page       ; 16 (0FDCDh) - Get the page in RAM/ROM being used as the base for the drive selected by A, or zero if error.
1620+  FDD0 C3 79 F9                        JP          rtc_get_time_hl     ; 15 (0FDD0h) - Get the time to the 7 bytes pointed to by HL. Returns carry set if sucessful
1621+  FDD3 C3 65 F7                        JP          disp_char_bright    ; 14 (0FDD3h) - Set LED Digit A to brightness C
1622+  FDD6 C3 C4 F7                        JP          disp_bitmask        ; 13 (0FDD6h) - Directly write bitmask in HL to display column A
1623+  FDD9 C3 04 F0                        JP          m_print_inline      ; 12 (0FDD9h) - Print the characters following the call instruction
1624+  FDDC C3 78 FA                        JP          get_page_mapping    ; 11 (0FDDCh) - Return the logical (cpu) page C (0-2) in A
1625+  FDDF C3 81 FA                        JP          set_page_mapping    ; 10 (0FDDFh) - Set the logical (cpu) page in A (0-2) to the physical (RAM/ROM) page in E
1626+  FDE2 C3 94 F5                        JP          i2c_start           ; 9  (0FDE2h) - Sends I2C start sequence
1627+  FDE5 C3 A3 F5                        JP          i2c_stop            ; 8  (0FDE5h) - Sends I2C stop sequence
1628+  FDE8 C3 EF F5                        JP          i2c_write           ; 7  (0FDE8h) - Write A as a byte to i2c bus. Carry SET if success. i2c_stop is not called.
1629+  FDEB C3 3A F6                        JP          i2c_read            ; 6  (0FDEBh) - Read byte from i2C into A, without ACK
1630+  FDEE C3 DB F5                        JP          i2c_write_to        ; 5  (0FDEEh) - Prepare to write to Device address H, Register L. Carry SET if success. i2c_stop is not called.
1631+  FDF1 C3 BA F5                        JP          i2c_read_from       ; 4  (0FDF1h) - Read a byte int A from Device address H, Register L. Carry SET if success. i2c_stop is not called.
1632+  FDF4 C3 2F F4                        JP          wait_for_key        ; 3  (0FDF4h) - Waits for until a key is pressed and released
1633+  FDF7 C3 C4 F3                        JP          play_note           ; 2  (0FDF7h) - Plays the note defined by DE (octave, note) and C (duration, tenths)
1634+  FDFA C3 A8 FA                        JP          get_version         ; 1  (0FDFAh) - Returns the Bios version in A
1635+  FDFD             
1636+  FDFD             
1637+  FDFD~            .IF $ > BIOS_TOP
1638+  FDFD~                .ECHO "End of BIOS is too high ("
1639+  FDFD~                .ECHO $
1640+  FDFD~                .ECHO " > "
1641+  FDFD~                .ECHO BIOS_TOP
1642+  FDFD~                .ECHO ") \n\n"
1643+  FDFD~                .STOP
1644+  FDFD             .ENDIF
1645+  FDFD             
1646+  FDFD             .ECHO "Bios Size is "
1647+  FDFD             .ECHO BIOS_TOP-BIOS_START-BIOS_SPARE
1648+  FDFD             .ECHO ". Limit is "
1649+  FDFD             .ECHO BIOS_TOP-BIOS_START
1650+  FDFD             .ECHO ". Spare "
1651+  FDFD             .ECHO BIOS_SPARE
1652+  FDFD             .ECHO "\n\n"
1653+  FDFD             
1654+  FDFD                                 .INCLUDE shared_data.asm
0001++ FDFD             ;
0002++ FDFD             ; Shared data - common state data for routines
0003++ FDFD             ;
0004++ FDFD             ; [] show default/initial values stored at the location
0005++ FDFD             ;
0006++ FDFD             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0007++ FDFD             ;
0008++ FDFD             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0009++ FDFD             ;
0010++ FDFD             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0011++ FDFD             ; of this software and associated documentation files (the "Software"), to deal
0012++ FDFD             ; in the Software without restriction, including without limitation the rights
0013++ FDFD             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0014++ FDFD             ; copies of the Software, and to permit persons to whom the Software is
0015++ FDFD             ; furnished to do so, subject to the following conditions:
0016++ FDFD             ; 
0017++ FDFD             ; The above copyright notice and this permission notice shall be included in all
0018++ FDFD             ; copies or substantial portions of the Software.
0019++ FDFD             ; 
0020++ FDFD             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0021++ FDFD             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0022++ FDFD             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0023++ FDFD             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0024++ FDFD             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0025++ FDFD             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0026++ FDFD             ; SOFTWARE.
0027++ FDFD             ;
0028++ FDFD             
0029++ FF00                                 .ORG    0FF00h
0030++ FF00             
0031++ FF00             ; I2C/Port B routines
0032++ FF00             port_b_mode         .BLOCK  1
0033++ FF01             port_b_dir          .BLOCK  1
0034++ FF02             port_b_data         .BLOCK  1
0035++ FF03             
0036++ FF03             ; Display functions
0037++ FF03             display_address     .BLOCK  1              ; byte - I/O address of the display driver (right or left) being written to
0038++ FF04             
0039++ FF04             ;
0040++ FF04             ; Stuff
0041++ FF04             timer               .BLOCK  4              ; 2 Words - counts up by 1 every 64th of a second. Rollover ~2 years.
0042++ FF08                                     
0043++ FF08             ; General I/O
0044++ FF08             ;
0045++ FF08             ; This MUST start with keyboard_state, and will all be reset to zero when io_init is called
0046++ FF08             ;
0047++ FF08             _key_state_size     .EQU    8               ; 8 key rollover
0048++ FF08             
0049++ FF08             keyboard_state      .BLOCK  _key_state_size ; state buffer - 8 bytes containing raw key codes for keys currently pressed
0050++ FF10             keyboard_pos        .BLOCK  2               ; Internal state
0051++ FF12             key_shift_state     .BLOCK  1               ; Holds state of shift and control keys in bits 0 and 1 respectively
0052++ FF13             control_key_pressed .BLOCK  1               ; If special control keys are pressed, they are stored here..
0053++ FF14             last_keycode        .BLOCK  1               ; The last keycode that was pressed, for repeats..
0054++ FF15             key_repeat_time     .BLOCK  1               ; How many poll events since the key state last changed
0055++ FF16             
0056++ FF16             _input_buffer_size  .EQU    16
0057++ FF16             input_buffer        .BLOCK _input_buffer_size          ; 16 byte input buffer. Note wraparound is handled by bitmasks, so don't change this length
0058++ FF26             input_pos           .BLOCK  1               ; Next read position in input buffer
0059++ FF27             input_free          .BLOCK  1               ; Next write position in input buffer
0060++ FF28             input_size          .BLOCK  1               ; Bytes occupied in the input buffer
0061++ FF29             
0062++ FF29             io_data_end         .EQU  input_size        ; Byte after IO data block, used to reset values to zero
0063++ FF29             
0064++ FF29             ;------------------------------- Console output and screen data ------------------------------------------------
0065++ FF29             screen_page         .BLOCK  1               ; [30?]  1 Byte, screen buffer page address
0066++ FF2A             screen_offset       .BLOCK  1               ; [0]    1 Byte, row offset (0-63) of virtual screen in screen buffer (high byte of screen address).
0067++ FF2B             
0068++ FF2B             ; *** ROW AND COL MUST BE IN THIS ORDER - READ BY bios_conout ***
0069++ FF2B             display_row         .BLOCK  1               ; [0]    1 Byte, current row being shown by the LED display
0070++ FF2C             display_col         .BLOCK  1               ; [0]    1 Byte, current column being shown by the LED display - Note, 0 based
0071++ FF2D             
0072++ FF2D             ; *** ROW AND COL MUST BE IN THIS ORDER - READ BY bios_conout ***
0073++ FF2D             cursor_row          .BLOCK  1               ; [1]    1 Byte, cursor row on virtual console. Top of page is row 1.   
0074++ FF2E             cursor_col          .BLOCK  1               ; [1]    1 Byte, cursor column on virtual console. Left of page is column 1.
0075++ FF2F             
0076++ FF2F             console_height      .BLOCK  1               ; [24]   1 Byte, virtual console height (rows)
0077++ FF30             console_width       .BLOCK  1               ; [40]   1 byte, virtual console width (columns)
0078++ FF31             
0079++ FF31             console_colour      .BLOCK  1               ; [0x0F] 1 Byte, current colour. Top 4 bits [7:4] are background, bottom 4 [3:0] are foreground
0080++ FF32             console_flags       .BLOCK  1               ;        1 Byte, bit flags for console
0081++ FF33             
0082++ FF33             console_timer       .BLOCK  1               ;        1 Byte, used to blink cursor, clear movement indicator etc.
0083++ FF34             console_escape      .BLOCK  1               ;        1 Byte, escape value (0 if not received yet)
0084++ FF35             console_param1      .BLOCK  1               ;        1 Byte, first character after escape (0 if not recieved yet)
0085++ FF36             
0086++ FF36             console_identify    .BLOCK  1               ; [0]    1 Byte, indicates console identifier sequence to be returned..
0087++ FF37             
0088++ FF37             CFLAGS_SHOW_CURSOR  .EQU    1               ; Awaiting input - show (blink) the cursor
0089++ FF37             CFLAGS_TRACK_CURSOR .EQU    2               ; LED display is tracking cursor position
0090++ FF37             CFLAGS_SHOW_MOVED   .EQU    4               ; Show display as being moved by user
0091++ FF37             CFLAGS_ESCAPE       .EQU    8               ; Escape sequence started
0092++ FF37             CFLAGS_CURSOR_ON    .EQU    16              ; Cursor is currently displayed
0093++ FF37             CFLAGS_LED_OFF      .EQU    32              ; If set, don't echo to the LED display
0094++ FF37             
0095++ FF37             SHOW_MOVE_DELAY     .EQU    60              ; How long to show the display has been moved
0096++ FF37             
0097++ FF37             ;------------------------------- BIOS customisation  ------------------------------------------------
0098++ FF37             
0099++ FF37             drive_a_mem_page    .BLOCK  1               ; First page in RAM/ROM for the Drive A image  - NOTE: These values must be in order of drive number
0100++ FF38             drive_b_mem_page    .BLOCK  1               ; First page in RAM/ROM for the Drive B image
0101++ FF39             
0102++ FF39             page_0_mapping      .BLOCK  1               ; Stores the user mapping for these pages, so they can be correctly restored after interrupts
0103++ FF3A             page_1_mapping      .BLOCK  1
0104++ FF3B             page_2_mapping      .BLOCK  1
0105++ FF3C             page_3_mapping      .BLOCK  1
0106++ FF3D             
0107++ FF3D             ;------------------------------- BDOS variables ------------------------------------------------
0108++ FF3D             ; *** TRACK AND SECTOR MUST BE IN THIS ORDER - READ BY _get_memdisc_addr ***
0109++ FF3D             sys_track           .BLOCK  1               ; 1 Byte, Current disk track 
0110++ FF3E             sys_sector          .BLOCK  2               ; Word, current disk sector
0111++ FF40             sys_dmaaddr         .BLOCK  2               ; Word, DMA address - Disc will read data to this address, or write from this address
0112++ FF42             sys_disk_dph        .BLOCK  2               ; Word, points to current disk parameter header (DPH) 
0113++ FF44             sys_seldsk          .BLOCK  1               ; Byte, current selected disk drive (A=0, B=1..)
0114++ FF45             
0115++ FF45             sys_alv0            .BLOCK  32              ; 32 bytes, allocation vector 0 (max 255 blocks)
0116++ FF65             sys_alv1            .BLOCK  32              ; 32 bytes, allocation vector 1 (max 255 blocks)
0117++ FF85             
0118++ FF85             display_buffer      .BLOCK  24*2            ; 48 byte scratch area used for composing display output (eg. rtc time display etc.)
0119++ FFB5             
0120++ FFB5             intr_stackarea      .BLOCK  24              ; Interrupt handler stack
0121++ FFCD             intr_stack          .BLOCK  2
0122++ FFCF             
0123++ FFCF             user_interrupt      .BLOCK  2               ; Address of user interrupt routine, or zero
0124++ FFD1             
0125++ FFD1             ; Panic codes
0126++ FFD1             ;
0127++ FFD1             PANIC_0001          .EQU    0F001h
0128++ FFD1             PANIC_0002          .EQU    0F002h
0129++ FFD1             PANIC_0003          .EQU    0F003h
0130++ FFD1             PANIC_0004          .EQU    0F004h
0131++ FFD1             
1655+  FFD1                                 .END1136   FFD1                                 .END
tasm: Number of errors = 0
