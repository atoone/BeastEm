0001   0000             ;
0002   0000             ; Monitor using CP/M BIOS
0003   0000             ;
0004   0000             ;
0005   0000             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006   0000             ;
0007   0000             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008   0000             ;
0009   0000             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010   0000             ; of this software and associated documentation files (the "Software"), to deal
0011   0000             ; in the Software without restriction, including without limitation the rights
0012   0000             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013   0000             ; copies of the Software, and to permit persons to whom the Software is
0014   0000             ; furnished to do so, subject to the following conditions:
0015   0000             ; 
0016   0000             ; The above copyright notice and this permission notice shall be included in all
0017   0000             ; copies or substantial portions of the Software.
0018   0000             ; 
0019   0000             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020   0000             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021   0000             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022   0000             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023   0000             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024   0000             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025   0000             ; SOFTWARE.
0026   0000             ;
0027   0000                                 .MODULE  main
0028   0000             
0029   0000             MONITOR_START       .EQU   0DF00h
0030   0000             
0031   DF00                                 .ORG   MONITOR_START
0032   DF00 CD C2 F3                        CALL   configure_hardware
0033   DF03             
0034   DF03 3E 01                           LD      A, 1
0035   DF05 32 03 00                        LD      (iobyte), A
0036   DF08             
0037   DF08 3E 24                           LD      A, DRIVE_B_PAGE
0038   DF0A 32 38 FF                        LD      (drive_b_mem_page), A
0039   DF0D             
0040   DF0D 21 37 E9    _clock_check        LD      HL, timer_int
0041   DF10 22 FE FD                        LD      (0FDFEh), HL
0042   DF13             
0043   DF13 3E 01                           LD      A, 1
0044   DF15 32 04 FF                        LD      (timer), A
0045   DF18 3E 03                           LD      A, 3
0046   DF1A CD 28 E9                        CALL    detect_int
0047   DF1D             
0048   DF1D 79                              LD      A, C
0049   DF1E B0                              OR      B
0050   DF1F 20 0A                           JR      NZ, _clock_detected
0051   DF21             
0052   DF21 CD AA F3    _no_clock           CALL    m_print_inline
0053   DF24 2E 00                           .DB     ".", 0
0054   DF26             
0055   DF26 CD EE F4                        CALL    _do_reti
0056   DF29 18 E2                           JR      _clock_check
0057   DF2B             
0058   DF2B 3E 07       _clock_detected     LD      A, 7
0059   DF2D CD 28 E9                        CALL    detect_int
0060   DF30 79                              LD      A, C
0061   DF31 B0                              OR      B 
0062   DF32 28 ED                           JR      Z, _no_clock
0063   DF34             
0064   DF34                                 ; At this point BC ~= 13 * (clock * 100)
0065   DF34                                 ; Divide by 13, round lowest digit up/down
0066   DF34             
0067   DF34 C5                              PUSH    BC
0068   DF35 E1                              POP     HL
0069   DF36 0E 0D                           LD      C, 13
0070   DF38 CD 44 E9                        CALL    divide_hl_c
0071   DF3B             
0072   DF3B E5                              PUSH    HL
0073   DF3C D1                              POP     DE
0074   DF3D CD 51 E9                        CALL    de_to_bcd
0075   DF40             
0076   DF40 3A 89 E9                        LD      A, (bcd_scratch)         ; Units
0077   DF43 FE 06                           CP      6
0078   DF45 38 11                           JR      C, _display_speed
0079   DF47             
0080   DF47 2A 8A E9                        LD      HL, (bcd_scratch+1)
0081   DF4A 06 04                           LD      B,  4
0082   DF4C             
0083   DF4C 7E          _increment_bcd      LD      A, (HL)
0084   DF4D 3C                              INC     A
0085   DF4E 77                              LD      (HL), A
0086   DF4F FE 0A                           CP      10
0087   DF51 38 05                           JR      C, _display_speed        ; No carry here
0088   DF53 AF                              XOR     A
0089   DF54 77                              LD      (HL), A
0090   DF55 23                              INC     HL
0091   DF56 10 F4                           DJNZ    _increment_bcd
0092   DF58             
0093   DF58 3A 8C E9    _display_speed      LD      A, (bcd_scratch+3)
0094   DF5B A7                              AND     A
0095   DF5C 28 05                           JR      Z, _skip_leading
0096   DF5E C6 30                           ADD     A, '0'
0097   DF60 32 8A DF                        LD      (_speed_value),A
0098   DF63 3A 8B E9    _skip_leading       LD       A, (bcd_scratch+2)
0099   DF66 C6 30                           ADD     A, '0'
0100   DF68 32 8B DF                        LD      (_speed_value+1), A
0101   DF6B 3A 8A E9                        LD      A, (bcd_scratch+1)
0102   DF6E C6 30                           ADD     A, '0'
0103   DF70 32 8D DF                        LD      (_speed_value+3), A
0104   DF73             
0105   DF73 01 60 00                        LD      BC, 60h
0106   DF76 CD 11 E9                        CALL    pause_for_ticks
0107   DF79             
0108   DF79 CD AA F3                        CALL    m_print_inline
0109   DF7C 0A 0D 43 6C                     .DB     NEWLINE, CARRIAGE_RETURN, "Clock speed "
0109   DF80 6F 63 6B 20 
0109   DF84 73 70 65 65 
0109   DF88 64 20 
0110   DF8A 20 30 2C 30 _speed_value        .DB     " 0,0Mhz", 0
0110   DF8E 4D 68 7A 00 
0111   DF92             
0112   DF92 21 97 F4                        LD      HL, interrupt_handler
0113   DF95 22 FE FD                        LD      (0FDFEh), HL
0114   DF98             
0115   DF98 01 60 00                        LD      BC, 60h
0116   DF9B CD 11 E9                        CALL    pause_for_ticks
0117   DF9E             
0118   DF9E CD AA F3                        CALL    m_print_inline
0119   DFA1 0A 0D 4D 69                     .DB     NEWLINE, CARRIAGE_RETURN, "MicroBeast Monitor 1.5", 0
0119   DFA5 63 72 6F 42 
0119   DFA9 65 61 73 74 
0119   DFAD 20 4D 6F 6E 
0119   DFB1 69 74 6F 72 
0119   DFB5 20 31 2E 35 
0119   DFB9 00 
0120   DFBA             
0121   DFBA 01 60 00                        LD      BC, 60h
0122   DFBD CD 11 E9                        CALL    pause_for_ticks
0123   DFC0             
0124   DFC0 0E 0A                           LD      C, NEWLINE
0125   DFC2 CD 00 F0                        CALL    bios_conout
0126   DFC5             
0127   DFC5 CD 8E E9    _monitor_menu       CALL    rtc_display_time
0128   DFC8             
0129   DFC8 01 40 00                        LD      BC, 040h
0130   DFCB CD 11 E9                        CALL    pause_for_ticks
0131   DFCE             
0132   DFCE CD 71 EF    _monitor_read       CALL    bios_conist
0133   DFD1 A7                              AND     A
0134   DFD2 28 F1                           JR      Z, _monitor_menu
0135   DFD4             
0136   DFD4 CD 9A EF                        CALL    bios_conin
0137   DFD7             
0138   DFD7 21 FE DF                        LD      HL, main_menu
0139   DFDA CD 42 E8                        CALL    start_menu
0140   DFDD 18 E6                           JR      _monitor_menu
0141   DFDF             
0142   DFDF             
0143   DFDF CD AA F3    boot_cpm            CALL    m_print_inline
0144   DFE2 0A 0D 46 6F                     .DB     NEWLINE, CARRIAGE_RETURN, "Format RAM disk", 0
0144   DFE6 72 6D 61 74 
0144   DFEA 20 52 41 4D 
0144   DFEE 20 64 69 73 
0144   DFF2 6B 00 
0145   DFF4             
0146   DFF4 CD 73 E7                        CALL    format_memdisk
0147   DFF7             
0148   DFF7 21 F1 EE    boot_without_format LD      HL, bios_boot
0149   DFFA E5                              PUSH    HL
0150   DFFB C3 31 EF                        JP      load_ccp
0151   DFFE             
0152   DFFE             
0153   DFFE 53 65 6C 65 main_menu           .DB     "Select action", 0
0153   E002 63 74 20 61 
0153   E006 63 74 69 6F 
0153   E00A 6E 00 
0154   E00C             
0155   E00C DF DF                           .DW     boot_cpm
0156   E00E 4C 61 75 6E                     .DB     "Launch CP/M", 0
0156   E012 63 68 20 43 
0156   E016 50 2F 4D 00 
0157   E01A             
0158   E01A 78 E5                           .DW     memory_view
0159   E01C 4D 65 6D 6F                     .DB     "Memory Editor", 0
0159   E020 72 79 20 45 
0159   E024 64 69 74 6F 
0159   E028 72 00 
0160   E02A             
0161   E02A B2 E1                           .DW     ymodem_loader
0162   E02C 59 2D 4D 6F                     .DB     "Y-Modem Transfer", 0
0162   E030 64 65 6D 20 
0162   E034 54 72 61 6E 
0162   E038 73 66 65 72 
0162   E03C 00 
0163   E03D             
0164   E03D 55 E0                           .DW     set_date
0165   E03F 53 65 74 20                     .DB     "Set Date", 0
0165   E043 44 61 74 65 
0165   E047 00 
0166   E048             
0167   E048 1C E1                           .DW     set_time
0168   E04A 53 65 74 20                     .DB     "Set Time", 0
0168   E04E 54 69 6D 65 
0168   E052 00 
0169   E053 00 00                           .DW     0
0170   E055             
0171   E055             
0172   E055                                 .INCLUDE monitor_dates.asm
0001+  E055             ;
0002+  E055             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0003+  E055             ;
0004+  E055             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0005+  E055             ;
0006+  E055             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0007+  E055             ; of this software and associated documentation files (the "Software"), to deal
0008+  E055             ; in the Software without restriction, including without limitation the rights
0009+  E055             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0010+  E055             ; copies of the Software, and to permit persons to whom the Software is
0011+  E055             ; furnished to do so, subject to the following conditions:
0012+  E055             ; 
0013+  E055             ; The above copyright notice and this permission notice shall be included in all
0014+  E055             ; copies or substantial portions of the Software.
0015+  E055             ; 
0016+  E055             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0017+  E055             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0018+  E055             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0019+  E055             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0020+  E055             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0021+  E055             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0022+  E055             ; SOFTWARE.
0023+  E055             ;
0024+  E055             
0025+  E055 3A 2D FF    set_date            LD      A, (cursor_row)
0026+  E058 C6 1F                           ADD     A, 31
0027+  E05A 32 75 E0                        LD      (_set_date_row), A
0028+  E05D 32 88 E0                        LD      (_set_week_row), A
0029+  E060 CD AA F3                        CALL    m_print_inline
0030+  E063 0D 44 61 74                     .DB     CARRIAGE_RETURN, "Date YY/MM/DD", ESCAPE_CHAR, "K", ESCAPE_CHAR, "Y",
0030+  E067 65 20 59 59 
0030+  E06B 2F 4D 4D 2F 
0030+  E06F 44 44 1B 4B 
0030+  E073 1B 59 
0031+  E075 00          _set_date_row       .DB     0
0032+  E076 25 00                           .DB     31+6, 0
0033+  E078 21 63 E1                        LD      HL, date_limits
0034+  E07B CD 71 E1                        CALL    get_date_time
0035+  E07E             
0036+  E07E 3E 01                           LD      A, 1
0037+  E080 32 69 E1    _select_loop        LD      (day_of_week), A
0038+  E083             
0039+  E083 CD AA F3                        CALL    m_print_inline
0040+  E086 1B 59                           .DB     ESCAPE_CHAR, "Y", 
0041+  E088 00          _set_week_row       .DB     0
0042+  E089 2F 00                           .DB     31+16, 0
0043+  E08B             
0044+  E08B 3A 69 E1                        LD      A, (day_of_week)
0045+  E08E 47                              LD      B, A
0046+  E08F 21 27 EA                        LD      HL, weekdays
0047+  E092 10 0A       _week_loop          DJNZ    _next_week
0048+  E094             
0049+  E094 7E          _print_week         LD      A, (HL)
0050+  E095 23                              INC     HL
0051+  E096 A7                              AND     A
0052+  E097 28 0C                           JR      Z, _select_week
0053+  E099 CD B7 F3                        CALL    m_print_a_safe
0054+  E09C 18 F6                           JR      _print_week
0055+  E09E             
0056+  E09E 7E          _next_week          LD      A, (HL)
0057+  E09F 23                              INC     HL
0058+  E0A0 A7                              AND     A
0059+  E0A1 20 FB                           JR      NZ, _next_week
0060+  E0A3 18 ED                           JR      _week_loop
0061+  E0A5             
0062+  E0A5 CD 71 EF    _select_week        CALL    bios_conist
0063+  E0A8 A7                              AND     A
0064+  E0A9 28 FA                           JR      Z, _select_week
0065+  E0AB CD 9A EF                        CALL    bios_conin
0066+  E0AE FE 80                           CP      KEY_UP
0067+  E0B0 20 0A                           JR      NZ, _test_down
0068+  E0B2 3A 69 E1                        LD      A, (day_of_week)
0069+  E0B5 FE 07                           CP      7
0070+  E0B7 28 EC                           JR      Z, _select_week
0071+  E0B9 3C                              INC     A
0072+  E0BA 18 C4                           JR      _select_loop
0073+  E0BC FE 81       _test_down          CP      KEY_DOWN
0074+  E0BE 20 0A                           JR      NZ, _test_enter 
0075+  E0C0 3A 69 E1                        LD      A, (day_of_week)
0076+  E0C3 FE 01                           CP      1
0077+  E0C5 28 DE                           JR      Z, _select_week
0078+  E0C7 3D                              DEC     A
0079+  E0C8 18 B6                           JR      _select_loop
0080+  E0CA FE 0D       _test_enter         CP      KEY_ENTER
0081+  E0CC 20 D7                           JR      NZ, _select_week
0082+  E0CE             
0083+  E0CE F3                              DI
0084+  E0CF 26 6F                           LD      H, RTC_ADDRESS      
0085+  E0D1 2E 03                           LD      L, RTC_REG_WKDAY
0086+  E0D3 CD 1D F9                        CALL    i2c_write_to
0087+  E0D6 D2 05 E1                        JP      NC, _clock_error
0088+  E0D9             
0089+  E0D9 21 69 E1                        LD      HL, day_of_week
0090+  E0DC 7E                              LD      A, (HL)
0091+  E0DD 23                              INC     HL
0092+  E0DE             
0093+  E0DE F6 08                           OR      RTC_WEEKDAY_RUNNING
0094+  E0E0 CD 31 F9                        CALL    i2c_write
0095+  E0E3 D2 05 E1                        JP      NC, _clock_error
0096+  E0E6             
0097+  E0E6 46          _write_date_loop    LD      B, (HL)
0098+  E0E7 23                              INC     HL
0099+  E0E8             
0100+  E0E8 7E                              LD      A, (HL)
0101+  E0E9 23                              INC     HL
0102+  E0EA CB 27                           SLA     A
0103+  E0EC CB 27                           SLA     A
0104+  E0EE CB 27                           SLA     A
0105+  E0F0 CB 27                           SLA     A
0106+  E0F2             
0107+  E0F2 B0                              OR      B
0108+  E0F3 FE FF                           CP      0ffh
0109+  E0F5 CA 00 E1                        JP      Z, _start_clock
0110+  E0F8 CD 31 F9                        CALL    i2c_write
0111+  E0FB D2 05 E1                        JP      NC, _clock_error
0112+  E0FE 18 E6                           JR      _write_date_loop
0113+  E100             
0114+  E100 CD E5 F8    _start_clock        CALL    i2c_stop
0115+  E103 FB                              EI
0116+  E104 C9                              RET
0117+  E105             
0118+  E105 CD E5 F8    _clock_error        CALL    i2c_stop
0119+  E108 FB                              EI
0120+  E109 CD AA F3                        CALL    m_print_inline
0121+  E10C 0D 52 54 43                     .DB     CARRIAGE_RETURN, "RTC Error", ESCAPE_CHAR, "K", 0
0121+  E110 20 45 72 72 
0121+  E114 6F 72 1B 4B 
0121+  E118 00 
0122+  E119 C3 9A EF                        JP      bios_conin
0123+  E11C             
0124+  E11C 3A 2D FF    set_time            LD      A, (cursor_row)
0125+  E11F C6 1F                           ADD     A, 31
0126+  E121 32 39 E1                        LD      (_set_time_row), A
0127+  E124 CD AA F3                        CALL    m_print_inline
0128+  E127 0D 54 69 6D                     .DB     CARRIAGE_RETURN, "Time HH/mm/ss", ESCAPE_CHAR, "K", ESCAPE_CHAR, "Y",
0128+  E12B 65 20 48 48 
0128+  E12F 2F 6D 6D 2F 
0128+  E133 73 73 1B 4B 
0128+  E137 1B 59 
0129+  E139 00          _set_time_row       .DB     0
0130+  E13A 25 00                           .DB     31+6, 0
0131+  E13C 21 5D E1                        LD      HL, time_limits
0132+  E13F CD 71 E1                        CALL    get_date_time
0133+  E142             
0134+  E142 3A 6B E1                        LD      A, (digit_values+1)
0135+  E145 F6 08                           OR      08h
0136+  E147 32 6B E1                        LD      (digit_values+1), A
0137+  E14A CD 9A EF                        CALL    bios_conin
0138+  E14D             
0139+  E14D F3                              DI
0140+  E14E 26 6F                           LD      H, RTC_ADDRESS      
0141+  E150 2E 00                           LD      L, RTC_REG_SEC
0142+  E152 CD 1D F9                        CALL    i2c_write_to
0143+  E155 D2 05 E1                        JP      NC, _clock_error
0144+  E158             
0145+  E158 21 6A E1                        LD      HL, digit_values
0146+  E15B 18 89                           JR      _write_date_loop
0147+  E15D                                 
0148+  E15D 09 05 09 05 time_limits         .DB     9,5,9,5,3,2
0148+  E161 03 02 
0149+  E163             
0150+  E163 01 03 02 01 date_limits         .DB     1,3,2,1,9,9
0150+  E167 09 09 
0151+  E169             
0152+  E169 01          day_of_week         .DB     1
0153+  E16A 00 00 00 00 digit_values        .DB     0,0,0,0,0,0
0153+  E16E 00 00 
0154+  E170 FF                              .DB     0FFh
0155+  E171             
0156+  E171 11 6A E1    get_date_time       LD      DE, digit_values
0157+  E174 01 06 00                        LD      BC, 6
0158+  E177 ED B0                           LDIR
0159+  E179 2B                              DEC     HL
0160+  E17A 1B                              DEC     DE
0161+  E17B 06 06                           LD      B, 6
0162+  E17D             
0163+  E17D E5          _get_digit          PUSH    HL
0164+  E17E D5                              PUSH    DE
0165+  E17F C5                              PUSH    BC
0166+  E180 CD 9A EF                        CALL    bios_conin
0167+  E183 C1                              POP     BC
0168+  E184 D1                              POP     DE
0169+  E185 E1                              POP     HL
0170+  E186 D6 30                           SUB     '0'
0171+  E188 38 F3                           JR      C, _get_digit
0172+  E18A 4F                              LD      C, A
0173+  E18B 1A                              LD      A, (DE)
0174+  E18C 32 A1 E1                        LD      (_digit_compare+1),A
0175+  E18F B9                              CP      C
0176+  E190 38 EB                           JR      C, _get_digit
0177+  E192             
0178+  E192 79                              LD      A, C
0179+  E193 12                              LD      (DE), A
0180+  E194 C6 30                           ADD     A,'0'
0181+  E196 CD B7 F3                        CALL    m_print_a_safe
0182+  E199             
0183+  E199 1A                              LD      A,(DE)
0184+  E19A 2B                              DEC     HL
0185+  E19B 1B                              DEC     DE
0186+  E19C CB 40                           BIT     0, B
0187+  E19E 20 0A                           JR      NZ, _next_tuple
0188+  E1A0 FE 00       _digit_compare      CP      0
0189+  E1A2 28 03                           JR      Z, _next_digit
0190+  E1A4 3E 09                           LD      A, 9
0191+  E1A6 12                              LD      (DE), A
0192+  E1A7 10 D4       _next_digit         DJNZ    _get_digit
0193+  E1A9 C9                              RET
0194+  E1AA CD AA F3    _next_tuple         CALL    m_print_inline
0195+  E1AD 1B 43 00                        .DB     ESCAPE_CHAR, 'C', 0
0196+  E1B0 18 F5                           JR      _next_digit0173   E1B2             
0174   E1B2             
0175   E1B2 AF          ymodem_loader       XOR     A
0176   E1B3 32 04 E4                        LD      (_ymodem_set), A
0177   E1B6 21 7D E4                        LD      HL, ymodem_menu
0178   E1B9 CD 42 E8                        CALL    start_menu
0179   E1BC                                 
0180   E1BC 3A 04 E4                        LD      A, (_ymodem_set)
0181   E1BF A7                              AND     A
0182   E1C0 C8                              RET     Z
0183   E1C1             
0184   E1C1 ED 5B 01 E4                     LD      DE, (_ymodem_address)
0185   E1C5 3A 03 E4                        LD      A, (_ymodem_page)
0186   E1C8 21 6F DE                        LD      HL, MONITOR_START-YMODEM_BUFFER
0187   E1CB F3                              DI
0188   E1CC CD B1 EA                        CALL    ymodem
0189   E1CF FB                              EI
0190   E1D0 A7                              AND     A
0191   E1D1 CA 83 E2                        JP      Z, _ymodem_success
0192   E1D4             
0193   E1D4 3D                              DEC     A
0194   E1D5 5F                              LD      E, A
0195   E1D6 16 00                           LD      D, 0
0196   E1D8 21 03 E2                        LD      HL, _ymodem_errors
0197   E1DB 19                              ADD     HL, DE
0198   E1DC 19                              ADD     HL, DE
0199   E1DD             
0200   E1DD 7E                              LD      A, (HL)
0201   E1DE 23                              INC     HL
0202   E1DF 66                              LD      H, (HL)
0203   E1E0 6F                              LD      L, A
0204   E1E1             
0205   E1E1 79                              LD      A, C
0206   E1E2 C6 30                           ADD     A, '0'
0207   E1E4 32 3F E2                        LD      (_packet_err_code), A
0208   E1E7             
0209   E1E7 E5                              PUSH    HL
0210   E1E8 CD AA F3                        CALL    m_print_inline
0211   E1EB 0D 45 52 52                     .DB     CARRIAGE_RETURN, "ERROR: ", 0
0211   E1EF 4F 52 3A 20 
0211   E1F3 00 
0212   E1F4             
0213   E1F4 E1                              POP     HL
0214   E1F5             
0215   E1F5 7E          _ymodem_err_loop    LD      A, (HL)
0216   E1F6 23                              INC     HL
0217   E1F7 A7                              AND     A
0218   E1F8 CA 9A EF                        JP      Z, bios_conin                   ; Wait for a key then go to main menu..
0219   E1FB 4F                              LD      C, A
0220   E1FC E5                              PUSH    HL
0221   E1FD CD 00 F0                        CALL    bios_conout
0222   E200 E1                              POP     HL
0223   E201 18 F2                           JR      _ymodem_err_loop
0224   E203             
0225   E203 13 E2       _ymodem_errors      .DW     _y_msg_timeout
0226   E205 1D E2                           .DW     _y_msg_unknown
0227   E207 2E E2                           .DW     _y_msg_cancel     
0228   E209 37 E2                           .DW     _y_msg_packet
0229   E20B 44 E2                           .DW     _y_msg_length
0230   E20D 52 E2                           .DW     _y_msg_no_dest
0231   E20F 63 E2                           .DW     _y_msg_send
0232   E211 72 E2                           .DW     _y_msg_files
0233   E213             
0234   E213 54 69 6D 65 _y_msg_timeout      .DB     "Timeout", ESCAPE_CHAR, "K", 0
0234   E217 6F 75 74 1B 
0234   E21B 4B 00 
0235   E21D 55 6E 6B 6E _y_msg_unknown      .DB     "Unknown packet", ESCAPE_CHAR, "K", 0
0235   E221 6F 77 6E 20 
0235   E225 70 61 63 6B 
0235   E229 65 74 1B 4B 
0235   E22D 00 
0236   E22E 43 61 6E 63 _y_msg_cancel       .DB     "Cancel", ESCAPE_CHAR, "K", 0
0236   E232 65 6C 1B 4B 
0236   E236 00 
0237   E237 50 61 63 6B _y_msg_packet       .DB     "Packet (", 
0237   E23B 65 74 20 28 
0238   E23F             
0239   E23F 30 29 1B 4B _packet_err_code    .DB     "0)", ESCAPE_CHAR, "K", 0
0239   E243 00 
0240   E244             
0241   E244 46 69 6C 65 _y_msg_length       .DB     "File length", ESCAPE_CHAR, "K", 0
0241   E248 20 6C 65 6E 
0241   E24C 67 74 68 1B 
0241   E250 4B 00 
0242   E252 4E 6F 20 64 _y_msg_no_dest      .DB     "No destination", ESCAPE_CHAR, "K", 0
0242   E256 65 73 74 69 
0242   E25A 6E 61 74 69 
0242   E25E 6F 6E 1B 4B 
0242   E262 00 
0243   E263 53 65 6E 64 _y_msg_send         .DB     "Send Timeout", ESCAPE_CHAR, "K", 0
0243   E267 20 54 69 6D 
0243   E26B 65 6F 75 74 
0243   E26F 1B 4B 00 
0244   E272 4D 75 6C 74 _y_msg_files        .DB     "Multiple files", ESCAPE_CHAR, "K", 0
0244   E276 69 70 6C 65 
0244   E27A 20 66 69 6C 
0244   E27E 65 73 1B 4B 
0244   E282 00 
0245   E283             
0246   E283 CD AA F3    _ymodem_success     CALL    m_print_inline           
0247   E286 0D 4F 4B 20                     .DB     CARRIAGE_RETURN, "OK ",0
0247   E28A 00 
0248   E28B 3A 73 DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_high)
0249   E28E FE FF                           CP      0FFh
0250   E290 28 06                           JR      Z, _ymodem_no_high
0251   E292 C6 30                           ADD     A, '0'
0252   E294 4F                              LD      C, A
0253   E295 CD 00 F0                        CALL    bios_conout
0254   E298 3A 72 DE    _ymodem_no_high     LD      A, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0255   E29B CD D0 E8                        CALL    hex_out
0256   E29E 3A 71 DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_low)
0257   E2A1 CD D0 E8                        CALL    hex_out
0258   E2A4 CD AA F3                        CALL    m_print_inline
0259   E2A7 20 42 59 54                     .DB     " BYTES @ ", 0
0259   E2AB 45 53 20 40 
0259   E2AF 20 00 
0260   E2B1 3A 6F DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)
0261   E2B4 17                              RLA
0262   E2B5 38 10                           JR      C, _ymodem_show_addr
0263   E2B7 1F                              RRA
0264   E2B8 CD D0 E8                        CALL    hex_out
0265   E2BB 0E 2F                           LD      C, '/'
0266   E2BD CD 00 F0                        CALL    bios_conout
0267   E2C0 3A 79 DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_high)
0268   E2C3 D6 40                           SUB     40h
0269   E2C5 18 03                           JR      _ymodem_addr
0270   E2C7             
0271   E2C7 3A 79 DE    _ymodem_show_addr   LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_high)
0272   E2CA CD D0 E8    _ymodem_addr        CALL    hex_out
0273   E2CD 3A 78 DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0274   E2D0 CD D0 E8                        CALL    hex_out
0275   E2D3 CD AA F3                        CALL    m_print_inline
0276   E2D6 1B 4B 00                        .DB     ESCAPE_CHAR, "K", 0
0277   E2D9 CD 71 EF    _ymodem_waitkey     CALL    bios_conist                  
0278   E2DC A7                              AND     A
0279   E2DD 28 FA                           JR      Z, _ymodem_waitkey
0280   E2DF             
0281   E2DF CD 9A EF                        CALL    bios_conin
0282   E2E2             
0283   E2E2             
0284   E2E2 3A 6F DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)      ; Do something with the file.
0285   E2E5 17                              RLA
0286   E2E6 30 06                           JR      NC, _ymodem_handle_page
0287   E2E8             
0288   E2E8 21 05 E4                        LD      HL, ymodem_mem_menu
0289   E2EB C3 42 E8                        JP      start_menu
0290   E2EE             
0291   E2EE             
0292   E2EE 21 32 E4    _ymodem_handle_page LD      HL, ymodem_page_menu
0293   E2F1 C3 42 E8                        JP      start_menu
0294   E2F4             
0295   E2F4 2A 78 DE    _ymodem_view        LD      HL, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0296   E2F7 22 72 E5                        LD      (monitor_address), HL
0297   E2FA C3 51 E6                        JP      edit_memory
0298   E2FD             
0299   E2FD 2A 78 DE    _ymodem_exec        LD      HL, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0300   E300 E5                              PUSH    HL
0301   E301 C9          _ymodem_exit        RET
0302   E302             
0303   E302 CD AA F3    _ymodem_flash       CALL    m_print_inline
0304   E305 0D 0A 50 61                     .DB     CARRIAGE_RETURN, NEWLINE, "Page 00-1f >", ESCAPE_CHAR, "K", 0
0304   E309 67 65 20 30 
0304   E30D 30 2D 31 66 
0304   E311 20 3E 1B 4B 
0304   E315 00 
0305   E316             
0306   E316 06 02                           LD      B, 2
0307   E318 CD BC E7                        CALL    hex_input
0308   E31B CD 2E E8                        CALL    delete_or_enter
0309   E31E 3A 2C E8                        LD      A, (hex_input_result)
0310   E321 FE 1F                           CP      1fh
0311   E323 30 DD                           JR      NC, _ymodem_flash
0312   E325             
0313   E325 CD AA F3                        CALL    m_print_inline
0314   E328 20 59 2F 4E                     .DB     " Y/N?", 0
0314   E32C 3F 00 
0315   E32E CD 9A EF                        CALL    bios_conin
0316   E331 FE 79                           CP      'y'
0317   E333 20 B9                           JR      NZ, _ymodem_handle_page
0318   E335             
0319   E335 CD AA F3                        CALL    m_print_inline
0320   E338 0D 0A 57 72                     .DB     CARRIAGE_RETURN, NEWLINE, "Writing", ESCAPE_CHAR, "K", 0
0320   E33C 69 74 69 6E 
0320   E340 67 1B 4B 00 
0321   E344             
0322   E344 3A 2C E8                        LD      A, (hex_input_result)
0323   E347 17                              RLA
0324   E348 17                              RLA
0325   E349 57                              LD      D, A
0326   E34A             
0327   E34A 3A 6F DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)         ; Page loaded
0328   E34D 32 03 E4    _next_page          LD      (_ymodem_page), A
0329   E350 D3 71                           OUT     (IO_MEM_1), A
0330   E352             
0331   E352 2A 72 DE                        LD      HL, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0332   E355 7D                              LD      A, L
0333   E356 E6 C0                           AND     0c0h
0334   E358 B4                              OR      H
0335   E359 20 22                           JR      NZ, _full_page
0336   E35B             
0337   E35B ED 4B 71 DE                     LD      BC, (MONITOR_START-YMODEM_INFO+ym_length_low)
0338   E35F 78                              LD      A, B
0339   E360 B1                              OR      C
0340   E361 28 06                           JR      Z, _flash_done
0341   E363 21 00 40                        LD      HL, 4000h
0342   E366 CD 84 FD                        CALL    flash_write
0343   E369             
0344   E369 3E 20       _flash_done         LD      A, RAM_PAGE_0
0345   E36B D3 70                           OUT     (IO_MEM_0), A
0346   E36D             
0347   E36D CD AA F3                        CALL    m_print_inline
0348   E370 0D 0A 44 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Done ", ESCAPE_CHAR, "K", 0           
0348   E374 6E 65 20 1B 
0348   E378 4B 00 
0349   E37A C3 9A EF                        JP      bios_conin
0350   E37D             
0351   E37D 01 40 00    _full_page          LD      BC, 0040h
0352   E380 AF                              XOR     A
0353   E381 ED 42                           SBC     HL, BC
0354   E383 22 72 DE                        LD      (MONITOR_START-YMODEM_INFO+ym_length_mid), HL
0355   E386 21 00 40                        LD      HL, 4000h
0356   E389 44                              LD      B, H
0357   E38A 4D                              LD      C, L
0358   E38B CD 84 FD                        CALL    flash_write
0359   E38E 14                              INC     D
0360   E38F 3A 03 E4                        LD      A,(_ymodem_page)
0361   E392 3C                              INC     A
0362   E393 18 B8                           JR      _next_page
0363   E395             
0364   E395 3A 73 DE    _ymodem_firmware    LD      A, (MONITOR_START-YMODEM_INFO+ym_length_high)
0365   E398 A7                              AND     A
0366   E399 20 52                           JR      NZ, _not_firmware
0367   E39B 3A 72 DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0368   E39E FE 40                           CP      040h
0369   E3A0 30 4B                           JR      NC, _not_firmware
0370   E3A2             
0371   E3A2 CD AA F3                        CALL    m_print_inline
0372   E3A5 0D 57 72 69                     .DB     CARRIAGE_RETURN, "Write firmware, Y/N?", ESCAPE_CHAR, "K", 0
0372   E3A9 74 65 20 66 
0372   E3AD 69 72 6D 77 
0372   E3B1 61 72 65 2C 
0372   E3B5 20 59 2F 4E 
0372   E3B9 3F 1B 4B 00 
0373   E3BD CD 9A EF                        CALL    bios_conin
0374   E3C0 FE 79                           CP      'y'
0375   E3C2 C2 EE E2                        JP      NZ, _ymodem_handle_page
0376   E3C5             
0377   E3C5 ED 4B 71 DE                     LD      BC, (MONITOR_START-YMODEM_INFO+ym_length_low)
0378   E3C9 3A 6F DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)         ; Page loaded
0379   E3CC D3 71                           OUT     (IO_MEM_1), A
0380   E3CE                                 
0381   E3CE 21 00 40                        LD      HL, 4000h
0382   E3D1 16 00                           LD      D, 0
0383   E3D3 CD 84 FD                        CALL    flash_write
0384   E3D6             
0385   E3D6 CD AA F3                        CALL    m_print_inline
0386   E3D9 0D 0A 44 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Done ", ESCAPE_CHAR, "K", 0
0386   E3DD 6E 65 20 1B 
0386   E3E1 4B 00 
0387   E3E3 ED 5B 71 DE                     LD      DE, (MONITOR_START-YMODEM_INFO+ym_length_low)
0388   E3E7 CD C9 E8                        CALL    hex_word
0389   E3EA C3 9A EF                        JP      bios_conin
0390   E3ED             
0391   E3ED CD AA F3    _not_firmware       CALL    m_print_inline
0392   E3F0 0D 0A 54 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Too large", ESCAPE_CHAR, "K", 0
0392   E3F4 6F 20 6C 61 
0392   E3F8 72 67 65 1B 
0392   E3FC 4B 00 
0393   E3FE C3 9A EF                        JP      bios_conin
0394   E401             
0395   E401             
0396   E401 00 00       _ymodem_address     .DW     0
0397   E403 00          _ymodem_page        .DB     0
0398   E404 00          _ymodem_set         .DB     0
0399   E405             
0400   E405 46 69 6C 65 ymodem_mem_menu     .DB     "File actions", 0
0400   E409 20 61 63 74 
0400   E40D 69 6F 6E 73 
0400   E411 00 
0401   E412 F4 E2                           .DW     _ymodem_view
0402   E414 56 69 65 77                     .DB     "View file", 0
0402   E418 20 66 69 6C 
0402   E41C 65 00 
0403   E41E FD E2                           .DW     _ymodem_exec
0404   E420 52 75 6E 00                     .DB     "Run", 0
0405   E424 01 E3                           .DW     _ymodem_exit
0406   E426 4D 61 69 6E                     .DB     "Main menu", 0
0406   E42A 20 6D 65 6E 
0406   E42E 75 00 
0407   E430 00 00                           .DW     0
0408   E432             
0409   E432 46 69 6C 65 ymodem_page_menu    .DB     "File actions", 0
0409   E436 20 61 63 74 
0409   E43A 69 6F 6E 73 
0409   E43E 00 
0410   E43F 02 E3                           .DW     _ymodem_flash
0411   E441 43 6F 70 79                     .DB     "Copy to flash", 0
0411   E445 20 74 6F 20 
0411   E449 66 6C 61 73 
0411   E44D 68 00 
0412   E44F F7 DF                           .DW     boot_without_format
0413   E451 43 50 4D 20                     .DB     "CPM Drive B", 0
0413   E455 44 72 69 76 
0413   E459 65 20 42 00 
0414   E45D 95 E3                           .DW     _ymodem_firmware
0415   E45F 55 70 64 61                     .DB     "Update firmware", 0
0415   E463 74 65 20 66 
0415   E467 69 72 6D 77 
0415   E46B 61 72 65 00 
0416   E46F 01 E3                           .DW     _ymodem_exit
0417   E471 4D 61 69 6E                     .DB     "Main menu", 0
0417   E475 20 6D 65 6E 
0417   E479 75 00 
0418   E47B 00 00                           .DW     0
0419   E47D             
0420   E47D 44 6F 77 6E ymodem_menu         .DB     "Download options", 0
0420   E481 6C 6F 61 64 
0420   E485 20 6F 70 74 
0420   E489 69 6F 6E 73 
0420   E48D 00 
0421   E48E CF E4                           .DW     _ymodem_from_file
0422   E490 41 64 64 72                     .DB     "Address from file", 0
0422   E494 65 73 73 20 
0422   E498 66 72 6F 6D 
0422   E49C 20 66 69 6C 
0422   E4A0 65 00 
0423   E4A2 F0 E4                           .DW     _ymodem_logical
0424   E4A4 43 50 55 20                     .DB     "CPU (Logical) address",0
0424   E4A8 28 4C 6F 67 
0424   E4AC 69 63 61 6C 
0424   E4B0 29 20 61 64 
0424   E4B4 64 72 65 73 
0424   E4B8 73 00 
0425   E4BA 26 E5                           .DW     _ymodem_physical
0426   E4BC 50 68 79 73                     .DB     "Physical address", 0
0426   E4C0 69 63 61 6C 
0426   E4C4 20 61 64 64 
0426   E4C8 72 65 73 73 
0426   E4CC 00 
0427   E4CD 00 00                           .DW     0
0428   E4CF             
0429   E4CF 11 FF FF    _ymodem_from_file   LD      DE, 0FFFFh
0430   E4D2 ED 53 01 E4                     LD      (_ymodem_address), DE
0431   E4D6 ED 53 03 E4                     LD      (_ymodem_page), DE
0432   E4DA CD AA F3    _ymodem_transfer    CALL    m_print_inline
0433   E4DD 0D 53 74 61                     .DB     CARRIAGE_RETURN, "Start transfer", ESCAPE_CHAR, "K", 0
0433   E4E1 72 74 20 74 
0433   E4E5 72 61 6E 73 
0433   E4E9 66 65 72 1B 
0433   E4ED 4B 00 
0434   E4EF C9                              RET
0435   E4F0             
0436   E4F0 CD AA F3    _ymodem_logical     CALL    m_print_inline
0437   E4F3 0D 41 64 64                     .DB     CARRIAGE_RETURN, "Address 0000-FFFF >", ESCAPE_CHAR, "K", 0
0437   E4F7 72 65 73 73 
0437   E4FB 20 30 30 30 
0437   E4FF 30 2D 46 46 
0437   E503 46 46 20 3E 
0437   E507 1B 4B 00 
0438   E50A 06 04                           LD      B, 4
0439   E50C CD BC E7                        CALL    hex_input
0440   E50F CD 2E E8                        CALL    delete_or_enter
0441   E512 3E FF                           LD      A, 0FFh
0442   E514 32 03 E4                        LD      (_ymodem_page), A
0443   E517             
0444   E517 ED 5B 2C E8 _ymodem_set_and_go  LD      DE, (hex_input_result)
0445   E51B ED 53 01 E4                     LD      (_ymodem_address), DE
0446   E51F 3E FF                           LD      A, 0FFh
0447   E521 32 04 E4                        LD      (_ymodem_set), A
0448   E524 18 B4                           JR      _ymodem_transfer
0449   E526             
0450   E526 CD AA F3    _ymodem_physical    CALL    m_print_inline
0451   E529 0D 50 61 67                     .DB     CARRIAGE_RETURN, "Page 20-3F >", ESCAPE_CHAR, "K", 0
0451   E52D 65 20 32 30 
0451   E531 2D 33 46 20 
0451   E535 3E 1B 4B 00 
0452   E539 06 02                           LD      B, 2
0453   E53B CD BC E7                        CALL    hex_input
0454   E53E CD 2E E8                        CALL    delete_or_enter
0455   E541 3A 2C E8                        LD      A, (hex_input_result)
0456   E544 32 03 E4                        LD      (_ymodem_page), A
0457   E547 CD AA F3                        CALL    m_print_inline
0458   E54A 0D 4F 66 66                     .DB     CARRIAGE_RETURN, "Offset 0000-3FFF >", ESCAPE_CHAR, "K", 0
0458   E54E 73 65 74 20 
0458   E552 30 30 30 30 
0458   E556 2D 33 46 46 
0458   E55A 46 20 3E 1B 
0458   E55E 4B 00 
0459   E560 06 04                           LD      B, 4
0460   E562 CD BC E7                        CALL    hex_input
0461   E565 CD 2E E8                        CALL    delete_or_enter
0462   E568 3A 2D E8                        LD      A, (hex_input_result+1)         ; YModem loads to page 1, so allow for offset..
0463   E56B F6 40                           OR      040h
0464   E56D 32 2D E8                        LD      (hex_input_result+1), A
0465   E570 18 A5                           JR      _ymodem_set_and_go
0466   E572             
0467   E572             ;------------------------------ Memory Editor --------------------------------------------
0468   E572             
0469   E572 00 80       monitor_address     .DW     08000h              ; Default address is 0x8000
0470   E574 00          monitor_mode        .DB     0                   ; 0 = show address + 3 characters, ~0 = hide address + 8 characters
0471   E575 00          edit_col            .DB     0                   ; Column currently being edited..
0472   E576 00 00       edit_digit          .DW     0
0473   E578             
0474   E578 CD 0E E7    memory_view         CALL    display_mem_row
0475   E57B             
0476   E57B CD 71 EF    _wait_key           CALL    bios_conist
0477   E57E A7                              AND     A
0478   E57F 28 FA                           JR      Z, _wait_key
0479   E581 CD 9A EF                        CALL    bios_conin
0480   E584             
0481   E584 FE 80                           CP      KEY_UP
0482   E586 20 0D                           JR      NZ, _not_up
0483   E588 2A 72 E5    memory_up           LD      HL, (monitor_address)
0484   E58B 11 08 00                        LD      DE, 8
0485   E58E ED 52                           SBC     HL, DE
0486   E590 22 72 E5                        LD      (monitor_address), HL
0487   E593 18 E3                           JR      memory_view
0488   E595             
0489   E595 FE 81       _not_up             CP      KEY_DOWN
0490   E597 20 0C                           JR      NZ, _not_down
0491   E599 2A 72 E5    memory_down         LD      HL, (monitor_address)
0492   E59C 11 08 00                        LD      DE, 8
0493   E59F 19                              ADD     HL, DE
0494   E5A0 22 72 E5                        LD      (monitor_address), HL
0495   E5A3 18 D3                           JR      memory_view
0496   E5A5             
0497   E5A5 FE 20       _not_down           CP      ' '
0498   E5A7 20 09                           JR      NZ, _not_space
0499   E5A9 3A 74 E5                        LD      A, (monitor_mode)
0500   E5AC 2F                              CPL
0501   E5AD 32 74 E5                        LD      (monitor_mode), A
0502   E5B0 18 C6                           JR      memory_view
0503   E5B2             
0504   E5B2 FE 0D       _not_space          CP      CARRIAGE_RETURN
0505   E5B4 28 0E                           JR      Z, _input_address
0506   E5B6             
0507   E5B6 FE 83                           CP      KEY_RIGHT
0508   E5B8 CA 51 E6                        JP      Z, edit_memory
0509   E5BB FE 08                           CP      KEY_BACKSPACE
0510   E5BD C8                              RET     Z
0511   E5BE             
0512   E5BE FE 78                           CP      'x'
0513   E5C0 28 1C                           JR      Z, execute
0514   E5C2 18 B7                           JR      _wait_key
0515   E5C4             
0516   E5C4 AF          _input_address      XOR     A
0517   E5C5 32 74 E5                        LD      (monitor_mode), A
0518   E5C8 CD 0E E7                        CALL    display_mem_row
0519   E5CB 0E 0D                           LD      C, CARRIAGE_RETURN
0520   E5CD CD 00 F0                        CALL    bios_conout
0521   E5D0             
0522   E5D0 06 04                           LD      B, 4
0523   E5D2 CD BC E7                        CALL    hex_input
0524   E5D5 2A 2C E8                        LD      HL, (hex_input_result)
0525   E5D8 22 72 E5                        LD      (monitor_address), HL
0526   E5DB C3 78 E5                        JP      memory_view
0527   E5DE             
0528   E5DE AF          execute             XOR     A
0529   E5DF 32 75 E5                        LD      (edit_col), A
0530   E5E2 CD AA F3    execute_col         CALL    m_print_inline
0531   E5E5 0D 1B 62 2E                     .DB     CARRIAGE_RETURN, ESCAPE_CHAR, 'b', CPM_NUM+15, "Execute from ", 0
0531   E5E9 45 78 65 63 
0531   E5ED 75 74 65 20 
0531   E5F1 66 72 6F 6D 
0531   E5F5 20 00 
0532   E5F7 21 35 E6                        LD      HL, _exec_done
0533   E5FA E5                              PUSH    HL
0534   E5FB 2A 72 E5                        LD      HL, (monitor_address)
0535   E5FE 3A 75 E5                        LD      A, (edit_col)
0536   E601 5F                              LD      E, A
0537   E602 16 00                           LD      D, 0
0538   E604 19                              ADD     HL, DE
0539   E605                                 
0540   E605 E5                              PUSH    HL
0541   E606 EB                              EX      DE, HL
0542   E607 CD C9 E8                        CALL    hex_word
0543   E60A CD AA F3                        CALL    m_print_inline
0544   E60D 20 59 2F 4E                     .DB     " Y/N?", ESCAPE_CHAR, "K", 0
0544   E611 3F 1B 4B 00 
0545   E615             
0546   E615 CD 9A EF    _exec_loop          CALL    bios_conin
0547   E618 FE 79                           CP      'y'
0548   E61A 28 09                           JR      Z, _exec_go
0549   E61C FE 6E                           CP      'n'
0550   E61E 20 F5                           JR      NZ, _exec_loop
0551   E620 E1                              POP     HL
0552   E621 E1                              POP     HL
0553   E622 C3 78 E5                        JP      memory_view
0554   E625             
0555   E625 CD AA F3    _exec_go            CALL    m_print_inline
0556   E628 0A 0D 52 75                     .DB     NEWLINE, CARRIAGE_RETURN, "Running", ESCAPE_CHAR, "K", 0
0556   E62C 6E 6E 69 6E 
0556   E630 67 1B 4B 00 
0557   E634 C9                              RET
0558   E635             
0559   E635 F5          _exec_done          PUSH    AF
0560   E636 CD AA F3                        CALL    m_print_inline
0561   E639 0A 0D 44 6F                     .DB     NEWLINE, CARRIAGE_RETURN, "Done. A=",0
0561   E63D 6E 65 2E 20 
0561   E641 41 3D 00 
0562   E644 F1                              POP     AF
0563   E645 CD D0 E8                        CALL    hex_out
0564   E648 CD AA F3                        CALL    m_print_inline
0565   E64B 1B 4B 00                        .DB     ESCAPE_CHAR, "K", 0
0566   E64E CD 9A EF                        CALL    bios_conin ;pause for a key, then return to memory edit at the execution location
0567   E651             
0568   E651             
0569   E651 AF          edit_memory         XOR     A
0570   E652 32 75 E5    _set_col_and_edit   LD      (edit_col), A
0571   E655 CD 0E E7    _edit_loop          CALL    display_mem_row
0572   E658 3A 75 E5                        LD      A, (edit_col)
0573   E65B 87                              ADD     A, A
0574   E65C 4F                              LD      C, A
0575   E65D 3A 74 E5                        LD      A, (monitor_mode)
0576   E660 A7                              AND     A
0577   E661 20 04                           JR      NZ, _address_hidden
0578   E663 3E 05                           LD      A, 5
0579   E665 81                              ADD     A, C
0580   E666 4F                              LD      C, A
0581   E667 3A 2D FF    _address_hidden     LD      A, (cursor_row)
0582   E66A C6 1F                           ADD     A, 31
0583   E66C 32 7D E6                        LD      (_edit_set_row), A
0584   E66F 79                              LD      A, C
0585   E670 C6 20                           ADD     A, 32
0586   E672 32 7E E6                        LD      (_edit_set_col), A
0587   E675             
0588   E675 CD AA F3                        CALL    m_print_inline
0589   E678 1B 62 27                        .DB     ESCAPE_CHAR, 'b', CPM_NUM+8         ; Set the correct brightness
0590   E67B 1B 59                           .DB     ESCAPE_CHAR, 'Y'                    ; And position the cursor
0591   E67D 00          _edit_set_row       .DB     0
0592   E67E 00          _edit_set_col       .DB     0
0593   E67F 00                              .DB     0
0594   E680             
0595   E680 11 00 02                        LD      DE, 0200h
0596   E683 ED 53 76 E5 _edit_next_digit    LD      (edit_digit), DE
0597   E687             
0598   E687 CD 9A EF    _edit_input         CALL    bios_conin
0599   E68A FE 78                           CP      'x'
0600   E68C CA E2 E5                        JP      Z, execute_col
0601   E68F             
0602   E68F FE 83                           CP      KEY_RIGHT
0603   E691 20 1B                           JR      NZ, _not_right
0604   E693 3A 75 E5    _edit_right         LD      A, (edit_col)
0605   E696 FE 07                           CP      7
0606   E698 28 03                           JR      Z, _edit_wrap_down
0607   E69A 3C                              INC     A
0608   E69B 18 B5                           JR      _set_col_and_edit
0609   E69D             
0610   E69D AF          _edit_wrap_down     XOR     A
0611   E69E 32 75 E5                        LD      (edit_col),A
0612   E6A1 11 08 00    _edit_down          LD      DE, 08h
0613   E6A4 2A 72 E5    _edit_move          LD      HL, (monitor_address)
0614   E6A7 19                              ADD     HL, DE
0615   E6A8 22 72 E5                        LD      (monitor_address), HL
0616   E6AB C3 55 E6                        JP      _edit_loop
0617   E6AE             
0618   E6AE FE 82       _not_right          CP      KEY_LEFT
0619   E6B0 20 13                           JR      NZ, _not_left
0620   E6B2 3A 75 E5                        LD      A, (edit_col)
0621   E6B5 A7                              AND     A
0622   E6B6 28 03                           JR      Z, _edit_wrap_up
0623   E6B8 3D                              DEC     A
0624   E6B9 18 97                           JR      _set_col_and_edit
0625   E6BB             
0626   E6BB 3E 07       _edit_wrap_up       LD      A, 7
0627   E6BD 32 75 E5                        LD      (edit_col),A
0628   E6C0 11 F8 FF    _edit_up            LD      DE, 0FFF8h
0629   E6C3 18 DF                           JR      _edit_move
0630   E6C5             
0631   E6C5 FE 80       _not_left           CP      KEY_UP
0632   E6C7 CA C0 E6                        JP      Z, _edit_up
0633   E6CA FE 81                           CP      KEY_DOWN
0634   E6CC CA A1 E6                        JP      Z, _edit_down
0635   E6CF FE 08                           CP      KEY_BACKSPACE
0636   E6D1 C2 DF E6                        JP      NZ, _not_delete
0637   E6D4             
0638   E6D4 3A 77 E5                        LD      A, (edit_digit+1)
0639   E6D7 FE 02                           CP      2
0640   E6D9 CA 78 E5                        JP      Z, memory_view
0641   E6DC C3 55 E6                        JP      _edit_loop
0642   E6DF             
0643   E6DF CD F7 E8    _not_delete         CALL    valid_hex_char
0644   E6E2 38 A3                           JR      C, _edit_input
0645   E6E4             
0646   E6E4 4F                              LD      C, A
0647   E6E5 CD 07 E9                        CALL    hex_char_to_num
0648   E6E8 F5                              PUSH    AF
0649   E6E9 CD 00 F0                        CALL    bios_conout
0650   E6EC F1                              POP     AF
0651   E6ED                                 
0652   E6ED ED 5B 76 E5                     LD      DE, (edit_digit)
0653   E6F1 CB 23                           SLA     E
0654   E6F3 CB 23                           SLA     E
0655   E6F5 CB 23                           SLA     E
0656   E6F7 CB 23                           SLA     E
0657   E6F9 B3                              OR      E
0658   E6FA 5F                              LD      E, A
0659   E6FB 15                              DEC     D
0660   E6FC 20 85                           JR      NZ, _edit_next_digit
0661   E6FE             
0662   E6FE 3A 75 E5                        LD      A, (edit_col)
0663   E701 4F                              LD      C, A
0664   E702 06 00                           LD      B, 0
0665   E704 2A 72 E5                        LD      HL, (monitor_address)
0666   E707 09                              ADD     HL, BC
0667   E708 73                              LD      (HL), E
0668   E709 CD 0E E7                        CALL    display_mem_row
0669   E70C 18 85                           JR      _edit_right
0670   E70E             
0671   E70E 0E 0D       display_mem_row     LD      C, CARRIAGE_RETURN
0672   E710 CD 00 F0                        CALL    bios_conout
0673   E713 3A 74 E5                        LD      A, (monitor_mode)
0674   E716 A7                              AND     A
0675   E717 20 14                           JR      NZ, _hex_values
0676   E719             
0677   E719 CD AA F3                        CALL    m_print_inline
0678   E71C 0D 1B 62 2E                     .DB     CARRIAGE_RETURN, ESCAPE_CHAR, 'b', CPM_NUM+15, 0
0678   E720 00 
0679   E721             
0680   E721 ED 5B 72 E5                     LD      DE, (monitor_address)
0681   E725 CD C9 E8                        CALL    hex_word
0682   E728             
0683   E728 0E 20                           LD      C, ' '
0684   E72A CD 00 F0                        CALL    bios_conout
0685   E72D             
0686   E72D CD AA F3    _hex_values         CALL    m_print_inline
0687   E730 1B 62 27 00                     .DB     ESCAPE_CHAR, 'b', CPM_NUM+8, 0
0688   E734             
0689   E734 2A 72 E5                        LD      HL, (monitor_address)
0690   E737 06 08                           LD      B, 8
0691   E739 7E          _mem_hex            LD      A, (HL)
0692   E73A E5                              PUSH    HL
0693   E73B C5                              PUSH    BC
0694   E73C CD D0 E8                        CALL    hex_out
0695   E73F C1                              POP     BC
0696   E740 E1                              POP     HL
0697   E741 23                              INC     HL
0698   E742 10 F5                           DJNZ    _mem_hex
0699   E744             
0700   E744 CD AA F3                        CALL    m_print_inline
0701   E747 1B 62 2E 00                     .DB     ESCAPE_CHAR, 'b', CPM_NUM+15, 0
0702   E74B             
0703   E74B 2A 72 E5                        LD      HL, (monitor_address)
0704   E74E 06 03                           LD      B, 3
0705   E750 3A 74 E5                        LD      A, (monitor_mode)
0706   E753 A7                              AND     A
0707   E754 28 02                           JR      Z, _mem_char
0708   E756 06 08                           LD      B, 8
0709   E758             
0710   E758 7E          _mem_char           LD      A, (HL)
0711   E759 FE 20                           CP      ' '
0712   E75B D2 60 E7                        JP      NC, _not_control_char
0713   E75E 3E 2E                           LD      A, '.'
0714   E760 FE 80       _not_control_char   CP      128
0715   E762 DA 67 E7                        JP      C, _not_extended_char
0716   E765 3E 2E                           LD      A, '.'
0717   E767 E5          _not_extended_char  PUSH    HL
0718   E768 C5                              PUSH    BC
0719   E769 4F                              LD      C, A
0720   E76A CD 00 F0                        CALL    bios_conout
0721   E76D C1                              POP     BC
0722   E76E E1                              POP     HL
0723   E76F 23                              INC     HL
0724   E770 10 E6                           DJNZ    _mem_char
0725   E772 C9                              RET
0726   E773             
0727   E773             ; Format memory disk
0728   E773             ;
0729   E773 3E 01       format_memdisk      LD      A, 1
0730   E775 4F                              LD      C, A
0731   E776 CD D5 F2                        CALL    bios_seldsk
0732   E779             
0733   E779 21 80 00                        LD      HL, BIOS_SECTOR_ADDRESS     ; Sector buffer
0734   E77C 22 BA E7                        LD      (_fmt_address),HL
0735   E77F             
0736   E77F 54                              LD      D, H                        ; Fill sector buffer with 0E5h (blank byte)
0737   E780 5D                              LD      E, L
0738   E781 13                              INC     DE
0739   E782 3E E5                           LD      A, 0E5h
0740   E784 77                              LD      (HL),A
0741   E785 01 7F 00                        LD      BC, 07fh
0742   E788 ED B0                           LDIR
0743   E78A             
0744   E78A 3E 02                           LD      A,BIOS_BOOT_TRACKS          ; First track (Offset = 2)
0745   E78C 32 B8 E7    _fmt_track_loop     LD      (_fmt_track),A
0746   E78F 4F                              LD      C,A                         ; Set track
0747   E790 CD F0 F2                        CALL    bios_settrk
0748   E793             
0749   E793 AF                              XOR     A                           ; Initial sector
0750   E794 32 B9 E7    _fmt_sector_loop    LD      (_fmt_sector),A
0751   E797             
0752   E797 FE 1A                           CP      MEMDISK_SECTORS
0753   E799 28 14                           JR      Z,_fmt_next_track
0754   E79B 4F                              LD      C,A                         ; Set sector
0755   E79C CD F5 F2                        CALL    bios_setsec
0756   E79F ED 4B BA E7                     LD      BC,(_fmt_address)           ; Address to write from
0757   E7A3 CD FA F2                        CALL    bios_setdma
0758   E7A6 CD 38 F3                        CALL    bios_write
0759   E7A9 3A B9 E7                        LD      A,(_fmt_sector)
0760   E7AC             
0761   E7AC 3C                              INC     A
0762   E7AD 18 E5                           JR      _fmt_sector_loop
0763   E7AF             
0764   E7AF 3A B8 E7    _fmt_next_track     LD      A,(_fmt_track)
0765   E7B2 FE 4F                           CP      MEMDISK_TRACKS
0766   E7B4 C8                              RET     Z
0767   E7B5 3C                              INC     A
0768   E7B6 18 D4                           JR      _fmt_track_loop
0769   E7B8             
0770   E7B8 00          _fmt_track          .DB     0
0771   E7B9 00          _fmt_sector         .DB     0
0772   E7BA 00 00       _fmt_address        .DW     0
0773   E7BC             
0774   E7BC             ;------------------------------------------------------
0775   E7BC             ; Read hex input into the (input_hex) address
0776   E7BC             ; Params - B = number of characters to input
0777   E7BC             ;
0778   E7BC 78          hex_input           LD      A, B
0779   E7BD 32 01 E8                        LD      (_hi_size), A
0780   E7C0 21 00 00                        LD      HL, 0
0781   E7C3 22 2C E8                        LD      (hex_input_result), HL
0782   E7C6             
0783   E7C6 C5          _hi_loop            PUSH    BC
0784   E7C7 CD EB E8    _hi_loop_join       CALL    hex_char_in
0785   E7CA FE 08                           CP      KEY_BACKSPACE
0786   E7CC 28 34                           JR      Z, _hi_delete
0787   E7CE 4F                              LD      C, A
0788   E7CF F5                              PUSH    AF
0789   E7D0 CD 00 F0                        CALL    bios_conout
0790   E7D3 F1                              POP     AF
0791   E7D4 CD 07 E9                        CALL    hex_char_to_num
0792   E7D7 2A 2C E8                        LD      HL, (hex_input_result)
0793   E7DA CB 27                           SLA     A
0794   E7DC CB 27                           SLA     A
0795   E7DE CB 27                           SLA     A
0796   E7E0 CB 27                           SLA     A
0797   E7E2             
0798   E7E2 CB 27                           SLA     A
0799   E7E4 CB 15                           RL      L
0800   E7E6 CB 14                           RL      H
0801   E7E8 CB 27                           SLA     A
0802   E7EA CB 15                           RL      L
0803   E7EC CB 14                           RL      H
0804   E7EE CB 27                           SLA     A
0805   E7F0 CB 15                           RL      L
0806   E7F2 CB 14                           RL      H
0807   E7F4 CB 27                           SLA     A
0808   E7F6 CB 15                           RL      L
0809   E7F8 CB 14                           RL      H
0810   E7FA 22 2C E8                        LD      (hex_input_result), HL
0811   E7FD C1                              POP     BC
0812   E7FE 10 C6                           DJNZ    _hi_loop
0813   E800 C9                              RET
0814   E801             
0815   E801 00          _hi_size            .DB     0
0816   E802             
0817   E802 C1          _hi_delete          POP     BC
0818   E803 3A 01 E8    _hi_delete_join     LD      A, (_hi_size)
0819   E806 B8                              CP      B
0820   E807 28 BD                           JR      Z, _hi_loop
0821   E809 04                              INC     B
0822   E80A C5                              PUSH    BC
0823   E80B             
0824   E80B 2A 2C E8                        LD      HL, (hex_input_result)
0825   E80E CB 3C                           SRL     H
0826   E810 CB 1D                           RR      L
0827   E812 CB 3C                           SRL     H
0828   E814 CB 1D                           RR      L
0829   E816 CB 3C                           SRL     H
0830   E818 CB 1D                           RR      L
0831   E81A CB 3C                           SRL     H
0832   E81C CB 1D                           RR      L
0833   E81E 22 2C E8                        LD      (hex_input_result), HL
0834   E821             
0835   E821 CD AA F3                        CALL    m_print_inline
0836   E824 1B 44 20 1B                     .DB     ESCAPE_CHAR, "D ", ESCAPE_CHAR, "D", 0
0836   E828 44 00 
0837   E82A 18 9B                           JR      _hi_loop_join
0838   E82C             
0839   E82C 00 00       hex_input_result    .DW     0
0840   E82E             
0841   E82E             delete_or_enter     ; Wait for Delete or enter keys and handle..
0842   E82E CD 9A EF                        CALL    bios_conin
0843   E831 FE 0D                           CP      CARRIAGE_RETURN
0844   E833 C8                              RET     Z
0845   E834 06 00                           LD      B, 0
0846   E836 FE 08                           CP      KEY_BACKSPACE
0847   E838 CC 03 E8                        CALL    Z, _hi_delete_join
0848   E83B 18 F1                           JR      delete_or_enter
0849   E83D             
0850   E83D             
0851   E83D             ;------------------------------------------------------
0852   E83D             ; Menu system
0853   E83D 00          menu_index          .DB     0
0854   E83E 00 00       menu_address        .DW     0
0855   E840 00 00       menu_current        .DW     0
0856   E842             
0857   E842 AF          start_menu          XOR    A
0858   E843 32 3D E8                        LD     (menu_index), A
0859   E846 22 3E E8                        LD     (menu_address), HL
0860   E849             
0861   E849 CD 89 E8    _menu_loop          CALL   _display_menu
0862   E84C 01 58 02                        LD     BC, 600
0863   E84F CD 11 E9                        CALL   pause_for_ticks
0864   E852 CD 71 EF                        CALL   bios_conist
0865   E855 A7                              AND    A
0866   E856 C8                              RET    Z
0867   E857             
0868   E857 CD 9A EF    _menu_key           CALL   bios_conin
0869   E85A FE 81                           CP     KEY_DOWN
0870   E85C 20 09                           JR     NZ, _menu_up
0871   E85E             
0872   E85E 3A 3D E8                        LD      A, (menu_index)
0873   E861 3C                              INC     A
0874   E862 32 3D E8    _menu_set_index     LD      (menu_index),A
0875   E865 18 E2                           JR      _menu_loop
0876   E867             
0877   E867 FE 80       _menu_up            CP      KEY_UP
0878   E869 20 08                           JR      NZ, _menu_delete
0879   E86B 3A 3D E8                        LD      A, (menu_index)
0880   E86E 3D                              DEC     A
0881   E86F 28 D8                           JR      Z, _menu_loop
0882   E871 18 EF                           JR      _menu_set_index
0883   E873             
0884   E873 FE 08       _menu_delete        CP      KEY_BACKSPACE
0885   E875 C8                              RET     Z
0886   E876             
0887   E876 FE 0D       _menu_enter         CP      KEY_ENTER
0888   E878 20 CF                           JR      NZ, _menu_loop
0889   E87A 3A 3D E8                        LD      A, (menu_index)
0890   E87D A7                              AND     A
0891   E87E 28 C9                           JR      Z, _menu_loop
0892   E880 2A 40 E8                        LD      HL, (menu_current)
0893   E883 7E                              LD      A, (HL)
0894   E884 23                              INC     HL
0895   E885 66                              LD      H, (HL)
0896   E886 6F                              LD      L, A
0897   E887 E5                              PUSH    HL
0898   E888 C9                              RET
0899   E889             
0900   E889             
0901   E889             
0902   E889 0E 0D       _display_menu       LD      C, CARRIAGE_RETURN
0903   E88B CD 00 F0                        CALL    bios_conout
0904   E88E             
0905   E88E 3A 3D E8                        LD      A, (menu_index)
0906   E891 2A 3E E8                        LD      HL, (menu_address)
0907   E894 A7          _entry_loop         AND     A
0908   E895 28 12                           JR      Z, _display_entry
0909   E897 47                              LD      B, A
0910   E898 7E          _next_menu          LD      A, (HL)
0911   E899 23                              INC     HL
0912   E89A A7                              AND     A
0913   E89B 20 FB                           JR      NZ, _next_menu
0914   E89D             
0915   E89D 22 40 E8                        LD      (menu_current), HL
0916   E8A0 7E                              LD      A, (HL)
0917   E8A1 23                              INC     HL
0918   E8A2 5E                              LD      E, (HL)
0919   E8A3 23                              INC     HL
0920   E8A4 B3                              OR      E
0921   E8A5 28 19                           JR      Z, _menu_end
0922   E8A7 10 EF                           DJNZ    _next_menu
0923   E8A9                                 
0924   E8A9 7E          _display_entry      LD      A, (HL)
0925   E8AA A7                              AND     A
0926   E8AB 28 09                           JR      Z, _entry_end
0927   E8AD 4F                              LD      C, A
0928   E8AE E5                              PUSH    HL
0929   E8AF CD 00 F0                        CALL    bios_conout
0930   E8B2 E1                              POP     HL
0931   E8B3 23                              INC     HL
0932   E8B4 18 F3                           JR      _display_entry
0933   E8B6 0E 1B       _entry_end          LD      C, ESCAPE_CHAR
0934   E8B8 CD 00 F0                        CALL    bios_conout
0935   E8BB 0E 4B                           LD      C, 'K'
0936   E8BD C3 00 F0                        JP      bios_conout
0937   E8C0             
0938   E8C0 3A 3D E8    _menu_end           LD      A, (menu_index)
0939   E8C3 3D                              DEC     A
0940   E8C4 32 3D E8                        LD      (menu_index), A
0941   E8C7 18 C0                           JR      _display_menu
0942   E8C9             
0943   E8C9             
0944   E8C9             ;------------------------------------------------------
0945   E8C9             ; Write the Hex value of DE as four characters to conout
0946   E8C9             ;
0947   E8C9 D5          hex_word            PUSH    DE
0948   E8CA 7A                              LD      A, D
0949   E8CB CD D0 E8                        CALL    hex_out
0950   E8CE D1                              POP     DE
0951   E8CF 7B                              LD      A, E                ; Fall into hex_out..
0952   E8D0             
0953   E8D0             ;------------------------------------------------------
0954   E8D0             ; Write the Hex value of A as two characters to conout
0955   E8D0             ;
0956   E8D0 4F          hex_out             LD      C, A
0957   E8D1 CB 3F                           SRL     A
0958   E8D3 CB 3F                           SRL     A
0959   E8D5 CB 3F                           SRL     A
0960   E8D7 CB 3F                           SRL     A
0961   E8D9 C5                              PUSH    BC
0962   E8DA CD DF E8                        CALL    _nibble
0963   E8DD C1                              POP     BC
0964   E8DE 79                              LD      A, C
0965   E8DF             
0966   E8DF E6 0F       _nibble             AND     $0F      ;LOW NIBBLE ONLY
0967   E8E1 C6 90                           ADD     A,$90
0968   E8E3 27                              DAA 
0969   E8E4 CE 40                           ADC     A,$40
0970   E8E6 27                              DAA 
0971   E8E7 4F                              LD      C,A
0972   E8E8 C3 00 F0                        JP      bios_conout
0973   E8EB             
0974   E8EB             
0975   E8EB             ;------------------------------------------------------
0976   E8EB             ; Only accept hex characters (0-9, a-f), or DELETE from the input
0977   E8EB             ; Returns with character in A, a-f are capitalised
0978   E8EB             ;
0979   E8EB CD 9A EF    hex_char_in         CALL    bios_conin
0980   E8EE FE 08                           CP      KEY_BACKSPACE
0981   E8F0 C8                              RET     Z
0982   E8F1 CD F7 E8                        CALL    valid_hex_char
0983   E8F4 38 F5                           JR      C, hex_char_in
0984   E8F6 C9                              RET
0985   E8F7             ;
0986   E8F7             ; Return with carry CLEAR if the character is a valid hex digit
0987   E8F7             ; Enter with A = character to test
0988   E8F7             ; Returns with A capitalised
0989   E8F7 FE 30       valid_hex_char      CP      '0'
0990   E8F9 D8                              RET     C
0991   E8FA FE 3A                           CP      ':'
0992   E8FC 3F                              CCF
0993   E8FD D0                              RET     NC
0994   E8FE FE 61                           CP      'a'
0995   E900 D8                              RET     C
0996   E901 FE 67                           CP      'g'
0997   E903 CB AF                           RES     5, a                ; Capitalise it..
0998   E905 3F                              CCF
0999   E906 C9                              RET
1000   E907             
1001   E907 FE 41       hex_char_to_num     CP      'A'
1002   E909 30 03                           JR      NC, _alpha_char
1003   E90B D6 30                           SUB     '0'
1004   E90D C9                              RET
1005   E90E D6 37       _alpha_char         SUB     'A'-10
1006   E910 C9                              RET
1007   E911             
1008   E911             ;
1009   E911             ; Pause for BC ticks
1010   E911             ; Uses HL, DE
1011   E911             ;
1012   E911 ED 5B 04 FF pause_for_ticks     LD      DE, (timer)
1013   E915 C5          _pause_loop         PUSH    BC
1014   E916 D5                              PUSH    DE
1015   E917 CD 71 EF                        CALL    bios_conist
1016   E91A D1                              POP     DE
1017   E91B C1                              POP     BC
1018   E91C A7                              AND     A
1019   E91D C0                              RET     NZ
1020   E91E 2A 04 FF                        LD      HL, (timer)
1021   E921 ED 52                           SBC     HL, DE
1022   E923 ED 42                           SBC     HL, BC
1023   E925 38 EE                           JR      C, _pause_loop
1024   E927 C9                              RET
1025   E928             ;
1026   E928             ; Detect (and time) interrupt
1027   E928             ; Enter with A containing the mask for which bits of the timer byte we check for zero
1028   E928             ; Return when the timer is zero, with BC containing 72 + 48*t-states taken
1029   E928             ;
1030   E928 01 00 00    detect_int          LD      BC, 0
1031   E92B 57                              LD      D, A
1032   E92C 3A 04 FF    _wait_for_tick      LD      A, (timer)               ; 13            ; Loop = 13+4+5+6+4+4+12 (=48) * BC + (13 + 4 + 11 + 13 + 4 + 17 + 10 (CALL)) = 72
1033   E92F A2                              AND     D                        ; 4
1034   E930 C8                              RET     Z                        ; 5 / 11
1035   E931 03                              INC     BC                       ; 6
1036   E932 79                              LD      A, C                     ; 4
1037   E933 B0                              OR      B                        ; 4
1038   E934 20 F6                           JR      NZ, _wait_for_tick       ; 7 / 12
1039   E936 C9                              RET
1040   E937             ;
1041   E937             ; Fast int routine to allow us to time CPU speed
1042   E937             ;
1043   E937 F3          timer_int           DI
1044   E938 E5                              PUSH    HL
1045   E939 2A 04 FF                        LD      HL, (timer)
1046   E93C 23                              INC     HL
1047   E93D 22 04 FF                        LD      (timer), HL
1048   E940 E1                              POP     HL
1049   E941 FB                              EI
1050   E942 ED 4D                           RETI
1051   E944             
1052   E944             ; Divide HL by C (unsigned)
1053   E944             ;Inputs:
1054   E944             ;     HL is the numerator
1055   E944             ;     C is the denominator
1056   E944             ;Outputs:
1057   E944             ;     A is the remainder
1058   E944             ;     B is 0
1059   E944             ;     C is not changed
1060   E944             ;     DE is not changed
1061   E944             ;     HL is the quotient
1062   E944             ;
1063   E944             divide_hl_c
1064   E944 06 10                           LD      B, 16
1065   E946 AF                              XOR     A
1066   E947 29          _div0               ADD     HL, HL
1067   E948 17                              RLA
1068   E949 B9                              CP      C
1069   E94A 38 02                           JR      C,_div1
1070   E94C 2C                              INC     L
1071   E94D 91                              SUB     C
1072   E94E 10 F7       _div1               DJNZ    _div0
1073   E950 C9                              RET
1074   E951             
1075   E951             ;
1076   E951             ; Convert DE to a five digit BCD value stored in bcd_scratch
1077   E951             ; 
1078   E951 AF          de_to_bcd           XOR     A
1079   E952 21 89 E9                        LD      HL, bcd_scratch
1080   E955 06 05                           LD      B, 5
1081   E957 77          _clear_scratch      LD      (HL), A
1082   E958 23                              INC     HL
1083   E959 10 FC                           DJNZ    _clear_scratch
1084   E95B                 
1085   E95B 06 10                           LD      B, 16           ; Convert 16 bits
1086   E95D 0E 05       _bcd_loop           LD      C, 5
1087   E95F 21 89 E9                        LD      HL, bcd_scratch
1088   E962 7E          _correct_digits     LD      A, (HL)
1089   E963 FE 05                           CP      5
1090   E965 38 03                           JR      C, _digit_ok
1091   E967 C6 03                           ADD     A, 3
1092   E969 77                              LD      (HL), A
1093   E96A 23          _digit_ok           INC     HL
1094   E96B 0D                              DEC     C
1095   E96C 20 F4                           JR      NZ, _correct_digits                   
1096   E96E             
1097   E96E 21 89 E9                        LD      HL, bcd_scratch
1098   E971 0E 05                           LD      C, 5
1099   E973 CB 23                           SLA     E
1100   E975 CB 12                           RL      D
1101   E977             
1102   E977 7E          _shift_digits       LD      A, (HL)
1103   E978 CB 17                           RL      A
1104   E97A CB 67                           BIT     4, A
1105   E97C 28 03                           JR      Z, _skip_carry
1106   E97E E6 0F                           AND     0Fh
1107   E980 37                              SCF
1108   E981 77          _skip_carry         LD      (HL), A
1109   E982 23                              INC     HL
1110   E983 0D                              DEC     C
1111   E984 20 F1                           JR      NZ, _shift_digits
1112   E986 10 D5                           DJNZ    _bcd_loop
1113   E988 C9                              RET
1114   E989             
1115   E989 00 00 00 00 bcd_scratch         .DB      0,0,0,0,0      ; Five bytes - 0 to 99,999. Smallest digit (units) first
1115   E98D 00 
1116   E98E             
1117   E98E                                 .INCLUDE  "monitor_rtc.asm"
0001+  E98E             ;
0002+  E98E             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0003+  E98E             ;
0004+  E98E             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0005+  E98E             ;
0006+  E98E             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0007+  E98E             ; of this software and associated documentation files (the "Software"), to deal
0008+  E98E             ; in the Software without restriction, including without limitation the rights
0009+  E98E             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0010+  E98E             ; copies of the Software, and to permit persons to whom the Software is
0011+  E98E             ; furnished to do so, subject to the following conditions:
0012+  E98E             ; 
0013+  E98E             ; The above copyright notice and this permission notice shall be included in all
0014+  E98E             ; copies or substantial portions of the Software.
0015+  E98E             ; 
0016+  E98E             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0017+  E98E             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0018+  E98E             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0019+  E98E             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0020+  E98E             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0021+  E98E             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0022+  E98E             ; SOFTWARE.
0023+  E98E             ;
0024+  E98E                                     .MODULE monitor_rtc
0025+  E98E             
0026+  E98E             _offset_sec             .EQU    0
0027+  E98E             _offset_min             .EQU    1
0028+  E98E             _offset_hour            .EQU    2
0029+  E98E             _offset_wkday           .EQU    3
0030+  E98E             _offset_date            .EQU    4
0031+  E98E             _offset_month           .EQU    5
0032+  E98E             _offset_year            .EQU    6
0033+  E98E             
0034+  E98E             
0035+  E98E CD 73 EA    rtc_display_time        CALL    rtc_get_time
0036+  E991 0E 0D                               LD      C, CARRIAGE_RETURN
0037+  E993 CD 00 F0                            CALL    bios_conout
0038+  E996                                     
0039+  E996 3A E0 FC                            LD      A, (time_scratch+_offset_wkday)
0040+  E999 21 27 EA                            LD      HL, weekdays
0041+  E99C E6 07                               AND     7
0042+  E99E 4F                                  LD      C, A
0043+  E99F             
0044+  E99F CD 11 EA                            CALL    _search_word
0045+  E9A2                                     
0046+  E9A2 CD F2 E9    _get_date               CALL    _space
0047+  E9A5 3A E1 FC                            LD      A, (time_scratch+_offset_date)
0048+  E9A8 E6 3F                               AND     03Fh
0049+  E9AA CD F7 E9                            CALL    _two_chars
0050+  E9AD CD F2 E9                            CALL    _space
0051+  E9B0             
0052+  E9B0 3A E2 FC                            LD      A, (time_scratch+_offset_month)
0053+  E9B3 21 43 EA                            LD      HL, _months
0054+  E9B6 E6 1F                               AND     01fh
0055+  E9B8 CB 67                               BIT     4, A
0056+  E9BA 28 02                               JR      Z, _month_ok
0057+  E9BC D6 06                               SUB     6
0058+  E9BE 4F          _month_ok               LD      C,A
0059+  E9BF             
0060+  E9BF CD 11 EA                            CALL    _search_word
0061+  E9C2 CD F2 E9                            CALL    _space
0062+  E9C5 3E 20                               LD      A, 20h
0063+  E9C7 CD F7 E9                            CALL    _two_chars
0064+  E9CA             
0065+  E9CA 3A E3 FC                            LD      A, (time_scratch+_offset_year)
0066+  E9CD CD F7 E9                            CALL    _two_chars
0067+  E9D0 CD F2 E9                            CALL    _space
0068+  E9D3             
0069+  E9D3 3A DF FC                            LD      A, (time_scratch+_offset_hour)
0070+  E9D6 E6 3F                               AND     03fh
0071+  E9D8 CD F7 E9                            CALL    _two_chars
0072+  E9DB CD F2 E9                            CALL    _space
0073+  E9DE             
0074+  E9DE 3A DE FC                            LD      A, (time_scratch+_offset_min)
0075+  E9E1 E6 7F                               AND     07fh
0076+  E9E3 CD F7 E9                            CALL    _two_chars
0077+  E9E6 CD F2 E9                            CALL    _space
0078+  E9E9             
0079+  E9E9 3A DD FC                            LD      A, (time_scratch+_offset_sec)
0080+  E9EC E6 7F                               AND     07fh
0081+  E9EE CD F7 E9                            CALL    _two_chars
0082+  E9F1 C9                                  RET
0083+  E9F2             
0084+  E9F2 0E 20       _space                  LD      C, ' '
0085+  E9F4 C3 00 F0                            JP      bios_conout
0086+  E9F7             
0087+  E9F7 4F          _two_chars              LD      C,A
0088+  E9F8 CB 3F                               SRL     A
0089+  E9FA CB 3F                               SRL     A
0090+  E9FC CB 3F                               SRL     A
0091+  E9FE CB 3F                               SRL     A
0092+  EA00 C6 30                               ADD     A, '0'
0093+  EA02 C5                                  PUSH    BC
0094+  EA03 4F                                  LD      C, A
0095+  EA04 CD 00 F0                            CALL    bios_conout
0096+  EA07 C1                                  POP     BC
0097+  EA08 79                                  LD      A,C
0098+  EA09 E6 0F                               AND     0fh
0099+  EA0B C6 30                               ADD     A, '0'
0100+  EA0D 4F                                  LD      C, A
0101+  EA0E C3 00 F0                            JP      bios_conout
0102+  EA11             ;
0103+  EA11             ; Search table pointed to by HL for the C'th word (1-based)
0104+  EA11             ; Prints the chosen word to conout
0105+  EA11             ;
0106+  EA11 0D          _search_word            DEC     C
0107+  EA12 20 0C                               JR      NZ, _next_char
0108+  EA14                                     
0109+  EA14 7E          _print_word             LD      A, (HL)
0110+  EA15 23                                  INC     HL
0111+  EA16 A7                                  AND     A
0112+  EA17 C8                                  RET     Z
0113+  EA18 4F                                  LD      C, A
0114+  EA19 E5                                  PUSH    HL
0115+  EA1A CD 00 F0                            CALL    bios_conout
0116+  EA1D E1                                  POP     HL
0117+  EA1E 18 F4                               JR      _print_word
0118+  EA20             
0119+  EA20 7E          _next_char              LD      A, (HL)
0120+  EA21 23                                  INC     HL
0121+  EA22 A7                                  AND     A
0122+  EA23 20 FB                               JR      NZ, _next_char
0123+  EA25 18 EA                               JR      _search_word
0124+  EA27             
0125+  EA27             
0126+  EA27 4D 6F 6E 00 weekdays                .DB "Mon",0
0127+  EA2B 54 75 65 00                         .DB "Tue",0
0128+  EA2F 57 65 64 00                         .DB "Wed",0
0129+  EA33 54 68 75 00                         .DB "Thu",0
0130+  EA37 46 72 69 00                         .DB "Fri",0
0131+  EA3B 53 61 74 00                         .DB "Sat",0
0132+  EA3F 53 75 6E 00                         .DB "Sun",0
0133+  EA43             
0134+  EA43 4A 61 6E 00 _months                 .DB "Jan",0
0135+  EA47 46 65 62 00                         .DB "Feb",0
0136+  EA4B 4D 61 72 00                         .DB "Mar",0
0137+  EA4F 41 70 72 00                         .DB "Apr",0
0138+  EA53 4D 61 79 00                         .DB "May",0
0139+  EA57 4A 75 6E 00                         .DB "Jun",0
0140+  EA5B 4A 75 6C 00                         .DB "Jul",0
0141+  EA5F 41 75 67 00                         .DB "Aug",0
0142+  EA63 53 65 70 00                         .DB "Sep",0
0143+  EA67 4F 63 74 00                         .DB "Oct",0
0144+  EA6B 4E 6F 76 00                         .DB "Nov",0
0145+  EA6F 44 65 63 00                         .DB "Dec",0
0146+  EA73             
0147+  EA73             ;
0148+  EA73             ; Read the time into the temp_data area
0149+  EA73             ; Returns with Carry SET if successful, else Carry CLEAR
0150+  EA73             ;
0151+  EA73 26 6F       rtc_get_time            LD      H, RTC_ADDRESS
0152+  EA75 2E 00                               LD      L, RTC_REG_SEC
0153+  EA77 CD FC F8                            CALL    i2c_read_from
0154+  EA7A 30 18                               JR      NC, _get_error
0155+  EA7C 21 DD FC                            LD      HL, time_scratch
0156+  EA7F 06 07                               LD      B, 7
0157+  EA81 18 08                               JR      _store_time
0158+  EA83 C5          _get_loop               PUSH    BC 
0159+  EA84 CD 51 F9                            CALL    i2c_ack
0160+  EA87 CD 3E F9                            CALL    i2c_read
0161+  EA8A C1                                  POP     BC
0162+  EA8B 77          _store_time             LD      (HL), A
0163+  EA8C 23                                  INC     HL
0164+  EA8D 10 F4                               DJNZ    _get_loop
0165+  EA8F CD E5 F8                            CALL    i2c_stop
0166+  EA92 37                                  SCF
0167+  EA93 C9                                  RET
0168+  EA94             
0169+  EA94 CD E5 F8    _get_error              CALL    i2c_stop
0170+  EA97 CD AA F3                            CALL    m_print_inline 
0171+  EA9A 45 72 72 6F                         .DB     "Error getting time\r\n", 0
0171+  EA9E 72 20 67 65 
0171+  EAA2 74 74 69 6E 
0171+  EAA6 67 20 74 69 
0171+  EAAA 6D 65 0D 0A 
0171+  EAAE 00 
0172+  EAAF AF                                  XOR     A
0173+  EAB0 C9                                  RET
0174+  EAB1             
0175+  EAB1                                     .MODULE main1118   EAB1                                 .INCLUDE "ymodem.asm"
0001+  EAB1             ;
0002+  EAB1             ; YModem implementation.
0003+  EAB1             ; File format: The filename MAY indicate the load address in memory for the file. If so, the format is:
0004+  EAB1             ;       filename_mHHHH.suffix
0005+  EAB1             ;    or filename_pHH.suffix
0006+  EAB1             ;
0007+  EAB1             ; Where:  _mHHHH indicates a preferred destination address of HHHH (in memory) - four digits hexadecimal value (uppercase).
0008+  EAB1             ;   or    _pHH   indicates the page in memory that the file is intended for (assumes start at offset 0 in page..)
0009+  EAB1             ;
0010+  EAB1             ; When _p is used, the file is always written to bank 1 - address 4000h. It is expected that the calling program will
0011+  EAB1             ; then copy the data to the target page, which can be retrieved from the ym_file_mode return value.
0012+  EAB1             ; 
0013+  EAB1             ;
0014+  EAB1             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0015+  EAB1             ;
0016+  EAB1             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0017+  EAB1             ;
0018+  EAB1             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0019+  EAB1             ; of this software and associated documentation files (the "Software"), to deal
0020+  EAB1             ; in the Software without restriction, including without limitation the rights
0021+  EAB1             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0022+  EAB1             ; copies of the Software, and to permit persons to whom the Software is
0023+  EAB1             ; furnished to do so, subject to the following conditions:
0024+  EAB1             ; 
0025+  EAB1             ; The above copyright notice and this permission notice shall be included in all
0026+  EAB1             ; copies or substantial portions of the Software.
0027+  EAB1             ; 
0028+  EAB1             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0029+  EAB1             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0030+  EAB1             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0031+  EAB1             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0032+  EAB1             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0033+  EAB1             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0034+  EAB1             ; SOFTWARE.
0035+  EAB1             ;
0036+  EAB1             
0037+  EAB1                                 .MODULE ymodem
0038+  EAB1             
0039+  EAB1             _PAGE_PREFIX        .EQU    'p'
0040+  EAB1             _DEST_PREFIX        .EQU    'm'
0041+  EAB1             
0042+  EAB1             ; Return values
0043+  EAB1             YMODEM_SUCCESS      .EQU    000h
0044+  EAB1             YMODEM_TIMEOUT      .EQU    001h
0045+  EAB1             YMODEM_UNKNOWN      .EQU    002h            ; Unknown packet type (Packet byte in C)
0046+  EAB1             YMODEM_CANCEL       .EQU    003h            ; Cancelled by sender
0047+  EAB1             YMODEM_PACKET_ERROR .EQU    004h            ; Packet data error (Error code in C)
0048+  EAB1             YMODEM_LENGTH_ERROR .EQU    005h            ; Length data in zeroth packet is invalid
0049+  EAB1             YMODEM_NO_DEST      .EQU    006h            ; No destination provided
0050+  EAB1             YMODEM_SEND_TIMEOUT .EQU    007h
0051+  EAB1             YMODEM_MULTI_FILES  .EQU    008h            ; Cannot receive more than one file 
0052+  EAB1             
0053+  EAB1             _SOH                .EQU    001h            ; 128 byte data packet header
0054+  EAB1             _STX                .EQU    002h            ; 1024 byte data packet header
0055+  EAB1             _EOT                .EQU    004h            ; End transfer
0056+  EAB1             _ACK                .EQU    006h            ; Respond
0057+  EAB1             _NAK                .EQU    015h            ; No response
0058+  EAB1             _CAN                .EQU    018h            ; Transmission aborted
0059+  EAB1             _C                  .EQU    043h            ; Request packet
0060+  EAB1             
0061+  EAB1             _SOH_PACKET_SIZE    .EQU    128
0062+  EAB1             _STX_PACKET_SIZE    .EQU    1024
0063+  EAB1             _FRAME_OVERHEAD     .EQU    5               ; Three byte header + two byte CRC (high byte first)
0064+  EAB1             
0065+  EAB1             _TIMEOUT_COUNT      .EQU    50000
0066+  EAB1             
0067+  EAB1             _ERR_PACKET_COUNT   .EQU    1               ; Wrong packet index
0068+  EAB1             _ERR_CHECK_HIGH     .EQU    2               ; High byte of CRC failed
0069+  EAB1             _ERR_CHECK_LOW      .EQU    3               ; Low byte of CRC failed
0070+  EAB1             _ERR_CANCEL         .EQU    4               ; Got a cancel request without second cancel
0071+  EAB1             _ERR_ZERO_PACKET    .EQU    5               ; Zeroth packet must be SOH
0072+  EAB1             
0073+  EAB1             YM_DEST_FROM_FILE   .EQU    0FEh            ; File destination set from filename
0074+  EAB1             
0075+  EAB1             ymodem_data_length  .EQU    17              ; Size of data block before buffer
0076+  EAB1             
0077+  EAB1             ym_file_mode        .EQU    -17             ; FFh : Normal transfer,  FEh : Destination set by file, 0-7Fh : Page write 
0078+  EAB1             ym_file_count       .EQU    -16
0079+  EAB1             ym_length_low       .EQU    -15             ; Length specified in header packet
0080+  EAB1             ym_length_mid       .EQU    -14
0081+  EAB1             ym_length_high      .EQU    -13
0082+  EAB1             ym_loaded_high      .EQU    -12             ; Tracks high byte of length during load.
0083+  EAB1             ym_soh_saved_len    .EQU    -11             ; We have to copy part of a final SOH packet from the buffer - track actual length needed
0084+  EAB1             ym_soh_saved_len_h  .EQU    -10 
0085+  EAB1             ym_current_page     .EQU    -9              ; FFh if no paging, otherwise page to send data to
0086+  EAB1             ym_dest_low         .EQU    -8              ; If specified in file header - the destination address of the file
0087+  EAB1             ym_dest_high        .EQU    -7
0088+  EAB1             ym_current_packet   .EQU    -6              ; Expected packet number
0089+  EAB1             ym_packet_type      .EQU    -5              ; Packet type - SOH/STX
0090+  EAB1             ym_packet_num       .EQU    -4              ; Packet number we're currently receiving
0091+  EAB1             ym_packet_num_cpl   .EQU    -3              ; Complement..
0092+  EAB1             ym_crc_low          .EQU    -2              ; CRC Low byte
0093+  EAB1             ym_crc_high         .EQU    -1              ; CRC High byte
0094+  EAB1             
0095+  EAB1             YMODEM_BUFFER       .EQU    _SOH_PACKET_SIZE + ymodem_data_length
0096+  EAB1             YMODEM_INFO         .EQU    _SOH_PACKET_SIZE
0097+  EAB1             
0098+  EAB1             ;
0099+  EAB1             ; ymodem - Main entry point. Call with:
0100+  EAB1             ;     HL = Address of YMODEM_BUFFER (=128 + ymodem_data_length) byte buffer for receiving data
0101+  EAB1             ;     DE = (Optional) address to write data. 0xFFFF to accept destination from filename otherwise
0102+  EAB1             ;      A = Page to write data. 0xFF to disable paging/accept page from filename otherwise
0103+  EAB1             ;
0104+  EAB1             ; If using A to set a Page destination, DE should be an offset within Bank 1 (ie 4000h - 7FFFh)
0105+  EAB1             ; If the file specifies a page destination, DE is initialised to 4000h - the start of the page
0106+  EAB1             ;
0107+  EAB1             ; Returns status code in A:
0108+  EAB1             ;     YMODEM_SUCCESS : (=0) If the file was successfully received
0109+  EAB1             ;     YMODEM_xxxx    : (Non zero) If the receiver timed out waiting for a byte
0110+  EAB1             ;
0111+  EAB1             ; Note Bank 1 may have been set to a new page destination if one was specified.
0112+  EAB1             
0113+  EAB1 01 11 00    ymodem              LD      BC, ymodem_data_length      ; Skip data block at start of buffer
0114+  EAB4 09                              ADD     HL, BC
0115+  EAB5 E5                              PUSH    HL
0116+  EAB6 DD E1                           POP     IX
0117+  EAB8 DD 77 F7                        LD      (IX+ym_current_page), A
0118+  EABB DD 77 EF                        LD      (IX+ym_file_mode), A           ; Default normal transfer, 0FFh, else page 
0119+  EABE AF                              XOR     A                           
0120+  EABF DD 77 F0                        LD      (IX+ym_file_count), A
0121+  EAC2 3D                              DEC     A
0122+  EAC3 DD 73 F8                        LD      (IX+ym_dest_low), E
0123+  EAC6 DD 72 F9                        LD      (IX+ym_dest_high), D
0124+  EAC9             
0125+  EAC9 AF          _ymodem_start       XOR     A                           ; Set initial packet number
0126+  EACA DD 77 FA                        LD      (IX+ym_current_packet), A
0127+  EACD FD 21 FF FF                     LD      IY, 0FFFFh                  ; IY - bytes to load. Default - load all bytes
0128+  EAD1             
0129+  EAD1                                 ; Now we can load.
0130+  EAD1                                 ; DE = destination
0131+  EAD1                                 ; IY = low 16 bits of length
0132+  EAD1                                 ; IX = load buffer
0133+  EAD1             
0134+  EAD1 CD 5E ED    _packet_loop        CALL    _recieve_safe
0135+  EAD4 20 07                           JR      NZ, _packet_byte
0136+  EAD6 3E 43       _send_crc_and_loop  LD      A, _C
0137+  EAD8 CD 89 ED                        CALL    _send_byte
0138+  EADB 18 F4                           JR      _packet_loop
0139+  EADD             
0140+  EADD FE 01       _packet_byte        CP      _SOH
0141+  EADF C2 EA EA                        JP      NZ, _check_stx
0142+  EAE2             
0143+  EAE2 DD E5                           PUSH    IX                          ; SOH - May be zero'th or last packet
0144+  EAE4 E1                              POP     HL
0145+  EAE5 01 80 00                        LD      BC, _SOH_PACKET_SIZE
0146+  EAE8 18 40                           JR      _receive_packet
0147+  EAEA             
0148+  EAEA FE 02       _check_stx          CP      _STX
0149+  EAEC 20 07                           JR      NZ, _check_eot
0150+  EAEE                                                                     
0151+  EAEE 62                              LD      H, D                        ; STX packets go straight to DE
0152+  EAEF 6B                              LD      L, E
0153+  EAF0 01 00 04                        LD      BC, _STX_PACKET_SIZE    
0154+  EAF3 18 35                           JR      _receive_packet
0155+  EAF5             
0156+  EAF5 FE 04       _check_eot          CP      _EOT
0157+  EAF7 20 0A                           JR      NZ, _check_can
0158+  EAF9                                                                     ; End of transmission
0159+  EAF9 3E 06                           LD      A, _ACK 
0160+  EAFB CD 89 ED                        CALL    _send_byte
0161+  EAFE             
0162+  EAFE DD 34 F0                        INC     (IX+ym_file_count)      
0163+  EB01 18 C6                           JR      _ymodem_start  
0164+  EB03             
0165+  EB03 FE 18       _check_can          CP      _CAN
0166+  EB05 20 1E                           JR      NZ, _unknown_packet
0167+  EB07                                                                     ; Single cancel request. Check for another
0168+  EB07 CD 69 ED                        CALL    _receive_byte
0169+  EB0A FE 18                           CP      _CAN
0170+  EB0C 3E 04                           LD      A, _ERR_CANCEL
0171+  EB0E 20 10                           JR      NZ, _packet_error
0172+  EB10             
0173+  EB10 3E 06                           LD      A, _ACK 
0174+  EB12 CD 89 ED                        CALL    _send_byte
0175+  EB15 CD 5E ED    _purge              CALL    _recieve_safe               ; Purge remains of any cancel request
0176+  EB18 20 FB                           JR      NZ, _purge
0177+  EB1A             
0178+  EB1A 3E 03                           LD      A, YMODEM_CANCEL
0179+  EB1C A7                              AND     A
0180+  EB1D C9                              RET
0181+  EB1E             
0182+  EB1E 3E 05       _zero_error         LD      A, _ERR_ZERO_PACKET
0183+  EB20 4F          _packet_error       LD      C, A                        ; Packet data error - return error code in C
0184+  EB21 3E 04                           LD      A, YMODEM_PACKET_ERROR
0185+  EB23 A7                              AND     A
0186+  EB24 C9                              RET
0187+  EB25             
0188+  EB25 4F          _unknown_packet     LD      C, A                        ; Unknown packet type - return header byte in C
0189+  EB26 3E 02                           LD      A, YMODEM_UNKNOWN
0190+  EB28 A7                              AND     A
0191+  EB29 C9                              RET     
0192+  EB2A             
0193+  EB2A             ; Receive data for both SOH and STX packets..
0194+  EB2A             ; At this point HL is destination (either DE or IX-buffer), and BC is a byte count
0195+  EB2A             ;
0196+  EB2A DD 77 FB    _receive_packet     LD      (IX+ym_packet_type), A   
0197+  EB2D             
0198+  EB2D DD 7E F7                        LD      A, (IX+ym_current_page)
0199+  EB30 FE FF                           CP      0FFh
0200+  EB32 28 02                           JR      Z, _no_page_specified
0201+  EB34 D3 71                           OUT     (IO_MEM_1), A
0202+  EB36             
0203+  EB36 AF          _no_page_specified  XOR     A
0204+  EB37 DD 77 F5                        LD      (IX+ym_soh_saved_len), A     ; Reset how many bytes of an SOH packet we actually loaded..
0205+  EB3A DD 77 F6                        LD      (IX+ym_soh_saved_len_h), A
0206+  EB3D             
0207+  EB3D DD BE FA                        CP      (IX+ym_current_packet)         ; If this is the zeroth packet, it must be SOH
0208+  EB40 20 07                           JR      NZ, _not_zeroth_packet
0209+  EB42 3E 01                           LD      A, _SOH
0210+  EB44 DD 96 FB                        SUB     (IX+ym_packet_type)            ; Leave A as zero if this is OK
0211+  EB47 20 D5                           JR      NZ, _zero_error
0212+  EB49             
0213+  EB49 DD 77 FF    _not_zeroth_packet  LD      (IX+ym_crc_high), A
0214+  EB4C DD 77 FE                        LD      (IX+ym_crc_low), A
0215+  EB4F             
0216+  EB4F CD 69 ED                        CALL    _receive_byte   
0217+  EB52 DD 77 FC                        LD      (IX+ym_packet_num), A
0218+  EB55 CD 69 ED                        CALL    _receive_byte   
0219+  EB58 DD 77 FD                        LD      (IX+ym_packet_num_cpl), A
0220+  EB5B             
0221+  EB5B 7D          _data_loop          LD      A, L                        ; Handle paging if we're loading into paged memory..
0222+  EB5C A7                              AND     A
0223+  EB5D 20 12                           JR      NZ, _data_receive
0224+  EB5F 7C                              LD      A, H
0225+  EB60 FE 80                           CP      80h
0226+  EB62 20 0D                           JR      NZ, _data_receive
0227+  EB64 DD 7E F7                        LD      A, (IX+ym_current_page)
0228+  EB67 3C                              INC     A
0229+  EB68 28 07                           JR      Z, _data_receive           ; Paging disabled
0230+  EB6A             
0231+  EB6A DD 77 F7                        LD      (IX+ym_current_page), A        ; Move to next page
0232+  EB6D D3 71                           OUT     (IO_MEM_1), A
0233+  EB6F 26 40                           LD      H, 40h
0234+  EB71                                 
0235+  EB71 CD 69 ED    _data_receive       CALL    _receive_byte
0236+  EB74             
0237+  EB74 77                              LD      (HL), A
0238+  EB75             
0239+  EB75 CD 2B ED                        CALL    _calc_checksum  
0240+  EB78             
0241+  EB78 C5                              PUSH    BC                          ; Count down the bytes remaining, and once we get to zero, send bytes to _dev_null
0242+  EB79 01 FF FF                        LD      BC, -1
0243+  EB7C FD 09                           ADD     IY, BC                      ; Carry set if IY not zero
0244+  EB7E C1                              POP     BC
0245+  EB7F 38 10                           JR      C, _in_range
0246+  EB81             
0247+  EB81 DD 35 F4                        DEC     (IX+ym_loaded_high)
0248+  EB84 F2 91 EB                        JP      P, _in_range
0249+  EB87                  
0250+  EB87 DD 34 F4                        INC     (IX+ym_loaded_high)      ; Keep resetting counter...
0251+  EB8A FD 23                           INC     IY
0252+  EB8C 21 5D ED                        LD      HL, _dev_null
0253+  EB8F 18 09                           JR      _do_next
0254+  EB91             
0255+  EB91 DD 34 F5    _in_range           INC     (IX+ym_soh_saved_len)
0256+  EB94 20 03                           JR      NZ, _packet_part_ok
0257+  EB96 DD 34 F6                        INC     (IX+ym_soh_saved_len_h)
0258+  EB99 23          _packet_part_ok     INC     HL
0259+  EB9A             
0260+  EB9A 0B          _do_next            DEC     BC
0261+  EB9B             
0262+  EB9B 78                              LD      A, B
0263+  EB9C B1                              OR      C
0264+  EB9D 20 BC                           JR      NZ, _data_loop
0265+  EB9F             
0266+  EB9F AF                              XOR     A
0267+  EBA0 CD 2B ED                        CALL    _calc_checksum  
0268+  EBA3 AF                              XOR     A
0269+  EBA4 CD 2B ED                        CALL    _calc_checksum  
0270+  EBA7             
0271+  EBA7 CD 69 ED                        CALL    _receive_byte
0272+  EBAA 47                              LD      B, A
0273+  EBAB CD 69 ED                        CALL    _receive_byte   
0274+  EBAE 4F                              LD      C, A
0275+  EBAF             ;
0276+  EBAF             ; Now do checks...
0277+  EBAF             
0278+  EBAF DD 7E FC                        LD      A, (IX+ym_packet_num)
0279+  EBB2 2F                              CPL
0280+  EBB3 DD BE FD                        CP      (IX+ym_packet_num_cpl)
0281+  EBB6 3E 01                           LD      A, _ERR_PACKET_COUNT
0282+  EBB8 C2 20 EB                        JP      NZ, _packet_error
0283+  EBBB DD 7E FF                        LD      A, (IX+ym_crc_high)
0284+  EBBE B8                              CP      B
0285+  EBBF 3E 02                           LD      A, _ERR_CHECK_HIGH
0286+  EBC1 C2 20 EB                        JP      NZ, _packet_error
0287+  EBC4 DD 7E FE                        LD      A, (IX+ym_crc_low)
0288+  EBC7 B9                              CP      C
0289+  EBC8 3E 03                           LD      A, _ERR_CHECK_LOW
0290+  EBCA C2 20 EB                        JP      NZ, _packet_error
0291+  EBCD             
0292+  EBCD             ; CRC and packet number check out... 
0293+  EBCD DD 7E FC                        LD      A, (IX+ym_packet_num)
0294+  EBD0 DD BE FA                        CP      (IX+ym_current_packet)
0295+  EBD3 20 23                           JR      NZ, _retry_packet               ; We need to restore IY (length) if we wish to survive.. DE is not updated until later, so OK
0296+  EBD5 DD 34 FA                        INC     (IX+ym_current_packet)
0297+  EBD8 A7                              AND     A
0298+  EBD9 28 4A                           JR      Z, _header_packet
0299+  EBDB             
0300+  EBDB DD 7E FB                        LD      A, (IX+ym_packet_type)
0301+  EBDE FE 01                           CP      _SOH
0302+  EBE0 20 0C                           JR      NZ, _not_soh
0303+  EBE2             
0304+  EBE2             ; SOH packets must be copied to DE -> 
0305+  EBE2 DD 4E F5                        LD      C, (IX+ym_soh_saved_len)
0306+  EBE5 06 00                           LD      B, 0
0307+  EBE7 DD E5                           PUSH    IX
0308+  EBE9 E1                              POP     HL
0309+  EBEA ED B0                           LDIR
0310+  EBEC 18 02                           JR      _send_ack
0311+  EBEE             
0312+  EBEE 54          _not_soh            LD      D, H
0313+  EBEF 5D                              LD      E, L
0314+  EBF0 3E 06       _send_ack           LD      A, _ACK 
0315+  EBF2 CD 89 ED    _send_and_loop      CALL    _send_byte
0316+  EBF5 C3 D6 EA                        JP      _send_crc_and_loop      
0317+  EBF8             
0318+  EBF8 AF          _retry_packet       XOR     A                           ; Clear carry
0319+  EBF9 ED 52                           SBC     HL, DE
0320+  EBFB 30 0D                           JR      NC, _retry_page_ok          
0321+  EBFD             
0322+  EBFD DD 7E F7                        LD      A,(IX+ym_current_page)         ; If HL (latest write dest) is less than DE (write dest at start of packet) assume we've changed pages..
0323+  EC00 FE FF                           CP      0FFH
0324+  EC02 28 06                           JR      Z, _retry_page_ok           ; We're not paging anyway...
0325+  EC04 3D                              DEC     A 
0326+  EC05 DD 77 F7                        LD      (IX+ym_current_page), A
0327+  EC08 D3 71                           OUT     (IO_MEM_1),A
0328+  EC0A             
0329+  EC0A DD 4E F5    _retry_page_ok      LD      C, (IX+ym_soh_saved_len)     ; Restore IY (length)
0330+  EC0D DD 46 F6                        LD      B, (IX+ym_soh_saved_len_h)
0331+  EC10 FD E5                           PUSH    IY
0332+  EC12 E1                              POP     HL
0333+  EC13 09                              ADD     HL, BC
0334+  EC14 30 03                           JR      NC, _retry_iy_ok
0335+  EC16 DD 34 F4                        INC     (IX+ym_loaded_high)
0336+  EC19 E5          _retry_iy_ok        PUSH    HL
0337+  EC1A FD E1                           POP     IY
0338+  EC1C                                                                     ; TODO: If we've changed the page, that needs to be restored as well
0339+  EC1C             
0340+  EC1C             
0341+  EC1C CD 5E ED    _retry_drain        CALL   _recieve_safe                ; Drain the incoming stream before sending nak
0342+  EC1F 20 FB                           JR      NZ, _retry_drain
0343+  EC21             
0344+  EC21 3E 15                           LD      A, _NAK
0345+  EC23 18 CD                           JR      _send_and_loop
0346+  EC25             
0347+  EC25             
0348+  EC25 DD E5       _header_packet      PUSH    IX
0349+  EC27 E1                              POP     HL
0350+  EC28 7E                              LD      A, (HL)                     ; Empty zeroth packet means end of batch send
0351+  EC29 A7                              AND     A
0352+  EC2A 20 09                           JR      NZ, _check_filecount
0353+  EC2C             
0354+  EC2C 3E 06                           LD      A, _ACK 
0355+  EC2E CD 89 ED                        CALL    _send_byte
0356+  EC31 3E 00                           LD      A, YMODEM_SUCCESS   
0357+  EC33 A7                              AND     A
0358+  EC34 C9                              RET
0359+  EC35             
0360+  EC35 DD 7E F0    _check_filecount    LD      A, (IX+ym_file_count)
0361+  EC38 A7                              AND     A
0362+  EC39 28 04                           JR      Z, _next_filechar
0363+  EC3B             
0364+  EC3B 3E 08                           LD      A, YMODEM_MULTI_FILES
0365+  EC3D A7                              AND     A
0366+  EC3E C9                              RET
0367+  EC3F             
0368+  EC3F 7E          _next_filechar      LD      A, (HL)
0369+  EC40 23                              INC     HL
0370+  EC41 A7          _check_char         AND     A
0371+  EC42 28 71                           JR      Z, _read_length
0372+  EC44 FE 5F                           CP      '_'                     ; Check for special transfer modes
0373+  EC46 20 F7                           JR      NZ, _next_filechar
0374+  EC48 7E                              LD      A, (HL)
0375+  EC49 4F                              LD      C, A                    ; Remember the prefix char in C
0376+  EC4A 23                              INC     HL
0377+  EC4B FE 6D                           CP      _DEST_PREFIX
0378+  EC4D 20 07                           JR      NZ, _check_flash
0379+  EC4F 06 04                           LD      B, 4
0380+  EC51 11 00 00                        LD      DE, 0
0381+  EC54 18 09                           JR      _parse_dest
0382+  EC56             
0383+  EC56 FE 70       _check_flash        CP      _PAGE_PREFIX
0384+  EC58 20 E7                           JR      NZ, _check_char
0385+  EC5A 06 02                           LD      B, 2
0386+  EC5C 11 00 00                        LD      DE, 0
0387+  EC5F             
0388+  EC5F 7E          _parse_dest         LD      A, (HL)
0389+  EC60 23                              INC     HL
0390+  EC61 D6 30                           SUB     '0'
0391+  EC63 38 48                           JR      C, _invalid_dest
0392+  EC65 FE 0A                           CP      10
0393+  EC67 38 08                           JR      C, _digit_checked
0394+  EC69 D6 07                           SUB     7
0395+  EC6B 38 40                           JR      C, _invalid_dest
0396+  EC6D FE 10                           CP      16
0397+  EC6F 30 3C                           JR      NC, _invalid_dest
0398+  EC71             
0399+  EC71 E5          _digit_checked      PUSH    HL                          ; Shift existing dest left 4 bits and merge new hex digit
0400+  EC72 62                              LD      H, D
0401+  EC73 6B                              LD      L, E
0402+  EC74 29                              ADD     HL, HL
0403+  EC75 29                              ADD     HL, HL
0404+  EC76 29                              ADD     HL, HL
0405+  EC77 29                              ADD     HL, HL
0406+  EC78 B5                              OR      L
0407+  EC79 54                              LD      D, H
0408+  EC7A 5F                              LD      E, A
0409+  EC7B E1                              POP     HL
0410+  EC7C 10 E1                           DJNZ    _parse_dest
0411+  EC7E             
0412+  EC7E 79                              LD      A, C                        ; Which char did we start with?
0413+  EC7F FE 70                           CP      _PAGE_PREFIX
0414+  EC81 20 12                           JR      NZ, _memory_dest
0415+  EC83             
0416+  EC83 DD 7E F7                        LD      A, (IX+ym_current_page)        ; Page prefix. Use original value if set when ymodem was called
0417+  EC86 FE FF                           CP      0FFh
0418+  EC88 20 B5                           JR      NZ, _next_filechar
0419+  EC8A             
0420+  EC8A DD 73 EF                        LD      (IX+ym_file_mode), E           ; Otherwise use the file specified value and load from 4000h
0421+  EC8D DD 73 F7                        LD      (IX+ym_current_page), E
0422+  EC90 11 00 40                        LD      DE,04000h    
0423+  EC93 18 10                           JR      _store_dest
0424+  EC95             
0425+  EC95 3E FF       _memory_dest        LD      A, 0FFh                     ; Only set the dest from the filename if 
0426+  EC97 DD BE F8                        CP      (IX+ym_dest_low)               ; the routine was called with a destination of 0FFFFh
0427+  EC9A 20 A3                           JR      NZ, _next_filechar
0428+  EC9C DD BE F9                        CP      (IX+ym_dest_high)
0429+  EC9F 20 9E                           JR      NZ, _next_filechar
0430+  ECA1             
0431+  ECA1 DD 36 EF FE                     LD      (IX+ym_file_mode), YM_DEST_FROM_FILE
0432+  ECA5             
0433+  ECA5 DD 73 F8    _store_dest         LD      (IX+ym_dest_low), E
0434+  ECA8 DD 72 F9                        LD      (IX+ym_dest_high), D
0435+  ECAB             
0436+  ECAB 18 92                           JR      _next_filechar
0437+  ECAD             
0438+  ECAD DD 5E F8    _invalid_dest       LD      E, (IX+ym_dest_low)            ; We silently skip invalid destination values
0439+  ECB0 DD 56 F9                        LD      D, (IX+ym_dest_high)
0440+  ECB3 18 8A                           JR      _next_filechar
0441+  ECB5             
0442+  ECB5 3E FF       _read_length        LD      A, 0FFh                     ; At this point we should have a valid destination
0443+  ECB7 DD BE F8                        CP      (IX+ym_dest_low)               
0444+  ECBA 20 09                           JR      NZ, _dest_ok
0445+  ECBC DD BE F9                        CP      (IX+ym_dest_high)
0446+  ECBF 20 04                           JR      NZ, _dest_ok
0447+  ECC1             
0448+  ECC1 3E 06                           LD      A, YMODEM_NO_DEST
0449+  ECC3 A7                              AND     A
0450+  ECC4 C9                              RET
0451+  ECC5             
0452+  ECC5 3E FF       _dest_ok            LD      A, 0FFh
0453+  ECC7 DD 77 F1                        LD      (IX+ym_length_low), A       ; Reset the length counter///
0454+  ECCA DD 77 F2                        LD      (IX+ym_length_mid), A
0455+  ECCD DD 77 F3                        LD      (IX+ym_length_high), A         
0456+  ECD0 DD 77 F4                        LD      (IX+ym_loaded_high), A
0457+  ECD3 FD 21 FF FF                     LD      IY, 0FFFFh 
0458+  ECD7 44                              LD      B, H
0459+  ECD8 4D                              LD      C, L               
0460+  ECD9 21 00 00                        LD      HL, 0
0461+  ECDC 0A                              LD      A, (BC)                     ; Length is optional
0462+  ECDD A7                              AND     A
0463+  ECDE CA F0 EB                        JP      Z, _send_ack
0464+  ECE1             
0465+  ECE1 0A          _parse_length       LD      A, (BC)
0466+  ECE2 03                              INC     BC
0467+  ECE3 A7                              AND     A
0468+  ECE4 28 2F                           JR      Z, _length_end
0469+  ECE6 FE 20                           CP      ' '
0470+  ECE8 28 2B                           JR      Z, _length_end
0471+  ECEA D6 30                           SUB     '0'
0472+  ECEC 38 39                           JR      C, _invalid_length
0473+  ECEE FE 0A                           CP      10
0474+  ECF0 30 35                           JR      NC, _invalid_length
0475+  ECF2             
0476+  ECF2 C5                              PUSH    BC
0477+  ECF3 D5                              PUSH    DE
0478+  ECF4 F5                              PUSH    AF
0479+  ECF5             
0480+  ECF5 EB                              EX      DE, HL              ; HL into DE 
0481+  ECF6 3E 0A                           LD      A, 10
0482+  ECF8             
0483+  ECF8                                 ; DE x A  -> AHL  (from http://z80-heaven.wikidot.com/advanced-math#toc12)
0484+  ECF8                                 ; preserves DE
0485+  ECF8 01 00 08                        LD      BC, 0800h
0486+  ECFB 61                              LD      H, C
0487+  ECFC 69                              LD      L, C
0488+  ECFD 29          _pl_loop            ADD     HL, HL
0489+  ECFE 17                              RLA
0490+  ECFF 30 02                           JR      NC, _pl_skip
0491+  ED01 19                              ADD     HL, DE
0492+  ED02 89                              ADC     A, C
0493+  ED03 10 F8       _pl_skip            DJNZ    _pl_loop
0494+  ED05             
0495+  ED05 DD 77 F3                        LD      (IX+ym_length_high), A     ; Note we only handle overflow for one digit.. max value 655,359?
0496+  ED08 F1                              POP     AF
0497+  ED09 5F                              LD      E, A
0498+  ED0A 51                              LD      D, C
0499+  ED0B 19                              ADD     HL, DE
0500+  ED0C 30 03                           JR      NC, _pl_length_ok
0501+  ED0E DD 34 F3                        INC     (IX+ym_length_high)
0502+  ED11             
0503+  ED11 D1          _pl_length_ok       POP     DE
0504+  ED12 C1                              POP     BC
0505+  ED13 18 CC                           JR      _parse_length
0506+  ED15             
0507+  ED15 E5          _length_end         PUSH    HL
0508+  ED16 FD E1                           POP     IY
0509+  ED18 DD 75 F1                        LD      (IX+ym_length_low), L
0510+  ED1B DD 74 F2                        LD      (IX+ym_length_mid), H
0511+  ED1E DD 7E F3                        LD      A, (IX+ym_length_high)
0512+  ED21 DD 77 F4                        LD      (IX+ym_loaded_high), A
0513+  ED24 C3 F0 EB                        JP      _send_ack
0514+  ED27             
0515+  ED27 3E 05       _invalid_length     LD      A, YMODEM_LENGTH_ERROR      ; Hard fail on invalid length data
0516+  ED29 A7                              AND     A
0517+  ED2A C9                              RET
0518+  ED2B             
0519+  ED2B             ;-----
0520+  ED2B             ; Calculate the checksum from A
0521+  ED2B E5          _calc_checksum      PUSH    HL
0522+  ED2C C5                              PUSH    BC
0523+  ED2D             
0524+  ED2D 06 01                           LD      B, 1
0525+  ED2F 4F                              LD      C, A
0526+  ED30 DD 66 FF                        LD      H, (IX+ym_crc_high)
0527+  ED33 DD 6E FE                        LD      L, (IX+ym_crc_low)
0528+  ED36             
0529+  ED36 29          _crc_loop           ADD     HL, HL
0530+  ED37 F5                              PUSH    AF
0531+  ED38             
0532+  ED38 CB 21                           SLA     C
0533+  ED3A CB 10                           RL      B
0534+  ED3C 30 02                           JR      NC, _no_in_overflow
0535+  ED3E CB C1                           SET     0, C
0536+  ED40             _no_in_overflow
0537+  ED40 CB 40                           BIT     0, B
0538+  ED42 28 01                           JR      Z, _no_in_bit
0539+  ED44 23                              INC     HL
0540+  ED45             _no_in_bit                    
0541+  ED45 F1                              POP     AF
0542+  ED46 30 08                           JR      NC, _no_crc_overflow
0543+  ED48 3E 21                           LD      A, 021h
0544+  ED4A AD                              XOR     L 
0545+  ED4B 6F                              LD      L,A
0546+  ED4C 3E 10                           LD      A, 010h
0547+  ED4E AC                              XOR     H 
0548+  ED4F 67                              LD      H, A
0549+  ED50             _no_crc_overflow
0550+  ED50 CB 41                           BIT     0, C
0551+  ED52 28 E2                           JR      Z, _crc_loop    
0552+  ED54             
0553+  ED54 DD 74 FF                        LD      (IX+ym_crc_high), H
0554+  ED57 DD 75 FE                        LD      (IX+ym_crc_low), L
0555+  ED5A C1                              POP     BC
0556+  ED5B E1                              POP     HL
0557+  ED5C C9                              RET
0558+  ED5D             
0559+  ED5D 00          _dev_null           .DB     0
0560+  ED5E             
0561+  ED5E             ;
0562+  ED5E             ; Recieve a byte with timeout, without exiting ymodem
0563+  ED5E             ; If success, A contains byte, non-zero flag set
0564+  ED5E             ; Otherwise A is zero, Zero flag is set
0565+  ED5E             ;
0566+  ED5E 21 67 ED    _recieve_safe       LD      HL, _back_safe
0567+  ED61 E5                              PUSH    HL
0568+  ED62 CD 69 ED                        CALL    _receive_byte
0569+  ED65 E1                              POP     HL
0570+  ED66 C9                              RET
0571+  ED67 AF          _back_safe          XOR     A
0572+  ED68 C9                              RET     
0573+  ED69             
0574+  ED69             ;
0575+  ED69             ; Receive a byte with timeout
0576+  ED69             ; If success: A contains byte, non-zero flag set
0577+  ED69             ; Otherwise : Pops the return address off the stack and returns to the original caller with A containing YMODEM_TIMEOUT
0578+  ED69             ;
0579+  ED69 C5          _receive_byte       PUSH    BC
0580+  ED6A 01 50 C3                        LD      BC, _TIMEOUT_COUNT
0581+  ED6D DB 25       _receive_loop       IN      A, (UART_LINE_STATUS)
0582+  ED6F CB 47                           BIT     0, A
0583+  ED71 20 12                           JR      NZ, _receive_ready
0584+  ED73 78                              LD      A, B
0585+  ED74 06 0A                           LD      B, 10
0586+  ED76 A7          _rx_delay           AND     A
0587+  ED77 10 FD                           DJNZ    _rx_delay
0588+  ED79 47                              LD      B, A
0589+  ED7A 0B                              DEC     BC
0590+  ED7B 78                              LD      A, B
0591+  ED7C B1                              OR      C
0592+  ED7D 20 EE                           JR      NZ, _receive_loop
0593+  ED7F C1                              POP     BC
0594+  ED80 C1                              POP     BC
0595+  ED81 3E 01                           LD      A, YMODEM_TIMEOUT
0596+  ED83 A7                              AND     A
0597+  ED84 C9                              RET
0598+  ED85             
0599+  ED85 DB 20       _receive_ready      IN      A, (UART_TX_RX)
0600+  ED87 C1                              POP     BC
0601+  ED88 C9                              RET
0602+  ED89             
0603+  ED89             ;
0604+  ED89             ; Send a byte with timeout
0605+  ED89             ; If success: returns normally, no registers affected
0606+  ED89             ; Otherwise : Pops the return address off the stack and returns to the original caller with A containing YMODEM_SEND_TIMEOUT
0607+  ED89             ;
0608+  ED89 C5          _send_byte          PUSH    BC
0609+  ED8A F5                              PUSH    AF
0610+  ED8B 01 50 C3                        LD      BC, _TIMEOUT_COUNT
0611+  ED8E DB 25       _send_loop          IN      A, (UART_LINE_STATUS)
0612+  ED90 CB 6F                           BIT     5, A
0613+  ED92 C2 A2 ED                        JP      NZ, _send_ready             ; Bit 5 is set when the UART is ready
0614+  ED95 0B                              DEC     BC
0615+  ED96 78                              LD      A, B
0616+  ED97 B1                              OR      C
0617+  ED98 C2 8E ED                        JP      NZ, _send_loop
0618+  ED9B             
0619+  ED9B F1                              POP     AF
0620+  ED9C C1                              POP     BC
0621+  ED9D C1                              POP     BC
0622+  ED9E             
0623+  ED9E 3E 07                           LD      A, YMODEM_SEND_TIMEOUT
0624+  EDA0 A7                              AND     A
0625+  EDA1 C9                              RET
0626+  EDA2             
0627+  EDA2 F1          _send_ready         POP     AF
0628+  EDA3 C1                              POP     BC
0629+  EDA4 D3 20                           OUT     (UART_TX_RX), A
0630+  EDA6 C9                              RET
0631+  EDA7             
0632+  EDA7                                 .MODULE main1119   EDA7             
1120   EDA7~            .IF $ >= BIOS_START
1121   EDA7~                .ECHO "End of Monitor is too high ("
1122   EDA7~                .ECHO $
1123   EDA7~                .ECHO " > "
1124   EDA7~                .ECHO BIOS_START
1125   EDA7~                .ECHO ") \n\n"
1126   EDA7~                .STOP
1127   EDA7             .ENDIF
1128   EDA7             
1129   EDA7             .ECHO "Spare after monitor "
1130   EDA7             .ECHO BIOS_START-$
1131   EDA7             .ECHO "\n\n"
1132   EDA7             
1133   EDA7 FF FF FF FF                     .FILL  BIOS_START-$
1133   EDAB FF FF FF FF 
1133   EDAF FF FF FF FF 
1133   EDB3 FF FF FF FF 
1133   EDB7 FF FF FF FF 
1133   EDBB FF FF FF FF 
1133   EDBF FF FF FF FF 
1133   EDC3 FF FF FF FF 
1133   EDC7 FF FF FF FF 
1133   EDCB FF FF FF FF 
1133   EDCF FF FF FF FF 
1133   EDD3 FF FF FF FF 
1133   EDD7 FF FF FF FF 
1133   EDDB FF FF FF FF 
1133   EDDF FF FF FF FF 
1133   EDE3 FF FF FF FF 
1133   EDE7 FF FF FF FF 
1133   EDEB FF FF FF FF 
1133   EDEF FF FF FF FF 
1133   EDF3 FF FF FF FF 
1133   EDF7 FF FF FF FF 
1133   EDFB FF FF FF FF 
1133   EDFF FF 
1134   EE00             
1135   EE00                                 .INCLUDE "bios.asm"
0001+  EE00             ;
0002+  EE00             ; Simple-ish CP/M compatible BIOS
0003+  EE00             ;
0004+  EE00             ; References - http://www.gaby.de/cpm/manuals/archive/cpm22htm/axb.htm - CPM Manual 'Simple skeletal BIOS'
0005+  EE00             ;
0006+  EE00             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0007+  EE00             ;
0008+  EE00             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0009+  EE00             ;
0010+  EE00             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0011+  EE00             ; of this software and associated documentation files (the "Software"), to deal
0012+  EE00             ; in the Software without restriction, including without limitation the rights
0013+  EE00             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0014+  EE00             ; copies of the Software, and to permit persons to whom the Software is
0015+  EE00             ; furnished to do so, subject to the following conditions:
0016+  EE00             ; 
0017+  EE00             ; The above copyright notice and this permission notice shall be included in all
0018+  EE00             ; copies or substantial portions of the Software.
0019+  EE00             ; 
0020+  EE00             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0021+  EE00             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0022+  EE00             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0023+  EE00             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0024+  EE00             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0025+  EE00             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0026+  EE00             ; SOFTWARE.
0027+  EE00             ;
0028+  EE00                                 .MODULE  main
0029+  EE00             
0030+  EE00             BIOS_START          .EQU    0EE00h
0031+  EE00             BIOS_TOP            .EQU    0FDFDh
0032+  EE00             
0033+  EE00             CCP                 .EQU    BIOS_START - 01600h
0034+  EE00             BDOS                .EQU    CCP + 0806h
0035+  EE00             
0036+  EE00             CCP_SECTOR_COUNT    .EQU    (BIOS_START-CCP)/128
0037+  EE00             
0038+  EE00~            .IF (CCP_SECTOR_COUNT * 128) < (BIOS_START-CCP)
0039+  EE00~                .ECHO "CCP isn't an exact multiple of 128 byte sectors\n"
0040+  EE00~                .ECHO "  Got "
0041+  EE00~                .ECHO (BIOS_START-CCP)
0042+  EE00~                .ECHO "\n"
0043+  EE00~                .STOP
0044+  EE00             .ENDIF
0045+  EE00             
0046+  EE00             iobyte              .EQU    03h     ; Location of Intel standard I/O definition byte
0047+  EE00             usrdrv              .EQU    04h     ; Location of Current user number and drive
0048+  EE00             tpabuf              .EQU    0080h   ; Default I/O buffer and command line storage
0049+  EE00             
0050+  EE00             IO_BAT              .EQU    02h     ; CONsole IO defined by RDR for input, LST for output
0051+  EE00             
0052+  EE00             bios_start          .ORG    BIOS_START
0053+  EE00             
0054+  EE00 C3 F1 EE                        JP      bios_boot     ;  0 Initialize
0055+  EE03 C3 08 EF    wboote              JP      bios_wboot    ;  1 Warm boot
0056+  EE06 C3 71 EF                        JP      bios_conist   ;  2 Console status - Return A = 0FFH if character ready, 00H if not
0057+  EE09 C3 9A EF                        JP      bios_conin    ;  3 Console input  - Wait for input, returning character in A
0058+  EE0C C3 00 F0                        JP      bios_conout   ;  4 Console OUTput - Write character in C to console
0059+  EE0F C3 D0 F2                        JP      bios_list     ;  5 List OUTput
0060+  EE12 C3 D2 F2                        JP      bios_punch    ;  6 punch OUTput
0061+  EE15 C3 D4 F2                        JP      bios_reader   ;  7 Reader input
0062+  EE18 C3 EE F2                        JP      bios_home     ;  8 Home disk
0063+  EE1B C3 D5 F2                        JP      bios_seldsk   ;  9 Select disk
0064+  EE1E C3 F0 F2                        JP      bios_settrk   ; 10 Select track
0065+  EE21 C3 F5 F2                        JP      bios_setsec   ; 11 Select sector
0066+  EE24 C3 FA F2                        JP      bios_setdma   ; 12 Set DMA ADDress
0067+  EE27 C3 FF F2                        JP      bios_read     ; 13 Read 128 bytes
0068+  EE2A C3 38 F3                        JP      bios_write    ; 14 Write 128 bytes
0069+  EE2D C3 A5 F3                        JP      bios_listst   ; 15 List status
0070+  EE30 C3 A7 F3                        JP      bios_sectrn   ; 16 Sector translate
0071+  EE33             
0072+  EE33             MEMDISK_SECTORS     .EQU    26
0073+  EE33             MEMDISK_TRACKS      .EQU    79
0074+  EE33             
0075+  EE33             BIOS_BOOT_TRACKS    .EQU    2
0076+  EE33             BIOS_SECTOR_ADDRESS .EQU    tpabuf
0077+  EE33             
0078+  EE33             DRIVE_A_PAGE        .EQU    04h     ; Page 4 of ROM - offset 010000h
0079+  EE33             DRIVE_B_PAGE        .EQU    24h     ; Page 4 of RAM
0080+  EE33             
0081+  EE33             ; Disk Parameter Headers -------------------------------------------------------
0082+  EE33             ; These are 256K discs, equivalent to this disc format (for cpmtools)
0083+  EE33             ; 
0084+  EE33             ; References : https://www.idealine.info/sharpmz/dpb.htm - Explanation of values
0085+  EE33             ;              https://jeelabs.org/article/1715b/        - Bootstrapping CP/M
0086+  EE33             ;
0087+  EE33             ; diskdef memotech-type50
0088+  EE33             ;  seclen 128
0089+  EE33             ;  tracks 79
0090+  EE33             ;  sectrk 26
0091+  EE33             ;  blocksize 1024
0092+  EE33             ;  maxdir 64
0093+  EE33             ;  skew 1
0094+  EE33             ;  boottrk 2
0095+  EE33             ;  os 2.2
0096+  EE33             ; end
0097+  EE33             ;
0098+  EE33             MAX_DRIVES          .EQU    2
0099+  EE33             
0100+  EE33 00 00 00 00 dpbase              .DW     0,0,0,0,dirbuf,dpb0,0,sys_alv0      ; Disk 0 is Flash
0100+  EE37 00 00 00 00 
0100+  EE3B 71 EE 53 EE 
0100+  EE3F 00 00 44 FF 
0101+  EE43 00 00 00 00                     .DW     0,0,0,0,dirbuf,dpb1,0,sys_alv1      ; Disk 1 is RAM
0101+  EE47 00 00 00 00 
0101+  EE4B 71 EE 62 EE 
0101+  EE4F 00 00 64 FF 
0102+  EE53             
0103+  EE53 1A 00       dpb0                .DW     MEMDISK_SECTORS     ; SPT - sectors per track
0104+  EE55 03                              .DB     3                   ; BSH - block shift factor  BSH+BLM together mean 1024 byte blocksize
0105+  EE56 07                              .DB     7                   ; BLM - block mask
0106+  EE57 00                              .DB     0                   ; EXM - Extent mask
0107+  EE58 F8 00                           .DW     248                 ; DSM - Storage size (blocks - 1)
0108+  EE5A 3F 00                           .DW     63                  ; DRM - Number of directory entries - 1
0109+  EE5C C0                              .DB     192                 ; AL0 - 1 bit set per directory block
0110+  EE5D 00                              .DB     0                   ; AL1 - ... 8 more bits
0111+  EE5E 00 00                           .DW     0                   ; CKS - DIR check vector size (DRM+1)/4 (0=fixed disk)
0112+  EE60 02 00                           .DW     BIOS_BOOT_TRACKS    ; OFF - Reserved tracks
0113+  EE62             
0114+  EE62 1A 00       dpb1                .DW     MEMDISK_SECTORS     ; SPT - sectors per track
0115+  EE64 03                              .DB     3                   ; BSH - block shift factor  BSH+BLM together mean 1024 byte blocksize
0116+  EE65 07                              .DB     7                   ; BLM - block mask
0117+  EE66 00                              .DB     0                   ; EXM - Extent mask
0118+  EE67 F8 00                           .DW     248                 ; DSM - Storage size (blocks - 1)
0119+  EE69 3F 00                           .DW     63                  ; DRM - Number of directory entries - 1
0120+  EE6B C0                              .DB     192                 ; AL0 - 1 bit set per directory block
0121+  EE6C 00                              .DB     0                   ; AL1 - ... 8 more bits
0122+  EE6D 00 00                           .DW     0                   ; CKS - DIR check vector size (DRM+1)/4 (0=fixed disk)
0123+  EE6F 02 00                           .DW     BIOS_BOOT_TRACKS    ; OFF - Reserved tracks
0124+  EE71             
0125+  EE71 00 00 00 00 dirbuf              .FILL   128, 0 ; disk directory scratch area
0125+  EE75 00 00 00 00 
0125+  EE79 00 00 00 00 
0125+  EE7D 00 00 00 00 
0125+  EE81 00 00 00 00 
0125+  EE85 00 00 00 00 
0125+  EE89 00 00 00 00 
0125+  EE8D 00 00 00 00 
0125+  EE91 00 00 00 00 
0125+  EE95 00 00 00 00 
0125+  EE99 00 00 00 00 
0125+  EE9D 00 00 00 00 
0125+  EEA1 00 00 00 00 
0125+  EEA5 00 00 00 00 
0125+  EEA9 00 00 00 00 
0125+  EEAD 00 00 00 00 
0125+  EEB1 00 00 00 00 
0125+  EEB5 00 00 00 00 
0125+  EEB9 00 00 00 00 
0125+  EEBD 00 00 00 00 
0125+  EEC1 00 00 00 00 
0125+  EEC5 00 00 00 00 
0125+  EEC9 00 00 00 00 
0125+  EECD 00 00 00 00 
0125+  EED1 00 00 00 00 
0125+  EED5 00 00 00 00 
0125+  EED9 00 00 00 00 
0125+  EEDD 00 00 00 00 
0125+  EEE1 00 00 00 00 
0125+  EEE5 00 00 00 00 
0125+  EEE9 00 00 00 00 
0125+  EEED 00 00 00 00 
0126+  EEF1             
0127+  EEF1             ; BIOS Entry points ---------------------------------------------------------------
0128+  EEF1             
0129+  EEF1             bios_boot     ;  0 Initialize - This is called on first boot when CCP and BIOS have all been read into memory. Initialise hardware and start CCP
0130+  EEF1 F3                              DI
0131+  EEF2 31 00 00                        LD      SP,000h
0132+  EEF5 21 00 EE                        LD      HL,BIOS_START        ; Why are we doing this?
0133+  EEF8 22 FE FF                        LD      (0FFFEh),HL
0134+  EEFB CD C2 F3                        CALL    configure_hardware
0135+  EEFE AF                              XOR     A
0136+  EEFF 32 04 00                        LD      (usrdrv),A
0137+  EF02 3C                              INC     A
0138+  EF03 32 03 00                        LD      (iobyte),A           ; Input on keyboard, output on display
0139+  EF06 18 07                           JR      start_cpm
0140+  EF08             
0141+  EF08             ;------------------------------------------------------                    
0142+  EF08             bios_wboot    ;  1 Warm boot - Hardware is intialised, but CCP should be reloaded before being run
0143+  EF08 F3                              DI
0144+  EF09 31 00 00                        LD      SP,000h
0145+  EF0C                                 ;CALL    setup_screen
0146+  EF0C CD 31 EF                        CALL    load_ccp
0147+  EF0F             
0148+  EF0F FB          start_cpm           EI                           ; Make sure interrupts are enabled
0149+  EF10 21 80 00                        LD      HL,tpabuf            ; Address of BIOS DMA buffer
0150+  EF13 22 3F FF                        LD      (sys_dmaaddr),hl
0151+  EF16 3E C3                           LD      A, 0C3h              ; Opcode for 'JP'
0152+  EF18 32 00 00                        LD      (00h),A              ; Load at start of RAM
0153+  EF1B 21 03 EE                        LD      HL,wboote            ; Address of jump for a warm boot
0154+  EF1E 22 01 00                        LD      (01h),HL
0155+  EF21 32 05 00                        LD      (05h),a              ; Opcode for 'JP'
0156+  EF24 21 06 E0                        LD      HL,BDOS              ; Address of jump for the BDOS
0157+  EF27 22 06 00                        LD      (06h),HL
0158+  EF2A 3A 04 00                        LD      A,(usrdrv)           ; Save new drive number (0)  ; TODO: Ugh? Where is this set, what does it mean???
0159+  EF2D 4F                              LD      C, A                 ; Pass drive number in C
0160+  EF2E C3 00 D8                        JP      CCP                  ; Start CP/M by jumping to the CCP
0161+  EF31             
0162+  EF31                                 ; Load CCP - Note we're doing this through BIOS calls, so if we move the OS to a different
0163+  EF31                                 ;       drive, the code should still function...
0164+  EF31 0E 00       load_ccp            LD      C, 0
0165+  EF33 CD D5 F2                        CALL    bios_seldsk
0166+  EF36 CD EE F2                        CALL    bios_home            ; Go to track 0
0167+  EF39             
0168+  EF39 06 2C                           LD      B, CCP_SECTOR_COUNT
0169+  EF3B 0E 00                           LD      C, 0                 ; Track number
0170+  EF3D 16 00                           LD      D, 0                 ; Sector to read - start with sector 0 (TODO: Check sectors are 0 based)
0171+  EF3F 21 00 D8                        LD      HL, CCP
0172+  EF42 C5          _read_ccp           PUSH    BC
0173+  EF43 D5                              PUSH    DE
0174+  EF44 E5                              PUSH    HL
0175+  EF45 4A                              LD      C, D                 ; Set the sector to read
0176+  EF46 CD F5 F2                        CALL    bios_setsec
0177+  EF49 C1                              POP     BC
0178+  EF4A C5                              PUSH    BC
0179+  EF4B CD FA F2                        CALL    bios_setdma
0180+  EF4E CD FF F2                        CALL    bios_read
0181+  EF51 A7                              AND     A                    ; Reboot if error 
0182+  EF52 20 B4                           JR      NZ, bios_wboot
0183+  EF54             
0184+  EF54 E1                              POP     HL                   ; Calculate next address to read
0185+  EF55 11 80 00                        LD      DE, 128
0186+  EF58 19                              ADD     HL, DE
0187+  EF59 D1                              POP     DE                   ; Count down the sectors
0188+  EF5A C1                              POP     BC
0189+  EF5B 05                              DEC     B
0190+  EF5C C8                              RET     Z                    ; And return if we've read 'em all
0191+  EF5D             
0192+  EF5D 14                              INC     D                    ; Otherwise, increment sector   
0193+  EF5E 7A                              LD      A, D
0194+  EF5F FE 1B                           CP      27
0195+  EF61 38 DF                           JR      C, _read_ccp
0196+  EF63             
0197+  EF63 16 01                           LD      D, 1                 ; Or, set sector back to 1 and increment track 
0198+  EF65 0C                              INC     C
0199+  EF66             
0200+  EF66 C5                              PUSH    BC
0201+  EF67 D5                              PUSH    DE
0202+  EF68 E5                              PUSH    HL
0203+  EF69 CD F0 F2                        CALL    bios_settrk
0204+  EF6C E1                              POP     HL
0205+  EF6D D1                              POP     DE
0206+  EF6E C1                              POP     BC
0207+  EF6F 18 D1                           JR      _read_ccp
0208+  EF71             
0209+  EF71             
0210+  EF71                                 
0211+  EF71             ;------------------------------------------------------  
0212+  EF71             bios_conist   ; CONSOLE STATUS, - Return A = 0FFH if character ready, 00H if not
0213+  EF71 3A 03 00                        LD      A, (iobyte)                ; Check input on CON
0214+  EF74 E6 03                           AND     03h
0215+  EF76 28 12                           JR      Z, _coninst_tty
0216+  EF78 FE 02                           CP      IO_BAT
0217+  EF7A 28 15                           JR      Z, _coninst_rdr
0218+  EF7C             
0219+  EF7C 3A 36 FF    _coninst_kbd        LD      A, (console_identify)
0220+  EF7F A7                              AND     A
0221+  EF80 20 05                           JR      NZ, _coninst_has_char
0222+  EF82             
0223+  EF82 3A 28 FF                        LD      A, (input_size)
0224+  EF85 A7                              AND     A
0225+  EF86 C8                              RET     Z
0226+  EF87 3E FF       _coninst_has_char   LD      A, 0FFh
0227+  EF89 C9                              RET
0228+  EF8A              
0229+  EF8A AF          _coninst_tty        XOR     A
0230+  EF8B CD 57 F8                        CALL    uart_ready
0231+  EF8E D0                              RET     NC
0232+  EF8F 3D                              DEC     A
0233+  EF90 C9                              RET     
0234+  EF91 3A 03 00    _coninst_rdr        LD      A, (iobyte)                 ; Input is determined by RDR
0235+  EF94 E6 0C                           AND     0Ch
0236+  EF96 28 F2                           JR      Z, _coninst_tty
0237+  EF98 18 E2                           JR      _coninst_kbd
0238+  EF9A             
0239+  EF9A             ;------------------------------------------------------  
0240+  EF9A             bios_conin    ;  3 Console input - Wait for input, returning character in A
0241+  EF9A 3A 03 00                        LD      A, (iobyte)
0242+  EF9D E6 03                           AND     03h
0243+  EF9F 28 17                           JR      Z, _conin_tty
0244+  EFA1 FE 02                           CP      02h
0245+  EFA3 28 19                           JR      Z, _conin_rdr
0246+  EFA5                                 
0247+  EFA5 3A 36 FF    _conin_kbd          LD      A, (console_identify)           ; If the terminal has been sent an identity request escape sequence, return the response
0248+  EFA8 3D                              DEC     A
0249+  EFA9 FA C7 EF                        JP      M, _conin_read_char
0250+  EFAC 32 36 FF                        LD      (console_identify), A
0251+  EFAF 21 FD EF                        LD      HL, _indentity_sequence
0252+  EFB2 4F                              LD      C, A
0253+  EFB3 06 00                           LD      B, 0
0254+  EFB5 09                              ADD     HL, BC
0255+  EFB6 7E                              LD      A, (HL) 
0256+  EFB7 C9                              RET        
0257+  EFB8             
0258+  EFB8 CD 66 F8    _conin_tty          CALL    uart_receive
0259+  EFBB D8                              RET     C
0260+  EFBC 18 FA                           JR      _conin_tty
0261+  EFBE                  
0262+  EFBE 3A 03 00    _conin_rdr          LD      A, (iobyte)
0263+  EFC1 E6 0C                           AND     0ch
0264+  EFC3 28 F3                           JR      Z, _conin_tty
0265+  EFC5 18 DE                           JR      _conin_kbd
0266+  EFC7             
0267+  EFC7 3A 28 FF    _conin_read_char    LD      A, (input_size)                 ; Don't blink cursor if there is a character already waiting..
0268+  EFCA A7                              AND     A
0269+  EFCB 28 03                           JR      Z, _conin_wait
0270+  EFCD C3 2A F7                        JP      get_key
0271+  EFD0             
0272+  EFD0 3A 32 FF    _conin_wait         LD      A, (console_flags)              ; Turn the cursor on..
0273+  EFD3 F6 01                           OR      CFLAGS_SHOW_CURSOR
0274+  EFD5 32 32 FF                        LD      (console_flags), A
0275+  EFD8 F3                              DI
0276+  EFD9 ED 5B 2D FF                     LD      DE, (cursor_row)
0277+  EFDD 7A                              LD      A, D                            ; Force cursor update...
0278+  EFDE 3D                              DEC     A
0279+  EFDF 32 2E FF                        LD      (cursor_col),A
0280+  EFE2 CD 04 F1                        CALL    _conout_csr_update
0281+  EFE5 FB                              EI
0282+  EFE6 CD 2A F7                        CALL    get_key
0283+  EFE9 47                              LD      B, A
0284+  EFEA 3A 32 FF                        LD      A, (console_flags)
0285+  EFED E6 FE                           AND     ~CFLAGS_SHOW_CURSOR
0286+  EFEF 32 32 FF                        LD      (console_flags), A
0287+  EFF2                                 ;
0288+  EFF2 C5                              PUSH    BC
0289+  EFF3 1E 00                           LD      E, 0
0290+  EFF5 F3                              DI
0291+  EFF6 CD 80 F5                        CALL    update_cursor
0292+  EFF9 FB                              EI
0293+  EFFA C1                              POP     BC
0294+  EFFB 78                              LD      A, B
0295+  EFFC C9                              RET
0296+  EFFD                  
0297+  EFFD 4B 2F 1B    _indentity_sequence .DB     'K', '/', ESCAPE_CHAR           ; RETURNED BY VT-52 emulation - note sequence is reversed
0298+  F000             IDENTITY_LENGTH     .EQU    3
0299+  F000             
0300+  F000             ;------------------------------------------------------  
0301+  F000             bios_conout   ;  4 Console OUTput  - Write character in C to console
0302+  F000 3A 03 00                        LD      A, (iobyte)
0303+  F003 E6 03                           AND     03h
0304+  F005 FE 02                           CP      IO_BAT
0305+  F007 20 0B                           JR      NZ, _conout_disp_tty
0306+  F009             
0307+  F009 3A 03 00                        LD      A, (iobyte)
0308+  F00C E6 C0                           AND     0C0h
0309+  F00E 20 08                           JR      NZ, _conout_disp 
0310+  F010 79                              LD      A, C
0311+  F011 C3 3A F8                        JP      uart_send
0312+  F014             
0313+  F014 79          _conout_disp_tty    LD      A, C
0314+  F015 CD 3A F8                        CALL    uart_send
0315+  F018             
0316+  F018 3A 34 FF    _conout_disp        LD      A, (console_escape)             ; Test to see if handling an escape sequence and expect more parameters
0317+  F01B B7                              OR      A
0318+  F01C C2 B5 F0                        JP      NZ, _conout_escape_seq
0319+  F01F             
0320+  F01F 3A 32 FF                        LD      A, (console_flags)              ; Test to see if we're expecting an escape character
0321+  F022 E6 08                           AND     CFLAGS_ESCAPE
0322+  F024 28 7C                           JR      Z, _conout_check_esc
0323+  F026             
0324+  F026                                                                         ; If so, this is the first character after we got an escape...
0325+  F026 ED 5B 2D FF                     LD      DE, (cursor_row)                ; Get cursor position in DE
0326+  F02A 3A 32 FF                        LD      A,(console_flags)               ; Reset the escape flag
0327+  F02D E6 F7                           AND     ~CFLAGS_ESCAPE
0328+  F02F 32 32 FF                        LD      (console_flags),A
0329+  F032             
0330+  F032 79                              LD      A, C
0331+  F033             
0332+  F033 FE 41                           CP      'A'
0333+  F035 20 04                           JR      NZ, _conout_not_up
0334+  F037 1D                              DEC     E
0335+  F038 C3 04 F1                        JP      _conout_csr_update
0336+  F03B             
0337+  F03B FE 42       _conout_not_up      CP      'B'
0338+  F03D 20 04                           JR      NZ, _conout_not_down
0339+  F03F 1C                              INC     E
0340+  F040 C3 04 F1                        JP      _conout_csr_update
0341+  F043             
0342+  F043 FE 43       _conout_not_down    CP      'C'
0343+  F045 20 09                           JR      NZ, _conout_not_right
0344+  F047 3A 30 FF                        LD      A, (console_width)
0345+  F04A BA                              CP      D
0346+  F04B C8                              RET     Z                           
0347+  F04C 14                              INC     D
0348+  F04D C3 04 F1                        JP      _conout_csr_update
0349+  F050             
0350+  F050 FE 44       _conout_not_right   CP      'D'
0351+  F052 20 05                           JR      NZ, _conout_not_left
0352+  F054 15                              DEC     D
0353+  F055 C8                              RET     Z
0354+  F056 C3 04 F1                        JP      _conout_csr_update
0355+  F059             
0356+  F059 FE 46       _conout_not_left    CP      'F'                         ; Enter graphics mode.. not supported
0357+  F05B C8                              RET     Z
0358+  F05C             
0359+  F05C FE 47                           CP      'G'                         ; Exit graphics mode
0360+  F05E C8                              RET     Z
0361+  F05F             
0362+  F05F FE 48                           CP      'H'
0363+  F061 20 06                           JR      NZ, _conout_not_home
0364+  F063 11 01 01                        LD      DE, 0101h
0365+  F066 C3 04 F1                        JP      _conout_csr_update
0366+  F069             
0367+  F069 FE 49       _conout_not_home    CP      'I'                         ; Reverse line feed. Insert line above and move cursor up. Not supported
0368+  F06B C8                              RET     Z                    
0369+  F06C             
0370+  F06C FE 4A                           CP      'J'
0371+  F06E 20 01                           JR      NZ, _conout_not_clr_sc
0372+  F070             
0373+  F070                                 ; TODO... Clear to end of screen
0374+  F070 C9                              RET
0375+  F071             
0376+  F071 FE 4B       _conout_not_clr_sc  CP      'K'
0377+  F073 20 0E                           JR      NZ, _conout_not_clr_ln
0378+  F075             
0379+  F075 ED 4B 2D FF                     LD      BC, (cursor_row)
0380+  F079 05                              DEC     B
0381+  F07A 79                              LD      A, C
0382+  F07B 3D                              DEC     A
0383+  F07C 48                              LD      C, B
0384+  F07D CD AC F2                        CALL   clear_screen_row
0385+  F080 C3 8E F1                        JP     _redraw_buffer
0386+  F083             
0387+  F083 FE 59       _conout_not_clr_ln  CP      'Y'
0388+  F085 20 08                           JR      NZ, _conout_not_pos
0389+  F087             
0390+  F087 32 34 FF    _conout_start_esc   LD      (console_escape), A         ; Start an escape sequence
0391+  F08A AF                              XOR     A
0392+  F08B 32 35 FF                        LD      (console_param1), A
0393+  F08E C9                              RET
0394+  F08F             
0395+  F08F FE 5A       _conout_not_pos     CP      'Z'
0396+  F091 20 06                           JR      NZ, _conout_not_ident
0397+  F093 3E 03                           LD      A, IDENTITY_LENGTH
0398+  F095 32 36 FF                        LD      (console_identify), A
0399+  F098 C9                              RET
0400+  F099             
0401+  F099 FE 62       _conout_not_ident   CP      'b'
0402+  F09B 28 EA                           JR      Z, _conout_start_esc
0403+  F09D FE 63                           CP      'c'
0404+  F09F 28 E6                           JR      Z, _conout_start_esc
0405+  F0A1             
0406+  F0A1                                 ; TODO: Any addtional escape sequences here...
0407+  F0A1 C9                              RET
0408+  F0A2             
0409+  F0A2 79          _conout_check_esc   LD      A, C                    
0410+  F0A3 FE 1B                           CP      ESCAPE_CHAR
0411+  F0A5 C2 55 F2                        JP      NZ, _conout_character
0412+  F0A8             
0413+  F0A8 3A 32 FF                        LD      A, (console_flags)
0414+  F0AB F6 08                           OR      CFLAGS_ESCAPE
0415+  F0AD 32 32 FF                        LD      (console_flags), A
0416+  F0B0 AF                              XOR     A
0417+  F0B1 32 34 FF                        LD      (console_escape),A
0418+  F0B4 C9                              RET
0419+  F0B5             
0420+  F0B5 3A 34 FF    _conout_escape_seq  LD      A,(console_escape)
0421+  F0B8 FE 59                           CP      'Y'
0422+  F0BA 28 0D                           JR      Z, _conout_esc_pos
0423+  F0BC FE 62                           CP      'b'
0424+  F0BE 28 20                           JR      Z, _conout_esc_foreg
0425+  F0C0 FE 63                           CP      'c'
0426+  F0C2 28 2D                           JR      Z, _conout_esc_backg
0427+  F0C4             
0428+  F0C4                                 ; All unknown sequences reset the escape sequence
0429+  F0C4 AF          _conout_reset_seq   XOR     A
0430+  F0C5 32 34 FF                        LD      (console_escape),A
0431+  F0C8 C9                              RET
0432+  F0C9             
0433+  F0C9 3A 35 FF    _conout_esc_pos     LD      A, (console_param1)
0434+  F0CC A7                              AND     A
0435+  F0CD 20 05                           JR      NZ, _conout_pos_param
0436+  F0CF 79                              LD      A, C
0437+  F0D0 32 35 FF                        LD      (console_param1),A
0438+  F0D3 C9                              RET
0439+  F0D4             
0440+  F0D4 D6 1F       _conout_pos_param   SUB     31
0441+  F0D6 5F                              LD      E, A
0442+  F0D7 79                              LD      A, C
0443+  F0D8 D6 1F                           SUB     31
0444+  F0DA 57                              LD      D, A
0445+  F0DB CD C4 F0                        CALL    _conout_reset_seq
0446+  F0DE 18 24                           JR      _conout_csr_update
0447+  F0E0             
0448+  F0E0 3A 31 FF    _conout_esc_foreg   LD      A, (console_colour)
0449+  F0E3 E6 F0                           AND     0F0h
0450+  F0E5 47                              LD      B, A
0451+  F0E6 79                              LD      A, C
0452+  F0E7 D6 1F                           SUB     31
0453+  F0E9 E6 0F                           AND     0Fh
0454+  F0EB B0          _conout_set_colour  OR      B
0455+  F0EC 32 31 FF                        LD      (console_colour), A
0456+  F0EF 18 D3                           JR      _conout_reset_seq
0457+  F0F1             
0458+  F0F1 3A 31 FF    _conout_esc_backg   LD      A, (console_colour)
0459+  F0F4 E6 0F                           AND     0Fh
0460+  F0F6 47                              LD      B, A
0461+  F0F7 79                              LD      A, C
0462+  F0F8 D6 1F                           SUB     31
0463+  F0FA CB 27                           SLA     A
0464+  F0FC CB 27                           SLA     A
0465+  F0FE CB 27                           SLA     A
0466+  F100 CB 27                           SLA     A
0467+  F102 18 E7                           JR      _conout_set_colour
0468+  F104             
0469+  F104             ; Cursor position has changed, check if we need to update the whole display.
0470+  F104             ; This is entered with DE as D = new cursor column, E = new cursor row
0471+  F104             ;         Writes new cursor poition to (cursor_row, cursor_column)
0472+  F104             ;         Returns HL = updated display column, row to track the cursor position..
0473+  F104             ; Assume column is always within range, row may be before start/after end of visible screen
0474+  F104             ;
0475+  F104 2A 2B FF    _conout_csr_update  LD      HL, (display_row)           ; HL = current display column, row..
0476+  F107 ED 4B 2D FF                     LD      BC, (cursor_row)            ; BC = old values of cursor column, row
0477+  F10B 7B                              LD      A, E                        
0478+  F10C B9                              CP      C
0479+  F10D 32 2D FF                        LD      (cursor_row), A
0480+  F110 20 09                           JR      NZ, _conout_check_row       ; If cursor row has changed, we must update display_row and optionally screen_offset
0481+  F112             
0482+  F112 7A          _conout_track_col   LD      A, D
0483+  F113 B8                              CP      B
0484+  F114 32 2E FF                        LD      (cursor_col), A
0485+  F117 20 19                           JR      NZ, _conout_check_col       ; If only column has changed, we may update display_col..
0486+  F119 18 73                           JR      _redraw_buffer              ; Otherwise, nothing has changed. Make sure display is up to date
0487+  F11B             
0488+  F11B A7          _conout_check_row   AND     A                           
0489+  F11C 20 05                           JR      NZ, _conout_chk_bottom         
0490+  F11E 3C                              INC     A                           ; We're above the screen, fix the cursor_row but set L (display row) to -1 
0491+  F11F 32 2D FF                        LD      (cursor_row), A
0492+  F122             
0493+  F122 AF                              XOR     A
0494+  F123             
0495+  F123 3D          _conout_chk_bottom  DEC     A
0496+  F124 6F                              LD      L, A                        ; Update the display row in HL which will force refresh
0497+  F125 3A 2F FF                        LD      A, (console_height)
0498+  F128 BD                              CP      L
0499+  F129 20 03                           JR      NZ, _conout_not_bottom
0500+  F12B             
0501+  F12B 32 2D FF                        LD      (cursor_row), A
0502+  F12E             
0503+  F12E 7A          _conout_not_bottom  LD      A, D                        ; Write col here since it wasn't previously set...
0504+  F12F 32 2E FF                        LD      (cursor_col), A
0505+  F132             
0506+  F132 7C          _conout_check_col   LD      A, H                        ; Current display col
0507+  F133 3C                              INC     A
0508+  F134 92                              SUB     D                           ; Subtract new cursor col
0509+  F135 30 18                           JR      NC, _conout_scroll_l        ; Cursor col is before beginning of screen
0510+  F137             
0511+  F137 3A 32 FF                        LD      A, (console_flags)
0512+  F13A E6 01                           AND     CFLAGS_SHOW_CURSOR
0513+  F13C 3E 01                           LD      A, 1
0514+  F13E 28 01                           JR      Z, _conout_keep_left
0515+  F140 3D                              DEC     A
0516+  F141 C6 18       _conout_keep_left   ADD     A, DISPLAY_WIDTH          
0517+  F143 47                              LD      B, A
0518+  F144 84                              ADD     A, H                        ; Right hand edge of display...
0519+  F145 BA                              CP      D
0520+  F146 30 0A                           JR      NC, _conout_refresh
0521+  F148             
0522+  F148 7A                              LD      A, D                        ; Cursor col is after end of screen
0523+  F149 90                              SUB     B
0524+  F14A 30 05                           JR      NC, _conout_scroll_done
0525+  F14C AF                              XOR     A
0526+  F14D 18 02                           JR      _conout_scroll_done
0527+  F14F             
0528+  F14F 7A          _conout_scroll_l    LD      A, D
0529+  F150 3D                              DEC     A
0530+  F151 67          _conout_scroll_done LD      H, A
0531+  F152             
0532+  F152             
0533+  F152             ; We enter with HL = new display column, row
0534+  F152             ; At this point one or both of display row or column may changed, so update the whole display...   
0535+  F152             ; If row is -1, we're before the beginning of the screen - need to scroll up
0536+  F152             ; And if row > console_height, we need to scroll down.. Display row stays constant, but screen_offset changes..
0537+  F152             
0538+  F152             ; Do scroll first, then only change display row/col if console_flags is set to track cursor..
0539+  F152             ; If display row/col have changed, compare screen buffer with display buffer and update whichever characters/brightnesses have changed..
0540+  F152             ;
0541+  F152             ; 
0542+  F152             _conout_refresh     
0543+  F152 7D                              LD      A, L
0544+  F153 B7                              OR      A
0545+  F154 F2 6B F1                        JP      P, _conout_row_postv
0546+  F157             
0547+  F157                                 ; Display row negative
0548+  F157 AF                              XOR     A
0549+  F158 6F                              LD      L, A                        ; Reset display row to zero
0550+  F159 3A 2A FF                        LD      A, (screen_offset)
0551+  F15C 3D                              DEC     A
0552+  F15D E6 3F                           AND     03Fh
0553+  F15F 32 2A FF                        LD      (screen_offset), A
0554+  F162 E5                              PUSH    HL
0555+  F163 0E 00                           LD      C, 0
0556+  F165 CD AC F2                        CALL    clear_screen_row
0557+  F168 E1                              POP     HL
0558+  F169 18 19                           JR      _conout_update_display
0559+  F16B             
0560+  F16B 3A 2F FF    _conout_row_postv   LD      A, (console_height)
0561+  F16E 4F                              LD      C, A                        ; Remember for later on
0562+  F16F BD                              CP      L
0563+  F170 20 12                           JR      NZ, _conout_update_display
0564+  F172             
0565+  F172                                 ; display row below screen
0566+  F172 3A 2A FF                        LD      A, (screen_offset)
0567+  F175 3C                              INC     A
0568+  F176 E6 3F                           AND     03Fh
0569+  F178 32 2A FF                        LD      (screen_offset), A
0570+  F17B 79                              LD      A, C
0571+  F17C E5                              PUSH    HL
0572+  F17D 0E 00                           LD      C, 0
0573+  F17F CD AC F2                        CALL    clear_screen_row
0574+  F182 E1                              POP     HL 
0575+  F183 2D                              DEC     L
0576+  F184             
0577+  F184             _conout_update_display
0578+  F184                                 ; We've scrolled if necessary, update the display row if required..
0579+  F184 3A 32 FF                        LD      A, (console_flags)
0580+  F187 E6 02                           AND     CFLAGS_TRACK_CURSOR         
0581+  F189 28 03                           JR      Z, _redraw_buffer
0582+  F18B 22 2B FF                        LD      (display_row), HL           ; Only move display row if we're tracking the cursor
0583+  F18E             
0584+  F18E F3          _redraw_buffer      DI
0585+  F18F CD 94 F1                        CALL    unsafe_redraw
0586+  F192 FB                              EI
0587+  F193 C9                              RET
0588+  F194             
0589+  F194             ;----------------------------------------------------------------------------------------------------
0590+  F194             ; Note that this uses Mem Page 1
0591+  F194             ;
0592+  F194 2A 2B FF    unsafe_redraw       LD      HL, (display_row)       ; Calculate our screen source in DE
0593+  F197 3A 2A FF                        LD      A, (screen_offset)      
0594+  F19A 85                              ADD     A, L
0595+  F19B             
0596+  F19B E6 3F                           AND     03Fh
0597+  F19D F6 40                           OR      040h                    ; We're going to use page 1 for the screen buffer
0598+  F19F 57                              LD      D, A
0599+  F1A0 7C                              LD      A, H
0600+  F1A1 CB 27                           SLA     A
0601+  F1A3 5F                              LD      E, A
0602+  F1A4             
0603+  F1A4 21 84 FF                        LD      HL, display_buffer
0604+  F1A7 06 18                           LD      B, DISPLAY_WIDTH
0605+  F1A9 0E 00                           LD      C, 0
0606+  F1AB             
0607+  F1AB 3A 32 FF                        LD      A, (console_flags)      ; Don't draw last character if we've moved
0608+  F1AE E6 04                           AND     CFLAGS_SHOW_MOVED
0609+  F1B0 28 01                           JR      Z, _full_redraw
0610+  F1B2 05                              DEC     B
0611+  F1B3             
0612+  F1B3 3A 29 FF    _full_redraw        LD      A, (screen_page)
0613+  F1B6 D3 71                           OUT     (IO_MEM_1), A
0614+  F1B8             
0615+  F1B8 1A          _redraw_loop        LD      A, (DE)
0616+  F1B9 BE                              CP      (HL)
0617+  F1BA 28 0A                           JR      Z, _redraw_skip_char
0618+  F1BC 77                              LD      (HL), A
0619+  F1BD C5                              PUSH    BC
0620+  F1BE E5                              PUSH    HL
0621+  F1BF D5                              PUSH    DE
0622+  F1C0 CD E9 FA                        CALL    disp_character
0623+  F1C3 D1                              POP     DE
0624+  F1C4 E1                              POP     HL
0625+  F1C5 C1                              POP     BC
0626+  F1C6             
0627+  F1C6 23          _redraw_skip_char   INC     HL
0628+  F1C7 13                              INC     DE
0629+  F1C8             
0630+  F1C8 3A 32 FF                        LD      A, (console_flags)
0631+  F1CB E6 04                           AND     CFLAGS_SHOW_MOVED
0632+  F1CD 1A                              LD      A, (DE)  
0633+  F1CE 28 05                           JR      Z, _redraw_normal
0634+  F1D0             
0635+  F1D0 CB 3F                           SRL     A
0636+  F1D2 CB 3F                           SRL     A
0637+  F1D4 3C                              INC     A
0638+  F1D5             
0639+  F1D5 BE          _redraw_normal      CP      (HL)
0640+  F1D6 28 12                           JR      Z, _redraw_skip_bri
0641+  F1D8 77                              LD      (HL), A
0642+  F1D9 C5                              PUSH    BC
0643+  F1DA E5                              PUSH    HL
0644+  F1DB D5                              PUSH    DE
0645+  F1DC 79                              LD      A, C                    ; Ugh... disp_char_bright has parameters in other order..
0646+  F1DD 4E                              LD      C, (HL)
0647+  F1DE CB 21                           SLA     C
0648+  F1E0 CB 21                           SLA     C
0649+  F1E2 CB 21                           SLA     C
0650+  F1E4 CD AB FA                        CALL    disp_char_bright    ; Column A, brightness C
0651+  F1E7 D1                              POP     DE
0652+  F1E8 E1                              POP     HL
0653+  F1E9 C1                              POP     BC
0654+  F1EA             
0655+  F1EA 23          _redraw_skip_bri    INC     HL
0656+  F1EB 13                              INC     DE
0657+  F1EC 0C                              INC     C
0658+  F1ED 10 C9                           DJNZ    _redraw_loop
0659+  F1EF             
0660+  F1EF 3A 32 FF                        LD      A, (console_flags)
0661+  F1F2 4F                              LD      C, A
0662+  F1F3 E6 04                           AND     CFLAGS_SHOW_MOVED
0663+  F1F5 28 53                           JR      Z, _redraw_done
0664+  F1F7             
0665+  F1F7                                 ; We've moved the cursor, so draw the last character as our location bitmap..
0666+  F1F7 36 00       _redraw_moved       LD      (HL), 0
0667+  F1F9 23                              INC     HL
0668+  F1FA 36 80                           LD      (HL), DISP_DEFAULT_BRIGHTNESS
0669+  F1FC 79                              LD      A, C
0670+  F1FD E6 02                           AND     CFLAGS_TRACK_CURSOR
0671+  F1FF 20 4F                           JR      NZ, _redraw_tracking
0672+  F201             
0673+  F201 21 00 00                        LD      HL, 0
0674+  F204 ED 4B 2D FF                     LD      BC, (cursor_row)
0675+  F208 0D                              DEC     C
0676+  F209                                 
0677+  F209 ED 5B 2B FF                     LD      DE, (display_row)
0678+  F20D 7B                              LD      A, E
0679+  F20E A7                              AND     A
0680+  F20F 20 05                           JR      NZ, _redraw_not_top
0681+  F211 21 01 00                        LD      HL, MOVE_TOP_BITMAP
0682+  F214 18 0A                           JR      _redraw_not_bottom
0683+  F216             
0684+  F216 3A 2F FF    _redraw_not_top     LD      A, (console_height)
0685+  F219 3D                              DEC     A
0686+  F21A BB                              CP      E
0687+  F21B 20 03                           JR      NZ, _redraw_not_bottom
0688+  F21D 21 08 00                        LD      HL, MOVE_BOTTOM_BITMAP
0689+  F220             
0690+  F220 7B          _redraw_not_bottom  LD      A, E
0691+  F221 B9                              CP      C
0692+  F222 01 00 00                        LD      BC, 0
0693+  F225 20 04                           JR      NZ, _redraw_not_row
0694+  F227 0E C0                           LD      C, MOVE_ROW_BITMAP_L
0695+  F229 18 08                           JR      _redraw_map
0696+  F22B             
0697+  F22B 06 28       _redraw_not_row     LD      B, MOVE_BELOW_BITMAP_H
0698+  F22D 38 02                           JR      C, _redraw_not_above
0699+  F22F 18 02                           JR      _redraw_map
0700+  F231             
0701+  F231 06 05       _redraw_not_above   LD      B, MOVE_ABOVE_BITMAP_H
0702+  F233             
0703+  F233 09          _redraw_map         ADD     HL, BC
0704+  F234 3A 2C FF                        LD      A, (display_col)
0705+  F237 A7                              AND     A
0706+  F238 20 04                           JR      NZ, _redraw_map2
0707+  F23A 3E 30                           LD      A, MOVE_AT_LEFT_BITMAP
0708+  F23C B5                              OR      L
0709+  F23D 6F                              LD      L, A
0710+  F23E 3E 17       _redraw_map2        LD      A, DISPLAY_WIDTH-1
0711+  F240 CD 0A FB                        CALL    disp_bitmask
0712+  F243             
0713+  F243 3E 17                           LD      A, DISPLAY_WIDTH-1
0714+  F245 0E 80                           LD      C, DISP_DEFAULT_BRIGHTNESS
0715+  F247 CD AB FA                        CALL    disp_char_bright
0716+  F24A             
0717+  F24A 3A 3A FF    _redraw_done        LD      A, (page_1_mapping)
0718+  F24D D3 71                           OUT     (IO_MEM_1), A
0719+  F24F C9                              RET
0720+  F250             
0721+  F250 21 3F 2D    _redraw_tracking    LD      HL, 2d3fh          ; Tracking symbol
0722+  F253 18 E9                           JR      _redraw_map2
0723+  F255             
0724+  F255             MOVE_TOP_BITMAP     .EQU    0001h
0725+  F255             MOVE_BOTTOM_BITMAP  .EQU    0008h
0726+  F255             MOVE_ROW_BITMAP_L   .EQU    0c0h
0727+  F255             MOVE_ABOVE_BITMAP_H .EQU    05h
0728+  F255             MOVE_BELOW_BITMAP_H .EQU    28h
0729+  F255             MOVE_AT_LEFT_BITMAP .EQU    030h
0730+  F255             
0731+  F255             ;---------------------------------------- Simple character output.. 
0732+  F255 ED 5B 2D FF _conout_character   LD      DE, (cursor_row)
0733+  F259 FE 0D                           CP      CARRIAGE_RETURN
0734+  F25B 20 05                           JR      NZ, _conout_not_cr
0735+  F25D                
0736+  F25D 16 01                           LD      D, 1
0737+  F25F C3 04 F1                        JP      _conout_csr_update
0738+  F262             
0739+  F262 FE 0A       _conout_not_cr      CP      NEWLINE
0740+  F264 20 04                           JR      NZ, _conout_not_lf
0741+  F266             
0742+  F266 1C                              INC     E
0743+  F267 C3 04 F1                        JP      _conout_csr_update
0744+  F26A             
0745+  F26A FE 08       _conout_not_lf      CP      BACKSPACE_CHAR
0746+  F26C 20 05                           JR      NZ, _conout_visible
0747+  F26E             
0748+  F26E 15                              DEC     D
0749+  F26F C2 04 F1                        JP      NZ, _conout_csr_update
0750+  F272 C9                              RET
0751+  F273             
0752+  F273                                 ; Now, C is character to write,
0753+  F273 ED 5B 2D FF _conout_visible     LD      DE, (cursor_row)
0754+  F277 15                              DEC     D                       ; 1 based col
0755+  F278 1D                              DEC     E                       ; 1 based row
0756+  F279             
0757+  F279 3A 2A FF                        LD      A, (screen_offset)      ; Write the character and colour into our screen buffer
0758+  F27C 83                              ADD     A, E
0759+  F27D             
0760+  F27D E6 3F                           AND     03Fh
0761+  F27F F6 40                           OR      040h                    ; We're going to use page 1 for the screen buffer
0762+  F281 67                              LD      H, A
0763+  F282 7A                              LD      A, D
0764+  F283 CB 27                           SLA     A
0765+  F285 6F                              LD      L, A
0766+  F286 3A 29 FF                        LD      A, (screen_page)
0767+  F289 D3 71                           OUT     (IO_MEM_1), A
0768+  F28B 71                              LD      (HL), C
0769+  F28C 3A 31 FF                        LD      A, (console_colour)
0770+  F28F 23                              INC     HL
0771+  F290 77                              LD      (HL), A
0772+  F291 3A 3A FF                        LD      A, (page_1_mapping)
0773+  F294 D3 71                           OUT     (IO_MEM_1), A
0774+  F296             
0775+  F296 ED 5B 2D FF                     LD      DE, (cursor_row)
0776+  F29A 3A 30 FF                        LD      A, (console_width)
0777+  F29D 6F                              LD      L, A
0778+  F29E 7A                              LD      A, D
0779+  F29F BD                              CP      L
0780+  F2A0 28 04                           JR      Z, _conout_wrap
0781+  F2A2 14                              INC     D
0782+  F2A3 C3 04 F1                        JP      _conout_csr_update
0783+  F2A6             
0784+  F2A6 16 01       _conout_wrap        LD      D, 1
0785+  F2A8 1C                              INC     E
0786+  F2A9 C3 04 F1                        JP      _conout_csr_update          ; If we've wrapped, use the new wrap position..
0787+  F2AC             ;
0788+  F2AC             ;
0789+  F2AC             ; Fill the row of the screen buffer with space chars..
0790+  F2AC             ; Enter with A -> row of screen buffer, C -> start column
0791+  F2AC             ;          Uses HL, C
0792+  F2AC             ;
0793+  F2AC 67          clear_screen_row    LD      H, A
0794+  F2AD 3A 2A FF                        LD      A, (screen_offset)
0795+  F2B0 84                              ADD     A, H
0796+  F2B1             
0797+  F2B1 E6 3F                           AND    03Fh
0798+  F2B3 F6 40                           OR     040h
0799+  F2B5 67                              LD     H, A
0800+  F2B6 79                              LD     A, C
0801+  F2B7 81                              ADD    A, C
0802+  F2B8 6F                              LD     L, A
0803+  F2B9             
0804+  F2B9 3A 31 FF                        LD      A, (console_colour)
0805+  F2BC 4F                              LD      C, A
0806+  F2BD             
0807+  F2BD 3A 29 FF                        LD      A, (screen_page)
0808+  F2C0 D3 71                           OUT     (IO_MEM_1), A
0809+  F2C2             
0810+  F2C2 3E 20                           LD      A, ' '
0811+  F2C4 77          _clear_loop         LD      (HL), A
0812+  F2C5 2C                              INC     L
0813+  F2C6 71                              LD      (HL), C
0814+  F2C7 2C                              INC     L
0815+  F2C8 20 FA                           JR      NZ, _clear_loop
0816+  F2CA             
0817+  F2CA 3A 3A FF                        LD      A, (page_1_mapping)
0818+  F2CD D3 71                           OUT     (IO_MEM_1), A
0819+  F2CF C9                              RET
0820+  F2D0             ;------------------------------------------------------  
0821+  F2D0             bios_list     ;  5 List OUTput
0822+  F2D0 AF                              XOR     A
0823+  F2D1 C9                              RET
0824+  F2D2                                 
0825+  F2D2             ;------------------------------------------------------  
0826+  F2D2             bios_punch    ;  6 punch OUTput
0827+  F2D2 AF                              XOR     A
0828+  F2D3 C9                              RET
0829+  F2D4                                 
0830+  F2D4             ;------------------------------------------------------  
0831+  F2D4             bios_reader   ;  7 Reader input
0832+  F2D4 C9                              RET
0833+  F2D5                                 
0834+  F2D5             
0835+  F2D5                                 
0836+  F2D5             ;------------------------------------------------------  
0837+  F2D5             bios_seldsk   ;  9 Select disk - Select disc in C, returns HL =  address of DPH, or 0 if error
0838+  F2D5                                 ; Store C in A, Check drive is in range
0839+  F2D5 79                              LD      A, C
0840+  F2D6 21 00 00                        LD      HL, 0
0841+  F2D9 FE 02                           CP      MAX_DRIVES
0842+  F2DB D0                              RET     NC
0843+  F2DC             
0844+  F2DC 06 00                           LD      B, 0
0845+  F2DE CB 21                           SLA     C
0846+  F2E0 CB 21                           SLA     C
0847+  F2E2 CB 21                           SLA     C
0848+  F2E4 CB 21                           SLA     C
0849+  F2E6 21 33 EE                        LD      HL, dpbase
0850+  F2E9 09                              ADD     HL, BC
0851+  F2EA 32 43 FF                        LD      (sys_seldsk), A
0852+  F2ED C9                              RET
0853+  F2EE             
0854+  F2EE             ;------------------------------------------------------  
0855+  F2EE             bios_home     ;  8 Home disk
0856+  F2EE 0E 00                           LD      C, 0            
0857+  F2F0             ;------------------------------------------------------  
0858+  F2F0             bios_settrk   ; 10 Select track - Move drive to track stored in C - 0 based (0-76)
0859+  F2F0 79                              LD      A, C
0860+  F2F1 32 3C FF                        LD      (sys_track), A
0861+  F2F4 C9                              RET
0862+  F2F5                                 
0863+  F2F5             ;------------------------------------------------------  
0864+  F2F5             bios_setsec   ; 11 Select sector - Move drive to sector stored in BC - 1 based (1-26) - TODO: Confirm this, not sure if true..
0865+  F2F5 ED 43 3D FF                     LD      (sys_sector), BC
0866+  F2F9 C9                              RET
0867+  F2FA                                 
0868+  F2FA             ;------------------------------------------------------  
0869+  F2FA             bios_setdma   ; 12 Set DMA ADDress - Set the DMA address to BC - source or destination for disk read/write
0870+  F2FA                           ; Note: CP/M 2.2 appears to only set this to the DIRBUF address defined in the DPF, or the USER DMA address (0x80h)
0871+  F2FA ED 43 3F FF                     LD      (sys_dmaaddr), BC
0872+  F2FE C9                              RET
0873+  F2FF                                 
0874+  F2FF             ;------------------------------------------------------  
0875+  F2FF             ;
0876+  F2FF             ; Uses Mem Page 1, 2
0877+  F2FF             ;
0878+  F2FF             bios_read     ; 13 Read 128 bytes
0879+  F2FF CD 6B F3                        CALL    _get_memdisc_addr
0880+  F302 F3                              DI
0881+  F303 D3 71                           OUT     (IO_MEM_1), A
0882+  F305 CB F0                           SET     6, B            ; Point B into page 1
0883+  F307 C5                              PUSH    BC
0884+  F308 E1                              POP     HL
0885+  F309 0E 80                           LD      C, 128
0886+  F30B             
0887+  F30B ED 5B 3F FF                     LD      DE, (sys_dmaaddr)
0888+  F30F 7A                              LD      A, D
0889+  F310 07                              RLCA
0890+  F311 07                              RLCA
0891+  F312 E6 03                           AND     03h             ; Bottom two bits
0892+  F314 F6 20                           OR      RAM_PAGE_0
0893+  F316 47                              LD      B, A            ; B is destination page
0894+  F317 D3 72       _read_page          OUT     (IO_MEM_2), A
0895+  F319             
0896+  F319 CB FA                           SET     7, D            ; Point D to second page
0897+  F31B CB B2                           RES     6, D
0898+  F31D             
0899+  F31D ED A0       _read_next          LDI
0900+  F31F 79                              LD      A, C
0901+  F320 B7                              OR      A
0902+  F321 28 08                           JR      Z, _read_write_done
0903+  F323             
0904+  F323 CB 72                           BIT     6, D
0905+  F325 28 F6                           JR      Z, _read_next
0906+  F327             
0907+  F327 04                              INC     B
0908+  F328 78                              LD      A, B
0909+  F329 18 EC                           JR      _read_page
0910+  F32B             
0911+  F32B 3A 3A FF    _read_write_done    LD      A, (page_1_mapping)   ; Return page map to normal
0912+  F32E D3 71                           OUT     (IO_MEM_1), A
0913+  F330 3A 3B FF                        LD      A, (page_2_mapping)
0914+  F333 D3 72                           OUT     (IO_MEM_2), A
0915+  F335 FB                              EI
0916+  F336 AF                              XOR     A               ; No errors
0917+  F337 C9                              RET
0918+  F338                                 
0919+  F338             ;------------------------------------------------------  
0920+  F338             ;
0921+  F338             ; Uses Mem Page 1, 2
0922+  F338             ;
0923+  F338             bios_write    ; 14 Write 128 bytes
0924+  F338 3A 43 FF                        LD      A, (sys_seldsk)
0925+  F33B B7                              OR      A
0926+  F33C 20 02                           JR      NZ, _write_ok
0927+  F33E 3C                              INC     A
0928+  F33F C9                              RET
0929+  F340             
0930+  F340 CD 6B F3    _write_ok           CALL    _get_memdisc_addr
0931+  F343 F3                              DI
0932+  F344 D3 71                           OUT     (IO_MEM_1), A
0933+  F346 CB F0                           SET     6, B
0934+  F348 C5                              PUSH    BC
0935+  F349 D1                              POP     DE
0936+  F34A 0E 80                           LD      C, 128
0937+  F34C             
0938+  F34C 2A 3F FF                        LD      HL, (sys_dmaaddr)
0939+  F34F 7C                              LD      A, H
0940+  F350 07                              RLCA
0941+  F351 07                              RLCA
0942+  F352 E6 03                           AND     03h              ; Bottom two bits
0943+  F354 F6 20                           OR      RAM_PAGE_0
0944+  F356 47                              LD      B, A             ; B is source page
0945+  F357 D3 72       _write_page         OUT     (IO_MEM_2), A
0946+  F359             
0947+  F359 CB FC                           SET     7, H
0948+  F35B CB B4                           RES     6, H
0949+  F35D             
0950+  F35D ED A0       _write_next         LDI
0951+  F35F 79                              LD      A, C
0952+  F360 B7                              OR      A
0953+  F361 28 C8                           JR      Z, _read_write_done
0954+  F363             
0955+  F363 CB 74                           BIT     6, H
0956+  F365 28 F6                           JR      Z, _write_next
0957+  F367             
0958+  F367 04                              INC     B
0959+  F368 78                              LD      A, B
0960+  F369 18 EC                           JR      _write_page
0961+  F36B                                 
0962+  F36B             ; IN THIS CASE, WE HAVE SAVED THE DISK NUMBER IN 'DISKNO' (0, 1)
0963+  F36B             ;           THE TRACK NUMBER IN 'TRACK' (0-76)
0964+  F36B             ;           THE SECTOR NUMBER IN 'SECTOR' (1-26)
0965+  F36B             ;           THE DMA ADDRESS IN 'DMAAD' (0-65535)
0966+  F36B             ;
0967+  F36B             ; Returns BC = address in page for sector
0968+  F36B             ;          A = page number (ROM/RAM)
0969+  F36B             ;
0970+  F36B             ; Note: BC is always aligned to page boundaries, so a sector will never overlap the end of a page.
0971+  F36B             ;
0972+  F36B 21 00 00    _get_memdisc_addr   LD      HL, 0
0973+  F36E ED 4B 3C FF                     LD      BC, (sys_track)     ; C is track, B is sector (up to 256!)
0974+  F372 68                              LD      L, B
0975+  F373 44                              LD      B, H 
0976+  F374 CB 21                           SLA     C                   ; x 2
0977+  F376 CB 10                           RL      B
0978+  F378 09                              ADD     HL, BC
0979+  F379 CB 21                           SLA     C                   ; x 4
0980+  F37B CB 10                           RL      B
0981+  F37D CB 21                           SLA     C                   ; x 8
0982+  F37F CB 10                           RL      B
0983+  F381 09                              ADD     HL, BC
0984+  F382 CB 21                           SLA     C                   ; x 16
0985+  F384 CB 10                           RL      B
0986+  F386 09                              ADD     HL, BC              ; HL = Sector + BC * (2 + 8 + 16) = sector + track * 26
0987+  F387             
0988+  F387 7D                              LD      A, L
0989+  F388 E6 7F                           AND     07Fh
0990+  F38A 47                              LD      B, A
0991+  F38B 0E 00                           LD      C, 0
0992+  F38D CB 38                           SRL     B
0993+  F38F CB 19                           RR      C                   ; BC = Address in page of sector
0994+  F391             
0995+  F391 CB 25                           SLA     L
0996+  F393 CB 14                           RL      H                   ; H is now page number 
0997+  F395             
0998+  F395 3A 43 FF                        LD      A, (sys_seldsk)
0999+  F398 B7                              OR      A
1000+  F399 28 05                           JR      Z, _get_memdisk_a
1001+  F39B 3A 38 FF                        LD      A, (drive_b_mem_page)
1002+  F39E 84                              ADD     A, H
1003+  F39F C9                              RET
1004+  F3A0 3A 37 FF    _get_memdisk_a      LD      A, (drive_a_mem_page)
1005+  F3A3 84                              ADD     A, H
1006+  F3A4 C9                              RET
1007+  F3A5             
1008+  F3A5             
1009+  F3A5             ;------------------------------------------------------  
1010+  F3A5             bios_listst   ; 15 List status
1011+  F3A5 AF                              XOR     A
1012+  F3A6 C9                              RET
1013+  F3A7                                 
1014+  F3A7             ;------------------------------------------------------  
1015+  F3A7             bios_sectrn   ; 16 Sector translate - BC = logical sector number (zero based), DE = address of translation table. Return HL as physical sector number
1016+  F3A7 69                              LD      L, C                ; No skewing needed, just return BC in HL
1017+  F3A8 60                              LD      H, B
1018+  F3A9 C9                              RET
1019+  F3AA                                 
1020+  F3AA             ;------------------------------------------------------
1021+  F3AA             ; Inline print. Preserves HL, DE, BC
1022+  F3AA             ;
1023+  F3AA E3          m_print_inline      EX      (SP), HL
1024+  F3AB 7E          _inline_loop        LD      A, (HL)
1025+  F3AC 23                              INC     HL
1026+  F3AD A7                              AND     A
1027+  F3AE 28 05                           JR      Z, _inline_done
1028+  F3B0 CD B7 F3                        CALL    m_print_a_safe
1029+  F3B3 18 F6                           JR      _inline_loop
1030+  F3B5             
1031+  F3B5 E3          _inline_done        EX      (SP), HL
1032+  F3B6 C9                              RET
1033+  F3B7             
1034+  F3B7             ;------------------------------------------------------
1035+  F3B7             ; Print character in A. Preserves HL, DE, BC
1036+  F3B7             ;
1037+  F3B7 E5          m_print_a_safe      PUSH    HL
1038+  F3B8 D5                              PUSH    DE
1039+  F3B9 C5                              PUSH    BC
1040+  F3BA 4F                              LD      C, A
1041+  F3BB CD 00 F0                        CALL    bios_conout
1042+  F3BE C1                              POP     BC
1043+  F3BF D1                              POP     DE
1044+  F3C0 E1                              POP     HL
1045+  F3C1 C9                              RET
1046+  F3C2             
1047+  F3C2             ;------------------------------------------------------  
1048+  F3C2             
1049+  F3C2 F3          configure_hardware  DI     
1050+  F3C3 3E 20                           LD      A, RAM_PAGE_0
1051+  F3C5 D3 70                           OUT     (IO_MEM_0), A       ; Page 0 is RAM 0 
1052+  F3C7 32 39 FF                        LD      (page_0_mapping), A
1053+  F3CA 3C                              INC     A
1054+  F3CB D3 71                           OUT     (IO_MEM_1), A       ; Page 1 is RAM 1
1055+  F3CD 32 3A FF                        LD      (page_1_mapping), A
1056+  F3D0 3C                              INC      A
1057+  F3D1 D3 72                           OUT     (IO_MEM_2), A       ; Page 2 is RAM 2 
1058+  F3D3 32 3B FF                        LD      (page_2_mapping), A
1059+  F3D6             
1060+  F3D6 21 00 FE                        LD      HL, 0FE00h          ; Set up the IM 2 table
1061+  F3D9 06 00                           LD      B, 0
1062+  F3DB 36 FD       _fill_vector        LD      (HL), 0FDh
1063+  F3DD 23                              INC     HL
1064+  F3DE 10 FB                           DJNZ    _fill_vector
1065+  F3E0             
1066+  F3E0 CD AA F5                        CALL    keyboard_init       ; Set up the keyboard status tables
1067+  F3E3             
1068+  F3E3 3E C3                           LD      A, 0C3h             ; JP reset   instruction
1069+  F3E5 32 FD FD                        LD      (0FDFDh), A
1070+  F3E8 21 97 F4                        LD      HL, interrupt_handler
1071+  F3EB 22 FE FD                        LD      (0FDFEh), HL
1072+  F3EE             
1073+  F3EE 3E 02                           LD      A, 2
1074+  F3F0 D3 13                           OUT     (PIO_B_CTRL),A      ; Zero interrupt vector
1075+  F3F2             
1076+  F3F2 3E B7                           LD      A, 0B7h             ; Enable interrupts on any of the following bits
1077+  F3F4 D3 13                           OUT     (PIO_B_CTRL),A
1078+  F3F6 00                              NOP
1079+  F3F7 3E CF                           LD      A, 0CFh             ; Just B5 (RTC interrupt) 
1080+  F3F9 D3 13                           OUT     (PIO_B_CTRL),A
1081+  F3FB             
1082+  F3FB 3E FE                           LD      A, 0FEh
1083+  F3FD ED 47                           LD      I, A
1084+  F3FF ED 5E                           IM      2
1085+  F401             
1086+  F401 CD 5B F4                        CALL    setup_screen
1087+  F404             
1088+  F404 3E 04                           LD      A, DRIVE_A_PAGE
1089+  F406 32 37 FF                        LD      (drive_a_mem_page), A
1090+  F409             
1091+  F409 FB                              EI
1092+  F40A             
1093+  F40A 3E 00                           LD      A, 0
1094+  F40C CD 0E F8                        CALL    uart_init           ; Reinitialise the UART to make sure we've not missed anything
1095+  F40F             
1096+  F40F CD 38 FC                        CALL    rtc_init            ; Make sure clock is running and reset time if necesary
1097+  F412             
1098+  F412 06 04       _set_ctrl           LD      B, 4                ; Set RTC Coarse mode and Output Pin to Square wave - gives 64 Hz pulse
1099+  F414 C5          _set_ctrl_loop      PUSH    BC
1100+  F415 26 6F                           LD      H, RTC_ADDRESS      
1101+  F417 2E 07                           LD      L, RTC_REG_CTRL
1102+  F419 CD 1D F9                        CALL    i2c_write_to
1103+  F41C 30 0B                           JR      NC, _rtc_ack_error
1104+  F41E 3E 44                           LD      A, RTC_64HZ_ENABLED
1105+  F420 CD 31 F9                        CALL    i2c_write
1106+  F423 30 04                           JR      NC, _rtc_ack_error
1107+  F425 AF                              XOR     A
1108+  F426 CD 31 F9                        CALL    i2c_write
1109+  F429 CD E5 F8    _rtc_ack_error      CALL    i2c_stop
1110+  F42C             
1111+  F42C CD 37 F4                        CALL    _pause
1112+  F42F             
1113+  F42F CD 3C F4                        CALL    _check_ctrl
1114+  F432 C1                              POP     BC
1115+  F433 C8                              RET     Z
1116+  F434 10 DE                           DJNZ    _set_ctrl_loop
1117+  F436 C9                              RET
1118+  F437             
1119+  F437 06 00       _pause              LD      B, 0
1120+  F439 10 FE                           DJNZ    $
1121+  F43B C9                              RET
1122+  F43C             
1123+  F43C             ; Check that the control is set to coarse trim and 0 offset
1124+  F43C             ; Returns with Zero flag set if settings are good.
1125+  F43C             ;
1126+  F43C 26 6F       _check_ctrl         LD      H, RTC_ADDRESS      
1127+  F43E 2E 07                           LD      L, RTC_REG_CTRL
1128+  F440 CD FC F8                        CALL    i2c_read_from
1129+  F443 16 02                           LD      D, 2
1130+  F445 30 11                           JR      NC, _ctrl_error
1131+  F447 5F                              LD      E, A
1132+  F448 CD 51 F9                        CALL    i2c_ack
1133+  F44B CD 3E F9                        CALL    i2c_read
1134+  F44E 57                              LD      D, A
1135+  F44F CD E5 F8                        CALL    i2c_stop
1136+  F452 7B                              LD      A, E
1137+  F453 06 04                           LD      B, 4
1138+  F455 FE 44                           CP      RTC_64HZ_ENABLED
1139+  F457 C0                              RET     NZ
1140+  F458 7A          _ctrl_error         LD      A, D
1141+  F459 A7                              AND     A
1142+  F45A C9                              RET 
1143+  F45B             
1144+  F45B             ; SHOULD NOT BE CALLED WITH INTERRUPTS ENABLED!
1145+  F45B             ;
1146+  F45B 11 29 FF    setup_screen        LD      DE, screen_page     ; Copy the startup defaults to the shared_data area
1147+  F45E 21 89 F4                        LD      HL, _screen_defaults
1148+  F461 01 0E 00                        LD      BC, _defaults_length
1149+  F464 ED B0                           LDIR
1150+  F466 3A 29 FF                        LD      A, (screen_page)    ; Clear the screen buffer
1151+  F469 D3 71                           OUT     (IO_MEM_1), A       ; Screen buffer is in PAGE_1
1152+  F46B 21 00 40                        LD      HL, PAGE_1_START
1153+  F46E 11 02 40                        LD      DE, PAGE_1_START+2
1154+  F471 0E 20                           LD      C, ' '
1155+  F473 3A 31 FF                        LD      A, (console_colour)
1156+  F476 47                              LD      B, A
1157+  F477 ED 43 00 40                     LD      (PAGE_1_START), BC
1158+  F47B 01 FA 3F                        LD      BC, 16378           ; Don't over write last couple of bytes (VideoBeast)
1159+  F47E ED B0                           LDIR
1160+  F480             
1161+  F480 CD 6A FB                        CALL    disp_clear          ; Clear the LED screen
1162+  F483             
1163+  F483 3A 3A FF    restore_page_return LD      A, (page_1_mapping)       ; Return Page 1 to normal RAM
1164+  F486 D3 71                           OUT     (IO_MEM_1), A
1165+  F488 C9                              RET
1166+  F489             
1167+  F489 3F          _screen_defaults    .DB     RAM_PAGE_31         ; Screen buffer page
1168+  F48A 00                              .DB     0                   ; Row offset in buffer
1169+  F48B 00 00                           .DB     0,0                 ; Row, column being shown on LED Display
1170+  F48D 01 01                           .DB     1,1                 ; Row, column of cursor
1171+  F48F 18 40                           .DB     24,64               ; Console height (rows), width (columns)
1172+  F491 0F                              .DB     00Fh                ; Current colour [7:4] = background, [3:0] = foreground
1173+  F492 02                              .DB     CFLAGS_TRACK_CURSOR ; Flags
1174+  F493 00                              .DB     0                   ; Timer
1175+  F494 00 00                           .DB     0, 0                ; Escape char and first parameter
1176+  F496 00                              .DB     0                   ; Disable identifier sequence
1177+  F497             _defaults_length    .EQU    $-_screen_defaults
1178+  F497             
1179+  F497 F3          interrupt_handler   DI
1180+  F498 ED 73 D4 FF                     LD      (intr_stack), SP
1181+  F49C 31 D4 FF                        LD      SP, intr_stack
1182+  F49F F5                              PUSH    AF
1183+  F4A0 D9                              EXX
1184+  F4A1 CD C0 F5                        CALL    keyboard_poll
1185+  F4A4             
1186+  F4A4 3A 13 FF                        LD      A,(control_key_pressed)
1187+  F4A7 A7                              AND     A
1188+  F4A8 C4 F0 F4                        CALL    NZ, handle_screen_shift
1189+  F4AB             
1190+  F4AB 3A 33 FF                        LD      A, (console_timer)
1191+  F4AE 3D                              DEC     A
1192+  F4AF FA C2 F4                        JP      M, _not_moved
1193+  F4B2 32 33 FF                        LD      (console_timer), A
1194+  F4B5 20 0B                           JR      NZ, _not_moved
1195+  F4B7             
1196+  F4B7 3A 32 FF                        LD      A, (console_flags)
1197+  F4BA E6 FB                           AND     ~CFLAGS_SHOW_MOVED
1198+  F4BC 32 32 FF                        LD      (console_flags), A
1199+  F4BF CD 94 F1                        CALL    unsafe_redraw
1200+  F4C2             
1201+  F4C2 2A 04 FF    _not_moved          LD      HL, (timer)
1202+  F4C5 5D                              LD      E, L                ; E is old low byte of timer - used to blink cursor
1203+  F4C6 23                              INC     HL
1204+  F4C7 22 04 FF                        LD      (timer), HL
1205+  F4CA 7C                              LD      A, H
1206+  F4CB B5                              OR      L
1207+  F4CC 20 07                           JR      NZ, _timer_done
1208+  F4CE 2A 06 FF                        LD      HL, (timer+2)
1209+  F4D1 23                              INC     HL
1210+  F4D2 22 06 FF                        LD      (timer+2),HL   
1211+  F4D5             
1212+  F4D5 3A 32 FF    _timer_done         LD      A, (console_flags)
1213+  F4D8 E6 01                           AND     CFLAGS_SHOW_CURSOR
1214+  F4DA 28 0B                           JR      Z, _int_done
1215+  F4DC             
1216+  F4DC 3A 04 FF                        LD      A, (timer)          ; Blink when timer bit changes
1217+  F4DF AB                              XOR     E
1218+  F4E0 E6 20                           AND     020h
1219+  F4E2 28 03                           JR      Z, _int_done
1220+  F4E4 CD 80 F5                        CALL    update_cursor
1221+  F4E7             
1222+  F4E7 D9          _int_done           EXX
1223+  F4E8 F1                              POP     AF
1224+  F4E9 ED 7B D4 FF                     LD      SP, (intr_stack)
1225+  F4ED FB                              EI
1226+  F4EE ED 4D       _do_reti            RETI
1227+  F4F0             
1228+  F4F0             ; Enter with A containing a special control character
1229+  F4F0             ;
1230+  F4F0             ;
1231+  F4F0 FE 90       handle_screen_shift CP      KEY_CTRL_UP
1232+  F4F2 20 25                           JR      NZ, _not_ctrl_up
1233+  F4F4             
1234+  F4F4 3A 2B FF                        LD      A, (display_row)
1235+  F4F7 3D                              DEC     A
1236+  F4F8 FA 7B F5                        JP      M, _shift_done
1237+  F4FB F5          _shift_row          PUSH    AF
1238+  F4FC 1E 00                           LD      E, 0
1239+  F4FE CD 80 F5                        CALL    update_cursor
1240+  F501 F1                              POP     AF
1241+  F502 32 2B FF                        LD      (display_row), A
1242+  F505             
1243+  F505 3A 32 FF    _shift_complete     LD      A, (console_flags)
1244+  F508 E6 FD                           AND     ~CFLAGS_TRACK_CURSOR
1245+  F50A F6 04       _flags_and_redraw   OR      CFLAGS_SHOW_MOVED
1246+  F50C 32 32 FF                        LD      (console_flags), A
1247+  F50F 3E 3C                           LD      A, SHOW_MOVE_DELAY
1248+  F511 32 33 FF                        LD      (console_timer),A
1249+  F514 CD 94 F1                        CALL    unsafe_redraw
1250+  F517 18 62                           JR      _shift_done
1251+  F519             
1252+  F519 FE 91       _not_ctrl_up        CP      KEY_CTRL_DOWN
1253+  F51B 20 0D                           JR      NZ, _not_ctrl_down
1254+  F51D             
1255+  F51D 3A 2F FF    _shift_down         LD      A, (console_height)
1256+  F520 4F                              LD      C, A
1257+  F521 3A 2B FF                        LD      A, (display_row)
1258+  F524 3C                              INC     A
1259+  F525 B9                              CP      C
1260+  F526 28 53                           JR      Z, _shift_done
1261+  F528 18 D1                           JR      _shift_row
1262+  F52A             
1263+  F52A FE 93       _not_ctrl_down      CP      KEY_CTRL_RIGHT
1264+  F52C 20 0F                           JR      NZ, _not_ctrl_right
1265+  F52E             
1266+  F52E 3A 30 FF                        LD      A, (console_width)
1267+  F531 D6 17                           SUB     DISPLAY_WIDTH-1
1268+  F533 4F                              LD      C, A
1269+  F534 3A 2C FF                        LD      A, (display_col)
1270+  F537 3C                              INC     A
1271+  F538 B9                              CP      C
1272+  F539 28 40                           JR      Z, _shift_done
1273+  F53B 18 0B                           JR      _shift_col
1274+  F53D             
1275+  F53D FE 92       _not_ctrl_right     CP      KEY_CTRL_LEFT
1276+  F53F 20 13                           JR      NZ, _not_ctrl_left
1277+  F541             
1278+  F541 3A 2C FF                        LD      A, (display_col)
1279+  F544 3D                              DEC     A
1280+  F545 FA 7B F5                        JP      M, _shift_done
1281+  F548 F5          _shift_col          PUSH    AF
1282+  F549 1E 00                           LD      E, 0
1283+  F54B CD 80 F5                        CALL    update_cursor
1284+  F54E F1                              POP     AF
1285+  F54F 32 2C FF                        LD      (display_col), A
1286+  F552 18 B1                           JR      _shift_complete
1287+  F554             
1288+  F554 FE 94       _not_ctrl_left      CP      KEY_CTRL_ENTER
1289+  F556 20 19                           JR      NZ, _not_ctrl_enter
1290+  F558 3A 2D FF                        LD      A, (cursor_row)
1291+  F55B 3D                              DEC     A
1292+  F55C 32 2B FF                        LD      (display_row), A
1293+  F55F 3A 2E FF                        LD      A, (cursor_col)
1294+  F562 D6 16                           SUB     DISPLAY_WIDTH-2
1295+  F564 30 01                           JR      NC, _col_ok
1296+  F566 AF                              XOR     A
1297+  F567             
1298+  F567 32 2C FF    _col_ok             LD      (display_col), A
1299+  F56A 3A 32 FF                        LD      A, (console_flags)
1300+  F56D F6 02                           OR      CFLAGS_TRACK_CURSOR
1301+  F56F 18 99                           JR      _flags_and_redraw
1302+  F571             
1303+  F571 FE 95       _not_ctrl_enter     CP      KEY_CTRL_SPACE
1304+  F573 20 06                           JR      NZ, _shift_done
1305+  F575             
1306+  F575 AF                              XOR     A
1307+  F576 32 2C FF                        LD      (display_col), A
1308+  F579 18 A2                           JR      _shift_down
1309+  F57B             
1310+  F57B AF          _shift_done         XOR     A
1311+  F57C 32 13 FF                        LD      (control_key_pressed),A
1312+  F57F C9                              RET
1313+  F580             
1314+  F580             ;
1315+  F580             ; Blinks the cursor 
1316+  F580             ;  Enter with E = timer low byte. 
1317+  F580             ;  If CURSOR_BIT is 1, show the cursor at the line, otherwise restore the existing character
1318+  F580             ;
1319+  F580 3A 2B FF    update_cursor       LD      A, (display_row)    ; Are we on the same row as the cursor?
1320+  F583 47                              LD      B, A
1321+  F584 3A 2D FF                        LD      A, (cursor_row)
1322+  F587 3D                              DEC     A
1323+  F588 B8                              CP      B
1324+  F589 C0                              RET     NZ
1325+  F58A             
1326+  F58A 3A 2C FF                        LD      A, (display_col)    ; Check the cursor column is within the display window
1327+  F58D 47                              LD      B, A
1328+  F58E 3A 2E FF                        LD      A, (cursor_col)
1329+  F591 3D                              DEC     A
1330+  F592 90                              SUB     B
1331+  F593 F8                              RET     M
1332+  F594             
1333+  F594 FE 18                           CP      DISPLAY_WIDTH
1334+  F596 D0                              RET     NC
1335+  F597             
1336+  F597                                 ; At this point, A holds the current display column for the cursor..
1337+  F597 4F                              LD      C, A
1338+  F598 06 00                           LD      B, 0
1339+  F59A 21 84 FF                        LD      HL, display_buffer
1340+  F59D 09                              ADD     HL, BC
1341+  F59E 09                              ADD     HL, BC
1342+  F59F 7B                              LD      A, E
1343+  F5A0 E6 20                           AND     20h
1344+  F5A2 7E                              LD      A, (HL)
1345+  F5A3 28 02                           JR      Z, _unblink
1346+  F5A5 3E 5F                           LD      A, '_'
1347+  F5A7 C3 E9 FA    _unblink            JP    disp_character
1348+  F5AA             
1349+  F5AA                                 .INCLUDE "../ports.asm"
0001++ F5AA             ;
0002++ F5AA             ; Port definintions
0003++ F5AA             ;
0004++ F5AA             ;
0005++ F5AA             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006++ F5AA             ;
0007++ F5AA             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008++ F5AA             ;
0009++ F5AA             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010++ F5AA             ; of this software and associated documentation files (the "Software"), to deal
0011++ F5AA             ; in the Software without restriction, including without limitation the rights
0012++ F5AA             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013++ F5AA             ; copies of the Software, and to permit persons to whom the Software is
0014++ F5AA             ; furnished to do so, subject to the following conditions:
0015++ F5AA             ; 
0016++ F5AA             ; The above copyright notice and this permission notice shall be included in all
0017++ F5AA             ; copies or substantial portions of the Software.
0018++ F5AA             ; 
0019++ F5AA             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020++ F5AA             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021++ F5AA             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022++ F5AA             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023++ F5AA             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024++ F5AA             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025++ F5AA             ; SOFTWARE.
0026++ F5AA             ;
0027++ F5AA             
0028++ F5AA             BACKSPACE_CHAR      .EQU  08h
0029++ F5AA             CARRIAGE_RETURN     .EQU  0Dh
0030++ F5AA             NEWLINE             .EQU  0Ah
0031++ F5AA             ESCAPE_CHAR         .EQU  1Bh
0032++ F5AA             CPM_NUM             .EQU  1Fh
0033++ F5AA             
0034++ F5AA             ;=================================== UART ============================================
0035++ F5AA             UART_TX_RX          .EQU    020h    ; Read: receiver buffer, Write: transmitter buffer
0036++ F5AA             UART_INT_ENABLE     .EQU    021h    ; Interrupt enable register
0037++ F5AA             UART_INT_ID         .EQU    022h    ; Read: Interrupt identification register
0038++ F5AA             UART_FIFO_CTRL      .EQU    022h    ; Write: FIFO Control register
0039++ F5AA             UART_LINE_CTRL      .EQU    023h    ; Line control register
0040++ F5AA             UART_MODEM_CTRL     .EQU    024h    ; Modem control
0041++ F5AA             UART_LINE_STATUS    .EQU    025h    ; Line status
0042++ F5AA             UART_MODEM_STATUS   .EQU    026h    ; Modem status
0043++ F5AA             UART_SCRATCH        .EQU    027h    ; Scratch register
0044++ F5AA             
0045++ F5AA             ;==================================== PIO ============================================
0046++ F5AA             PIO_A_DATA          .EQU  010h
0047++ F5AA             PIO_A_CTRL          .EQU  012h
0048++ F5AA             
0049++ F5AA             PIO_B_DATA          .EQU  011h
0050++ F5AA             PIO_B_CTRL          .EQU  013h
0051++ F5AA             
0052++ F5AA             PIO_MODE_0          .EQU  00Fh      ; Mode 0: All outputs
0053++ F5AA             PIO_MODE_1          .EQU  04fh      ; Mode 1: All inputs
0054++ F5AA             PIO_MODE_2          .EQU  080h      ; Mode 2 (Port A only): Bi-directional
0055++ F5AA             PIO_MODE_3          .EQU  0CFh      ; Mode 3: Per-pin I/O on the given port - write an additional word with bits set (1) for input, reset (0) for output on the matching pin.
0056++ F5AA             
0057++ F5AA             PIO_SET_INTERRUPT   .EQU  007h      ; Set interrupt control world. By itself, this wil disable interrupts on the given port. OR with the following constants to change this
0058++ F5AA             PIO_ENABLE_INT      .EQU  080h      ; Enable interrupts on the given port, when OR'd with the PIO_SET_INTERRUPT control word.
0059++ F5AA             PIO_INT_MASK        .EQU  010h      ; When OR'd with the PIO_SET_INTERRUPT control word, the following word will enable interrupts for pins where the matching bit is zero
0060++ F5AA             
0061++ F5AA             ;================================== AUDIO ============================================
0062++ F5AA             ; Constants for Audio output
0063++ F5AA             AUDIO_PIO           .EQU  1         ; Audio on PIO (rev. 0.1 boards)
0064++ F5AA             AUDIO_UART          .EQU  2         ; Audio on UART (rev. 0.2 boards)
0065++ F5AA             
0066++ F5AA             AUDIO_VERSION       .EQU  AUDIO_UART
0067++ F5AA             
0068++ F5AA~            #IF AUDIO_VERSION = AUDIO_PIO
0069++ F5AA~            PORT_B_IOMASK       .EQU  0EFh      ; All inputs, apart from bit 4 (audio out)
0070++ F5AA~            AUDIO_MASK          .EQU  010h      ; Bitmask for audio output on Port B. The bit is set for the output pin.
0071++ F5AA~            AUDIO_PORT          .EQU  PIO_B_DATA
0072++ F5AA~            
0073++ F5AA             #ELSE
0074++ F5AA             PORT_B_IOMASK       .EQU  0FFh      ; All inputs
0075++ F5AA             AUDIO_MASK          .EQU  008h      ; Bitmask for audio output on UART Out 2. The bit is set for the output pin
0076++ F5AA             AUDIO_PORT          .EQU  UART_MODEM_CTRL
0077++ F5AA             
0078++ F5AA             #ENDIF
0079++ F5AA             
0080++ F5AA             
0081++ F5AA             ;=================================== MEMORY PAGING ===================================
0082++ F5AA             IO_MEM_0            .EQU    070h      ; Page 0: 0000h - 3fffh
0083++ F5AA             IO_MEM_1            .EQU    071h      ; Page 1: 4000h - 7fffh
0084++ F5AA             IO_MEM_2            .EQU    072h      ; Page 2: 8000h - bfffh
0085++ F5AA             IO_MEM_3            .EQU    073h      ; Page 3: c000h - ffffh
0086++ F5AA             
0087++ F5AA             IO_MEM_CTRL         .EQU    074h      ; Paging enable register
0088++ F5AA             IO_MEM_ENABLE       .EQU    1
0089++ F5AA             IO_MEM_DISABLE      .EQU    0 
0090++ F5AA             
0091++ F5AA             RAM_PAGE_0          .EQU    020h
0092++ F5AA             RAM_PAGE_1          .EQU    021h
0093++ F5AA             RAM_PAGE_2          .EQU    022h
0094++ F5AA             RAM_PAGE_3          .EQU    023h
0095++ F5AA             
0096++ F5AA             RAM_PAGE_16         .EQU    030h
0097++ F5AA             RAM_PAGE_31         .EQU    03Fh
0098++ F5AA             
0099++ F5AA             ROM_PAGE_0          .EQU    000h
0100++ F5AA             ROM_PAGE_16         .EQU    010h
0101++ F5AA             
0102++ F5AA             PAGE_1_START        .EQU    4000h
0103++ F5AA             
0104++ F5AA             ;====================================== I2C DEVICES ===================================
0105++ F5AA             I2C_DATA_BIT            .equ    7
0106++ F5AA             I2C_CLK_BIT             .equ    6
0107++ F5AA             
0108++ F5AA             I2C_DATA_MASK           .equ    1 << I2C_DATA_BIT
0109++ F5AA             I2C_CLK_MASK            .equ    1 << I2C_CLK_BIT
0110++ F5AA             
0111++ F5AA             ; Display
0112++ F5AA             ;==========
0113++ F5AA             DL_ADDRESS              .EQU    050h     ; Left  Matrix controller I2C address
0114++ F5AA             DR_ADDRESS              .EQU    053h     ; Right Matrix controller I2C address
0115++ F5AA             
0116++ F5AA             DISP_REG_CRWL           .EQU    0FEh     ; Command Register write lock
0117++ F5AA             DISP_UNLOCK             .EQU    0C5h     ; Unlock command
0118++ F5AA             
0119++ F5AA             DISP_DEFAULT_BRIGHTNESS .EQU    080h     ; Default brightness
0120++ F5AA             DISP_DIMMED             .EQU    018h     ; Dimmed
0121++ F5AA             
0122++ F5AA             DISPLAY_WIDTH           .EQU    24       ; 24 characters
0123++ F5AA             
0124++ F5AA             ; RTC
0125++ F5AA             ;==========
0126++ F5AA             RTC_ADDRESS             .EQU    06fh
0127++ F5AA             
0128++ F5AA             RTC_REG_SEC             .EQU    000h    ; Also has oscillator enable bit in B7, 1 = run
0129++ F5AA             RTC_REG_MIN             .EQU    001h
0130++ F5AA             RTC_REG_HOUR            .EQU    002h    ; B6: 1 = 12hr/ 0 = 24hr clock (r/w) 
0131++ F5AA                                                     ;        If 12 hr clock, B5: 1 = PM/ 0 = AM. B4: hour tens. Otherwise B5-4: hour tens, B3-0: hour units
0132++ F5AA             RTC_REG_WKDAY           .EQU    003h    ; Oscillator status bit in B5, 1 = enabled and running. 
0133++ F5AA                                                     ;   B4: 1 = power was lost, write 0 to clear (timestamp registers are set)
0134++ F5AA                                                     ;   B3: 1 = enable external battery supply (VBAT)
0135++ F5AA                                                     ;   B2-0: Weekday, from 1 to 7 
0136++ F5AA             RTC_REG_DATE            .EQU    004h    ; BCD Date (1 to 31)
0137++ F5AA             RTC_REG_MTH             .EQU    005h    ; B5: 1 = Leap year (read only). B4: month tens, B3-0: month units  (Month is 1 to 12)
0138++ F5AA             RTC_REG_YEAR            .EQU    006h    ; BCD Year
0139++ F5AA             
0140++ F5AA             RTC_REG_CTRL            .EQU    007h    ; B7: If Square wave and Alarm 0 and Alarm 1 are disabled, sets Output Pin level
0141++ F5AA                                                     ;   B6: SQWEN, 1 = Enable square wave on Output Pin, Alarms disabled
0142++ F5AA                                                     ;   B5, B4: Alarm 1, 0 Enable. 1 = Alarm is enabled
0143++ F5AA                                                     ;   B3: 1 = Use external oscillator
0144++ F5AA                                                     ;   B2: CRSTRIM, 1 = Coarse trim mode, Output pin is 64Hz
0145++ F5AA                                                     ;   B1-0: If SQWEN = 1 & CRSTRIM = 0, sets Output pin freq. 00 -> 1Hz, 01 -> 4.096kHz, 10 -> 8.192kHz, 11 -> 32.768kHz
0146++ F5AA             RTC_REG_TRIM            .EQU    008h    ; Trim, initially 0. B7: Sign, 1=Add, 0=Subtract clock cycles.  
0147++ F5AA                                                     ;   B6-0: Trim amount/2. Applied 1 every minute in fine trim, 128 times a second in coarse trim mode. 0 = disable trim
0148++ F5AA             
0149++ F5AA             RTC_64HZ_ENABLED        .EQU    044h    ; Value for RTC_REG_CTRL to enable 64Hz interrupt output
0150++ F5AA             
0151++ F5AA             RTC_WEEKDAY_RUNNING     .EQU    008h    ; Value for RTC_REG_WKDAY for normall running of clock1350+  F5AA             
1351+  F5AA                                 .INCLUDE "../io.asm"
0001++ F5AA             ;
0002++ F5AA             ; I/O routines.. specifically keyboard and serial
0003++ F5AA             ;
0004++ F5AA             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ F5AA             ;
0006++ F5AA             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ F5AA             ;
0008++ F5AA             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ F5AA             ; of this software and associated documentation files (the "Software"), to deal
0010++ F5AA             ; in the Software without restriction, including without limitation the rights
0011++ F5AA             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ F5AA             ; copies of the Software, and to permit persons to whom the Software is
0013++ F5AA             ; furnished to do so, subject to the following conditions:
0014++ F5AA             ; 
0015++ F5AA             ; The above copyright notice and this permission notice shall be included in all
0016++ F5AA             ; copies or substantial portions of the Software.
0017++ F5AA             ; 
0018++ F5AA             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ F5AA             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ F5AA             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ F5AA             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ F5AA             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ F5AA             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ F5AA             ; SOFTWARE.
0025++ F5AA             ;
0026++ F5AA             
0027++ F5AA             
0028++ F5AA 21 08 FF    keyboard_init       LD      HL, keyboard_state
0029++ F5AD 06 20                           LD      B, io_data_end - keyboard_state
0030++ F5AF AF                              XOR     A
0031++ F5B0 77          _init_loop          LD      (HL),A
0032++ F5B1 23                              INC     HL
0033++ F5B2 05                              DEC     B
0034++ F5B3 20 FB                           JR      NZ, _init_loop
0035++ F5B5 AF                              XOR     A
0036++ F5B6 32 28 FF                        LD      (input_size),A
0037++ F5B9 32 27 FF                        LD      (input_free),A
0038++ F5BC 32 26 FF                        LD      (input_pos),A
0039++ F5BF C9                              RET
0040++ F5C0             
0041++ F5C0             ; Poll the keyboard, adding raw codes to the keyboard_state buffer, and decoded characters to the input_buffer
0042++ F5C0             ;
0043++ F5C0 01 00 FD    keyboard_poll       LD      BC, 0FD00h          ; Check shift key
0044++ F5C3 3A 12 FF                        LD      A, (key_shift_state)
0045++ F5C6 E6 FC                           AND     ~(KEY_SHIFT_BIT | KEY_CTRL_BIT)
0046++ F5C8 57                              LD      D, A
0047++ F5C9             
0048++ F5C9 ED 78                           IN      A, (C)
0049++ F5CB E6 20                           AND     020h
0050++ F5CD 20 04                           JR      NZ, _check_ctrl_key
0051++ F5CF 3E 01                           LD      A, KEY_SHIFT_BIT
0052++ F5D1 B2                              OR      D
0053++ F5D2 57                              LD      D, A
0054++ F5D3             
0055++ F5D3 01 00 FE    _check_ctrl_key     LD      BC, 0FE00h          ; Keyboard row 0
0056++ F5D6 ED 78                           IN      A, (C)
0057++ F5D8 E6 10                           AND     010h
0058++ F5DA 20 04                           JR      NZ, _store_modifiers
0059++ F5DC 3E 02                           LD      A, KEY_CTRL_BIT
0060++ F5DE B2                              OR      D
0061++ F5DF 57                              LD      D, A
0062++ F5E0             
0063++ F5E0 7A          _store_modifiers    LD      A, D
0064++ F5E1 32 12 FF                        LD      (key_shift_state), A
0065++ F5E4             
0066++ F5E4             
0067++ F5E4 21 4E F7                        LD      HL, keyboard
0068++ F5E7 ED 78       _poll_loop          IN      A, (C)              ; BC -> Keyboard row port..
0069++ F5E9 16 01                           LD      D, 1                ; D -> Current Bit
0070++ F5EB 5F                              LD      E, A                ; E -> Key row bit set
0071++ F5EC 22 10 FF    _next_key           LD      (keyboard_pos), HL
0072++ F5EF A2                              AND     D
0073++ F5F0 20 3F                           JR      NZ, _released
0074++ F5F2                                                             ; Key is pressed... add it to state buffer
0075++ F5F2 C5                              PUSH    BC
0076++ F5F3 7E                              LD      A, (HL)             ; Raw key code in A
0077++ F5F4             
0078++ F5F4 21 08 FF                        LD      HL, keyboard_state
0079++ F5F7 06 08                           LD      B, _key_state_size
0080++ F5F9 BE          _check_pressed      CP      (HL)
0081++ F5FA CA 4A F6                        JP      Z, _do_nothing      ; Key already in state table - nothing to do..
0082++ F5FD 23                              INC     HL
0083++ F5FE 05                              DEC     B
0084++ F5FF 20 F8                           JR      NZ, _check_pressed
0085++ F601                                                             ; Key wasn't pressed, so add it to the first free slot
0086++ F601 21 08 FF                        LD      HL, keyboard_state
0087++ F604 06 08                           LD      B, _key_state_size
0088++ F606 4F                              LD      C, A
0089++ F607 AF                              XOR     A
0090++ F608 BE          _find_free          CP      (HL)
0091++ F609 28 07                           JR      Z, _key_pressed
0092++ F60B 23                              INC     HL
0093++ F60C 05                              DEC     B
0094++ F60D 20 F9                           JR      NZ, _find_free
0095++ F60F C3 4A F6                        JP      _do_nothing         ; No free slots, so ignore the key
0096++ F612             
0097++ F612 71          _key_pressed        LD      (HL), C             ; Found free slot, store the raw key code
0098++ F613             
0099++ F613                                 ; Reset repeat counter       
0100++ F613             
0101++ F613 2A 10 FF                        LD      HL, (keyboard_pos)  ; Get the current keyboard character location
0102++ F616 01 30 00                        LD      BC, _keyboard_size
0103++ F619 3A 12 FF                        LD      A, (key_shift_state)
0104++ F61C A7                              AND     A
0105++ F61D 28 04                           JR      Z, _got_keycode
0106++ F61F 09          _modifier_offset    ADD     HL, BC
0107++ F620 3D                              DEC     A
0108++ F621 20 FC                           JR      NZ, _modifier_offset
0109++ F623             
0110++ F623 7E          _got_keycode        LD      A, (HL) 
0111++ F624 32 14 FF                        LD      (last_keycode), A
0112++ F627 CD 7A F6                        CALL    _store_key
0113++ F62A AF                              XOR     A
0114++ F62B 32 15 FF                        LD      (key_repeat_time), A
0115++ F62E             
0116++ F62E C1                              POP     BC
0117++ F62F 18 1A                           JR      _poll_next
0118++ F631             
0119++ F631                                                             ; Key is not pressed... remove it from the state buffer if it was pressed (key up event)
0120++ F631                                                             ; TODO: This is rather inefficient...
0121++ F631 C5          _released           PUSH    BC
0122++ F632 7E                              LD      A, (HL)             ; Raw key code in A
0123++ F633 A7                              AND     A
0124++ F634 28 14                           JR      Z, _do_nothing      ; Ignore character zero
0125++ F636             
0126++ F636 21 08 FF                        LD      HL, keyboard_state
0127++ F639 06 08                           LD      B, _key_state_size
0128++ F63B BE          _check_released     CP      (HL)
0129++ F63C 28 06                           JR      Z, _handle_release
0130++ F63E 23                              INC     HL
0131++ F63F 05                              DEC     B
0132++ F640 20 F9                           JR      NZ, _check_released
0133++ F642 18 06                           JR      _do_nothing         ; Code not in state buffer, not released
0134++ F644             
0135++ F644 4F          _handle_release     LD      C, A
0136++ F645 AF                              XOR     A
0137++ F646 77                              LD      (HL), A             ; Remove it from the buffer 
0138++ F647 32 14 FF                        LD      (last_keycode), A
0139++ F64A                                                             ; TODO: We should probably tell someone about this...
0140++ F64A C1          _do_nothing         POP     BC
0141++ F64B             
0142++ F64B 2A 10 FF    _poll_next          LD      HL, (keyboard_pos)
0143++ F64E 7B                              LD      A, E                ; Get the bitmask back
0144++ F64F 23                              INC     HL
0145++ F650 CB 22                           SLA     D
0146++ F652 CB 72                           BIT     6, D
0147++ F654 CA EC F5                        JP      Z, _next_key
0148++ F657             
0149++ F657 CB 00                           RLC     B                   ; Move to the next key row
0150++ F659 3E FE                           LD      A, 0FEh
0151++ F65B B8                              CP      B
0152++ F65C C2 E7 F5                        JP      NZ, _poll_loop
0153++ F65F             
0154++ F65F 3A 14 FF                        LD      A, (last_keycode)
0155++ F662 A7                              AND     A
0156++ F663 C8                              RET     Z
0157++ F664 3A 15 FF                        LD      A, (key_repeat_time)
0158++ F667 3C                              INC     A
0159++ F668 32 15 FF                        LD      (key_repeat_time), A
0160++ F66B FE 28                           CP      KEY_REPEAT_DELAY
0161++ F66D 28 08                           JR      Z, _do_repeat
0162++ F66F FE 2F                           CP      KEY_REPEAT_AFTER
0163++ F671 C0                              RET     NZ
0164++ F672 3E 28                           LD      A, KEY_REPEAT_DELAY
0165++ F674 32 15 FF                        LD      (key_repeat_time),A
0166++ F677 3A 14 FF    _do_repeat          LD      A, (last_keycode)
0167++ F67A             
0168++ F67A             
0169++ F67A             ; Store the decoded keycode in A to the relevant buffer...
0170++ F67A 4F          _store_key          LD      C, A
0171++ F67B E6 F8                           AND     CTRL_KEY_MASK       ; Check for special control characters 
0172++ F67D FE 90                           CP      CTRL_KEY_CHECK
0173++ F67F 20 05                           JR      NZ, _get_key
0174++ F681             
0175++ F681 79                              LD      A, C                ; Store them in a separate location
0176++ F682 32 13 FF                        LD      (control_key_pressed), A
0177++ F685 C9                              RET
0178++ F686                                                             ; Write the character to the input buffer
0179++ F686 79          _get_key            LD      A, C                ; Get the actual character...
0180++ F687 A7                              AND     A                   ; Skip blank character codes
0181++ F688 C8                              RET     Z
0182++ F689             
0183++ F689 6F                              LD      L, A                ; Store it in L
0184++ F68A             
0185++ F68A 3A 28 FF                        LD      A, (input_size)     ; Now check we have space
0186++ F68D FE 10                           CP      _input_buffer_size
0187++ F68F C8                              RET     Z
0188++ F690             
0189++ F690 3C                              INC     A
0190++ F691 32 28 FF                        LD      (input_size), A
0191++ F694             
0192++ F694 06 00                           LD      B, 0
0193++ F696 3A 27 FF                        LD      A, (input_free)
0194++ F699 4F                              LD      C, A
0195++ F69A 7D                              LD      A, L                ; Get the character from L
0196++ F69B 21 16 FF                        LD      HL, input_buffer
0197++ F69E 09                              ADD     HL, BC
0198++ F69F 77                              LD      (HL), A             ; Store the character
0199++ F6A0             
0200++ F6A0 0C                              INC     C                   ; Point to next byte in input
0201++ F6A1 3E 0F                           LD      A, 0Fh
0202++ F6A3 A1                              AND     C
0203++ F6A4 32 27 FF                        LD      (input_free), A
0204++ F6A7 C9                              RET
0205++ F6A8             
0206++ F6A8             ;
0207++ F6A8             ; Reads the next available character in A, returning that or 0 if none are available
0208++ F6A8             ; Z flag is set if no character
0209++ F6A8             ; Uses HL, BC, A
0210++ F6A8 3A 28 FF    read_character      LD      A, (input_size)
0211++ F6AB A7                              AND     A
0212++ F6AC C8                              RET     Z
0213++ F6AD             
0214++ F6AD F3                              DI                          ; Make sure we don't get into a race condition..
0215++ F6AE 3A 28 FF                        LD      A, (input_size)
0216++ F6B1 3D                              DEC     A
0217++ F6B2 32 28 FF                        LD      (input_size),A
0218++ F6B5 3A 26 FF                        LD      A, (input_pos)
0219++ F6B8 4F                              LD      C, A
0220++ F6B9 3C                              INC     A
0221++ F6BA E6 0F                           AND     0Fh
0222++ F6BC 32 26 FF                        LD      (input_pos),A
0223++ F6BF 06 00                           LD      B, 0
0224++ F6C1 21 16 FF                        LD      HL, input_buffer
0225++ F6C4 09                              ADD     HL, BC
0226++ F6C5 7E                              LD      A, (HL)
0227++ F6C6 B7                              OR      A
0228++ F6C7 FB                              EI
0229++ F6C8 C9                              RET
0230++ F6C9                                 
0231++ F6C9             ;;
0232++ F6C9             ; D = Octave 2-6
0233++ F6C9             ; E = Note 0-11
0234++ F6C9             ; C = 1-15 duration, ~tenths of a second
0235++ F6C9             ;
0236++ F6C9 3E 07       play_note           LD      A, 7
0237++ F6CB 92                              SUB     D
0238++ F6CC 16 00                           LD      D, 0
0239++ F6CE 21 10 F7                        LD      HL, _note_table
0240++ F6D1 19                              ADD     HL, DE
0241++ F6D2 19                              ADD     HL, DE
0242++ F6D3             
0243++ F6D3 5E                              LD      E, (HL)
0244++ F6D4 23                              INC     HL
0245++ F6D5 56                              LD      D, (HL)
0246++ F6D6             
0247++ F6D6 A7          _note_octave        AND     A
0248++ F6D7 28 07                           JR      Z, _note_shifted
0249++ F6D9             
0250++ F6D9 CB 3A                           SRL     D
0251++ F6DB CB 1B                           RR      E
0252++ F6DD 3D                              DEC     A
0253++ F6DE 18 F6                           JR      _note_octave
0254++ F6E0             
0255++ F6E0 41          _note_shifted       LD      B, C
0256++ F6E1 4F                              LD      C, A        ; A is zero from previous octave calc
0257++ F6E2 CB 20                           SLA     B    
0258++ F6E4 CB 20                           SLA     B    
0259++ F6E6 CB 20                           SLA     B    
0260++ F6E8 CB 20                           SLA     B           ; Now BC = 4096 * C
0261++ F6EA             
0262++ F6EA DB 24                           IN      A, (AUDIO_PORT)
0263++ F6EC 32 FD F6                        LD      (_tone_val+1), A
0264++ F6EF F3                              DI
0265++ F6F0             
0266++ F6F0             _tone_loop          ; 186 T-states          
0267++ F6F0 19                              ADD     HL, DE              ; 11
0268++ F6F1 1F                              RRA                         ; 4   Carry into bit 7
0269++ F6F2 CB 2F                           SRA     A                   ; 8   Copy to bit 6
0270++ F6F4 CB 2F                           SRA     A                   ; 8   ..5
0271++ F6F6 CB 2F                           SRA     A                   ; 8   ..4
0272++ F6F8 CB 2F                           SRA     A                   ; 8   ..3
0273++ F6FA             
0274++ F6FA E6 08                           AND     AUDIO_MASK          ; 7
0275++ F6FC EE 00       _tone_val           XOR     0                   ; 7
0276++ F6FE 32 FD F6                        LD      (_tone_val+1), A    ; 13
0277++ F701             
0278++ F701 D3 24                           OUT     (AUDIO_PORT),A      ; 12
0279++ F703             
0280++ F703 78                              LD      A, B                ; 4
0281++ F704 06 05                           LD      B, 5                ; 7
0282++ F706 10 FE                           DJNZ    $                   ; 4 * 13 + 7 = 59
0283++ F708 47                              LD      B, A                ; 4
0284++ F709             
0285++ F709 0B                              DEC     BC                  ; 6
0286++ F70A 78                              LD      A, B                ; 4
0287++ F70B B1                              OR      C                   ; 4
0288++ F70C 20 E2                           JR      NZ, _tone_loop      ; 12
0289++ F70E             
0290++ F70E FB                              EI
0291++ F70F C9                              RET
0292++ F710             
0293++ F710 EB 18       _note_table         .DW 6379
0294++ F712 65 1A                           .DW 6757
0295++ F714 F6 1B                           .DW 7158
0296++ F716 A1 1D                           .DW 7585
0297++ F718 63 1F                           .DW 8035
0298++ F71A 40 21                           .DW 8512
0299++ F71C 3F 23                           .DW 9023
0300++ F71E 51 25                           .DW 9553
0301++ F720 8C 27                           .DW 10124
0302++ F722 EA 29                           .DW 10730
0303++ F724 60 2C                           .DW 11360
0304++ F726 0D 2F                           .DW 12045
0305++ F728 00 00                           .DW 0
0306++ F72A             
0307++ F72A             ;
0308++ F72A             ; Get the next key press
0309++ F72A             ;
0310++ F72A CD A8 F6    get_key             CALL    read_character
0311++ F72D 06 00                           LD      B, 0
0312++ F72F 10 FE                           DJNZ    $
0313++ F731 28 F7                           JR      Z, get_key
0314++ F733 C9                              RET
0315++ F734             ;
0316++ F734             ; Wait for a key to be pressed and released
0317++ F734             ;
0318++ F734             ;
0319++ F734 CD A8 F6    wait_for_key        CALL    read_character
0320++ F737 06 00                           LD      B, 0
0321++ F739 10 FE                           DJNZ    $
0322++ F73B 28 F7                           JR      Z, wait_for_key
0323++ F73D             
0324++ F73D             ;
0325++ F73D             ; wait until there are no keys being pressed
0326++ F73D             ;
0327++ F73D             ;
0328++ F73D CD A8 F6    wait_no_keys        CALL    read_character
0329++ F740 20 FB                           JR      NZ, wait_no_keys
0330++ F742 01 00 00                        LD      BC, 0h              ; Make sure key is released
0331++ F745 ED 78                           IN      A, (C)
0332++ F747 E6 3F                           AND     03Fh
0333++ F749 FE 3F                           CP      03Fh
0334++ F74B 20 F0                           JR      NZ, wait_no_keys
0335++ F74D C9                              RET
0336++ F74E             
0337++ F74E             ; Non-printing key codes
0338++ F74E             ;
0339++ F74E             KEY_ENTER       .EQU    13
0340++ F74E             KEY_DELETE      .EQU    127
0341++ F74E             KEY_CTRL_C      .EQU    03h
0342++ F74E             KEY_CTRL_E      .EQU    05h
0343++ F74E             
0344++ F74E             KEY_CTRL_P      .EQU    10h
0345++ F74E             KEY_CTRL_R      .EQU    12h
0346++ F74E             KEY_CTRL_S      .EQU    13h
0347++ F74E             KEY_CTRL_U      .EQU    15h
0348++ F74E             KEY_CTRL_X      .EQU    18h
0349++ F74E             KEY_CTRL_Z      .EQU    1Ah
0350++ F74E             
0351++ F74E             KEY_BACKSPACE   .EQU    08h
0352++ F74E             
0353++ F74E             ; Modifier and special keys have key codes with the top bit set..
0354++ F74E             ;
0355++ F74E             KEY_UP          .EQU    128
0356++ F74E             KEY_DOWN        .EQU    129
0357++ F74E             KEY_LEFT        .EQU    130
0358++ F74E             KEY_RIGHT       .EQU    131
0359++ F74E             KEY_SHIFT       .EQU    132
0360++ F74E             KEY_CTRL        .EQU    134
0361++ F74E             
0362++ F74E             ; 144 = 90h
0363++ F74E             ;
0364++ F74E             CTRL_KEY_MASK   .EQU    0F8h
0365++ F74E             CTRL_KEY_CHECK  .EQU    090h
0366++ F74E             
0367++ F74E             KEY_CTRL_UP     .EQU    144             ; These characters start on an exact multiple of 8 so they 
0368++ F74E             KEY_CTRL_DOWN   .EQU    145             ; Can easily be detected
0369++ F74E             KEY_CTRL_LEFT   .EQU    146
0370++ F74E             KEY_CTRL_RIGHT  .EQU    147
0371++ F74E             KEY_CTRL_ENTER  .EQU    148
0372++ F74E             KEY_CTRL_SPACE  .EQU    149 
0373++ F74E             
0374++ F74E             _keyboard_size  .EQU    48
0375++ F74E             
0376++ F74E             KEY_SHIFT_BIT   .EQU    1
0377++ F74E             KEY_CTRL_BIT    .EQU    2
0378++ F74E             
0379++ F74E             KEY_REPEAT_DELAY .EQU   40
0380++ F74E             KEY_REPEAT_AFTER .EQU   KEY_REPEAT_DELAY+7
0381++ F74E             
0382++ F74E 76 63 78 7A keyboard        .DB    "vcxz", 0, 0
0382++ F752 00 00 
0383++ F754 67 66 64 73                 .DB    "gfdsa", 0
0383++ F758 61 00 
0384++ F75A 74 72 65 77                 .DB    "trewq", KEY_DOWN
0384++ F75E 71 81 
0385++ F760 35 34 33 32                 .DB    "54321", KEY_UP  
0385++ F764 31 80 
0386++ F766 36 37 38 39                 .DB    "67890", KEY_BACKSPACE
0386++ F76A 30 08 
0387++ F76C 79 75 69 6F                 .DB    "yuiop:"
0387++ F770 70 3A 
0388++ F772 68 6A 6B 6C                 .DB    "hjkl.", KEY_ENTER
0388++ F776 2E 0D 
0389++ F778 62 6E 6D 20                 .DB    "bnm ", KEY_LEFT, KEY_RIGHT
0389++ F77C 82 83 
0390++ F77E             
0391++ F77E 56 43 58 5A _shifted        .DB     "VCXZ", 0, 0
0391++ F782 00 00 
0392++ F784 47 46 44 53                 .DB     "GFDSA", 0
0392++ F788 41 00 
0393++ F78A 54 52 45 57                 .DB     "TREWQ", 0              ; Shift + down?
0393++ F78E 51 00 
0394++ F790 25 24 23 22                 .DB     "%$", 35, 34, "!", 0    ; Shift + up
0394++ F794 21 00 
0395++ F796 5E 26 2A 28                 .DB     "^&*()", 0              ; Shift + delete
0395++ F79A 29 00 
0396++ F79C 59 55 49 4F                 .DB     "YUIOP;"
0396++ F7A0 50 3B 
0397++ F7A2 48 4A 4B 4C                 .DB     "HJKL,", 0              ; Shift + enter
0397++ F7A6 2C 00 
0398++ F7A8 42 4E 4D 00                 .DB     "BNM", 0,0,0            ; Shift left + right
0398++ F7AC 00 00 
0399++ F7AE             
0400++ F7AE 00 03 18 1A _ctrl           .DB    0,KEY_CTRL_C,KEY_CTRL_X,KEY_CTRL_Z,0,0
0400++ F7B2 00 00 
0401++ F7B4 00 00 00 13                 .DB    0,0,0,KEY_CTRL_S,0,0
0401++ F7B8 00 00 
0402++ F7BA 00 12 05 00                 .DB    0,KEY_CTRL_R,KEY_CTRL_E,0,0,KEY_CTRL_DOWN
0402++ F7BE 00 91 
0403++ F7C0 00 00 00 27                 .DB    0,0,0,27h,7Ch,KEY_CTRL_UP ; Vertical bar, single quote
0403++ F7C4 7C 90 
0404++ F7C6 7B 7D 60 5B                 .DB    "{}`[]",KEY_DELETE
0404++ F7CA 5D 7F 
0405++ F7CC 00 15 2B 3D                 .DB    0,KEY_CTRL_U, "+=-", 0
0405++ F7D0 2D 00 
0406++ F7D2 00 3C 40 3E                 .DB    0, "<@>_", KEY_CTRL_ENTER
0406++ F7D6 5F 94 
0407++ F7D8 5C 3F 2F 95                 .DB    "\\?/", KEY_CTRL_SPACE,KEY_CTRL_LEFT,KEY_CTRL_RIGHT
0407++ F7DC 92 93 
0408++ F7DE             
0409++ F7DE 00 00 00 00 _shift_ctrl     .DB    0,0,0,0,0,0
0409++ F7E2 00 00 
0410++ F7E4 00 00 00 00                 .DB    0,0,0,0,0,0
0410++ F7E8 00 00 
0411++ F7EA 00 00 00 00                 .DB    0,0,0,0,0,0
0411++ F7EE 00 00 
0412++ F7F0 00 00 00 00                 .DB    0,0,0,0,0,0
0412++ F7F4 00 00 
0413++ F7F6 00 00 00 00                 .DB    0,0,0,0,0,0
0413++ F7FA 00 00 
0414++ F7FC 00 00 00 00                 .DB    0,0,0,0,KEY_CTRL_P,0
0414++ F800 10 00 
0415++ F802 00 00 00 00                 .DB    0,0,0,0,0,0
0415++ F806 00 00 
0416++ F808 00 00 00 00                 .DB    0,0,0,0,0,0
0416++ F80C 00 00 
1352+  F80E                                 .INCLUDE "../uart.asm"
0001++ F80E             ;
0002++ F80E             ; UART routines..
0003++ F80E             ;
0004++ F80E             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ F80E             ;
0006++ F80E             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ F80E             ;
0008++ F80E             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ F80E             ; of this software and associated documentation files (the "Software"), to deal
0010++ F80E             ; in the Software without restriction, including without limitation the rights
0011++ F80E             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ F80E             ; copies of the Software, and to permit persons to whom the Software is
0013++ F80E             ; furnished to do so, subject to the following conditions:
0014++ F80E             ; 
0015++ F80E             ; The above copyright notice and this permission notice shall be included in all
0016++ F80E             ; copies or substantial portions of the Software.
0017++ F80E             ; 
0018++ F80E             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ F80E             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ F80E             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ F80E             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ F80E             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ F80E             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ F80E             ; SOFTWARE.
0025++ F80E             ;
0026++ F80E                                 .MODULE     uart
0027++ F80E             
0028++ F80E             ;
0029++ F80E             ; Baud rates, assuming 1.8432Mhz crystal
0030++ F80E             ;
0031++ F80E             UART_9600           .EQU    12
0032++ F80E             UART_19200          .EQU    6
0033++ F80E             UART_38400          .EQU    3
0034++ F80E             
0035++ F80E             UART_MODE_AUTO      .EQU    022h   ; Auto flow mode
0036++ F80E             UART_MODE_NO_FLOW   .EQU    000h   ; Auto RTS and CTS disabled
0037++ F80E             UART_MODE_DIAG      .EQU    030h   ; Loopback mode
0038++ F80E             
0039++ F80E             ;
0040++ F80E             ; Various constants
0041++ F80E             ;
0042++ F80E             UART_8N1            .EQU    003h
0043++ F80E             UART_TIMEOUT        .EQU    50000
0044++ F80E             
0045++ F80E             _CTS_STATUS_MASK    .EQU    010h
0046++ F80E             
0047++ F80E             ;
0048++ F80E             ; Set up the UART. Assume it has had time to settle after reset...
0049++ F80E             ;
0050++ F80E             ;
0051++ F80E 01 06 00    uart_init           LD      BC, UART_19200              ; B is flow control, 0 -> No auto flow control
0052++ F811             
0053++ F811 DB 26                           IN      A,(UART_MODEM_STATUS)       ; If CTS is enabled, assume we can use flow control
0054++ F813 E6 10                           AND     _CTS_STATUS_MASK
0055++ F815 28 02                           JR      Z, _no_listener
0056++ F817             
0057++ F817 06 22                           LD      B, UART_MODE_AUTO
0058++ F819                                     
0059++ F819 3E 80       _no_listener        LD      A, 80h                      ; Divisor Latch Setting Mode
0060++ F81B D3 23                           OUT     (UART_LINE_CTRL), A         ;  - entered by writing 1 to bit 7 of LCR
0061++ F81D 00                              NOP
0062++ F81E 00                              NOP
0063++ F81F 79                              LD      A, C
0064++ F820 D3 20                           OUT     (UART_TX_RX), A
0065++ F822 00                              NOP
0066++ F823 00                              NOP
0067++ F824 AF                              XOR     A
0068++ F825 D3 21                           OUT     (UART_INT_ENABLE), A
0069++ F827 00                              NOP
0070++ F828 00                              NOP
0071++ F829             
0072++ F829 3E 03                           LD      A, UART_8N1                 ; Set 8N1 and exit divisor latch setting mode
0073++ F82B D3 23                           OUT     (UART_LINE_CTRL), A
0074++ F82D             
0075++ F82D 3E 07                           LD      A, 07h                      ; Enable and clear FIFO registers
0076++ F82F D3 22                           OUT     (UART_FIFO_CTRL), A
0077++ F831             
0078++ F831 78                              LD      A, B
0079++ F832 A7                              AND     A
0080++ F833 28 02                           JR      Z, _no_flowcontrol
0081++ F835             
0082++ F835 D3 24                           OUT     (UART_MODEM_CTRL), A
0083++ F837             
0084++ F837 00          _no_flowcontrol     NOP
0085++ F838 00                              NOP
0086++ F839 C9                              RET
0087++ F83A             
0088++ F83A             ;
0089++ F83A             ; Send character in A to UART
0090++ F83A             ; Preserves all registers
0091++ F83A             ;
0092++ F83A             ; Carry flag is set on return if the UART send succeeded, clear if it timed out
0093++ F83A             ;
0094++ F83A C5          uart_send           PUSH    BC
0095++ F83B F5                              PUSH    AF
0096++ F83C 01 50 C3                        LD      BC, UART_TIMEOUT
0097++ F83F DB 25       _check_ready        IN      A, (UART_LINE_STATUS)
0098++ F841 CB 6F                           BIT     5, A
0099++ F843 C2 51 F8                        JP      NZ, _uart_ready             ; Bit 5 is set when the UART is ready
0100++ F846 0B                              DEC     BC
0101++ F847 78                              LD      A, B
0102++ F848 B1                              OR      C
0103++ F849 C2 3F F8                        JP      NZ, _check_ready
0104++ F84C             
0105++ F84C F1                              POP     AF
0106++ F84D C1                              POP     BC
0107++ F84E 37                              SCF
0108++ F84F 3F                              CCF
0109++ F850 C9                              RET
0110++ F851             
0111++ F851 F1          _uart_ready         POP     AF
0112++ F852 C1                              POP     BC
0113++ F853 D3 20                           OUT     (UART_TX_RX), A
0114++ F855 37                              SCF
0115++ F856 C9                              RET
0116++ F857             
0117++ F857             ;
0118++ F857             ; Check to see if there are any characters to receive
0119++ F857             ; Preserves all registers
0120++ F857             ;
0121++ F857             ; Returns with carry set if there are characters ready, clear if not
0122++ F857             ;
0123++ F857 F5          uart_ready          PUSH    AF
0124++ F858 DB 25                           IN      A, (UART_LINE_STATUS)
0125++ F85A CB 47                           BIT     0, A
0126++ F85C CA 62 F8                        JP      Z, _not_ready
0127++ F85F F1                              POP     AF
0128++ F860 37                              SCF
0129++ F861 C9                              RET
0130++ F862             
0131++ F862 F1          _not_ready          POP     AF
0132++ F863 37                              SCF
0133++ F864 3F                              CCF
0134++ F865 C9                              RET
0135++ F866             
0136++ F866             ;
0137++ F866             ; Receive a character from the UART in A
0138++ F866             ; 
0139++ F866             ; Returns with a character in A and the carry flag set. If no characters
0140++ F866             ; are available, returns with the carry flag clear.
0141++ F866             ;
0142++ F866 DB 25       uart_receive        IN      A, (UART_LINE_STATUS)
0143++ F868 CB 47                           BIT     0, A
0144++ F86A CA 71 F8                        JP      Z, _no_character
0145++ F86D DB 20                           IN      A, (UART_TX_RX)
0146++ F86F 37                              SCF
0147++ F870 C9                              RET
0148++ F871             
0149++ F871 37          _no_character       SCF
0150++ F872 3F                              CCF
0151++ F873 C9                              RET
0152++ F874             
0153++ F874             ;
0154++ F874             ; Write A as a hex byte
0155++ F874             ; Overwrites A...
0156++ F874             ;
0157++ F874 F5          uart_hex            PUSH    AF
0158++ F875 CB 2F                           SRA     A
0159++ F877 CB 2F                           SRA     A
0160++ F879 CB 2F                           SRA     A
0161++ F87B CB 2F                           SRA     A
0162++ F87D CD 8A F8                        CALL    to_hex
0163++ F880 CD 3A F8                        CALL    uart_send
0164++ F883 F1                              POP     AF
0165++ F884 CD 8A F8                        CALL    to_hex
0166++ F887 C3 3A F8                        JP      uart_send
0167++ F88A             ;
0168++ F88A             ; Returns the low nibble of A as a hex digit
0169++ F88A             ;
0170++ F88A E6 0F       to_hex              AND $0F      ;LOW NIBBLE ONLY
0171++ F88C C6 90                           ADD A,$90
0172++ F88E 27                              DAA 
0173++ F88F CE 40                           ADC A,$40
0174++ F891 27                              DAA 
0175++ F892 C9                              RET 
0176++ F893             ;
0177++ F893             ; Inline send. Sends the zero terminated string immediately following the call to this function to the UART.
0178++ F893             ;  e.g.             CALL    uart_inline
0179++ F893             ;                   .DB     "My text to send", 0
0180++ F893             ;                   <code continues after message...>
0181++ F893             ; Returns with Carry set if the string was successfully sent, otherwise, carry is clear.
0182++ F893             ;
0183++ F893             ; Uses A 
0184++ F893             ;
0185++ F893 E3          uart_inline         EX      (SP), HL
0186++ F894 CD A2 F8                        CALL    uart_string
0187++ F897 DA A0 F8                        JP      C, _inline_end      
0188++ F89A 7E          _find_end           LD      A, (HL)             ; Get the current character  (Carry preserved)
0189++ F89B 23                              INC     HL                  ; Point to next character    (Carry preserved)
0190++ F89C A7                              AND     A                   ; Test if the current character was zero (Clears carry)
0191++ F89D C2 9A F8                        JP      NZ, _find_end       ; If it was, we're done, otherwise repeat
0192++ F8A0 E3          _inline_end         EX      (SP), HL
0193++ F8A1 C9                              RET
0194++ F8A2             ;
0195++ F8A2             ; Send a zero terminated string pointed to by HL to the UART
0196++ F8A2             ;
0197++ F8A2             ; Returns with Carry Set if the string was sent sucessfully, clear otherwise
0198++ F8A2             ;                    
0199++ F8A2 7E          uart_string         LD      A,(HL)
0200++ F8A3 23                              INC     HL
0201++ F8A4 A7                              AND     A
0202++ F8A5 CA AF F8                        JP      Z, _string_end
0203++ F8A8 CD 3A F8                        CALL    uart_send
0204++ F8AB DA A2 F8                        JP      C, uart_string
0205++ F8AE C9                              RET
0206++ F8AF 37          _string_end         SCF
0207++ F8B0 C9                              RET
0208++ F8B1             
0209++ F8B1                                 .MODULE main1353+  F8B1                                 .INCLUDE "../i2c.asm"
0001++ F8B1             ; ============================================ I2C Routines =================================================
0002++ F8B1             ; Software driven I2C for Z80 PIO
0003++ F8B1             ;
0004++ F8B1             ; Assume I2C clock is on Port B bit 6
0005++ F8B1             ;            data is on Port B bit 7
0006++ F8B1             ;
0007++ F8B1             ;
0008++ F8B1             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0009++ F8B1             ;
0010++ F8B1             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0011++ F8B1             ;
0012++ F8B1             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0013++ F8B1             ; of this software and associated documentation files (the "Software"), to deal
0014++ F8B1             ; in the Software without restriction, including without limitation the rights
0015++ F8B1             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0016++ F8B1             ; copies of the Software, and to permit persons to whom the Software is
0017++ F8B1             ; furnished to do so, subject to the following conditions:
0018++ F8B1             ; 
0019++ F8B1             ; The above copyright notice and this permission notice shall be included in all
0020++ F8B1             ; copies or substantial portions of the Software.
0021++ F8B1             ; 
0022++ F8B1             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0023++ F8B1             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0024++ F8B1             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0025++ F8B1             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0026++ F8B1             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0027++ F8B1             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0028++ F8B1             ; SOFTWARE.
0029++ F8B1             ;
0030++ F8B1                                 .MODULE i2c
0031++ F8B1             
0032++ F8B1 3E CF       init_portb          LD      A, PIO_MODE_3           ; Port B mode 3
0033++ F8B3 32 00 FF                        LD      (port_b_mode), A
0034++ F8B6 D3 13                           OUT     (PIO_B_CTRL), A
0035++ F8B8             
0036++ F8B8 3E FF                           LD      A, PORT_B_IOMASK        ;
0037++ F8BA 32 01 FF                        LD      (port_b_dir), A
0038++ F8BD D3 13                           OUT     (PIO_B_CTRL), A
0039++ F8BF             
0040++ F8BF 3E 3F                           LD      A, 03Fh                 ; All bits high apart from D7, D6
0041++ F8C1 32 02 FF                        LD      (port_b_data),A
0042++ F8C4 D3 11                           OUT     (PIO_B_DATA), A         ; Changing D7 or D6 to an output will drive the lines low
0043++ F8C6 C9                              RET
0044++ F8C7             
0045++ F8C7             ; Reset the bus
0046++ F8C7             ;
0047++ F8C7             ; Uses A, B, D
0048++ F8C7 06 0A       i2c_bus_reset       LD      B, 0ah          ; ten cycles
0049++ F8C9 CD DC F9    _loop_b             CALL    i2c_scl_cycle
0050++ F8CC 10 FB                           DJNZ    _loop_b
0051++ F8CE CD CC F9                        CALL    i2c_scl_high
0052++ F8D1 06 F0                           LD      B, 0F0h
0053++ F8D3 10 FE                           DJNZ    $
0054++ F8D5 C9                              RET
0055++ F8D6             
0056++ F8D6             ;
0057++ F8D6             ; Uses A
0058++ F8D6 CD AC F9    i2c_start           CALL    i2c_sda_high
0059++ F8D9 CD CC F9                        CALL    i2c_scl_high
0060++ F8DC CD BC F9                        CALL    i2c_sda_low     ; Drive data low
0061++ F8DF C3 9C F9                        JP      i2c_scl_low     ; Drive clock low
0062++ F8E2             
0063++ F8E2             
0064++ F8E2             ;
0065++ F8E2             ; Read a byte from Device address H, Register L into A
0066++ F8E2             ; Calls i2c_start, sets address, reads byte and then calls i2c_stop
0067++ F8E2             ; Returns With Carry SET and A containing the register value, or Carry CLEAR if no acknowledge
0068++ F8E2             ; Uses A, B, C, D, H, L
0069++ F8E2             ; Preserves H, L
0070++ F8E2 CD FC F8    i2c_read_byte       CALL    i2c_read_from
0071++ F8E5                                 ; Fall through into stop
0072++ F8E5                             
0073++ F8E5             ;
0074++ F8E5             ; Uses A
0075++ F8E5 CD BC F9    i2c_stop            CALL    i2c_sda_low     ; Drive data low
0076++ F8E8 CD CC F9                        CALL    i2c_scl_high
0077++ F8EB C3 AC F9                        JP      i2c_sda_high
0078++ F8EE             
0079++ F8EE             ; Write a byte in C to Device address H, register L
0080++ F8EE             ; Returns with Carry SET if OK, CLEAR if no acknowledgement
0081++ F8EE             ; Calls i2c_stop when done..
0082++ F8EE             ;
0083++ F8EE             ; Preserves H, L
0084++ F8EE C5          i2c_write_byte      PUSH    BC
0085++ F8EF CD 1D F9                        CALL    i2c_write_to
0086++ F8F2 C1                              POP     BC
0087++ F8F3 D2 E5 F8                        JP      NC, i2c_stop
0088++ F8F6 79                              LD      A, C
0089++ F8F7 CD 31 F9                        CALL    i2c_write
0090++ F8FA 18 E9                           JR      i2c_stop
0091++ F8FC                                 
0092++ F8FC             ;
0093++ F8FC             ; Read a byte from Device address H, Register L
0094++ F8FC             ; Calls i2c_start, but does NOT call i2c_stop
0095++ F8FC             ; Returns With Carry SET and A containing the register value, or Carry CLEAR if no acknowledge
0096++ F8FC             ; Uses A, B, C, D, H, L
0097++ F8FC             ; Preserves H, L
0098++ F8FC CD D6 F8    i2c_read_from       CALL    i2c_start
0099++ F8FF 7C                              LD      A, H
0100++ F900 CD 2F F9                        CALL    i2c_address_w
0101++ F903 30 17                           JR      NC, _read_end
0102++ F905 7D                              LD      A, L
0103++ F906 CD 31 F9                        CALL    i2c_write
0104++ F909 30 11                           JR      NC, _read_end
0105++ F90B 06 32                           LD      B, 50
0106++ F90D 10 FE       _read_pause         DJNZ    _read_pause
0107++ F90F CD D6 F8                        CALL    i2c_start
0108++ F912 7C                              LD      A, H
0109++ F913 CD 29 F9                        CALL    i2c_address_r
0110++ F916 30 04                           JR      NC, _read_end
0111++ F918 CD 3E F9                        CALL    i2c_read
0112++ F91B 37                              SCF
0113++ F91C C9          _read_end           RET
0114++ F91D             
0115++ F91D             
0116++ F91D             ;
0117++ F91D             ; Prepare to write to Device address H, Register L
0118++ F91D             ; Calls i2c_start, but does NOT call i2c_stop
0119++ F91D             ; Returns with Carry SET if OK, CLEAR if no acknowledgement
0120++ F91D             ;
0121++ F91D             ; Preserves H, L
0122++ F91D CD D6 F8    i2c_write_to        CALL    i2c_start
0123++ F920 7C                              LD      A, H
0124++ F921 CD 2F F9                        CALL    i2c_address_w
0125++ F924 D0                              RET     NC
0126++ F925 7D                              LD      A, L
0127++ F926 C3 31 F9                        JP      i2c_write
0128++ F929             
0129++ F929             ; Start reading from device address held in A
0130++ F929             ;
0131++ F929             ; Uses A, B, C, D
0132++ F929 CB 27       i2c_address_r       SLA     A
0133++ F92B F6 01                           OR      1
0134++ F92D 18 02                           JR      i2c_write
0135++ F92F             
0136++ F92F             ; Start writing to device address held in A
0137++ F92F             ;
0138++ F92F             ; Uses A, B, C, D
0139++ F92F CB 27       i2c_address_w       SLA     A
0140++ F931             
0141++ F931             ; Write A as a byte to i2c bus
0142++ F931             ; Returns Carry CLEAR if no acknowledge
0143++ F931             ;
0144++ F931             ; Uses A, B, C, D
0145++ F931 CD 59 F9    i2c_write           CALL    i2c_send_byte
0146++ F934 CB 7A                           BIT     I2C_DATA_BIT, D     ; D contains acknowledge bit
0147++ F936 37                              SCF
0148++ F937 C8                              RET     Z               ; Return with carry set if acknowledge bit is low
0149++ F938             
0150++ F938 CD E5 F8                        CALL    i2c_stop        ; Stop bus if error
0151++ F93B 37                              SCF
0152++ F93C 3F                              CCF
0153++ F93D C9                              RET                     ; Clear carry if acknowledge is high
0154++ F93E             
0155++ F93E             ; Read byte from i2C into A, without ACK
0156++ F93E             ;
0157++ F93E             ; Uses A, B, C, D
0158++ F93E 06 08       i2c_read            LD      B, 8h
0159++ F940 DB 11       _loop_r             IN      A, (PIO_B_DATA)
0160++ F942 37                              SCF
0161++ F943 CB 7F                           BIT     I2C_DATA_BIT, A
0162++ F945 20 01                           JR      NZ, _data_high
0163++ F947 3F                              CCF
0164++ F948 CB 11       _data_high          RL      C
0165++ F94A CD DC F9                        CALL    i2c_scl_cycle
0166++ F94D 10 F1                           DJNZ    _loop_r
0167++ F94F                                 ; CALL    i2c_scl_cycle
0168++ F94F             
0169++ F94F 79                              LD      A, C
0170++ F950 C9                              RET
0171++ F951             
0172++ F951             ;
0173++ F951             ; Send an ACK..
0174++ F951             ;
0175++ F951 CD BC F9    i2c_ack             CALL    i2c_sda_low
0176++ F954 CD DC F9                        CALL    i2c_scl_cycle
0177++ F957 18 53                           JR      i2c_sda_high
0178++ F959             
0179++ F959             ;
0180++ F959             ; Send a byte in A, returning the ACK state in D
0181++ F959             ; Uses A, B, C,
0182++ F959             ;
0183++ F959 E5          i2c_send_byte       PUSH    HL
0184++ F95A D5                              PUSH    DE
0185++ F95B 2A 00 FF                        LD      HL, (port_b_mode)           ; L = port_b_mode, H = port_b_dir
0186++ F95E 57                              LD      D, A
0187++ F95F                                 
0188++ F95F 3E 3F                           LD      A, ~(I2C_DATA_MASK|I2C_CLK_MASK)           ; Set SDA and SCL (port_b_dir bit) LOW
0189++ F961 A4                              AND     H
0190++ F962 CB 27                           SLA     A
0191++ F964 67                              LD      H, A
0192++ F965             
0193++ F965 0E 13                           LD      C, PIO_B_CTRL
0194++ F967 06 08                           LD      B, 8
0195++ F969             
0196++ F969 1E 40                           LD      E, I2C_CLK_MASK
0197++ F96B             
0198++ F96B 7C          _fast_loop          LD      A, H
0199++ F96C CB 22                           SLA     D
0200++ F96E CB 1F                           RR      A
0201++ F970 ED 69                           OUT     (C),L
0202++ F972 D3 13                           OUT     (PIO_B_CTRL), A
0203++ F974             
0204++ F974 B3                              OR      E
0205++ F975 ED 69                           OUT     (C), L
0206++ F977 D3 13                           OUT     (PIO_B_CTRL), A                 ; Clock high
0207++ F979             
0208++ F979 AB                              XOR     E
0209++ F97A ED 69                           OUT     (C), L
0210++ F97C D3 13                           OUT     (PIO_B_CTRL),A                  ; Clock low
0211++ F97E 10 EB                           DJNZ    _fast_loop
0212++ F980             
0213++ F980 7C                              LD      A, H
0214++ F981 37                              SCF
0215++ F982 CB 1F                           RR      A
0216++ F984 ED 69                           OUT     (C),L                           ; Release SDA
0217++ F986 D3 13                           OUT     (PIO_B_CTRL), A
0218++ F988             
0219++ F988 B3                              OR      E
0220++ F989 ED 69                           OUT     (C), L
0221++ F98B D3 13                           OUT     (PIO_B_CTRL), A                 ; Clock high
0222++ F98D             
0223++ F98D ED 69                           OUT     (C), L
0224++ F98F AB                              XOR     E
0225++ F990 6F                              LD      L, A
0226++ F991 32 01 FF                        LD      (port_b_dir), A
0227++ F994             
0228++ F994 DB 11                           IN      A, (PIO_B_DATA)                 ; Read ACK
0229++ F996 ED 69                           OUT     (C),L                           ; Clock low
0230++ F998             
0231++ F998 D1                              POP     DE
0232++ F999 E1                              POP     HL
0233++ F99A 57                              LD      D, A
0234++ F99B C9                              RET
0235++ F99C             
0236++ F99C             ; SCL/SDA toggle routines
0237++ F99C             ;
0238++ F99C             ; All use A
0239++ F99C 3A 00 FF    i2c_scl_low         LD      A, (port_b_mode)
0240++ F99F D3 13                           OUT     (PIO_B_CTRL), A
0241++ F9A1             
0242++ F9A1 3A 01 FF                        LD      A, (port_b_dir)
0243++ F9A4 CB B7                           RES     I2C_CLK_BIT, A
0244++ F9A6 D3 13                           OUT     (PIO_B_CTRL), A
0245++ F9A8 32 01 FF                        LD      (port_b_dir), A
0246++ F9AB C9                              RET
0247++ F9AC             
0248++ F9AC 3A 00 FF    i2c_sda_high        LD      A, (port_b_mode)
0249++ F9AF D3 13                           OUT     (PIO_B_CTRL), A
0250++ F9B1             
0251++ F9B1 3A 01 FF                        LD      A, (port_b_dir)
0252++ F9B4 CB FF                           SET     I2C_DATA_BIT, A
0253++ F9B6 D3 13                           OUT     (PIO_B_CTRL), A
0254++ F9B8 32 01 FF                        LD      (port_b_dir), A
0255++ F9BB C9                              RET
0256++ F9BC             
0257++ F9BC 3A 00 FF    i2c_sda_low         LD      A, (port_b_mode)
0258++ F9BF D3 13                           OUT     (PIO_B_CTRL), A
0259++ F9C1             
0260++ F9C1 3A 01 FF                        LD      A, (port_b_dir)
0261++ F9C4 CB BF                           RES     I2C_DATA_BIT, A
0262++ F9C6 D3 13                           OUT     (PIO_B_CTRL), A
0263++ F9C8 32 01 FF                        LD      (port_b_dir), A
0264++ F9CB C9                              RET
0265++ F9CC             
0266++ F9CC 3A 00 FF    i2c_scl_high        LD      A, (port_b_mode)
0267++ F9CF D3 13                           OUT     (PIO_B_CTRL), A
0268++ F9D1             
0269++ F9D1 3A 01 FF                        LD      A, (port_b_dir)
0270++ F9D4 CB F7                           SET     I2C_CLK_BIT, A
0271++ F9D6 D3 13                           OUT     (PIO_B_CTRL), A
0272++ F9D8 32 01 FF                        LD      (port_b_dir), A
0273++ F9DB C9                              RET
0274++ F9DC             
0275++ F9DC C5          i2c_scl_cycle       PUSH   BC
0276++ F9DD 01 13 00                        LD     BC, PIO_B_CTRL
0277++ F9E0 3A 00 FF                        LD     A, (port_b_mode)
0278++ F9E3 57                              LD     D, A
0279++ F9E4 3A 01 FF                        LD     A, (port_b_dir)
0280++ F9E7             
0281++ F9E7 CB B7                           RES    I2C_CLK_BIT, A
0282++ F9E9 32 01 FF                        LD     (port_b_dir), A
0283++ F9EC ED 51                           OUT    (C), D
0284++ F9EE D3 13                           OUT    (PIO_B_CTRL), A
0285++ F9F0                                 
0286++ F9F0 CB F7                           SET    I2C_CLK_BIT, A
0287++ F9F2 ED 51                           OUT    (C), D
0288++ F9F4 D3 13                           OUT    (PIO_B_CTRL), A
0289++ F9F6                                 
0290++ F9F6 DB 11                           IN     A, (PIO_B_DATA)
0291++ F9F8 ED 51                           OUT    (C), D
0292++ F9FA 57                              LD     D, A
0293++ F9FB 3A 01 FF                        LD     A, (port_b_dir)
0294++ F9FE D3 13                           OUT    (PIO_B_CTRL), A
0295++ FA00 C1                              POP    BC
0296++ FA01 C9                              RET
0297++ FA02             
0298++ FA02                                 .MODULE main
1354+  FA02             
1355+  FA02                                 .INCLUDE "../disp.asm"
0001++ FA02             ; ========================================== Display Routines ===============================================
0002++ FA02             ;
0003++ FA02             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0004++ FA02             ;
0005++ FA02             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0006++ FA02             ;
0007++ FA02             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0008++ FA02             ; of this software and associated documentation files (the "Software"), to deal
0009++ FA02             ; in the Software without restriction, including without limitation the rights
0010++ FA02             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0011++ FA02             ; copies of the Software, and to permit persons to whom the Software is
0012++ FA02             ; furnished to do so, subject to the following conditions:
0013++ FA02             ; 
0014++ FA02             ; The above copyright notice and this permission notice shall be included in all
0015++ FA02             ; copies or substantial portions of the Software.
0016++ FA02             ; 
0017++ FA02             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0018++ FA02             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0019++ FA02             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0020++ FA02             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0021++ FA02             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0022++ FA02             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0023++ FA02             ; SOFTWARE.
0024++ FA02             ;
0025++ FA02                                 .MODULE disp
0026++ FA02             
0027++ FA02             CONFIG_PAGE         .EQU    3
0028++ FA02             BRIGHT_PAGE         .EQU    1
0029++ FA02             LED_PAGE            .EQU    0 
0030++ FA02             
0031++ FA02 CD 6A FB    display_init        CALL    disp_clear
0032++ FA05 1E 80                           LD      E, DISP_DEFAULT_BRIGHTNESS
0033++ FA07 CD 42 FA                        CALL    disp_brightness
0034++ FA0A             
0035++ FA0A CD 16 FA                        CALL    disp_select_l
0036++ FA0D CD 22 FA                        CALL    disp_config
0037++ FA10             
0038++ FA10 CD 1C FA                        CALL    disp_select_r
0039++ FA13 CD 22 FA                        CALL    disp_config
0040++ FA16             
0041++ FA16 3E 50       disp_select_l       LD      A, DL_ADDRESS
0042++ FA18 32 03 FF                        LD      (display_address), A
0043++ FA1B C9                              RET
0044++ FA1C             
0045++ FA1C 3E 53       disp_select_r       LD      A, DR_ADDRESS
0046++ FA1E 32 03 FF                        LD      (display_address), A
0047++ FA21 C9                              RET
0048++ FA22             
0049++ FA22 2E 03       disp_config         LD      L, CONFIG_PAGE
0050++ FA24 CD 7D FA                        CALL    disp_page
0051++ FA27 CD D6 F8                        CALL    i2c_start
0052++ FA2A 3A 03 FF                        LD      A, (display_address)
0053++ FA2D CD 2F F9                        CALL    i2c_address_w
0054++ FA30 3E 00                           LD      A, 000h
0055++ FA32 CD 31 F9                        CALL    i2c_write
0056++ FA35 3E 01                           LD      A, 001h         ; Turn display on
0057++ FA37 CD 31 F9                        CALL    i2c_write
0058++ FA3A 3E 78                           LD      A, 078h         ; 0.020mA
0059++ FA3C CD 31 F9                        CALL    i2c_write
0060++ FA3F C3 E5 F8                        JP      i2c_stop
0061++ FA42             
0062++ FA42             ;
0063++ FA42             ; Sets the brightness for the display
0064++ FA42             ; Enter with E set to the desired brightness for all segments
0065++ FA42             ;
0066++ FA42 CD 16 FA    disp_brightness     CALL    disp_select_l
0067++ FA45 CD 4B FA                        CALL    _set_bright
0068++ FA48 CD 1C FA                        CALL    disp_select_r
0069++ FA4B 2E 01       _set_bright         LD      L, BRIGHT_PAGE
0070++ FA4D CD 7D FA                        CALL    disp_page
0071++ FA50 2E 0C                           LD      L, 12
0072++ FA52 CD D6 F8    _bright_loop        CALL    i2c_start
0073++ FA55 3A 03 FF                        LD      A, (display_address)
0074++ FA58 CD 2F F9                        CALL    i2c_address_w
0075++ FA5B 7D                              LD      A, L
0076++ FA5C 3D                              DEC     A
0077++ FA5D CB 27                           SLA     A
0078++ FA5F CB 27                           SLA     A
0079++ FA61 CB 27                           SLA     A
0080++ FA63 CB 27                           SLA     A
0081++ FA65 CD 31 F9                        CALL    i2c_write
0082++ FA68 26 10                           LD      H, 010h
0083++ FA6A 7B          _bright_byte        LD      A, E
0084++ FA6B CD 31 F9                        CALL    i2c_write
0085++ FA6E 25                              DEC     H
0086++ FA6F 20 F9                           JR      NZ, _bright_byte
0087++ FA71 CD E5 F8                        CALL    i2c_stop
0088++ FA74 2D                              DEC     L
0089++ FA75 20 DB                           JR      NZ, _bright_loop
0090++ FA77 2E 00                           LD      L, LED_PAGE
0091++ FA79 CD 7D FA                        CALL    disp_page
0092++ FA7C C9                              RET
0093++ FA7D             
0094++ FA7D             ; Set the Page number
0095++ FA7D             ; Call with page number in L
0096++ FA7D             ;
0097++ FA7D             ; Uses A, B, C, D
0098++ FA7D CD 95 FA    disp_page           CALL    disp_unlock
0099++ FA80 CD D6 F8                        CALL    i2c_start
0100++ FA83 3A 03 FF                        LD      A, (display_address)
0101++ FA86 CD 2F F9                        CALL    i2c_address_w
0102++ FA89 3E FD                           LD      A, 0FDh
0103++ FA8B CD 31 F9                        CALL    i2c_write
0104++ FA8E 7D                              LD      A, L
0105++ FA8F CD 31 F9                        CALL    i2c_write
0106++ FA92 C3 E5 F8                        JP      i2c_stop
0107++ FA95             
0108++ FA95 CD D6 F8    disp_unlock         CALL    i2c_start           ; Must be called before switching pages
0109++ FA98 3A 03 FF                        LD      A, (display_address)
0110++ FA9B CD 2F F9                        CALL    i2c_address_w
0111++ FA9E 3E FE                           LD      A, DISP_REG_CRWL
0112++ FAA0 CD 31 F9                        CALL    i2c_write
0113++ FAA3 3E C5                           LD      A, DISP_UNLOCK
0114++ FAA5 CD 31 F9                        CALL    i2c_write
0115++ FAA8 C3 E5 F8                        JP      i2c_stop
0116++ FAAB             
0117++ FAAB             ; Set the character at column A to brightness C
0118++ FAAB             ;
0119++ FAAB             ;
0120++ FAAB C5          disp_char_bright    PUSH    BC
0121++ FAAC 06 50                           LD      B, DL_ADDRESS
0122++ FAAE FE 0C                           CP      12
0123++ FAB0 DA B7 FA                        JP      C, _bright_left
0124++ FAB3 06 53                           LD      B, DR_ADDRESS
0125++ FAB5 D6 0C                           SUB     12
0126++ FAB7 5F          _bright_left        LD      E, A
0127++ FAB8 78                              LD      A, B
0128++ FAB9 32 03 FF                        LD      (display_address), A
0129++ FABC 2E 01                           LD      L, BRIGHT_PAGE
0130++ FABE CD 7D FA                        CALL    disp_page
0131++ FAC1             
0132++ FAC1 CD D6 F8                        CALL    i2c_start
0133++ FAC4 3A 03 FF                        LD      A, (display_address)
0134++ FAC7 CD 2F F9                        CALL    i2c_address_w
0135++ FACA 7B                              LD      A, E
0136++ FACB CB 27                           SLA     A
0137++ FACD CB 27                           SLA     A
0138++ FACF CB 27                           SLA     A
0139++ FAD1 CB 27                           SLA     A
0140++ FAD3 CD 31 F9                        CALL    i2c_write
0141++ FAD6 E1                              POP     HL
0142++ FAD7 26 10                           LD      H, 010h
0143++ FAD9 7D          _bright_char_loop   LD      A, L
0144++ FADA CD 31 F9                        CALL    i2c_write
0145++ FADD 25                              DEC     H
0146++ FADE 20 F9                           JR      NZ, _bright_char_loop
0147++ FAE0 CD E5 F8                        CALL    i2c_stop
0148++ FAE3             
0149++ FAE3 2E 00                           LD      L, LED_PAGE
0150++ FAE5 CD 7D FA                        CALL    disp_page
0151++ FAE8 C9                              RET
0152++ FAE9                                 
0153++ FAE9             ; Display a single character A at column C
0154++ FAE9             ;
0155++ FAE9             ; Returns with A pointing to next column
0156++ FAE9             ;
0157++ FAE9 FE 20       disp_character      CP      32
0158++ FAEB F2 F5 FA                        JP      P, _not_control
0159++ FAEE             
0160++ FAEE 21 61 48    _invalid_char       LD      HL, INVALID_CHAR_BITMASK
0161++ FAF1 79                              LD      A, C
0162++ FAF2 C3 0A FB                        JP      disp_bitmask
0163++ FAF5             
0164++ FAF5 CB 7F       _not_control        BIT     7, A
0165++ FAF7 C2 EE FA                        JP      NZ, _invalid_char
0166++ FAFA D6 20                           SUB     32
0167++ FAFC             
0168++ FAFC 16 00                           LD      D, 0
0169++ FAFE 5F                              LD      E, A
0170++ FAFF CB 23                           SLA     E                   ; Don't need to shift into D, since bit 7 is zero
0171++ FB01 21 78 FB                        LD      HL, font  
0172++ FB04 19                              ADD     HL, DE
0173++ FB05 56                              LD      D, (HL)
0174++ FB06 23                              INC     HL
0175++ FB07 66                              LD      H, (HL)
0176++ FB08 6A                              LD      L, D
0177++ FB09 79                              LD      A, C
0178++ FB0A                                 ; Fall into disp_bitmask
0179++ FB0A             
0180++ FB0A             ; Display a bitmask in HL at column A (0 - 23)
0181++ FB0A             ;
0182++ FB0A             ; Returns with A pointing to next column
0183++ FB0A             ;
0184++ FB0A             ; Uses A, B, C, D, E
0185++ FB0A F5          disp_bitmask        PUSH    AF
0186++ FB0B 06 50                           LD      B, DL_ADDRESS
0187++ FB0D FE 0C                           CP      12
0188++ FB0F DA 16 FB                        JP      C, _disp_left
0189++ FB12 06 53                           LD      B, DR_ADDRESS
0190++ FB14 D6 0C                           SUB     12
0191++ FB16 5F          _disp_left          LD      E, A
0192++ FB17 CD D6 F8                        CALL    i2c_start
0193++ FB1A 78                              LD      A, B
0194++ FB1B CD 2F F9                        CALL    i2c_address_w
0195++ FB1E 7B                              LD      A, E
0196++ FB1F CB 27                           SLA     A
0197++ FB21 CD 31 F9                        CALL    i2c_write
0198++ FB24 7D                              LD      A, L
0199++ FB25 CD 31 F9                        CALL    i2c_write
0200++ FB28 7C                              LD      A, H
0201++ FB29 CD 31 F9                        CALL    i2c_write
0202++ FB2C CD E5 F8                        CALL    i2c_stop
0203++ FB2F F1                              POP     AF
0204++ FB30 3C                              INC     A
0205++ FB31 C9                              RET
0206++ FB32             
0207++ FB32             
0208++ FB32 C3 0A FB                        JP      disp_bitmask
0209++ FB35             ;
0210++ FB35             ; Clear the display and show an inline string from column 0
0211++ FB35             ;
0212++ FB35 CD 6A FB    disp_clear_inline   CALL    disp_clear
0213++ FB38 AF                              XOR     A
0214++ FB39             ;
0215++ FB39             ; Display an inline string to column A->
0216++ FB39             ;
0217++ FB39 E3          disp_inline         EX      (SP), HL
0218++ FB3A CD 40 FB                        CALL    disp_string
0219++ FB3D 23                              INC     HL
0220++ FB3E E3                              EX      (SP), HL
0221++ FB3F C9                              RET
0222++ FB40             
0223++ FB40             ; Display a string pointed to by HL to column A->
0224++ FB40             ; Note string should be zero terminated...
0225++ FB40             ; Returns with HL pointing to the 0 terminator
0226++ FB40             ;
0227++ FB40 5F          disp_string         LD      E, A
0228++ FB41 7E                              LD      A, (HL)
0229++ FB42 B7                              OR      A
0230++ FB43 C2 47 FB                        JP      NZ, _char_ok
0231++ FB46 C9                              RET
0232++ FB47             
0233++ FB47 D6 20       _char_ok            SUB     32
0234++ FB49 F2 51 FB                        JP      P, _char_ok2
0235++ FB4C 21 61 48                        LD      HL, INVALID_CHAR_BITMASK
0236++ FB4F 18 10                           JR      _show_char
0237++ FB51             
0238++ FB51 06 00       _char_ok2           LD      B, 0
0239++ FB53 4F                              LD      C, A
0240++ FB54 E5                              PUSH    HL
0241++ FB55 21 78 FB                        LD      HL, font
0242++ FB58 CB 21                           SLA     C
0243++ FB5A CB 10                           RL      B
0244++ FB5C 09                              ADD     HL, BC
0245++ FB5D 4E                              LD      C, (HL)
0246++ FB5E 23                              INC     HL
0247++ FB5F 66                              LD      H, (HL)
0248++ FB60 69                              LD      L, C
0249++ FB61 7B          _show_char          LD      A, E
0250++ FB62 CD 0A FB                        CALL    disp_bitmask
0251++ FB65 E1                              POP     HL
0252++ FB66 23                              INC     HL
0253++ FB67 C3 40 FB                        JP      disp_string
0254++ FB6A             
0255++ FB6A             ; Clear the display
0256++ FB6A             ;
0257++ FB6A 3E 00       disp_clear          LD      A, 0
0258++ FB6C 21 00 00                        LD      HL, 0
0259++ FB6F CD 0A FB    _clear_loop         CALL    disp_bitmask
0260++ FB72 FE 18                           CP      24
0261++ FB74 C2 6F FB                        JP      NZ, _clear_loop
0262++ FB77 C9                              RET
0263++ FB78             
0264++ FB78                                 .MODULE main1356+  FB78                                 .INCLUDE "../font.asm"
0001++ FB78             ;
0002++ FB78             ; Font definition
0003++ FB78             ;
0004++ FB78             ;
0005++ FB78             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006++ FB78             ;
0007++ FB78             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008++ FB78             ;
0009++ FB78             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010++ FB78             ; of this software and associated documentation files (the "Software"), to deal
0011++ FB78             ; in the Software without restriction, including without limitation the rights
0012++ FB78             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013++ FB78             ; copies of the Software, and to permit persons to whom the Software is
0014++ FB78             ; furnished to do so, subject to the following conditions:
0015++ FB78             ; 
0016++ FB78             ; The above copyright notice and this permission notice shall be included in all
0017++ FB78             ; copies or substantial portions of the Software.
0018++ FB78             ; 
0019++ FB78             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020++ FB78             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021++ FB78             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022++ FB78             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023++ FB78             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024++ FB78             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025++ FB78             ; SOFTWARE.
0026++ FB78             ;
0027++ FB78             
0028++ FB78             INVALID_CHAR_BITMASK    .EQU 04861h
0029++ FB78             
0030++ FB78             font
0031++ FB78 00 00                           .dw     0000h
0032++ FB7A 00 49                           .dw     4900h   ; !
0033++ FB7C 02 02                           .dw     0202h   ; "
0034++ FB7E CE 12                           .dw     12ceh   ; #
0035++ FB80 ED 12                           .dw     12edh   ; $
0036++ FB82 E4 2D                           .dw     2de4h   ; %
0037++ FB84 59 0B                           .dw     0b59h   ; &
0038++ FB86 00 02                           .dw     0200h   ; '
0039++ FB88 00 0C                           .dw     0c00h   ; (
0040++ FB8A 00 21                           .dw     2100h   ; )
0041++ FB8C C0 3F                           .dw     3fc0h   ; *
0042++ FB8E C0 12                           .dw     12c0h   ; +
0043++ FB90 00 20                           .dw     2000h   ; ,
0044++ FB92 C0 00                           .dw     00c0h   ; -
0045++ FB94 00 40                           .dw     4000h   ; .
0046++ FB96 00 24                           .dw     2400h   ; /
0047++ FB98             
0048++ FB98 3F 24                           .dw     243fh   ; 0
0049++ FB9A 06 04                           .dw     0406h   ; 1
0050++ FB9C DB 00                           .dw     00dbh   ; 2
0051++ FB9E 8F 00                           .dw     008fh   ; 3
0052++ FBA0 E6 00                           .dw     00e6h   ; 4
0053++ FBA2 69 08                           .dw     0869h   ; 5
0054++ FBA4 FD 00                           .dw     00fdh   ; 6
0055++ FBA6 01 14                           .dw     1401h   ; 7
0056++ FBA8 FF 00                           .dw     00ffh   ; 8
0057++ FBAA EF 00                           .dw     00efh   ; 9
0058++ FBAC 40 00                           .dw     0040h   ; :
0059++ FBAE 00 22                           .dw     2200h   ; ;
0060++ FBB0 40 0C                           .dw     0c40h   ; <
0061++ FBB2 C8 00                           .dw     00c8h   ; = 
0062++ FBB4 80 21                           .dw     2180h   ; >
0063++ FBB6 83 50                           .dw     5083h   ; ?
0064++ FBB8             
0065++ FBB8 BB 02                           .dw     02bbh   ; @
0066++ FBBA F7 00                           .dw     00f7h   ; A
0067++ FBBC 8F 12                           .dw     128fh   ; B
0068++ FBBE 39 00                           .dw     0039h   ; C
0069++ FBC0 0F 12                           .dw     120fh   ; D
0070++ FBC2 79 00                           .dw     0079h   ; E
0071++ FBC4 71 00                           .dw     0071h   ; F
0072++ FBC6 BD 00                           .dw     00bdh   ; G
0073++ FBC8 F6 00                           .dw     00f6h   ; H
0074++ FBCA 09 12                           .dw     1209h   ; I
0075++ FBCC 1E 00                           .dw     001eh   ; J
0076++ FBCE 70 0C                           .dw     0c70h   ; K
0077++ FBD0 38 00                           .dw     0038h   ; L
0078++ FBD2 36 05                           .dw     0536h   ; M
0079++ FBD4 36 09                           .dw     0936h   ; N
0080++ FBD6 3F 00                           .dw     003fh   ; O
0081++ FBD8             
0082++ FBD8 F3 00                           .dw     00f3h   ; P
0083++ FBDA 3F 08                           .dw     083fh   ; Q
0084++ FBDC F3 08                           .dw     08f3h   ; R
0085++ FBDE ED 00                           .dw     00edh   ; S
0086++ FBE0 01 12                           .dw     1201h   ; T
0087++ FBE2 3E 00                           .dw     003eh   ; U
0088++ FBE4 30 24                           .dw     2430h   ; V
0089++ FBE6 36 28                           .dw     2836h   ; W
0090++ FBE8 00 2D                           .dw     2d00h   ; X
0091++ FBEA EE 00                           .dw     00eeh   ; Y
0092++ FBEC 09 24                           .dw     2409h   ; Z
0093++ FBEE 39 00                           .dw     0039h   ; [
0094++ FBF0 00 09                           .dw     0900h   ; \
0095++ FBF2 0F 00                           .dw     000fh   ; ]
0096++ FBF4 00 28                           .dw     2800h   ; ^
0097++ FBF6 08 00                           .dw     0008h   ; _
0098++ FBF8             
0099++ FBF8 00 01                           .dw     0100h   ; `
0100++ FBFA 8C 20                           .dw     208ch   ; a
0101++ FBFC 78 08                           .dw     0878h   ; b
0102++ FBFE D8 00                           .dw     00d8h   ; c
0103++ FC00 8E 20                           .dw     208eh   ; d 
0104++ FC02 58 20                           .dw     2058h   ; e 
0105++ FC04 C0 14                           .dw     14c0h   ; f
0106++ FC06 8E 04                           .dw     048eh   ; g
0107++ FC08 70 10                           .dw     1070h   ; h
0108++ FC0A 00 10                           .dw     1000h   ; i
0109++ FC0C 10 22                           .dw     2210h   ; j
0110++ FC0E 00 1E                           .dw     1e00h   ; k
0111++ FC10 00 12                           .dw     1200h   ; l
0112++ FC12 D4 10                           .dw     10d4h   ; m
0113++ FC14 50 10                           .dw     1050h   ; n
0114++ FC16 DC 00                           .dw     00dch   ; o
0115++ FC18             
0116++ FC18 70 01                           .dw     0170h   ; p
0117++ FC1A 86 04                           .dw     0486h   ; q
0118++ FC1C 50 00                           .dw     0050h   ; r
0119++ FC1E 88 08                           .dw     0888h   ; s
0120++ FC20 78 00                           .dw     0078h   ; t
0121++ FC22 1C 00                           .dw     001ch   ; u
0122++ FC24 10 20                           .dw     2010h   ; v
0123++ FC26 14 28                           .dw     2814h   ; w
0124++ FC28 00 2D                           .dw     2d00h   ; x
0125++ FC2A 8E 02                           .dw     028eh   ; y
0126++ FC2C 48 20                           .dw     2048h   ; z
0127++ FC2E 49 21                           .dw     2149h   ; {
0128++ FC30 00 12                           .dw     1200h   ; |
0129++ FC32 89 0C                           .dw     0c89h   ; }
0130++ FC34 C0 24                           .dw     24c0h   ; ~
0131++ FC36 00 00                           .dw     0000h   ; 1357+  FC38                                 .INCLUDE "bios_rtc.asm"
0001++ FC38             ; RTC Routines
0002++ FC38             ;
0003++ FC38             ;
0004++ FC38             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ FC38             ;
0006++ FC38             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ FC38             ;
0008++ FC38             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ FC38             ; of this software and associated documentation files (the "Software"), to deal
0010++ FC38             ; in the Software without restriction, including without limitation the rights
0011++ FC38             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ FC38             ; copies of the Software, and to permit persons to whom the Software is
0013++ FC38             ; furnished to do so, subject to the following conditions:
0014++ FC38             ; 
0015++ FC38             ; The above copyright notice and this permission notice shall be included in all
0016++ FC38             ; copies or substantial portions of the Software.
0017++ FC38             ; 
0018++ FC38             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ FC38             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ FC38             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ FC38             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ FC38             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ FC38             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ FC38             ; SOFTWARE.
0025++ FC38             ;
0026++ FC38             ;
0027++ FC38                                     .MODULE rtc
0028++ FC38             
0029++ FC38             ; Set the initial time and start the clock
0030++ FC38             ;
0031++ FC38             ;
0032++ FC38 CD AA F3    rtc_init                CALL    m_print_inline
0033++ FC3B 0A 0D 43 68                         .DB     "\n\rCheck RTC",0
0033++ FC3F 65 63 6B 20 
0033++ FC43 52 54 43 00 
0034++ FC47             
0035++ FC47 CD BC FC                            CALL    _read_seconds
0036++ FC4A CD B7 FC                            CALL    _pause
0037++ FC4D CB 7B                               BIT     7, E                ; Check to see if the clock is running
0038++ FC4F C0                                  RET     NZ                  ; Return if it is..
0039++ FC50             
0040++ FC50 CD AA F3    _do_reset               CALL    m_print_inline
0041++ FC53 0A 0D 52 65                         .DB     "\n\rReset RTC",0
0041++ FC57 73 65 74 20 
0041++ FC5B 52 54 43 00 
0042++ FC5F             
0043++ FC5F 26 6F                               LD      H, RTC_ADDRESS      ; Clock isn't running, reset to default time
0044++ FC61 2E 00                               LD      L, RTC_REG_SEC
0045++ FC63 CD 1D F9                            CALL    i2c_write_to
0046++ FC66 D2 CA FC                            JP      NC, rtc_ack_error
0047++ FC69             
0048++ FC69 21 DD FC                            LD      HL, time_scratch
0049++ FC6C 7E          _reset_loop             LD      A, (HL)
0050++ FC6D 23                                  INC     HL
0051++ FC6E FE FF                               CP      0ffh
0052++ FC70 CA 7B FC                            JP      Z, _start_clock
0053++ FC73 CD 31 F9                            CALL    i2c_write
0054++ FC76 D2 CA FC                            JP      NC, rtc_ack_error
0055++ FC79 18 F1                               JR      _reset_loop
0056++ FC7B             
0057++ FC7B CD E5 F8    _start_clock            CALL    i2c_stop            ; Enable VBAT and start the clock
0058++ FC7E             
0059++ FC7E 26 6F                               LD      H, RTC_ADDRESS      ; Enable VBAT
0060++ FC80 2E 03                               LD      L, RTC_REG_WKDAY
0061++ FC82 CD FC F8                            CALL    i2c_read_from
0062++ FC85 D2 CA FC                            JP      NC, rtc_ack_error
0063++ FC88 5F                                  LD      E, A
0064++ FC89 CD E5 F8                            CALL    i2c_stop
0065++ FC8C CB DB                               SET     3, E
0066++ FC8E CD B7 FC                            CALL    _pause
0067++ FC91             
0068++ FC91 CD 1D F9                            CALL    i2c_write_to
0069++ FC94 D2 CA FC                            JP      NC, rtc_ack_error
0070++ FC97 7B                                  LD      A, E
0071++ FC98 CD 31 F9                            CALL    i2c_write
0072++ FC9B D2 CA FC                            JP      NC, rtc_ack_error
0073++ FC9E CD E5 F8                            CALL    i2c_stop
0074++ FCA1             
0075++ FCA1 CD BC FC                            CALL    _read_seconds
0076++ FCA4 CB FB                               SET     7, E                ; Set bit 7 to enable clock
0077++ FCA6                                     
0078++ FCA6 CD 1D F9                            CALL    i2c_write_to
0079++ FCA9 D2 CA FC                            JP      NC, rtc_ack_error
0080++ FCAC 7B                                  LD      A, E
0081++ FCAD CD 31 F9                            CALL    i2c_write
0082++ FCB0 D2 CA FC                            JP      NC, rtc_ack_error
0083++ FCB3 CD E5 F8                            CALL    i2c_stop
0084++ FCB6 C9                                  RET
0085++ FCB7             
0086++ FCB7 06 00       _pause                  LD      B, 0
0087++ FCB9 10 FE                               DJNZ    $
0088++ FCBB C9                                  RET
0089++ FCBC             
0090++ FCBC             ;
0091++ FCBC             ; Read seconds register in E
0092++ FCBC             ;
0093++ FCBC 26 6F       _read_seconds           LD      H, RTC_ADDRESS      
0094++ FCBE 2E 00                               LD      L, RTC_REG_SEC      
0095++ FCC0 CD FC F8                            CALL    i2c_read_from
0096++ FCC3 D2 CA FC                            JP      NC, rtc_ack_error
0097++ FCC6 5F                                  LD      E, A
0098++ FCC7 C3 E5 F8                            JP     i2c_stop
0099++ FCCA             
0100++ FCCA CD E5 F8    rtc_ack_error           CALL    i2c_stop
0101++ FCCD                                     
0102++ FCCD CD AA F3                            CALL    m_print_inline
0103++ FCD0 0A 0D 52 54                         .DB     "\n\rRTC Panic",0
0103++ FCD4 43 20 50 61 
0103++ FCD8 6E 69 63 00 
0104++ FCDC C9                                  RET
0105++ FCDD             
0106++ FCDD                                     ;  Initial time on power up..
0107++ FCDD 23          time_scratch            .db  23h            ; Seconds
0108++ FCDE 59                                  .db  59h            ; Minutes
0109++ FCDF 08                                  .db  08h            ; Hours    (24 hr clock)
0110++ FCE0 06                                  .db  06h            ; Weekday  (1-7. Monday=1)
0111++ FCE1 05                                  .db  05h            ; Date
0112++ FCE2 11                                  .db  11h            ; Month
0113++ FCE3 22                                  .db  22h            ; Year 
0114++ FCE4 FF                                  .db  0ffh           ; 0ffh end marker
0115++ FCE5             
0116++ FCE5                                     .MODULE main1358+  FCE5                                 .INCLUDE "../flash.asm"
0001++ FCE5             ;
0002++ FCE5             ; Flash update routines
0003++ FCE5             ;
0004++ FCE5             ; Note that any memory write operations *at all* during flash updates will cancel the current operation.
0005++ FCE5             ; That means no data can be stored to memory, no stack operations (call, push), no interrupts.
0006++ FCE5             ; 
0007++ FCE5             ;
0008++ FCE5             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0009++ FCE5             ;
0010++ FCE5             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0011++ FCE5             ;
0012++ FCE5             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0013++ FCE5             ; of this software and associated documentation files (the "Software"), to deal
0014++ FCE5             ; in the Software without restriction, including without limitation the rights
0015++ FCE5             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0016++ FCE5             ; copies of the Software, and to permit persons to whom the Software is
0017++ FCE5             ; furnished to do so, subject to the following conditions:
0018++ FCE5             ; 
0019++ FCE5             ; The above copyright notice and this permission notice shall be included in all
0020++ FCE5             ; copies or substantial portions of the Software.
0021++ FCE5             ; 
0022++ FCE5             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0023++ FCE5             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0024++ FCE5             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0025++ FCE5             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0026++ FCE5             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0027++ FCE5             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0028++ FCE5             ; SOFTWARE.
0029++ FCE5             ;
0030++ FCE5                                 .MODULE     flash
0031++ FCE5             
0032++ FCE5             _cmd_1_addr         .EQU  05555h
0033++ FCE5             _cmd_2_addr         .EQU  02AAAh
0034++ FCE5             
0035++ FCE5             _bank_mask          .EQU  03FFFh                ; One memory bank is 14 bits -> 16Kb
0036++ FCE5             _sector_mask        .EQU  00FFFh                ; A sector is 12 bits -> 4Kb
0037++ FCE5             
0038++ FCE5             _cmd_1_addr_bank    .EQU  _cmd_1_addr >> 14
0039++ FCE5             _cmd_2_addr_bank    .EQU  _cmd_2_addr >> 14
0040++ FCE5             _cmd_3_addr_bank    .EQU  _cmd_1_addr_bank
0041++ FCE5             _cmd_4_addr_bank    .EQU  _cmd_1_addr_bank
0042++ FCE5             _cmd_5_addr_bank    .EQU  _cmd_2_addr_bank
0043++ FCE5             
0044++ FCE5             _cmd_1_logical_addr .EQU  _cmd_1_addr & _bank_mask
0045++ FCE5             _cmd_2_logical_addr .EQU  _cmd_2_addr & _bank_mask
0046++ FCE5             _cmd_3_logical_addr .EQU  _cmd_1_logical_addr
0047++ FCE5             _cmd_4_logical_addr .EQU  _cmd_1_logical_addr
0048++ FCE5             _cmd_5_logical_addr .EQU  _cmd_2_logical_addr
0049++ FCE5             
0050++ FCE5             _cmd_1_data         .EQU  0AAh
0051++ FCE5             _cmd_2_data         .EQU  055h
0052++ FCE5             _cmd_3_data_write   .EQU  0A0h
0053++ FCE5             _cmd_3_data_erase   .EQU  080h
0054++ FCE5             _cmd_4_data         .EQU  0AAh
0055++ FCE5             _cmd_5_data         .EQU  055h
0056++ FCE5             
0057++ FCE5             _cmd_6_data_erase   .EQU  030h
0058++ FCE5             
0059++ FCE5             ;
0060++ FCE5             ; Enter with A -> 7 bit index of 4K sector to be erased.
0061++ FCE5             ;
0062++ FCE5             ; Preserves BC, DE, HL
0063++ FCE5             ;
0064++ FCE5             ; Note this uses bank 0, and leaves it configured for the page containing the erased sector
0065++ FCE5             ;
0066++ FCE5             ; Typical time to erase sector ~18ms
0067++ FCE5             ;
0068++ FCE5 F3          flash_sector_erase  DI                          ; Disable interrupts
0069++ FCE6 E5                              PUSH    HL
0070++ FCE7 C5                              PUSH    BC
0071++ FCE8 D5                              PUSH    DE
0072++ FCE9             
0073++ FCE9 E6 7F                           AND     07fh
0074++ FCEB 57                              LD      D, A
0075++ FCEC CB 3A                           SRL     D
0076++ FCEE CB 3A                           SRL     D                   ; D is now the bank number
0077++ FCF0             
0078++ FCF0 CB 27                           SLA     A
0079++ FCF2 CB 27                           SLA     A
0080++ FCF4 CB 27                           SLA     A
0081++ FCF6 CB 27                           SLA     A
0082++ FCF8 E6 30                           AND     030h
0083++ FCFA 5F                              LD      E, A                ; E is the sector within the bank shifted into bits 13 & 12
0084++ FCFB             
0085++ FCFB 0E 70                           LD      C, IO_MEM_0         ; Use bank 0 to write to
0086++ FCFD 3E 01                           LD      A, _cmd_1_addr_bank
0087++ FCFF ED 79                           OUT     (C), A
0088++ FD01 21 55 15                        LD      HL, _cmd_1_logical_addr
0089++ FD04 36 AA                           LD      (HL), _cmd_1_data
0090++ FD06             
0091++ FD06 3E 00                           LD      A, _cmd_2_addr_bank
0092++ FD08 ED 79                           OUT     (C), A
0093++ FD0A 21 AA 2A                        LD      HL, _cmd_2_logical_addr
0094++ FD0D 36 55                           LD      (HL), _cmd_2_data
0095++ FD0F             
0096++ FD0F 3E 01                           LD      A, _cmd_3_addr_bank
0097++ FD11 ED 79                           OUT     (C), A
0098++ FD13 21 55 15                        LD      HL, _cmd_3_logical_addr
0099++ FD16 36 80                           LD      (HL), _cmd_3_data_erase
0100++ FD18             
0101++ FD18 3E 01                           LD      A, _cmd_4_addr_bank
0102++ FD1A ED 79                           OUT     (C), A
0103++ FD1C 21 55 15                        LD      HL, _cmd_4_logical_addr
0104++ FD1F 36 AA                           LD      (HL), _cmd_4_data
0105++ FD21             
0106++ FD21 3E 00                           LD      A, _cmd_5_addr_bank
0107++ FD23 ED 79                           OUT     (C), A
0108++ FD25 21 AA 2A                        LD      HL, _cmd_5_logical_addr
0109++ FD28 36 55                           LD      (HL), _cmd_5_data
0110++ FD2A             
0111++ FD2A ED 51                           OUT     (C), D                  ; Switch to the bank containing our sector
0112++ FD2C 63                              LD      H, E                    ; And write the sector bits as an address (bits 0-11 are ignored)
0113++ FD2D 36 30                           LD      (HL), _cmd_6_data_erase
0114++ FD2F             
0115++ FD2F 7E          _wait_erase         LD      A,(HL)
0116++ FD30 CB 07                           RLC     A
0117++ FD32 30 FB                           JR      NC, _wait_erase
0118++ FD34             
0119++ FD34 D1                              POP     DE
0120++ FD35 C1                              POP     BC
0121++ FD36 E1                              POP     HL
0122++ FD37 FB                              EI
0123++ FD38 C9                              RET
0124++ FD39             
0125++ FD39             ;
0126++ FD39             ; Enter with A -> Byte to write
0127++ FD39             ;            D -> 7 bit index of 4K sector being written
0128++ FD39             ;            HL -> 12 bit address of byte within sector
0129++ FD39             ;
0130++ FD39             ; Preserves D, HL
0131++ FD39             ; Uses A, BC, E
0132++ FD39             ;
0133++ FD39             ; Typical time to erase byte ~14us
0134++ FD39             ;
0135++ FD39 F3          flash_write_byte    DI
0136++ FD3A 5F                              LD      E, A                ; Preserve our byte
0137++ FD3B                                 
0138++ FD3B 7C                              LD      A, H                ; Make sure HL is within our sector
0139++ FD3C E6 0F                           AND     _sector_mask >> 8
0140++ FD3E 67                              LD      H, A
0141++ FD3F             
0142++ FD3F 7A                              LD      A, D                ; Make sure D is a valid sector index
0143++ FD40 E6 7F                           AND     07fh
0144++ FD42 57                              LD      D, A
0145++ FD43 47                              LD      B, A
0146++ FD44             
0147++ FD44 7A                              LD      A, D                ; Get the bottom 2 bits of our sector index..
0148++ FD45 E6 03                           AND     03h
0149++ FD47 CB 27                           SLA     A
0150++ FD49 CB 27                           SLA     A
0151++ FD4B CB 27                           SLA     A
0152++ FD4D CB 27                           SLA     A
0153++ FD4F B4                              OR      H
0154++ FD50 67                              LD      H, A                ; ..and OR them into H to get a 14 bit address within our bank
0155++ FD51             
0156++ FD51 CB 3A                           SRL     D
0157++ FD53 CB 3A                           SRL     D                   ; D is now our bank number
0158++ FD55             
0159++ FD55 E5                              PUSH    HL
0160++ FD56             
0161++ FD56 0E 70                           LD      C, IO_MEM_0         ; Use bank 0 to write to
0162++ FD58 3E 01                           LD      A, _cmd_1_addr_bank
0163++ FD5A ED 79                           OUT     (C), A
0164++ FD5C 21 55 15                        LD      HL, _cmd_1_logical_addr
0165++ FD5F 36 AA                           LD      (HL), _cmd_1_data
0166++ FD61             
0167++ FD61 3E 00                           LD      A, _cmd_2_addr_bank
0168++ FD63 ED 79                           OUT     (C), A
0169++ FD65 21 AA 2A                        LD      HL, _cmd_2_logical_addr
0170++ FD68 36 55                           LD      (HL), _cmd_2_data
0171++ FD6A             
0172++ FD6A 3E 01                           LD      A, _cmd_3_addr_bank
0173++ FD6C ED 79                           OUT     (C), A
0174++ FD6E 21 55 15                        LD      HL, _cmd_3_logical_addr
0175++ FD71 36 A0                           LD      (HL), _cmd_3_data_write
0176++ FD73             
0177++ FD73 ED 51                           OUT     (C), D
0178++ FD75 E1                              POP     HL
0179++ FD76 73                              LD      (HL), E
0180++ FD77             
0181++ FD77 7E          _wait_byte          LD      A, (HL)
0182++ FD78 AB                              XOR     E
0183++ FD79 CB 07                           RLC     A
0184++ FD7B 30 FA                           JR      NC, _wait_byte
0185++ FD7D             
0186++ FD7D 7C                              LD      A, H                ; Clear bits 13 & 12 to restore HL to sector address..
0187++ FD7E E6 0F                           AND     _sector_mask >> 8
0188++ FD80 67                              LD      H, A
0189++ FD81                            
0190++ FD81 50                              LD      D, B                ; And restore D
0191++ FD82 FB                              EI
0192++ FD83 C9                              RET
0193++ FD84             
0194++ FD84             ;
0195++ FD84             ; Write a flash data block. This uses Page 0 to write the data, so the source must be above 4000h
0196++ FD84             ;
0197++ FD84             ;       D -> 7 bit index of 4K sector being written
0198++ FD84             ;       HL -> Address of source data
0199++ FD84             ;       BC -> bytes to write
0200++ FD84             ;
0201++ FD84             ; Returns D pointing to last sector written
0202++ FD84             ; Note: This means if BC is an exact multiple of sector size, D is returned as the previous sector
0203++ FD84             
0204++ FD84 DD E5       flash_write         PUSH    IX
0205++ FD86 E5                              PUSH    HL
0206++ FD87 DD E1                           POP     IX
0207++ FD89 21 00 00                        LD      HL, 0           ; Address in sector..
0208++ FD8C             
0209++ FD8C             _erase_sector       ; Lower 12 bits of HL are zero, erase sector before writing bytes
0210++ FD8C 7A                              LD      A, D
0211++ FD8D CD E5 FC                        CALL    flash_sector_erase
0212++ FD90 DD 7E 00    _write_loop         LD      A, (IX+0)
0213++ FD93 C5                              PUSH    BC
0214++ FD94 CD 39 FD                        CALL    flash_write_byte
0215++ FD97 C1                              POP     BC
0216++ FD98             
0217++ FD98 DD 23                           INC     IX
0218++ FD9A 0B                              DEC     BC
0219++ FD9B 78                              LD      A, B
0220++ FD9C B1                              OR      C
0221++ FD9D 28 0E                           JR      Z, _success
0222++ FD9F             
0223++ FD9F 23                              INC     HL
0224++ FDA0 7D                              LD      A, L
0225++ FDA1 A7                              AND     A
0226++ FDA2 20 EC                           JR      NZ, _write_loop
0227++ FDA4 7C                              LD      A, H
0228++ FDA5 E6 0F                           AND     _sector_mask >> 8
0229++ FDA7 67                              LD      H, A
0230++ FDA8 20 E6                           JR      NZ, _write_loop
0231++ FDAA             
0232++ FDAA 14                              INC     D
0233++ FDAB 18 DF                           JR      _erase_sector
0234++ FDAD             
0235++ FDAD DD E1       _success            POP     IX
0236++ FDAF C9                              RET
0237++ FDB0             
0238++ FDB0                                 .MODULE main1359+  FDB0             
1360+  FDB0             ;
1361+  FDB0             ;
1362+  FDB0             ; Page mapping - since the BIOS uses other pages to manage disk and screen, it must also manage the expected page for the user 
1363+  FDB0             ; programs, to prevent them from being unexpectedly changed (eg. after interrupts).
1364+  FDB0             ;
1365+  FDB0             
1366+  FDB0             ; Set the User page mapping. Sets page A (0-2) to the physical (RAM/ROM) page in E
1367+  FDB0             ; Returns with carry SET if successful. The given logical page will now point to the physical page in RAM or ROM
1368+  FDB0             ;
1369+  FDB0 FE 03       set_page_mapping    CP      3
1370+  FDB2 D0                              RET     NC
1371+  FDB3 4F                              LD      C, A
1372+  FDB4 06 00                           LD      B, 0
1373+  FDB6 21 39 FF                        LD      HL, page_0_mapping
1374+  FDB9 09                              ADD     HL, BC
1375+  FDBA 73                              LD      (HL), E 
1376+  FDBB             
1377+  FDBB C6 70                           ADD     A, IO_MEM_0             ; NOTE: Order is important here. Interrupts may occur after the page is stored (above)
1378+  FDBD 4F                              LD      C, A                    ; This may result in the page being prematurely mapped, but that's OK.
1379+  FDBE ED 59                           OUT     (C), E                  ; If we tried to set the page before storing the new default we'd have to disable interrupts
1380+  FDC0 37                              SCF                             ; To avoid a race condition
1381+  FDC1 C9                              RET
1382+  FDC2             
1383+  FDC2             JUMP_TABLE_SIZE     .EQU    9
1384+  FDC2             
1385+  FDC2             BIOS_SPARE          .EQU    BIOS_TOP - $ - (3*JUMP_TABLE_SIZE)
1386+  FDC2 00 00 00 00                     .FILL   BIOS_SPARE, 0
1386+  FDC6 00 00 00 00 
1386+  FDCA 00 00 00 00 
1386+  FDCE 00 00 00 00 
1386+  FDD2 00 00 00 00 
1386+  FDD6 00 00 00 00 
1386+  FDDA 00 00 00 00 
1386+  FDDE 00 00 00 00 
1387+  FDE2             
1388+  FDE2 C3 B0 FD                        JP          set_page_mapping    ; 9  - Set the logical (cpu) page in A (0-2) to the physical (RAM/ROM) page in E
1389+  FDE5 C3 D6 F8                        JP          i2c_start           ; 8  - Sends I2C start sequence
1390+  FDE8 C3 E5 F8                        JP          i2c_stop            ; 7  - Sends I2C stop sequence
1391+  FDEB C3 31 F9                        JP          i2c_write           ; 6  - Write A as a byte to i2c bus. Carry SET if success. i2c_stop is not called.
1392+  FDEE C3 3E F9                        JP          i2c_read            ; 5  - Read byte from i2C into A, without ACK
1393+  FDF1 C3 1D F9                        JP          i2c_write_to        ; 4  - Prepare to write to Device address H, Register L. Carry SET if success. i2c_stop is not called.
1394+  FDF4 C3 FC F8                        JP          i2c_read_from       ; 3  - Read a byte int A from Device address H, Register L. Carry SET if success. i2c_stop is not called.
1395+  FDF7 C3 34 F7                        JP          wait_for_key        ; 2  - Waits for until a key is pressed and released
1396+  FDFA C3 C9 F6                        JP          play_note           ; 1  - Plays the note defined by DE (octave, note) and C (duration, tenths)
1397+  FDFD             
1398+  FDFD             
1399+  FDFD~            .IF $ > BIOS_TOP
1400+  FDFD~                .ECHO "End of BIOS is too high ("
1401+  FDFD~                .ECHO $
1402+  FDFD~                .ECHO " > "
1403+  FDFD~                .ECHO BIOS_TOP
1404+  FDFD~                .ECHO ") \n\n"
1405+  FDFD~                .STOP
1406+  FDFD             .ENDIF
1407+  FDFD             
1408+  FDFD             .ECHO "Bios Size is "
1409+  FDFD             .ECHO BIOS_TOP-BIOS_START-BIOS_SPARE
1410+  FDFD             .ECHO ". Limit is "
1411+  FDFD             .ECHO BIOS_TOP-BIOS_START
1412+  FDFD             .ECHO ". Spare "
1413+  FDFD             .ECHO BIOS_SPARE
1414+  FDFD             .ECHO "\n\n"
1415+  FDFD             
1416+  FDFD                                 .INCLUDE shared_data.asm
0001++ FDFD             ;
0002++ FDFD             ; Shared data - common state data for routines
0003++ FDFD             ;
0004++ FDFD             ; [] show default/initial values stored at the location
0005++ FDFD             ;
0006++ FDFD             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0007++ FDFD             ;
0008++ FDFD             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0009++ FDFD             ;
0010++ FDFD             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0011++ FDFD             ; of this software and associated documentation files (the "Software"), to deal
0012++ FDFD             ; in the Software without restriction, including without limitation the rights
0013++ FDFD             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0014++ FDFD             ; copies of the Software, and to permit persons to whom the Software is
0015++ FDFD             ; furnished to do so, subject to the following conditions:
0016++ FDFD             ; 
0017++ FDFD             ; The above copyright notice and this permission notice shall be included in all
0018++ FDFD             ; copies or substantial portions of the Software.
0019++ FDFD             ; 
0020++ FDFD             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0021++ FDFD             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0022++ FDFD             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0023++ FDFD             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0024++ FDFD             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0025++ FDFD             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0026++ FDFD             ; SOFTWARE.
0027++ FDFD             ;
0028++ FDFD             
0029++ FF00                                 .ORG    0FF00h
0030++ FF00             
0031++ FF00             ; I2C/Port B routines
0032++ FF00             port_b_mode         .BLOCK  1
0033++ FF01             port_b_dir          .BLOCK  1
0034++ FF02             port_b_data         .BLOCK  1
0035++ FF03             
0036++ FF03             ; Display functions
0037++ FF03             display_address     .BLOCK  1              ; byte - I/O address of the display driver (right or left) being written to
0038++ FF04             
0039++ FF04             ;
0040++ FF04             ; Stuff
0041++ FF04             timer               .BLOCK  4              ; 2 Words - counts up by 1 every 64th of a second. Rollover ~2 years.
0042++ FF08                                     
0043++ FF08             ; General I/O
0044++ FF08             ;
0045++ FF08             ; This MUST start with keyboard_state, and will all be reset to zero when io_init is called
0046++ FF08             ;
0047++ FF08             _key_state_size     .EQU    8               ; 8 key rollover
0048++ FF08             
0049++ FF08             keyboard_state      .BLOCK  _key_state_size ; state buffer - 8 bytes containing raw key codes for keys currently pressed
0050++ FF10             keyboard_pos        .BLOCK  2               ; Internal state
0051++ FF12             key_shift_state     .BLOCK  1               ; Holds state of shift and control keys in bits 0 and 1 respectively
0052++ FF13             control_key_pressed .BLOCK  1               ; If special control keys are pressed, they are stored here..
0053++ FF14             last_keycode        .BLOCK  1               ; The last keycode that was pressed, for repeats..
0054++ FF15             key_repeat_time     .BLOCK  1               ; How many poll events since the key state last changed
0055++ FF16             
0056++ FF16             _input_buffer_size  .EQU    16
0057++ FF16             input_buffer        .BLOCK _input_buffer_size          ; 16 byte input buffer. Note wraparound is handled by bitmasks, so don't change this length
0058++ FF26             input_pos           .BLOCK  1               ; Next read position in input buffer
0059++ FF27             input_free          .BLOCK  1               ; Next write position in input buffer
0060++ FF28             input_size          .BLOCK  1               ; Bytes occupied in the input buffer
0061++ FF29             
0062++ FF29             io_data_end         .EQU  input_size        ; Byte after IO data block, used to reset values to zero
0063++ FF29             
0064++ FF29             ;------------------------------- Console output and screen data ------------------------------------------------
0065++ FF29             screen_page         .BLOCK  1               ; [30?]  1 Byte, screen buffer page address
0066++ FF2A             screen_offset       .BLOCK  1               ; [0]    1 Byte, row offset (0-63) of virtual screen in screen buffer (high byte of screen address).
0067++ FF2B             
0068++ FF2B             ; *** ROW AND COL MUST BE IN THIS ORDER - READ BY bios_conout ***
0069++ FF2B             display_row         .BLOCK  1               ; [0]    1 Byte, current row being shown by the LED display
0070++ FF2C             display_col         .BLOCK  1               ; [0]    1 Byte, current column being shown by the LED display - Note, 0 based
0071++ FF2D             
0072++ FF2D             ; *** ROW AND COL MUST BE IN THIS ORDER - READ BY bios_conout ***
0073++ FF2D             cursor_row          .BLOCK  1               ; [1]    1 Byte, cursor row on virtual console. Top of page is row 1.   
0074++ FF2E             cursor_col          .BLOCK  1               ; [1]    1 Byte, cursor column on virtual console. Left of page is column 1.
0075++ FF2F             
0076++ FF2F             console_height      .BLOCK  1               ; [24]   1 Byte, virtual console height (rows)
0077++ FF30             console_width       .BLOCK  1               ; [40]   1 byte, virtual console width (columns)
0078++ FF31             
0079++ FF31             console_colour      .BLOCK  1               ; [0x0F] 1 Byte, current colour. Top 4 bits [7:4] are background, bottom 4 [3:0] are foreground
0080++ FF32             console_flags       .BLOCK  1               ;        1 Byte, bit flags for console
0081++ FF33             
0082++ FF33             console_timer       .BLOCK  1               ;        1 Byte, used to blink cursor, clear movement indicator etc.
0083++ FF34             console_escape      .BLOCK  1               ;        1 Byte, escape value (0 if not received yet)
0084++ FF35             console_param1      .BLOCK  1               ;        1 Byte, first character after escape (0 if not recieved yet)
0085++ FF36             
0086++ FF36             console_identify    .BLOCK  1               ; [0]    1 Byte, indicates console identifier sequence to be returned..
0087++ FF37             
0088++ FF37             CFLAGS_SHOW_CURSOR  .EQU    1               ; Awaiting input - show (blink) the cursor
0089++ FF37             CFLAGS_TRACK_CURSOR .EQU    2               ; LED display is tracking cursor position
0090++ FF37             CFLAGS_SHOW_MOVED   .EQU    4               ; Show display as being moved by user
0091++ FF37             CFLAGS_ESCAPE       .EQU    8               ; Escape sequence started
0092++ FF37             CFLAGS_CURSOR_ON    .EQU    16              ; Cursor is currently displayed
0093++ FF37             
0094++ FF37             SHOW_MOVE_DELAY     .EQU    60              ; How long to show the display has been moved
0095++ FF37             
0096++ FF37             ;------------------------------- BIOS customisation  ------------------------------------------------
0097++ FF37             
0098++ FF37             drive_a_mem_page    .BLOCK  1               ; First page in RAM/ROM for the Drive A image
0099++ FF38             drive_b_mem_page    .BLOCK  1               ; First page in RAM/ROM for the Drive B image
0100++ FF39             
0101++ FF39             page_0_mapping      .BLOCK  1               ; Stores the user mapping for these pages, so they can be correctly restored after interrupts
0102++ FF3A             page_1_mapping      .BLOCK  1
0103++ FF3B             page_2_mapping      .BLOCK  1
0104++ FF3C             
0105++ FF3C             ;------------------------------- BDOS variables ------------------------------------------------
0106++ FF3C             ; *** TRACK AND SECTOR MUST BE IN THIS ORDER - READ BY _get_memdisc_addr ***
0107++ FF3C             sys_track           .BLOCK  1               ; 1 Byte, Current disk track 
0108++ FF3D             sys_sector          .BLOCK  2               ; Word, current disk sector
0109++ FF3F             sys_dmaaddr         .BLOCK  2               ; Word, DMA address - Disc will read data to this address, or write from this address
0110++ FF41             sys_disk_dph        .BLOCK  2               ; Word, points to current disk parameter header (DPH) 
0111++ FF43             sys_seldsk          .BLOCK  1               ; Byte, current selected disk drive (A=0, B=1..)
0112++ FF44             
0113++ FF44             sys_alv0            .BLOCK  32              ; 32 bytes, allocation vector 0 (max 255 blocks)
0114++ FF64             sys_alv1            .BLOCK  32              ; 32 bytes, allocation vector 1 (max 255 blocks)
0115++ FF84             
0116++ FF84             display_buffer      .BLOCK  24*2            ; 48 byte scratch area used for composing display output (eg. rtc time display etc.)
0117++ FFB4             
0118++ FFB4             intr_stackarea      .BLOCK  32              ; Interrupt handler stack
0119++ FFD4             intr_stack          .BLOCK  2
0120++ FFD6             
0121++ FFD6             ; Panic codes
0122++ FFD6             ;
0123++ FFD6             PANIC_0001          .EQU    0F001h
0124++ FFD6             PANIC_0002          .EQU    0F002h
0125++ FFD6             PANIC_0003          .EQU    0F003h
0126++ FFD6             PANIC_0004          .EQU    0F004h
0127++ FFD6             
1417+  FFD6                                 .END1136   FFD6                                 .END
tasm: Number of errors = 0
